!STARTOFREGISTRYGENERATEDFILE 'StrucCtrl_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! StrucCtrl_Types
!.................................................................................................................................
! This file is part of StrucCtrl.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in StrucCtrl. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE StrucCtrl_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  StC_InputFile  =======
  TYPE, PUBLIC :: StC_InputFile
    CHARACTER(1024)  :: StCFileName      !< Name of the input file; remove if there is no file [-]
    LOGICAL  :: Echo      !< Echo input file to echo file [-]
    INTEGER(IntKi)  :: StC_CMODE      !< control mode {0:none; 1: Semi-Active Control Mode; 2: Active Control Mode;}  [-]
    INTEGER(IntKi)  :: StC_SA_MODE      !< Semi-Active control mode {1: velocity-based ground hook control; 2: Inverse velocity-based ground hook control; 3: displacement-based ground hook control 4: Phase difference Algorithm with Friction Force 5: Phase difference Algorithm with Damping Force}  [-]
    INTEGER(IntKi)  :: StC_DOF_MODE      !< DOF mode {0: NO StC_DOF; 1: StC_X_DOF and StC_Y_DOF; 2: StC_XY_DOF; 3: TLCD; 4: Prescribed force/moment time series} [-]
    LOGICAL  :: StC_X_DOF      !< DOF on or off [-]
    LOGICAL  :: StC_Y_DOF      !< DOF on or off [-]
    LOGICAL  :: StC_Z_DOF      !< DOF on or off [-]
    REAL(ReKi)  :: StC_X_DSP      !< StC_X initial displacement [m]
    REAL(ReKi)  :: StC_Y_DSP      !< StC_Y initial displacement [m]
    REAL(ReKi)  :: StC_Z_DSP      !< StC_Z initial displacement [m]
    Character(10)  :: StC_Z_PreLdC      !< StC_Z spring preload [N]
    REAL(ReKi)  :: StC_X_M      !< StC X mass [kg]
    REAL(ReKi)  :: StC_Y_M      !< StC Y mass [kg]
    REAL(ReKi)  :: StC_Z_M      !< StC Z mass [kg]
    REAL(ReKi)  :: StC_XY_M      !< StC XY mass [kg]
    REAL(ReKi)  :: StC_X_K      !< StC X stiffness [N/m]
    REAL(ReKi)  :: StC_Y_K      !< StC Y stiffness [N/m]
    REAL(ReKi)  :: StC_Z_K      !< StC Y stiffness [N/m]
    REAL(ReKi)  :: StC_X_C      !< StC X damping [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C      !< StC Y damping [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C      !< StC Z damping [N/(m/s)]
    REAL(ReKi)  :: StC_X_PSP      !< Positive stop position (maximum X mass displacement) [m]
    REAL(ReKi)  :: StC_X_NSP      !< Negative stop position (minimum X mass displacement) [m]
    REAL(ReKi)  :: StC_Y_PSP      !< Positive stop position (maximum Y mass displacement) [m]
    REAL(ReKi)  :: StC_Y_NSP      !< Negative stop position (minimum Y mass displacement) [m]
    REAL(ReKi)  :: StC_Z_PSP      !< Positive stop position (maximum Z mass displacement) [m]
    REAL(ReKi)  :: StC_Z_NSP      !< Negative stop position (minimum Z mass displacement) [m]
    REAL(ReKi)  :: StC_X_KS      !< Stop spring X stiffness [N/m]
    REAL(ReKi)  :: StC_X_CS      !< Stop spring X damping [N/(m/s)]
    REAL(ReKi)  :: StC_Y_KS      !< Stop spring Y stiffness [N/m]
    REAL(ReKi)  :: StC_Y_CS      !< Stop spring Y damping [N/(m/s)]
    REAL(ReKi)  :: StC_Z_KS      !< Stop spring Z stiffness [used only when StC_DOF_MODE=1 and StC_Z_DOF=TRUE] [N/m]
    REAL(ReKi)  :: StC_Z_CS      !< Stop spring Z damping   [used only when StC_DOF_MODE=1 and StC_Z_DOF=TRUE] [N/(m/s)]
    REAL(ReKi)  :: StC_P_X      !< StC X initial displacement (m) [relative to at rest position] [m]
    REAL(ReKi)  :: StC_P_Y      !< StC Y initial displacement (m) [relative to at rest position] [m]
    REAL(ReKi)  :: StC_P_Z      !< StC Z initial displacement (m) [relative to at rest position; used only when StC_DOF_MODE=1 and StC_Z_DOF=TRUE] [m]
    REAL(ReKi)  :: StC_X_C_HIGH      !< StC X high damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_X_C_LOW      !< StC X low damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C_HIGH      !< StC Y high damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C_LOW      !< StC Y low damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C_HIGH      !< StC Z high damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C_LOW      !< StC Z low damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_X_C_BRAKE      !< StC X high damping for braking the StC [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C_BRAKE      !< StC Y high damping for braking the StC [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C_BRAKE      !< StC Z high damping for braking the StC [N/(m/s)]
    REAL(ReKi)  :: L_X      !< X TLCD total length [m]
    REAL(ReKi)  :: B_X      !< X TLCD horizontal length [m]
    REAL(ReKi)  :: area_X      !< X TLCD cross-sectional area of vertical column [m^2]
    REAL(ReKi)  :: area_ratio_X      !< X TLCD cross-sectional area ratio (vertical column area divided by horizontal column area) [-]
    REAL(ReKi)  :: headLossCoeff_X      !< X TLCD head loss coeff [-]
    REAL(ReKi)  :: rho_X      !< X TLCD liquid density [kg/m^3]
    REAL(ReKi)  :: L_Y      !< Y TLCD total length [m]
    REAL(ReKi)  :: B_Y      !< Y TLCD horizontal length [m]
    REAL(ReKi)  :: area_Y      !< Side-Side TLCD cross-sectional area of vertical column [m]
    REAL(ReKi)  :: area_ratio_Y      !< Side-Side TLCD cross-sectional area ratio (vertical column area divided by horizontal column area) [-]
    REAL(ReKi)  :: headLossCoeff_Y      !< Side-Side TLCD head loss coeff [-]
    REAL(ReKi)  :: rho_Y      !< Side-Side TLCD liquid density [kg/m^3]
    LOGICAL  :: USE_F_TBL      !< use spring force from user-defined table (flag) [-]
    INTEGER(IntKi)  :: NKInpSt      !< Number of input spring force rows in table [-]
    CHARACTER(1024)  :: StC_F_TBL_FILE      !< user-defined spring table filename [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_TBL      !< user-defined spring force [N]
    INTEGER(IntKi)  :: PrescribedForcesCoordSys      !< Prescribed forces coordinate system {0: global; 1: local} [-]
    CHARACTER(1024)  :: PrescribedForcesFile      !< Prescribed force time-series filename [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: StC_PrescribedForce      !< StC prescribed force time-series info [(s,N,N-m)]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: StC_CChan      !< StC control chan to use -- one per instance [-]
  END TYPE StC_InputFile
! =======================
! =========  StC_InitInputType  =======
  TYPE, PUBLIC :: StC_InitInputType
    CHARACTER(1024)  :: InputFile      !< Name of the input file; remove if there is no file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    REAL(ReKi) , DIMENSION(1:3)  :: Gravity      !< Gravitational acceleration vector [m/s^2]
    INTEGER(IntKi)  :: NumMeshPts      !< Number of mesh points [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InitRefPos      !< X-Y-Z reference position of point: i.e. each blade root (3 x NumBlades) [m]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: InitTransDisp      !< X-Y-Z displacement from position of point at init: i.e. each blade root (3 x NumBlades) [m]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: InitOrient      !< DCM orientation of point at init: i.e. each blade root (3x3 x NumBlades) [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: InitRefOrient      !< DCM reference orientation of point: i.e. each blade root (3x3 x NumBlades) [-]
    LOGICAL  :: UseInputFile = .TRUE.      !< Read from the input file.  If false, must parse the string info passed [-]
    TYPE(FileInfoType)  :: PassedPrimaryInputData      !< Primary input file as FileInfoType (set by driver/glue code) [-]
    LOGICAL  :: UseInputFile_PrescribeFrc = .TRUE.      !< Read from the input file.  If false, must parse the string info passed [-]
    TYPE(FileInfoType)  :: PassedPrescribeFrcData      !< Prescribed forces input file as FileInfoType (set by driver/glue code) [-]
  END TYPE StC_InitInputType
! =======================
! =========  StC_CtrlChanInitInfoType  =======
  TYPE, PUBLIC :: StC_CtrlChanInitInfoType
    CHARACTER(64) , DIMENSION(:), ALLOCATABLE  :: Requestor      !< text string of which StC requests which cable control channel [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: InitStiff      !< StC stiffness at initialization  (3,NumStC_Control) -- passed from StC to let controller know the value during init [N/m]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: InitDamp      !< StC damping at initialization  (3,NumStC_Control) -- passed from StC to let controller know the value during init [N/(m/s)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: InitBrake      !< StC braking signal at initialization  (3,NumStC_Control) -- passed from StC to let controller know the value during init [N]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: InitForce      !< StC external force signal at initialization  (3,NumStC_Control) -- passed from StC to let controller know the value during init (should be zero) [N]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: InitMeasDisp      !< StC measured local displacement signal from StC at initialization  (3,NumStC_Control) [m]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: InitMeasVel      !< StC measured local velocity     signal from StC at initialization (3,NumStC_Control) [m/s]
  END TYPE StC_CtrlChanInitInfoType
! =======================
! =========  StC_InitOutputType  =======
  TYPE, PUBLIC :: StC_InitOutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: RelPosition      !< StC position relative to reference point (3,NumMeshPts) [m]
  END TYPE StC_InitOutputType
! =======================
! =========  StC_ContinuousStateType  =======
  TYPE, PUBLIC :: StC_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: StC_x      !< Continuous States -- StrucCtrl x [-]
  END TYPE StC_ContinuousStateType
! =======================
! =========  StC_DiscreteStateType  =======
  TYPE, PUBLIC :: StC_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !< Remove this variable if you have discrete states [-]
  END TYPE StC_DiscreteStateType
! =======================
! =========  StC_ConstraintStateType  =======
  TYPE, PUBLIC :: StC_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE StC_ConstraintStateType
! =======================
! =========  StC_OtherStateType  =======
  TYPE, PUBLIC :: StC_OtherStateType
    REAL(ReKi)  :: DummyOtherState      !< Remove this variable if you have other/logical states [-]
  END TYPE StC_OtherStateType
! =======================
! =========  StC_MiscVarType  =======
  TYPE, PUBLIC :: StC_MiscVarType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_stop      !< Stop forces [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_ext      !< External forces (user defined or from controller) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_fr      !< Friction forces [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: K      !< Stiffness -- might be changed if controller controls this [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C_ctrl      !< Controlled Damping (On/Off) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C_Brake      !< Braking Damping [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_table      !< Tabled Stiffness [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_k      !< Factor for x and y-component stiffness force [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: a_G      !< Gravitational acceleration vector, local coordinates for point [m/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rdisp_P      !< Translational displacement vector, local coordinates for point [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rdot_P      !< Translational velocity     vector, local coordinates for point [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rddot_P      !< Translational acceleration vector, local coordinates for point [m/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: omega_P      !< Rotational		velocity		 vector, local coordinates for point [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: alpha_P      !< Rotational    aceeleration vector, local coordinates for point [rad/s^2]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_P      !< StC force  vector, local coordinates for point [N]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M_P      !< StC moment vector, local coordinates for point [N-m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Acc      !< StC aggregated acceleration in X,Y local coordinates for point [m/s^2]
    INTEGER(IntKi)  :: PrescribedInterpIdx      !< Index for interpolation of Prescribed force array [-]
  END TYPE StC_MiscVarType
! =======================
! =========  StC_ParameterType  =======
  TYPE, PUBLIC :: StC_ParameterType
    REAL(DbKi)  :: DT      !< Time step for cont. state integration & disc. state update [seconds]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    INTEGER(IntKi)  :: StC_DOF_MODE      !< DOF mode {0: NO StC_DOF; 1: StC_X_DOF and StC_Y_DOF; 2: StC_XY_DOF; 3: TLCD; 4: Prescribed force/moment time series} [-]
    LOGICAL  :: StC_X_DOF      !< DOF on or off [-]
    LOGICAL  :: StC_Y_DOF      !< DOF on or off [-]
    LOGICAL  :: StC_Z_DOF      !< DOF on or off [-]
    REAL(ReKi)  :: StC_Z_PreLd      !< StC_Z spring preload [N]
    REAL(ReKi)  :: M_X      !< StC mass [kg]
    REAL(ReKi)  :: M_Y      !< StC mass [kg]
    REAL(ReKi)  :: M_Z      !< StC mass [kg]
    REAL(ReKi)  :: M_XY      !< StCXY mass [kg]
    REAL(ReKi)  :: K_X      !< StC stiffness [N/m]
    REAL(ReKi)  :: K_Y      !< StC stiffness [N/m]
    REAL(ReKi)  :: K_Z      !< StC stiffness [N/m]
    REAL(ReKi)  :: C_X      !< StC damping [N/(m/s)]
    REAL(ReKi)  :: C_Y      !< StC damping [N/(m/s)]
    REAL(ReKi)  :: C_Z      !< StC damping [N/(m/s)]
    REAL(ReKi) , DIMENSION(1:3)  :: K_S      !< StC stop stiffness [N/m]
    REAL(ReKi) , DIMENSION(1:3)  :: C_S      !< StC stop damping [N/(m/s)]
    REAL(ReKi) , DIMENSION(1:3)  :: P_SP      !< Positive stop position (maximum mass displacement) [m]
    REAL(ReKi) , DIMENSION(1:3)  :: N_SP      !< Negative stop position (minimum X mass displacement) [m]
    REAL(ReKi) , DIMENSION(1:3)  :: Gravity      !< Gravitational acceleration vector [m/s^2]
    INTEGER(IntKi)  :: StC_CMODE      !< control mode {0:none; 1: Semi-Active Control Mode; 4: Active Control Mode through Simulink (not available); 5: Active Control Mode through Bladed interface}  [-]
    INTEGER(IntKi)  :: StC_SA_MODE      !< Semi-Active control mode {1: velocity-based ground hook control; 2: Inverse velocity-based ground hook control; 3: displacement-based ground hook control 4: Phase difference Algorithm with Friction Force 5: Phase difference Algorithm with Damping Force}  [-]
    REAL(ReKi)  :: StC_X_C_HIGH      !< StC X high damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_X_C_LOW      !< StC X low damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C_HIGH      !< StC Y high damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C_LOW      !< StC Y low damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C_HIGH      !< StC Z high damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C_LOW      !< StC Z low damping for ground hook control [N/(m/s)]
    REAL(ReKi)  :: StC_X_C_BRAKE      !< StC X high damping for braking the StC [N/(m/s)]
    REAL(ReKi)  :: StC_Y_C_BRAKE      !< StC Y high damping for braking the StC [N/(m/s)]
    REAL(ReKi)  :: StC_Z_C_BRAKE      !< StC Y high damping for braking the StC [N/(m/s)]
    REAL(ReKi)  :: L_X      !< X TLCD total length [m]
    REAL(ReKi)  :: B_X      !< X TLCD horizontal length [m]
    REAL(ReKi)  :: area_X      !< X TLCD cross-sectional area of vertical column [m^2]
    REAL(ReKi)  :: area_ratio_X      !< X TLCD cross-sectional area ratio (vertical column area divided by horizontal column area) [-]
    REAL(ReKi)  :: headLossCoeff_X      !< X TLCD head loss coeff [-]
    REAL(ReKi)  :: rho_X      !< X TLCD liquid density [kg/m^3]
    REAL(ReKi)  :: L_Y      !< Y TLCD total length [m]
    REAL(ReKi)  :: B_Y      !< Y TLCD horizontal length [m]
    REAL(ReKi)  :: area_Y      !< Side-Side TLCD cross-sectional area of vertical column [m]
    REAL(ReKi)  :: area_ratio_Y      !< Side-Side TLCD cross-sectional area ratio (vertical column area divided by horizontal column area) [-]
    REAL(ReKi)  :: headLossCoeff_Y      !< Side-Side TLCD head loss coeff [-]
    REAL(ReKi)  :: rho_Y      !< Side-Side TLCD liquid density [kg/m^3]
    LOGICAL  :: Use_F_TBL      !< use spring force from user-defined table (flag) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_TBL      !< user-defined spring force [N]
    INTEGER(IntKi)  :: NumMeshPts      !< Number of mesh points [-]
    INTEGER(IntKi)  :: PrescribedForcesCoordSys      !< Prescribed forces coordinate system {0: global; 1: local} [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: StC_PrescribedForce      !< StC prescribed force time-series info [(s,N,N-m)]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: StC_CChan      !< StC control chan to use [-]
  END TYPE StC_ParameterType
! =======================
! =========  StC_InputType  =======
  TYPE, PUBLIC :: StC_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: Mesh      !< Displacements at the StC reference point(s) P in the inertial frame [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CmdStiff      !< StC stiffness from controller [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CmdDamp      !< StC damping   from controller [N/(m/s)]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CmdBrake      !< StC braking   from controller [N/(m/s)]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CmdForce      !< StC force     from controller [N]
  END TYPE StC_InputType
! =======================
! =========  StC_OutputType  =======
  TYPE, PUBLIC :: StC_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: Mesh      !< Loads at the StC reference points in the inertial frame [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MeasDisp      !< StC measured relative displacement of tmd mass (local coordinates) signal to controller [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MeasVel      !< StC measured relative velocity     of tmd mass (local coordinates) signal to controller [m/s]
  END TYPE StC_OutputType
! =======================
CONTAINS
 SUBROUTINE StC_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(StC_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%StCFileName = SrcInputFileData%StCFileName
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%StC_CMODE = SrcInputFileData%StC_CMODE
    DstInputFileData%StC_SA_MODE = SrcInputFileData%StC_SA_MODE
    DstInputFileData%StC_DOF_MODE = SrcInputFileData%StC_DOF_MODE
    DstInputFileData%StC_X_DOF = SrcInputFileData%StC_X_DOF
    DstInputFileData%StC_Y_DOF = SrcInputFileData%StC_Y_DOF
    DstInputFileData%StC_Z_DOF = SrcInputFileData%StC_Z_DOF
    DstInputFileData%StC_X_DSP = SrcInputFileData%StC_X_DSP
    DstInputFileData%StC_Y_DSP = SrcInputFileData%StC_Y_DSP
    DstInputFileData%StC_Z_DSP = SrcInputFileData%StC_Z_DSP
    DstInputFileData%StC_Z_PreLdC = SrcInputFileData%StC_Z_PreLdC
    DstInputFileData%StC_X_M = SrcInputFileData%StC_X_M
    DstInputFileData%StC_Y_M = SrcInputFileData%StC_Y_M
    DstInputFileData%StC_Z_M = SrcInputFileData%StC_Z_M
    DstInputFileData%StC_XY_M = SrcInputFileData%StC_XY_M
    DstInputFileData%StC_X_K = SrcInputFileData%StC_X_K
    DstInputFileData%StC_Y_K = SrcInputFileData%StC_Y_K
    DstInputFileData%StC_Z_K = SrcInputFileData%StC_Z_K
    DstInputFileData%StC_X_C = SrcInputFileData%StC_X_C
    DstInputFileData%StC_Y_C = SrcInputFileData%StC_Y_C
    DstInputFileData%StC_Z_C = SrcInputFileData%StC_Z_C
    DstInputFileData%StC_X_PSP = SrcInputFileData%StC_X_PSP
    DstInputFileData%StC_X_NSP = SrcInputFileData%StC_X_NSP
    DstInputFileData%StC_Y_PSP = SrcInputFileData%StC_Y_PSP
    DstInputFileData%StC_Y_NSP = SrcInputFileData%StC_Y_NSP
    DstInputFileData%StC_Z_PSP = SrcInputFileData%StC_Z_PSP
    DstInputFileData%StC_Z_NSP = SrcInputFileData%StC_Z_NSP
    DstInputFileData%StC_X_KS = SrcInputFileData%StC_X_KS
    DstInputFileData%StC_X_CS = SrcInputFileData%StC_X_CS
    DstInputFileData%StC_Y_KS = SrcInputFileData%StC_Y_KS
    DstInputFileData%StC_Y_CS = SrcInputFileData%StC_Y_CS
    DstInputFileData%StC_Z_KS = SrcInputFileData%StC_Z_KS
    DstInputFileData%StC_Z_CS = SrcInputFileData%StC_Z_CS
    DstInputFileData%StC_P_X = SrcInputFileData%StC_P_X
    DstInputFileData%StC_P_Y = SrcInputFileData%StC_P_Y
    DstInputFileData%StC_P_Z = SrcInputFileData%StC_P_Z
    DstInputFileData%StC_X_C_HIGH = SrcInputFileData%StC_X_C_HIGH
    DstInputFileData%StC_X_C_LOW = SrcInputFileData%StC_X_C_LOW
    DstInputFileData%StC_Y_C_HIGH = SrcInputFileData%StC_Y_C_HIGH
    DstInputFileData%StC_Y_C_LOW = SrcInputFileData%StC_Y_C_LOW
    DstInputFileData%StC_Z_C_HIGH = SrcInputFileData%StC_Z_C_HIGH
    DstInputFileData%StC_Z_C_LOW = SrcInputFileData%StC_Z_C_LOW
    DstInputFileData%StC_X_C_BRAKE = SrcInputFileData%StC_X_C_BRAKE
    DstInputFileData%StC_Y_C_BRAKE = SrcInputFileData%StC_Y_C_BRAKE
    DstInputFileData%StC_Z_C_BRAKE = SrcInputFileData%StC_Z_C_BRAKE
    DstInputFileData%L_X = SrcInputFileData%L_X
    DstInputFileData%B_X = SrcInputFileData%B_X
    DstInputFileData%area_X = SrcInputFileData%area_X
    DstInputFileData%area_ratio_X = SrcInputFileData%area_ratio_X
    DstInputFileData%headLossCoeff_X = SrcInputFileData%headLossCoeff_X
    DstInputFileData%rho_X = SrcInputFileData%rho_X
    DstInputFileData%L_Y = SrcInputFileData%L_Y
    DstInputFileData%B_Y = SrcInputFileData%B_Y
    DstInputFileData%area_Y = SrcInputFileData%area_Y
    DstInputFileData%area_ratio_Y = SrcInputFileData%area_ratio_Y
    DstInputFileData%headLossCoeff_Y = SrcInputFileData%headLossCoeff_Y
    DstInputFileData%rho_Y = SrcInputFileData%rho_Y
    DstInputFileData%USE_F_TBL = SrcInputFileData%USE_F_TBL
    DstInputFileData%NKInpSt = SrcInputFileData%NKInpSt
    DstInputFileData%StC_F_TBL_FILE = SrcInputFileData%StC_F_TBL_FILE
IF (ALLOCATED(SrcInputFileData%F_TBL)) THEN
  i1_l = LBOUND(SrcInputFileData%F_TBL,1)
  i1_u = UBOUND(SrcInputFileData%F_TBL,1)
  i2_l = LBOUND(SrcInputFileData%F_TBL,2)
  i2_u = UBOUND(SrcInputFileData%F_TBL,2)
  IF (.NOT. ALLOCATED(DstInputFileData%F_TBL)) THEN 
    ALLOCATE(DstInputFileData%F_TBL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%F_TBL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%F_TBL = SrcInputFileData%F_TBL
ENDIF
    DstInputFileData%PrescribedForcesCoordSys = SrcInputFileData%PrescribedForcesCoordSys
    DstInputFileData%PrescribedForcesFile = SrcInputFileData%PrescribedForcesFile
IF (ALLOCATED(SrcInputFileData%StC_PrescribedForce)) THEN
  i1_l = LBOUND(SrcInputFileData%StC_PrescribedForce,1)
  i1_u = UBOUND(SrcInputFileData%StC_PrescribedForce,1)
  i2_l = LBOUND(SrcInputFileData%StC_PrescribedForce,2)
  i2_u = UBOUND(SrcInputFileData%StC_PrescribedForce,2)
  IF (.NOT. ALLOCATED(DstInputFileData%StC_PrescribedForce)) THEN 
    ALLOCATE(DstInputFileData%StC_PrescribedForce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%StC_PrescribedForce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%StC_PrescribedForce = SrcInputFileData%StC_PrescribedForce
ENDIF
IF (ALLOCATED(SrcInputFileData%StC_CChan)) THEN
  i1_l = LBOUND(SrcInputFileData%StC_CChan,1)
  i1_u = UBOUND(SrcInputFileData%StC_CChan,1)
  IF (.NOT. ALLOCATED(DstInputFileData%StC_CChan)) THEN 
    ALLOCATE(DstInputFileData%StC_CChan(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%StC_CChan.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%StC_CChan = SrcInputFileData%StC_CChan
ENDIF
 END SUBROUTINE StC_CopyInputFile

 SUBROUTINE StC_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(StC_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputFileData%F_TBL)) THEN
  DEALLOCATE(InputFileData%F_TBL)
ENDIF
IF (ALLOCATED(InputFileData%StC_PrescribedForce)) THEN
  DEALLOCATE(InputFileData%StC_PrescribedForce)
ENDIF
IF (ALLOCATED(InputFileData%StC_CChan)) THEN
  DEALLOCATE(InputFileData%StC_CChan)
ENDIF
 END SUBROUTINE StC_DestroyInputFile


subroutine StC_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackInputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   ! StCFileName
   call RegPack(Buf, InData%StCFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_CMODE
   call RegPack(Buf, InData%StC_CMODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_SA_MODE
   call RegPack(Buf, InData%StC_SA_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_DOF_MODE
   call RegPack(Buf, InData%StC_DOF_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_DOF
   call RegPack(Buf, InData%StC_X_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_DOF
   call RegPack(Buf, InData%StC_Y_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_DOF
   call RegPack(Buf, InData%StC_Z_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_DSP
   call RegPack(Buf, InData%StC_X_DSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_DSP
   call RegPack(Buf, InData%StC_Y_DSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_DSP
   call RegPack(Buf, InData%StC_Z_DSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_PreLdC
   call RegPack(Buf, InData%StC_Z_PreLdC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_M
   call RegPack(Buf, InData%StC_X_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_M
   call RegPack(Buf, InData%StC_Y_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_M
   call RegPack(Buf, InData%StC_Z_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_XY_M
   call RegPack(Buf, InData%StC_XY_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_K
   call RegPack(Buf, InData%StC_X_K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_K
   call RegPack(Buf, InData%StC_Y_K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_K
   call RegPack(Buf, InData%StC_Z_K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C
   call RegPack(Buf, InData%StC_X_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C
   call RegPack(Buf, InData%StC_Y_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C
   call RegPack(Buf, InData%StC_Z_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_PSP
   call RegPack(Buf, InData%StC_X_PSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_NSP
   call RegPack(Buf, InData%StC_X_NSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_PSP
   call RegPack(Buf, InData%StC_Y_PSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_NSP
   call RegPack(Buf, InData%StC_Y_NSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_PSP
   call RegPack(Buf, InData%StC_Z_PSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_NSP
   call RegPack(Buf, InData%StC_Z_NSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_KS
   call RegPack(Buf, InData%StC_X_KS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_CS
   call RegPack(Buf, InData%StC_X_CS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_KS
   call RegPack(Buf, InData%StC_Y_KS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_CS
   call RegPack(Buf, InData%StC_Y_CS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_KS
   call RegPack(Buf, InData%StC_Z_KS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_CS
   call RegPack(Buf, InData%StC_Z_CS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_P_X
   call RegPack(Buf, InData%StC_P_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_P_Y
   call RegPack(Buf, InData%StC_P_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_P_Z
   call RegPack(Buf, InData%StC_P_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_HIGH
   call RegPack(Buf, InData%StC_X_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_LOW
   call RegPack(Buf, InData%StC_X_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_HIGH
   call RegPack(Buf, InData%StC_Y_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_LOW
   call RegPack(Buf, InData%StC_Y_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_HIGH
   call RegPack(Buf, InData%StC_Z_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_LOW
   call RegPack(Buf, InData%StC_Z_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_BRAKE
   call RegPack(Buf, InData%StC_X_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_BRAKE
   call RegPack(Buf, InData%StC_Y_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_BRAKE
   call RegPack(Buf, InData%StC_Z_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_X
   call RegPack(Buf, InData%L_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_X
   call RegPack(Buf, InData%B_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_X
   call RegPack(Buf, InData%area_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_X
   call RegPack(Buf, InData%area_ratio_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_X
   call RegPack(Buf, InData%headLossCoeff_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_X
   call RegPack(Buf, InData%rho_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_Y
   call RegPack(Buf, InData%L_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_Y
   call RegPack(Buf, InData%B_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_Y
   call RegPack(Buf, InData%area_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_Y
   call RegPack(Buf, InData%area_ratio_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_Y
   call RegPack(Buf, InData%headLossCoeff_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_Y
   call RegPack(Buf, InData%rho_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! USE_F_TBL
   call RegPack(Buf, InData%USE_F_TBL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NKInpSt
   call RegPack(Buf, InData%NKInpSt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_F_TBL_FILE
   call RegPack(Buf, InData%StC_F_TBL_FILE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_TBL
   call RegPack(Buf, allocated(InData%F_TBL))
   if (allocated(InData%F_TBL)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_TBL), ubound(InData%F_TBL))
      call RegPack(Buf, InData%F_TBL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedForcesCoordSys
   call RegPack(Buf, InData%PrescribedForcesCoordSys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedForcesFile
   call RegPack(Buf, InData%PrescribedForcesFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_PrescribedForce
   call RegPack(Buf, allocated(InData%StC_PrescribedForce))
   if (allocated(InData%StC_PrescribedForce)) then
      call RegPackBounds(Buf, 2, lbound(InData%StC_PrescribedForce), ubound(InData%StC_PrescribedForce))
      call RegPack(Buf, InData%StC_PrescribedForce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_CChan
   call RegPack(Buf, allocated(InData%StC_CChan))
   if (allocated(InData%StC_CChan)) then
      call RegPackBounds(Buf, 1, lbound(InData%StC_CChan), ubound(InData%StC_CChan))
      call RegPack(Buf, InData%StC_CChan)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackInputFile'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! StCFileName
   call RegUnpack(Buf, OutData%StCFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_CMODE
   call RegUnpack(Buf, OutData%StC_CMODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_SA_MODE
   call RegUnpack(Buf, OutData%StC_SA_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_DOF_MODE
   call RegUnpack(Buf, OutData%StC_DOF_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_DOF
   call RegUnpack(Buf, OutData%StC_X_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_DOF
   call RegUnpack(Buf, OutData%StC_Y_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_DOF
   call RegUnpack(Buf, OutData%StC_Z_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_DSP
   call RegUnpack(Buf, OutData%StC_X_DSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_DSP
   call RegUnpack(Buf, OutData%StC_Y_DSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_DSP
   call RegUnpack(Buf, OutData%StC_Z_DSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_PreLdC
   call RegUnpack(Buf, OutData%StC_Z_PreLdC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_M
   call RegUnpack(Buf, OutData%StC_X_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_M
   call RegUnpack(Buf, OutData%StC_Y_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_M
   call RegUnpack(Buf, OutData%StC_Z_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_XY_M
   call RegUnpack(Buf, OutData%StC_XY_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_K
   call RegUnpack(Buf, OutData%StC_X_K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_K
   call RegUnpack(Buf, OutData%StC_Y_K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_K
   call RegUnpack(Buf, OutData%StC_Z_K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C
   call RegUnpack(Buf, OutData%StC_X_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C
   call RegUnpack(Buf, OutData%StC_Y_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C
   call RegUnpack(Buf, OutData%StC_Z_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_PSP
   call RegUnpack(Buf, OutData%StC_X_PSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_NSP
   call RegUnpack(Buf, OutData%StC_X_NSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_PSP
   call RegUnpack(Buf, OutData%StC_Y_PSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_NSP
   call RegUnpack(Buf, OutData%StC_Y_NSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_PSP
   call RegUnpack(Buf, OutData%StC_Z_PSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_NSP
   call RegUnpack(Buf, OutData%StC_Z_NSP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_KS
   call RegUnpack(Buf, OutData%StC_X_KS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_CS
   call RegUnpack(Buf, OutData%StC_X_CS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_KS
   call RegUnpack(Buf, OutData%StC_Y_KS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_CS
   call RegUnpack(Buf, OutData%StC_Y_CS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_KS
   call RegUnpack(Buf, OutData%StC_Z_KS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_CS
   call RegUnpack(Buf, OutData%StC_Z_CS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_P_X
   call RegUnpack(Buf, OutData%StC_P_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_P_Y
   call RegUnpack(Buf, OutData%StC_P_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_P_Z
   call RegUnpack(Buf, OutData%StC_P_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_HIGH
   call RegUnpack(Buf, OutData%StC_X_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_LOW
   call RegUnpack(Buf, OutData%StC_X_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_HIGH
   call RegUnpack(Buf, OutData%StC_Y_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_LOW
   call RegUnpack(Buf, OutData%StC_Y_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_HIGH
   call RegUnpack(Buf, OutData%StC_Z_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_LOW
   call RegUnpack(Buf, OutData%StC_Z_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_BRAKE
   call RegUnpack(Buf, OutData%StC_X_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_BRAKE
   call RegUnpack(Buf, OutData%StC_Y_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_BRAKE
   call RegUnpack(Buf, OutData%StC_Z_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_X
   call RegUnpack(Buf, OutData%L_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_X
   call RegUnpack(Buf, OutData%B_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_X
   call RegUnpack(Buf, OutData%area_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_X
   call RegUnpack(Buf, OutData%area_ratio_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_X
   call RegUnpack(Buf, OutData%headLossCoeff_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_X
   call RegUnpack(Buf, OutData%rho_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_Y
   call RegUnpack(Buf, OutData%L_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_Y
   call RegUnpack(Buf, OutData%B_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_Y
   call RegUnpack(Buf, OutData%area_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_Y
   call RegUnpack(Buf, OutData%area_ratio_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_Y
   call RegUnpack(Buf, OutData%headLossCoeff_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_Y
   call RegUnpack(Buf, OutData%rho_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! USE_F_TBL
   call RegUnpack(Buf, OutData%USE_F_TBL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NKInpSt
   call RegUnpack(Buf, OutData%NKInpSt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_F_TBL_FILE
   call RegUnpack(Buf, OutData%StC_F_TBL_FILE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_TBL
   if (allocated(OutData%F_TBL)) deallocate(OutData%F_TBL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_TBL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_TBL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_TBL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrescribedForcesCoordSys
   call RegUnpack(Buf, OutData%PrescribedForcesCoordSys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedForcesFile
   call RegUnpack(Buf, OutData%PrescribedForcesFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_PrescribedForce
   if (allocated(OutData%StC_PrescribedForce)) deallocate(OutData%StC_PrescribedForce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StC_PrescribedForce(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StC_PrescribedForce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StC_PrescribedForce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StC_CChan
   if (allocated(OutData%StC_CChan)) deallocate(OutData%StC_CChan)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StC_CChan(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StC_CChan.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StC_CChan)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE StC_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(StC_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%NumMeshPts = SrcInitInputData%NumMeshPts
IF (ALLOCATED(SrcInitInputData%InitRefPos)) THEN
  i1_l = LBOUND(SrcInitInputData%InitRefPos,1)
  i1_u = UBOUND(SrcInitInputData%InitRefPos,1)
  i2_l = LBOUND(SrcInitInputData%InitRefPos,2)
  i2_u = UBOUND(SrcInitInputData%InitRefPos,2)
  IF (.NOT. ALLOCATED(DstInitInputData%InitRefPos)) THEN 
    ALLOCATE(DstInitInputData%InitRefPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InitRefPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%InitRefPos = SrcInitInputData%InitRefPos
ENDIF
IF (ALLOCATED(SrcInitInputData%InitTransDisp)) THEN
  i1_l = LBOUND(SrcInitInputData%InitTransDisp,1)
  i1_u = UBOUND(SrcInitInputData%InitTransDisp,1)
  i2_l = LBOUND(SrcInitInputData%InitTransDisp,2)
  i2_u = UBOUND(SrcInitInputData%InitTransDisp,2)
  IF (.NOT. ALLOCATED(DstInitInputData%InitTransDisp)) THEN 
    ALLOCATE(DstInitInputData%InitTransDisp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InitTransDisp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%InitTransDisp = SrcInitInputData%InitTransDisp
ENDIF
IF (ALLOCATED(SrcInitInputData%InitOrient)) THEN
  i1_l = LBOUND(SrcInitInputData%InitOrient,1)
  i1_u = UBOUND(SrcInitInputData%InitOrient,1)
  i2_l = LBOUND(SrcInitInputData%InitOrient,2)
  i2_u = UBOUND(SrcInitInputData%InitOrient,2)
  i3_l = LBOUND(SrcInitInputData%InitOrient,3)
  i3_u = UBOUND(SrcInitInputData%InitOrient,3)
  IF (.NOT. ALLOCATED(DstInitInputData%InitOrient)) THEN 
    ALLOCATE(DstInitInputData%InitOrient(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InitOrient.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%InitOrient = SrcInitInputData%InitOrient
ENDIF
IF (ALLOCATED(SrcInitInputData%InitRefOrient)) THEN
  i1_l = LBOUND(SrcInitInputData%InitRefOrient,1)
  i1_u = UBOUND(SrcInitInputData%InitRefOrient,1)
  i2_l = LBOUND(SrcInitInputData%InitRefOrient,2)
  i2_u = UBOUND(SrcInitInputData%InitRefOrient,2)
  i3_l = LBOUND(SrcInitInputData%InitRefOrient,3)
  i3_u = UBOUND(SrcInitInputData%InitRefOrient,3)
  IF (.NOT. ALLOCATED(DstInitInputData%InitRefOrient)) THEN 
    ALLOCATE(DstInitInputData%InitRefOrient(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%InitRefOrient.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%InitRefOrient = SrcInitInputData%InitRefOrient
ENDIF
    DstInitInputData%UseInputFile = SrcInitInputData%UseInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedPrimaryInputData, DstInitInputData%PassedPrimaryInputData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%UseInputFile_PrescribeFrc = SrcInitInputData%UseInputFile_PrescribeFrc
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedPrescribeFrcData, DstInitInputData%PassedPrescribeFrcData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE StC_CopyInitInput

 SUBROUTINE StC_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(StC_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%InitRefPos)) THEN
  DEALLOCATE(InitInputData%InitRefPos)
ENDIF
IF (ALLOCATED(InitInputData%InitTransDisp)) THEN
  DEALLOCATE(InitInputData%InitTransDisp)
ENDIF
IF (ALLOCATED(InitInputData%InitOrient)) THEN
  DEALLOCATE(InitInputData%InitOrient)
ENDIF
IF (ALLOCATED(InitInputData%InitRefOrient)) THEN
  DEALLOCATE(InitInputData%InitRefOrient)
ENDIF
  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedPrimaryInputData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedPrescribeFrcData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE StC_DestroyInitInput


subroutine StC_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumMeshPts
   call RegPack(Buf, InData%NumMeshPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitRefPos
   call RegPack(Buf, allocated(InData%InitRefPos))
   if (allocated(InData%InitRefPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitRefPos), ubound(InData%InitRefPos))
      call RegPack(Buf, InData%InitRefPos)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitTransDisp
   call RegPack(Buf, allocated(InData%InitTransDisp))
   if (allocated(InData%InitTransDisp)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitTransDisp), ubound(InData%InitTransDisp))
      call RegPack(Buf, InData%InitTransDisp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitOrient
   call RegPack(Buf, allocated(InData%InitOrient))
   if (allocated(InData%InitOrient)) then
      call RegPackBounds(Buf, 3, lbound(InData%InitOrient), ubound(InData%InitOrient))
      call RegPack(Buf, InData%InitOrient)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitRefOrient
   call RegPack(Buf, allocated(InData%InitRefOrient))
   if (allocated(InData%InitRefOrient)) then
      call RegPackBounds(Buf, 3, lbound(InData%InitRefOrient), ubound(InData%InitRefOrient))
      call RegPack(Buf, InData%InitRefOrient)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegPack(Buf, InData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedPrimaryInputData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile_PrescribeFrc
   call RegPack(Buf, InData%UseInputFile_PrescribeFrc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrescribeFrcData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedPrescribeFrcData) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumMeshPts
   call RegUnpack(Buf, OutData%NumMeshPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitRefPos
   if (allocated(OutData%InitRefPos)) deallocate(OutData%InitRefPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitRefPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitRefPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitRefPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitTransDisp
   if (allocated(OutData%InitTransDisp)) deallocate(OutData%InitTransDisp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitTransDisp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitTransDisp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitTransDisp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitOrient
   if (allocated(OutData%InitOrient)) deallocate(OutData%InitOrient)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitOrient(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitOrient.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitOrient)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitRefOrient
   if (allocated(OutData%InitRefOrient)) deallocate(OutData%InitRefOrient)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitRefOrient(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitRefOrient.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitRefOrient)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UseInputFile
   call RegUnpack(Buf, OutData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedPrimaryInputData) ! PassedPrimaryInputData 
   ! UseInputFile_PrescribeFrc
   call RegUnpack(Buf, OutData%UseInputFile_PrescribeFrc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrescribeFrcData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedPrescribeFrcData) ! PassedPrescribeFrcData 
end subroutine
 SUBROUTINE StC_CopyCtrlChanInitInfoType( SrcCtrlChanInitInfoTypeData, DstCtrlChanInitInfoTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_CtrlChanInitInfoType), INTENT(IN) :: SrcCtrlChanInitInfoTypeData
   TYPE(StC_CtrlChanInitInfoType), INTENT(INOUT) :: DstCtrlChanInitInfoTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyCtrlChanInitInfoType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%Requestor)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%Requestor,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%Requestor,1)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%Requestor)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%Requestor(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%Requestor.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%Requestor = SrcCtrlChanInitInfoTypeData%Requestor
ENDIF
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%InitStiff)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitStiff,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitStiff,1)
  i2_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitStiff,2)
  i2_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitStiff,2)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%InitStiff)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%InitStiff(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%InitStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%InitStiff = SrcCtrlChanInitInfoTypeData%InitStiff
ENDIF
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%InitDamp)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitDamp,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitDamp,1)
  i2_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitDamp,2)
  i2_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitDamp,2)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%InitDamp)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%InitDamp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%InitDamp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%InitDamp = SrcCtrlChanInitInfoTypeData%InitDamp
ENDIF
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%InitBrake)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitBrake,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitBrake,1)
  i2_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitBrake,2)
  i2_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitBrake,2)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%InitBrake)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%InitBrake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%InitBrake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%InitBrake = SrcCtrlChanInitInfoTypeData%InitBrake
ENDIF
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%InitForce)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitForce,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitForce,1)
  i2_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitForce,2)
  i2_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitForce,2)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%InitForce)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%InitForce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%InitForce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%InitForce = SrcCtrlChanInitInfoTypeData%InitForce
ENDIF
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%InitMeasDisp)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitMeasDisp,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitMeasDisp,1)
  i2_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitMeasDisp,2)
  i2_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitMeasDisp,2)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%InitMeasDisp)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%InitMeasDisp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%InitMeasDisp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%InitMeasDisp = SrcCtrlChanInitInfoTypeData%InitMeasDisp
ENDIF
IF (ALLOCATED(SrcCtrlChanInitInfoTypeData%InitMeasVel)) THEN
  i1_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitMeasVel,1)
  i1_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitMeasVel,1)
  i2_l = LBOUND(SrcCtrlChanInitInfoTypeData%InitMeasVel,2)
  i2_u = UBOUND(SrcCtrlChanInitInfoTypeData%InitMeasVel,2)
  IF (.NOT. ALLOCATED(DstCtrlChanInitInfoTypeData%InitMeasVel)) THEN 
    ALLOCATE(DstCtrlChanInitInfoTypeData%InitMeasVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCtrlChanInitInfoTypeData%InitMeasVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCtrlChanInitInfoTypeData%InitMeasVel = SrcCtrlChanInitInfoTypeData%InitMeasVel
ENDIF
 END SUBROUTINE StC_CopyCtrlChanInitInfoType

 SUBROUTINE StC_DestroyCtrlChanInitInfoType( CtrlChanInitInfoTypeData, ErrStat, ErrMsg )
  TYPE(StC_CtrlChanInitInfoType), INTENT(INOUT) :: CtrlChanInitInfoTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyCtrlChanInitInfoType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(CtrlChanInitInfoTypeData%Requestor)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%Requestor)
ENDIF
IF (ALLOCATED(CtrlChanInitInfoTypeData%InitStiff)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%InitStiff)
ENDIF
IF (ALLOCATED(CtrlChanInitInfoTypeData%InitDamp)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%InitDamp)
ENDIF
IF (ALLOCATED(CtrlChanInitInfoTypeData%InitBrake)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%InitBrake)
ENDIF
IF (ALLOCATED(CtrlChanInitInfoTypeData%InitForce)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%InitForce)
ENDIF
IF (ALLOCATED(CtrlChanInitInfoTypeData%InitMeasDisp)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%InitMeasDisp)
ENDIF
IF (ALLOCATED(CtrlChanInitInfoTypeData%InitMeasVel)) THEN
  DEALLOCATE(CtrlChanInitInfoTypeData%InitMeasVel)
ENDIF
 END SUBROUTINE StC_DestroyCtrlChanInitInfoType


subroutine StC_PackCtrlChanInitInfoType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_CtrlChanInitInfoType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackCtrlChanInitInfoType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Requestor
   call RegPack(Buf, allocated(InData%Requestor))
   if (allocated(InData%Requestor)) then
      call RegPackBounds(Buf, 1, lbound(InData%Requestor), ubound(InData%Requestor))
      call RegPack(Buf, InData%Requestor)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitStiff
   call RegPack(Buf, allocated(InData%InitStiff))
   if (allocated(InData%InitStiff)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitStiff), ubound(InData%InitStiff))
      call RegPack(Buf, InData%InitStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitDamp
   call RegPack(Buf, allocated(InData%InitDamp))
   if (allocated(InData%InitDamp)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitDamp), ubound(InData%InitDamp))
      call RegPack(Buf, InData%InitDamp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitBrake
   call RegPack(Buf, allocated(InData%InitBrake))
   if (allocated(InData%InitBrake)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitBrake), ubound(InData%InitBrake))
      call RegPack(Buf, InData%InitBrake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitForce
   call RegPack(Buf, allocated(InData%InitForce))
   if (allocated(InData%InitForce)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitForce), ubound(InData%InitForce))
      call RegPack(Buf, InData%InitForce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitMeasDisp
   call RegPack(Buf, allocated(InData%InitMeasDisp))
   if (allocated(InData%InitMeasDisp)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitMeasDisp), ubound(InData%InitMeasDisp))
      call RegPack(Buf, InData%InitMeasDisp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitMeasVel
   call RegPack(Buf, allocated(InData%InitMeasVel))
   if (allocated(InData%InitMeasVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%InitMeasVel), ubound(InData%InitMeasVel))
      call RegPack(Buf, InData%InitMeasVel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackCtrlChanInitInfoType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_CtrlChanInitInfoType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackCtrlChanInitInfoType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Requestor
   if (allocated(OutData%Requestor)) deallocate(OutData%Requestor)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Requestor(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Requestor.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Requestor)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitStiff
   if (allocated(OutData%InitStiff)) deallocate(OutData%InitStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitStiff(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitDamp
   if (allocated(OutData%InitDamp)) deallocate(OutData%InitDamp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitDamp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitDamp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitDamp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitBrake
   if (allocated(OutData%InitBrake)) deallocate(OutData%InitBrake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitBrake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitBrake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitBrake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitForce
   if (allocated(OutData%InitForce)) deallocate(OutData%InitForce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitForce(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitForce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitForce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitMeasDisp
   if (allocated(OutData%InitMeasDisp)) deallocate(OutData%InitMeasDisp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitMeasDisp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitMeasDisp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitMeasDisp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InitMeasVel
   if (allocated(OutData%InitMeasVel)) deallocate(OutData%InitMeasVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InitMeasVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InitMeasVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InitMeasVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE StC_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(StC_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%RelPosition)) THEN
  i1_l = LBOUND(SrcInitOutputData%RelPosition,1)
  i1_u = UBOUND(SrcInitOutputData%RelPosition,1)
  i2_l = LBOUND(SrcInitOutputData%RelPosition,2)
  i2_u = UBOUND(SrcInitOutputData%RelPosition,2)
  IF (.NOT. ALLOCATED(DstInitOutputData%RelPosition)) THEN 
    ALLOCATE(DstInitOutputData%RelPosition(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RelPosition.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RelPosition = SrcInitOutputData%RelPosition
ENDIF
 END SUBROUTINE StC_CopyInitOutput

 SUBROUTINE StC_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(StC_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%RelPosition)) THEN
  DEALLOCATE(InitOutputData%RelPosition)
ENDIF
 END SUBROUTINE StC_DestroyInitOutput


subroutine StC_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! RelPosition
   call RegPack(Buf, allocated(InData%RelPosition))
   if (allocated(InData%RelPosition)) then
      call RegPackBounds(Buf, 2, lbound(InData%RelPosition), ubound(InData%RelPosition))
      call RegPack(Buf, InData%RelPosition)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackInitOutput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! RelPosition
   if (allocated(OutData%RelPosition)) deallocate(OutData%RelPosition)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RelPosition(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RelPosition.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RelPosition)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE StC_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(StC_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%StC_x)) THEN
  i1_l = LBOUND(SrcContStateData%StC_x,1)
  i1_u = UBOUND(SrcContStateData%StC_x,1)
  i2_l = LBOUND(SrcContStateData%StC_x,2)
  i2_u = UBOUND(SrcContStateData%StC_x,2)
  IF (.NOT. ALLOCATED(DstContStateData%StC_x)) THEN 
    ALLOCATE(DstContStateData%StC_x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%StC_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%StC_x = SrcContStateData%StC_x
ENDIF
 END SUBROUTINE StC_CopyContState

 SUBROUTINE StC_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(StC_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%StC_x)) THEN
  DEALLOCATE(ContStateData%StC_x)
ENDIF
 END SUBROUTINE StC_DestroyContState


subroutine StC_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! StC_x
   call RegPack(Buf, allocated(InData%StC_x))
   if (allocated(InData%StC_x)) then
      call RegPackBounds(Buf, 2, lbound(InData%StC_x), ubound(InData%StC_x))
      call RegPack(Buf, InData%StC_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackContState'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! StC_x
   if (allocated(OutData%StC_x)) deallocate(OutData%StC_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StC_x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StC_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StC_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE StC_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(StC_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE StC_CopyDiscState

 SUBROUTINE StC_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(StC_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE StC_DestroyDiscState


subroutine StC_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyDiscState
   call RegPack(Buf, InData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyDiscState
   call RegUnpack(Buf, OutData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE StC_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(StC_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE StC_CopyConstrState

 SUBROUTINE StC_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(StC_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE StC_DestroyConstrState


subroutine StC_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE StC_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(StC_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
 END SUBROUTINE StC_CopyOtherState

 SUBROUTINE StC_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(StC_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE StC_DestroyOtherState


subroutine StC_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyOtherState
   call RegPack(Buf, InData%DummyOtherState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyOtherState
   call RegUnpack(Buf, OutData%DummyOtherState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE StC_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(StC_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%F_stop)) THEN
  i1_l = LBOUND(SrcMiscData%F_stop,1)
  i1_u = UBOUND(SrcMiscData%F_stop,1)
  i2_l = LBOUND(SrcMiscData%F_stop,2)
  i2_u = UBOUND(SrcMiscData%F_stop,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_stop)) THEN 
    ALLOCATE(DstMiscData%F_stop(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_stop.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_stop = SrcMiscData%F_stop
ENDIF
IF (ALLOCATED(SrcMiscData%F_ext)) THEN
  i1_l = LBOUND(SrcMiscData%F_ext,1)
  i1_u = UBOUND(SrcMiscData%F_ext,1)
  i2_l = LBOUND(SrcMiscData%F_ext,2)
  i2_u = UBOUND(SrcMiscData%F_ext,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_ext)) THEN 
    ALLOCATE(DstMiscData%F_ext(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_ext.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_ext = SrcMiscData%F_ext
ENDIF
IF (ALLOCATED(SrcMiscData%F_fr)) THEN
  i1_l = LBOUND(SrcMiscData%F_fr,1)
  i1_u = UBOUND(SrcMiscData%F_fr,1)
  i2_l = LBOUND(SrcMiscData%F_fr,2)
  i2_u = UBOUND(SrcMiscData%F_fr,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_fr)) THEN 
    ALLOCATE(DstMiscData%F_fr(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_fr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_fr = SrcMiscData%F_fr
ENDIF
IF (ALLOCATED(SrcMiscData%K)) THEN
  i1_l = LBOUND(SrcMiscData%K,1)
  i1_u = UBOUND(SrcMiscData%K,1)
  i2_l = LBOUND(SrcMiscData%K,2)
  i2_u = UBOUND(SrcMiscData%K,2)
  IF (.NOT. ALLOCATED(DstMiscData%K)) THEN 
    ALLOCATE(DstMiscData%K(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%K.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%K = SrcMiscData%K
ENDIF
IF (ALLOCATED(SrcMiscData%C_ctrl)) THEN
  i1_l = LBOUND(SrcMiscData%C_ctrl,1)
  i1_u = UBOUND(SrcMiscData%C_ctrl,1)
  i2_l = LBOUND(SrcMiscData%C_ctrl,2)
  i2_u = UBOUND(SrcMiscData%C_ctrl,2)
  IF (.NOT. ALLOCATED(DstMiscData%C_ctrl)) THEN 
    ALLOCATE(DstMiscData%C_ctrl(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%C_ctrl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%C_ctrl = SrcMiscData%C_ctrl
ENDIF
IF (ALLOCATED(SrcMiscData%C_Brake)) THEN
  i1_l = LBOUND(SrcMiscData%C_Brake,1)
  i1_u = UBOUND(SrcMiscData%C_Brake,1)
  i2_l = LBOUND(SrcMiscData%C_Brake,2)
  i2_u = UBOUND(SrcMiscData%C_Brake,2)
  IF (.NOT. ALLOCATED(DstMiscData%C_Brake)) THEN 
    ALLOCATE(DstMiscData%C_Brake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%C_Brake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%C_Brake = SrcMiscData%C_Brake
ENDIF
IF (ALLOCATED(SrcMiscData%F_table)) THEN
  i1_l = LBOUND(SrcMiscData%F_table,1)
  i1_u = UBOUND(SrcMiscData%F_table,1)
  i2_l = LBOUND(SrcMiscData%F_table,2)
  i2_u = UBOUND(SrcMiscData%F_table,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_table)) THEN 
    ALLOCATE(DstMiscData%F_table(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_table.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_table = SrcMiscData%F_table
ENDIF
IF (ALLOCATED(SrcMiscData%F_k)) THEN
  i1_l = LBOUND(SrcMiscData%F_k,1)
  i1_u = UBOUND(SrcMiscData%F_k,1)
  i2_l = LBOUND(SrcMiscData%F_k,2)
  i2_u = UBOUND(SrcMiscData%F_k,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_k)) THEN 
    ALLOCATE(DstMiscData%F_k(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_k.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_k = SrcMiscData%F_k
ENDIF
IF (ALLOCATED(SrcMiscData%a_G)) THEN
  i1_l = LBOUND(SrcMiscData%a_G,1)
  i1_u = UBOUND(SrcMiscData%a_G,1)
  i2_l = LBOUND(SrcMiscData%a_G,2)
  i2_u = UBOUND(SrcMiscData%a_G,2)
  IF (.NOT. ALLOCATED(DstMiscData%a_G)) THEN 
    ALLOCATE(DstMiscData%a_G(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%a_G.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%a_G = SrcMiscData%a_G
ENDIF
IF (ALLOCATED(SrcMiscData%rdisp_P)) THEN
  i1_l = LBOUND(SrcMiscData%rdisp_P,1)
  i1_u = UBOUND(SrcMiscData%rdisp_P,1)
  i2_l = LBOUND(SrcMiscData%rdisp_P,2)
  i2_u = UBOUND(SrcMiscData%rdisp_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%rdisp_P)) THEN 
    ALLOCATE(DstMiscData%rdisp_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rdisp_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%rdisp_P = SrcMiscData%rdisp_P
ENDIF
IF (ALLOCATED(SrcMiscData%rdot_P)) THEN
  i1_l = LBOUND(SrcMiscData%rdot_P,1)
  i1_u = UBOUND(SrcMiscData%rdot_P,1)
  i2_l = LBOUND(SrcMiscData%rdot_P,2)
  i2_u = UBOUND(SrcMiscData%rdot_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%rdot_P)) THEN 
    ALLOCATE(DstMiscData%rdot_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rdot_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%rdot_P = SrcMiscData%rdot_P
ENDIF
IF (ALLOCATED(SrcMiscData%rddot_P)) THEN
  i1_l = LBOUND(SrcMiscData%rddot_P,1)
  i1_u = UBOUND(SrcMiscData%rddot_P,1)
  i2_l = LBOUND(SrcMiscData%rddot_P,2)
  i2_u = UBOUND(SrcMiscData%rddot_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%rddot_P)) THEN 
    ALLOCATE(DstMiscData%rddot_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rddot_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%rddot_P = SrcMiscData%rddot_P
ENDIF
IF (ALLOCATED(SrcMiscData%omega_P)) THEN
  i1_l = LBOUND(SrcMiscData%omega_P,1)
  i1_u = UBOUND(SrcMiscData%omega_P,1)
  i2_l = LBOUND(SrcMiscData%omega_P,2)
  i2_u = UBOUND(SrcMiscData%omega_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%omega_P)) THEN 
    ALLOCATE(DstMiscData%omega_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%omega_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%omega_P = SrcMiscData%omega_P
ENDIF
IF (ALLOCATED(SrcMiscData%alpha_P)) THEN
  i1_l = LBOUND(SrcMiscData%alpha_P,1)
  i1_u = UBOUND(SrcMiscData%alpha_P,1)
  i2_l = LBOUND(SrcMiscData%alpha_P,2)
  i2_u = UBOUND(SrcMiscData%alpha_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%alpha_P)) THEN 
    ALLOCATE(DstMiscData%alpha_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%alpha_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%alpha_P = SrcMiscData%alpha_P
ENDIF
IF (ALLOCATED(SrcMiscData%F_P)) THEN
  i1_l = LBOUND(SrcMiscData%F_P,1)
  i1_u = UBOUND(SrcMiscData%F_P,1)
  i2_l = LBOUND(SrcMiscData%F_P,2)
  i2_u = UBOUND(SrcMiscData%F_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_P)) THEN 
    ALLOCATE(DstMiscData%F_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_P = SrcMiscData%F_P
ENDIF
IF (ALLOCATED(SrcMiscData%M_P)) THEN
  i1_l = LBOUND(SrcMiscData%M_P,1)
  i1_u = UBOUND(SrcMiscData%M_P,1)
  i2_l = LBOUND(SrcMiscData%M_P,2)
  i2_u = UBOUND(SrcMiscData%M_P,2)
  IF (.NOT. ALLOCATED(DstMiscData%M_P)) THEN 
    ALLOCATE(DstMiscData%M_P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%M_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%M_P = SrcMiscData%M_P
ENDIF
IF (ALLOCATED(SrcMiscData%Acc)) THEN
  i1_l = LBOUND(SrcMiscData%Acc,1)
  i1_u = UBOUND(SrcMiscData%Acc,1)
  i2_l = LBOUND(SrcMiscData%Acc,2)
  i2_u = UBOUND(SrcMiscData%Acc,2)
  IF (.NOT. ALLOCATED(DstMiscData%Acc)) THEN 
    ALLOCATE(DstMiscData%Acc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Acc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Acc = SrcMiscData%Acc
ENDIF
    DstMiscData%PrescribedInterpIdx = SrcMiscData%PrescribedInterpIdx
 END SUBROUTINE StC_CopyMisc

 SUBROUTINE StC_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(StC_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%F_stop)) THEN
  DEALLOCATE(MiscData%F_stop)
ENDIF
IF (ALLOCATED(MiscData%F_ext)) THEN
  DEALLOCATE(MiscData%F_ext)
ENDIF
IF (ALLOCATED(MiscData%F_fr)) THEN
  DEALLOCATE(MiscData%F_fr)
ENDIF
IF (ALLOCATED(MiscData%K)) THEN
  DEALLOCATE(MiscData%K)
ENDIF
IF (ALLOCATED(MiscData%C_ctrl)) THEN
  DEALLOCATE(MiscData%C_ctrl)
ENDIF
IF (ALLOCATED(MiscData%C_Brake)) THEN
  DEALLOCATE(MiscData%C_Brake)
ENDIF
IF (ALLOCATED(MiscData%F_table)) THEN
  DEALLOCATE(MiscData%F_table)
ENDIF
IF (ALLOCATED(MiscData%F_k)) THEN
  DEALLOCATE(MiscData%F_k)
ENDIF
IF (ALLOCATED(MiscData%a_G)) THEN
  DEALLOCATE(MiscData%a_G)
ENDIF
IF (ALLOCATED(MiscData%rdisp_P)) THEN
  DEALLOCATE(MiscData%rdisp_P)
ENDIF
IF (ALLOCATED(MiscData%rdot_P)) THEN
  DEALLOCATE(MiscData%rdot_P)
ENDIF
IF (ALLOCATED(MiscData%rddot_P)) THEN
  DEALLOCATE(MiscData%rddot_P)
ENDIF
IF (ALLOCATED(MiscData%omega_P)) THEN
  DEALLOCATE(MiscData%omega_P)
ENDIF
IF (ALLOCATED(MiscData%alpha_P)) THEN
  DEALLOCATE(MiscData%alpha_P)
ENDIF
IF (ALLOCATED(MiscData%F_P)) THEN
  DEALLOCATE(MiscData%F_P)
ENDIF
IF (ALLOCATED(MiscData%M_P)) THEN
  DEALLOCATE(MiscData%M_P)
ENDIF
IF (ALLOCATED(MiscData%Acc)) THEN
  DEALLOCATE(MiscData%Acc)
ENDIF
 END SUBROUTINE StC_DestroyMisc


subroutine StC_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! F_stop
   call RegPack(Buf, allocated(InData%F_stop))
   if (allocated(InData%F_stop)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_stop), ubound(InData%F_stop))
      call RegPack(Buf, InData%F_stop)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_ext
   call RegPack(Buf, allocated(InData%F_ext))
   if (allocated(InData%F_ext)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_ext), ubound(InData%F_ext))
      call RegPack(Buf, InData%F_ext)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_fr
   call RegPack(Buf, allocated(InData%F_fr))
   if (allocated(InData%F_fr)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_fr), ubound(InData%F_fr))
      call RegPack(Buf, InData%F_fr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! K
   call RegPack(Buf, allocated(InData%K))
   if (allocated(InData%K)) then
      call RegPackBounds(Buf, 2, lbound(InData%K), ubound(InData%K))
      call RegPack(Buf, InData%K)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_ctrl
   call RegPack(Buf, allocated(InData%C_ctrl))
   if (allocated(InData%C_ctrl)) then
      call RegPackBounds(Buf, 2, lbound(InData%C_ctrl), ubound(InData%C_ctrl))
      call RegPack(Buf, InData%C_ctrl)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Brake
   call RegPack(Buf, allocated(InData%C_Brake))
   if (allocated(InData%C_Brake)) then
      call RegPackBounds(Buf, 2, lbound(InData%C_Brake), ubound(InData%C_Brake))
      call RegPack(Buf, InData%C_Brake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_table
   call RegPack(Buf, allocated(InData%F_table))
   if (allocated(InData%F_table)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_table), ubound(InData%F_table))
      call RegPack(Buf, InData%F_table)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_k
   call RegPack(Buf, allocated(InData%F_k))
   if (allocated(InData%F_k)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_k), ubound(InData%F_k))
      call RegPack(Buf, InData%F_k)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! a_G
   call RegPack(Buf, allocated(InData%a_G))
   if (allocated(InData%a_G)) then
      call RegPackBounds(Buf, 2, lbound(InData%a_G), ubound(InData%a_G))
      call RegPack(Buf, InData%a_G)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rdisp_P
   call RegPack(Buf, allocated(InData%rdisp_P))
   if (allocated(InData%rdisp_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%rdisp_P), ubound(InData%rdisp_P))
      call RegPack(Buf, InData%rdisp_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rdot_P
   call RegPack(Buf, allocated(InData%rdot_P))
   if (allocated(InData%rdot_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%rdot_P), ubound(InData%rdot_P))
      call RegPack(Buf, InData%rdot_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rddot_P
   call RegPack(Buf, allocated(InData%rddot_P))
   if (allocated(InData%rddot_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%rddot_P), ubound(InData%rddot_P))
      call RegPack(Buf, InData%rddot_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! omega_P
   call RegPack(Buf, allocated(InData%omega_P))
   if (allocated(InData%omega_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%omega_P), ubound(InData%omega_P))
      call RegPack(Buf, InData%omega_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! alpha_P
   call RegPack(Buf, allocated(InData%alpha_P))
   if (allocated(InData%alpha_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%alpha_P), ubound(InData%alpha_P))
      call RegPack(Buf, InData%alpha_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_P
   call RegPack(Buf, allocated(InData%F_P))
   if (allocated(InData%F_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_P), ubound(InData%F_P))
      call RegPack(Buf, InData%F_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_P
   call RegPack(Buf, allocated(InData%M_P))
   if (allocated(InData%M_P)) then
      call RegPackBounds(Buf, 2, lbound(InData%M_P), ubound(InData%M_P))
      call RegPack(Buf, InData%M_P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Acc
   call RegPack(Buf, allocated(InData%Acc))
   if (allocated(InData%Acc)) then
      call RegPackBounds(Buf, 2, lbound(InData%Acc), ubound(InData%Acc))
      call RegPack(Buf, InData%Acc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedInterpIdx
   call RegPack(Buf, InData%PrescribedInterpIdx)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackMisc'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! F_stop
   if (allocated(OutData%F_stop)) deallocate(OutData%F_stop)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_stop(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_stop.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_stop)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_ext
   if (allocated(OutData%F_ext)) deallocate(OutData%F_ext)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_ext(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_ext.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_ext)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_fr
   if (allocated(OutData%F_fr)) deallocate(OutData%F_fr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_fr(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_fr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_fr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! K
   if (allocated(OutData%K)) deallocate(OutData%K)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%K(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%K.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%K)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C_ctrl
   if (allocated(OutData%C_ctrl)) deallocate(OutData%C_ctrl)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C_ctrl(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C_ctrl.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C_ctrl)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C_Brake
   if (allocated(OutData%C_Brake)) deallocate(OutData%C_Brake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C_Brake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C_Brake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C_Brake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_table
   if (allocated(OutData%F_table)) deallocate(OutData%F_table)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_table(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_table.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_table)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_k
   if (allocated(OutData%F_k)) deallocate(OutData%F_k)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_k(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_k.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_k)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! a_G
   if (allocated(OutData%a_G)) deallocate(OutData%a_G)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%a_G(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%a_G.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%a_G)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rdisp_P
   if (allocated(OutData%rdisp_P)) deallocate(OutData%rdisp_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rdisp_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rdisp_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rdisp_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rdot_P
   if (allocated(OutData%rdot_P)) deallocate(OutData%rdot_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rdot_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rdot_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rdot_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rddot_P
   if (allocated(OutData%rddot_P)) deallocate(OutData%rddot_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rddot_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rddot_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rddot_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! omega_P
   if (allocated(OutData%omega_P)) deallocate(OutData%omega_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%omega_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%omega_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%omega_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! alpha_P
   if (allocated(OutData%alpha_P)) deallocate(OutData%alpha_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%alpha_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%alpha_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%alpha_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_P
   if (allocated(OutData%F_P)) deallocate(OutData%F_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! M_P
   if (allocated(OutData%M_P)) deallocate(OutData%M_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%M_P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%M_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%M_P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Acc
   if (allocated(OutData%Acc)) deallocate(OutData%Acc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Acc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Acc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Acc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrescribedInterpIdx
   call RegUnpack(Buf, OutData%PrescribedInterpIdx)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE StC_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(StC_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%RootName = SrcParamData%RootName
    DstParamData%StC_DOF_MODE = SrcParamData%StC_DOF_MODE
    DstParamData%StC_X_DOF = SrcParamData%StC_X_DOF
    DstParamData%StC_Y_DOF = SrcParamData%StC_Y_DOF
    DstParamData%StC_Z_DOF = SrcParamData%StC_Z_DOF
    DstParamData%StC_Z_PreLd = SrcParamData%StC_Z_PreLd
    DstParamData%M_X = SrcParamData%M_X
    DstParamData%M_Y = SrcParamData%M_Y
    DstParamData%M_Z = SrcParamData%M_Z
    DstParamData%M_XY = SrcParamData%M_XY
    DstParamData%K_X = SrcParamData%K_X
    DstParamData%K_Y = SrcParamData%K_Y
    DstParamData%K_Z = SrcParamData%K_Z
    DstParamData%C_X = SrcParamData%C_X
    DstParamData%C_Y = SrcParamData%C_Y
    DstParamData%C_Z = SrcParamData%C_Z
    DstParamData%K_S = SrcParamData%K_S
    DstParamData%C_S = SrcParamData%C_S
    DstParamData%P_SP = SrcParamData%P_SP
    DstParamData%N_SP = SrcParamData%N_SP
    DstParamData%Gravity = SrcParamData%Gravity
    DstParamData%StC_CMODE = SrcParamData%StC_CMODE
    DstParamData%StC_SA_MODE = SrcParamData%StC_SA_MODE
    DstParamData%StC_X_C_HIGH = SrcParamData%StC_X_C_HIGH
    DstParamData%StC_X_C_LOW = SrcParamData%StC_X_C_LOW
    DstParamData%StC_Y_C_HIGH = SrcParamData%StC_Y_C_HIGH
    DstParamData%StC_Y_C_LOW = SrcParamData%StC_Y_C_LOW
    DstParamData%StC_Z_C_HIGH = SrcParamData%StC_Z_C_HIGH
    DstParamData%StC_Z_C_LOW = SrcParamData%StC_Z_C_LOW
    DstParamData%StC_X_C_BRAKE = SrcParamData%StC_X_C_BRAKE
    DstParamData%StC_Y_C_BRAKE = SrcParamData%StC_Y_C_BRAKE
    DstParamData%StC_Z_C_BRAKE = SrcParamData%StC_Z_C_BRAKE
    DstParamData%L_X = SrcParamData%L_X
    DstParamData%B_X = SrcParamData%B_X
    DstParamData%area_X = SrcParamData%area_X
    DstParamData%area_ratio_X = SrcParamData%area_ratio_X
    DstParamData%headLossCoeff_X = SrcParamData%headLossCoeff_X
    DstParamData%rho_X = SrcParamData%rho_X
    DstParamData%L_Y = SrcParamData%L_Y
    DstParamData%B_Y = SrcParamData%B_Y
    DstParamData%area_Y = SrcParamData%area_Y
    DstParamData%area_ratio_Y = SrcParamData%area_ratio_Y
    DstParamData%headLossCoeff_Y = SrcParamData%headLossCoeff_Y
    DstParamData%rho_Y = SrcParamData%rho_Y
    DstParamData%Use_F_TBL = SrcParamData%Use_F_TBL
IF (ALLOCATED(SrcParamData%F_TBL)) THEN
  i1_l = LBOUND(SrcParamData%F_TBL,1)
  i1_u = UBOUND(SrcParamData%F_TBL,1)
  i2_l = LBOUND(SrcParamData%F_TBL,2)
  i2_u = UBOUND(SrcParamData%F_TBL,2)
  IF (.NOT. ALLOCATED(DstParamData%F_TBL)) THEN 
    ALLOCATE(DstParamData%F_TBL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%F_TBL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%F_TBL = SrcParamData%F_TBL
ENDIF
    DstParamData%NumMeshPts = SrcParamData%NumMeshPts
    DstParamData%PrescribedForcesCoordSys = SrcParamData%PrescribedForcesCoordSys
IF (ALLOCATED(SrcParamData%StC_PrescribedForce)) THEN
  i1_l = LBOUND(SrcParamData%StC_PrescribedForce,1)
  i1_u = UBOUND(SrcParamData%StC_PrescribedForce,1)
  i2_l = LBOUND(SrcParamData%StC_PrescribedForce,2)
  i2_u = UBOUND(SrcParamData%StC_PrescribedForce,2)
  IF (.NOT. ALLOCATED(DstParamData%StC_PrescribedForce)) THEN 
    ALLOCATE(DstParamData%StC_PrescribedForce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%StC_PrescribedForce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%StC_PrescribedForce = SrcParamData%StC_PrescribedForce
ENDIF
IF (ALLOCATED(SrcParamData%StC_CChan)) THEN
  i1_l = LBOUND(SrcParamData%StC_CChan,1)
  i1_u = UBOUND(SrcParamData%StC_CChan,1)
  IF (.NOT. ALLOCATED(DstParamData%StC_CChan)) THEN 
    ALLOCATE(DstParamData%StC_CChan(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%StC_CChan.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%StC_CChan = SrcParamData%StC_CChan
ENDIF
 END SUBROUTINE StC_CopyParam

 SUBROUTINE StC_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(StC_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%F_TBL)) THEN
  DEALLOCATE(ParamData%F_TBL)
ENDIF
IF (ALLOCATED(ParamData%StC_PrescribedForce)) THEN
  DEALLOCATE(ParamData%StC_PrescribedForce)
ENDIF
IF (ALLOCATED(ParamData%StC_CChan)) THEN
  DEALLOCATE(ParamData%StC_CChan)
ENDIF
 END SUBROUTINE StC_DestroyParam


subroutine StC_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_DOF_MODE
   call RegPack(Buf, InData%StC_DOF_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_DOF
   call RegPack(Buf, InData%StC_X_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_DOF
   call RegPack(Buf, InData%StC_Y_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_DOF
   call RegPack(Buf, InData%StC_Z_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_PreLd
   call RegPack(Buf, InData%StC_Z_PreLd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_X
   call RegPack(Buf, InData%M_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_Y
   call RegPack(Buf, InData%M_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_Z
   call RegPack(Buf, InData%M_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_XY
   call RegPack(Buf, InData%M_XY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_X
   call RegPack(Buf, InData%K_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_Y
   call RegPack(Buf, InData%K_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_Z
   call RegPack(Buf, InData%K_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_X
   call RegPack(Buf, InData%C_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Y
   call RegPack(Buf, InData%C_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Z
   call RegPack(Buf, InData%C_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_S
   call RegPack(Buf, InData%K_S)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_S
   call RegPack(Buf, InData%C_S)
   if (RegCheckErr(Buf, RoutineName)) return
   ! P_SP
   call RegPack(Buf, InData%P_SP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N_SP
   call RegPack(Buf, InData%N_SP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_CMODE
   call RegPack(Buf, InData%StC_CMODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_SA_MODE
   call RegPack(Buf, InData%StC_SA_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_HIGH
   call RegPack(Buf, InData%StC_X_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_LOW
   call RegPack(Buf, InData%StC_X_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_HIGH
   call RegPack(Buf, InData%StC_Y_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_LOW
   call RegPack(Buf, InData%StC_Y_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_HIGH
   call RegPack(Buf, InData%StC_Z_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_LOW
   call RegPack(Buf, InData%StC_Z_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_BRAKE
   call RegPack(Buf, InData%StC_X_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_BRAKE
   call RegPack(Buf, InData%StC_Y_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_BRAKE
   call RegPack(Buf, InData%StC_Z_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_X
   call RegPack(Buf, InData%L_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_X
   call RegPack(Buf, InData%B_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_X
   call RegPack(Buf, InData%area_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_X
   call RegPack(Buf, InData%area_ratio_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_X
   call RegPack(Buf, InData%headLossCoeff_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_X
   call RegPack(Buf, InData%rho_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_Y
   call RegPack(Buf, InData%L_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_Y
   call RegPack(Buf, InData%B_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_Y
   call RegPack(Buf, InData%area_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_Y
   call RegPack(Buf, InData%area_ratio_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_Y
   call RegPack(Buf, InData%headLossCoeff_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_Y
   call RegPack(Buf, InData%rho_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Use_F_TBL
   call RegPack(Buf, InData%Use_F_TBL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_TBL
   call RegPack(Buf, allocated(InData%F_TBL))
   if (allocated(InData%F_TBL)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_TBL), ubound(InData%F_TBL))
      call RegPack(Buf, InData%F_TBL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumMeshPts
   call RegPack(Buf, InData%NumMeshPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedForcesCoordSys
   call RegPack(Buf, InData%PrescribedForcesCoordSys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_PrescribedForce
   call RegPack(Buf, allocated(InData%StC_PrescribedForce))
   if (allocated(InData%StC_PrescribedForce)) then
      call RegPackBounds(Buf, 2, lbound(InData%StC_PrescribedForce), ubound(InData%StC_PrescribedForce))
      call RegPack(Buf, InData%StC_PrescribedForce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_CChan
   call RegPack(Buf, allocated(InData%StC_CChan))
   if (allocated(InData%StC_CChan)) then
      call RegPackBounds(Buf, 1, lbound(InData%StC_CChan), ubound(InData%StC_CChan))
      call RegPack(Buf, InData%StC_CChan)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackParam'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_DOF_MODE
   call RegUnpack(Buf, OutData%StC_DOF_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_DOF
   call RegUnpack(Buf, OutData%StC_X_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_DOF
   call RegUnpack(Buf, OutData%StC_Y_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_DOF
   call RegUnpack(Buf, OutData%StC_Z_DOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_PreLd
   call RegUnpack(Buf, OutData%StC_Z_PreLd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_X
   call RegUnpack(Buf, OutData%M_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_Y
   call RegUnpack(Buf, OutData%M_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_Z
   call RegUnpack(Buf, OutData%M_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_XY
   call RegUnpack(Buf, OutData%M_XY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_X
   call RegUnpack(Buf, OutData%K_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_Y
   call RegUnpack(Buf, OutData%K_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_Z
   call RegUnpack(Buf, OutData%K_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_X
   call RegUnpack(Buf, OutData%C_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Y
   call RegUnpack(Buf, OutData%C_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Z
   call RegUnpack(Buf, OutData%C_Z)
   if (RegCheckErr(Buf, RoutineName)) return
   ! K_S
   call RegUnpack(Buf, OutData%K_S)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_S
   call RegUnpack(Buf, OutData%C_S)
   if (RegCheckErr(Buf, RoutineName)) return
   ! P_SP
   call RegUnpack(Buf, OutData%P_SP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N_SP
   call RegUnpack(Buf, OutData%N_SP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_CMODE
   call RegUnpack(Buf, OutData%StC_CMODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_SA_MODE
   call RegUnpack(Buf, OutData%StC_SA_MODE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_HIGH
   call RegUnpack(Buf, OutData%StC_X_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_LOW
   call RegUnpack(Buf, OutData%StC_X_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_HIGH
   call RegUnpack(Buf, OutData%StC_Y_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_LOW
   call RegUnpack(Buf, OutData%StC_Y_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_HIGH
   call RegUnpack(Buf, OutData%StC_Z_C_HIGH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_LOW
   call RegUnpack(Buf, OutData%StC_Z_C_LOW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_X_C_BRAKE
   call RegUnpack(Buf, OutData%StC_X_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Y_C_BRAKE
   call RegUnpack(Buf, OutData%StC_Y_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_Z_C_BRAKE
   call RegUnpack(Buf, OutData%StC_Z_C_BRAKE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_X
   call RegUnpack(Buf, OutData%L_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_X
   call RegUnpack(Buf, OutData%B_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_X
   call RegUnpack(Buf, OutData%area_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_X
   call RegUnpack(Buf, OutData%area_ratio_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_X
   call RegUnpack(Buf, OutData%headLossCoeff_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_X
   call RegUnpack(Buf, OutData%rho_X)
   if (RegCheckErr(Buf, RoutineName)) return
   ! L_Y
   call RegUnpack(Buf, OutData%L_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_Y
   call RegUnpack(Buf, OutData%B_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_Y
   call RegUnpack(Buf, OutData%area_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! area_ratio_Y
   call RegUnpack(Buf, OutData%area_ratio_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! headLossCoeff_Y
   call RegUnpack(Buf, OutData%headLossCoeff_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho_Y
   call RegUnpack(Buf, OutData%rho_Y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Use_F_TBL
   call RegUnpack(Buf, OutData%Use_F_TBL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_TBL
   if (allocated(OutData%F_TBL)) deallocate(OutData%F_TBL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_TBL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_TBL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_TBL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumMeshPts
   call RegUnpack(Buf, OutData%NumMeshPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedForcesCoordSys
   call RegUnpack(Buf, OutData%PrescribedForcesCoordSys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StC_PrescribedForce
   if (allocated(OutData%StC_PrescribedForce)) deallocate(OutData%StC_PrescribedForce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StC_PrescribedForce(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StC_PrescribedForce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StC_PrescribedForce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StC_CChan
   if (allocated(OutData%StC_CChan)) deallocate(OutData%StC_CChan)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StC_CChan(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StC_CChan.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StC_CChan)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE StC_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(StC_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%Mesh)) THEN
  i1_l = LBOUND(SrcInputData%Mesh,1)
  i1_u = UBOUND(SrcInputData%Mesh,1)
  IF (.NOT. ALLOCATED(DstInputData%Mesh)) THEN 
    ALLOCATE(DstInputData%Mesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Mesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%Mesh,1), UBOUND(SrcInputData%Mesh,1)
      CALL MeshCopy( SrcInputData%Mesh(i1), DstInputData%Mesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%CmdStiff)) THEN
  i1_l = LBOUND(SrcInputData%CmdStiff,1)
  i1_u = UBOUND(SrcInputData%CmdStiff,1)
  i2_l = LBOUND(SrcInputData%CmdStiff,2)
  i2_u = UBOUND(SrcInputData%CmdStiff,2)
  IF (.NOT. ALLOCATED(DstInputData%CmdStiff)) THEN 
    ALLOCATE(DstInputData%CmdStiff(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CmdStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%CmdStiff = SrcInputData%CmdStiff
ENDIF
IF (ALLOCATED(SrcInputData%CmdDamp)) THEN
  i1_l = LBOUND(SrcInputData%CmdDamp,1)
  i1_u = UBOUND(SrcInputData%CmdDamp,1)
  i2_l = LBOUND(SrcInputData%CmdDamp,2)
  i2_u = UBOUND(SrcInputData%CmdDamp,2)
  IF (.NOT. ALLOCATED(DstInputData%CmdDamp)) THEN 
    ALLOCATE(DstInputData%CmdDamp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CmdDamp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%CmdDamp = SrcInputData%CmdDamp
ENDIF
IF (ALLOCATED(SrcInputData%CmdBrake)) THEN
  i1_l = LBOUND(SrcInputData%CmdBrake,1)
  i1_u = UBOUND(SrcInputData%CmdBrake,1)
  i2_l = LBOUND(SrcInputData%CmdBrake,2)
  i2_u = UBOUND(SrcInputData%CmdBrake,2)
  IF (.NOT. ALLOCATED(DstInputData%CmdBrake)) THEN 
    ALLOCATE(DstInputData%CmdBrake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CmdBrake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%CmdBrake = SrcInputData%CmdBrake
ENDIF
IF (ALLOCATED(SrcInputData%CmdForce)) THEN
  i1_l = LBOUND(SrcInputData%CmdForce,1)
  i1_u = UBOUND(SrcInputData%CmdForce,1)
  i2_l = LBOUND(SrcInputData%CmdForce,2)
  i2_u = UBOUND(SrcInputData%CmdForce,2)
  IF (.NOT. ALLOCATED(DstInputData%CmdForce)) THEN 
    ALLOCATE(DstInputData%CmdForce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CmdForce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%CmdForce = SrcInputData%CmdForce
ENDIF
 END SUBROUTINE StC_CopyInput

 SUBROUTINE StC_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(StC_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%Mesh)) THEN
DO i1 = LBOUND(InputData%Mesh,1), UBOUND(InputData%Mesh,1)
  CALL MeshDestroy( InputData%Mesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%Mesh)
ENDIF
IF (ALLOCATED(InputData%CmdStiff)) THEN
  DEALLOCATE(InputData%CmdStiff)
ENDIF
IF (ALLOCATED(InputData%CmdDamp)) THEN
  DEALLOCATE(InputData%CmdDamp)
ENDIF
IF (ALLOCATED(InputData%CmdBrake)) THEN
  DEALLOCATE(InputData%CmdBrake)
ENDIF
IF (ALLOCATED(InputData%CmdForce)) THEN
  DEALLOCATE(InputData%CmdForce)
ENDIF
 END SUBROUTINE StC_DestroyInput


subroutine StC_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Mesh
   call RegPack(Buf, allocated(InData%Mesh))
   if (allocated(InData%Mesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%Mesh), ubound(InData%Mesh))
      LB(1:1) = lbound(InData%Mesh)
      UB(1:1) = ubound(InData%Mesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%Mesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CmdStiff
   call RegPack(Buf, allocated(InData%CmdStiff))
   if (allocated(InData%CmdStiff)) then
      call RegPackBounds(Buf, 2, lbound(InData%CmdStiff), ubound(InData%CmdStiff))
      call RegPack(Buf, InData%CmdStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CmdDamp
   call RegPack(Buf, allocated(InData%CmdDamp))
   if (allocated(InData%CmdDamp)) then
      call RegPackBounds(Buf, 2, lbound(InData%CmdDamp), ubound(InData%CmdDamp))
      call RegPack(Buf, InData%CmdDamp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CmdBrake
   call RegPack(Buf, allocated(InData%CmdBrake))
   if (allocated(InData%CmdBrake)) then
      call RegPackBounds(Buf, 2, lbound(InData%CmdBrake), ubound(InData%CmdBrake))
      call RegPack(Buf, InData%CmdBrake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CmdForce
   call RegPack(Buf, allocated(InData%CmdForce))
   if (allocated(InData%CmdForce)) then
      call RegPackBounds(Buf, 2, lbound(InData%CmdForce), ubound(InData%CmdForce))
      call RegPack(Buf, InData%CmdForce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Mesh
   if (allocated(OutData%Mesh)) deallocate(OutData%Mesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Mesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%Mesh(i1)) ! Mesh 
      end do
   end if
   ! CmdStiff
   if (allocated(OutData%CmdStiff)) deallocate(OutData%CmdStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CmdStiff(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CmdStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CmdStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CmdDamp
   if (allocated(OutData%CmdDamp)) deallocate(OutData%CmdDamp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CmdDamp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CmdDamp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CmdDamp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CmdBrake
   if (allocated(OutData%CmdBrake)) deallocate(OutData%CmdBrake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CmdBrake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CmdBrake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CmdBrake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CmdForce
   if (allocated(OutData%CmdForce)) deallocate(OutData%CmdForce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CmdForce(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CmdForce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CmdForce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE StC_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(StC_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(StC_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'StC_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Mesh)) THEN
  i1_l = LBOUND(SrcOutputData%Mesh,1)
  i1_u = UBOUND(SrcOutputData%Mesh,1)
  IF (.NOT. ALLOCATED(DstOutputData%Mesh)) THEN 
    ALLOCATE(DstOutputData%Mesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Mesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%Mesh,1), UBOUND(SrcOutputData%Mesh,1)
      CALL MeshCopy( SrcOutputData%Mesh(i1), DstOutputData%Mesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%MeasDisp)) THEN
  i1_l = LBOUND(SrcOutputData%MeasDisp,1)
  i1_u = UBOUND(SrcOutputData%MeasDisp,1)
  i2_l = LBOUND(SrcOutputData%MeasDisp,2)
  i2_u = UBOUND(SrcOutputData%MeasDisp,2)
  IF (.NOT. ALLOCATED(DstOutputData%MeasDisp)) THEN 
    ALLOCATE(DstOutputData%MeasDisp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%MeasDisp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%MeasDisp = SrcOutputData%MeasDisp
ENDIF
IF (ALLOCATED(SrcOutputData%MeasVel)) THEN
  i1_l = LBOUND(SrcOutputData%MeasVel,1)
  i1_u = UBOUND(SrcOutputData%MeasVel,1)
  i2_l = LBOUND(SrcOutputData%MeasVel,2)
  i2_u = UBOUND(SrcOutputData%MeasVel,2)
  IF (.NOT. ALLOCATED(DstOutputData%MeasVel)) THEN 
    ALLOCATE(DstOutputData%MeasVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%MeasVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%MeasVel = SrcOutputData%MeasVel
ENDIF
 END SUBROUTINE StC_CopyOutput

 SUBROUTINE StC_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(StC_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'StC_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%Mesh)) THEN
DO i1 = LBOUND(OutputData%Mesh,1), UBOUND(OutputData%Mesh,1)
  CALL MeshDestroy( OutputData%Mesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%Mesh)
ENDIF
IF (ALLOCATED(OutputData%MeasDisp)) THEN
  DEALLOCATE(OutputData%MeasDisp)
ENDIF
IF (ALLOCATED(OutputData%MeasVel)) THEN
  DEALLOCATE(OutputData%MeasVel)
ENDIF
 END SUBROUTINE StC_DestroyOutput


subroutine StC_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(StC_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'StC_PackOutput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Mesh
   call RegPack(Buf, allocated(InData%Mesh))
   if (allocated(InData%Mesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%Mesh), ubound(InData%Mesh))
      LB(1:1) = lbound(InData%Mesh)
      UB(1:1) = ubound(InData%Mesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%Mesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeasDisp
   call RegPack(Buf, allocated(InData%MeasDisp))
   if (allocated(InData%MeasDisp)) then
      call RegPackBounds(Buf, 2, lbound(InData%MeasDisp), ubound(InData%MeasDisp))
      call RegPack(Buf, InData%MeasDisp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeasVel
   call RegPack(Buf, allocated(InData%MeasVel))
   if (allocated(InData%MeasVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%MeasVel), ubound(InData%MeasVel))
      call RegPack(Buf, InData%MeasVel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine StC_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(StC_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'StC_UnPackOutput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Mesh
   if (allocated(OutData%Mesh)) deallocate(OutData%Mesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Mesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%Mesh(i1)) ! Mesh 
      end do
   end if
   ! MeasDisp
   if (allocated(OutData%MeasDisp)) deallocate(OutData%MeasDisp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MeasDisp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MeasDisp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MeasDisp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MeasVel
   if (allocated(OutData%MeasVel)) deallocate(OutData%MeasVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MeasVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MeasVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MeasVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE StC_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(StC_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(StC_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'StC_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL StC_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL StC_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL StC_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE StC_Input_ExtrapInterp


 SUBROUTINE StC_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(StC_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(StC_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(StC_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'StC_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%Mesh) .AND. ALLOCATED(u1%Mesh)) THEN
  DO i1 = LBOUND(u_out%Mesh,1),UBOUND(u_out%Mesh,1)
      CALL MeshExtrapInterp1(u1%Mesh(i1), u2%Mesh(i1), tin, u_out%Mesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdStiff) .AND. ALLOCATED(u1%CmdStiff)) THEN
  DO i2 = LBOUND(u_out%CmdStiff,2),UBOUND(u_out%CmdStiff,2)
    DO i1 = LBOUND(u_out%CmdStiff,1),UBOUND(u_out%CmdStiff,1)
      b = -(u1%CmdStiff(i1,i2) - u2%CmdStiff(i1,i2))
      u_out%CmdStiff(i1,i2) = u1%CmdStiff(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdDamp) .AND. ALLOCATED(u1%CmdDamp)) THEN
  DO i2 = LBOUND(u_out%CmdDamp,2),UBOUND(u_out%CmdDamp,2)
    DO i1 = LBOUND(u_out%CmdDamp,1),UBOUND(u_out%CmdDamp,1)
      b = -(u1%CmdDamp(i1,i2) - u2%CmdDamp(i1,i2))
      u_out%CmdDamp(i1,i2) = u1%CmdDamp(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdBrake) .AND. ALLOCATED(u1%CmdBrake)) THEN
  DO i2 = LBOUND(u_out%CmdBrake,2),UBOUND(u_out%CmdBrake,2)
    DO i1 = LBOUND(u_out%CmdBrake,1),UBOUND(u_out%CmdBrake,1)
      b = -(u1%CmdBrake(i1,i2) - u2%CmdBrake(i1,i2))
      u_out%CmdBrake(i1,i2) = u1%CmdBrake(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdForce) .AND. ALLOCATED(u1%CmdForce)) THEN
  DO i2 = LBOUND(u_out%CmdForce,2),UBOUND(u_out%CmdForce,2)
    DO i1 = LBOUND(u_out%CmdForce,1),UBOUND(u_out%CmdForce,1)
      b = -(u1%CmdForce(i1,i2) - u2%CmdForce(i1,i2))
      u_out%CmdForce(i1,i2) = u1%CmdForce(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE StC_Input_ExtrapInterp1


 SUBROUTINE StC_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(StC_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(StC_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(StC_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(StC_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'StC_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%Mesh) .AND. ALLOCATED(u1%Mesh)) THEN
  DO i1 = LBOUND(u_out%Mesh,1),UBOUND(u_out%Mesh,1)
      CALL MeshExtrapInterp2(u1%Mesh(i1), u2%Mesh(i1), u3%Mesh(i1), tin, u_out%Mesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdStiff) .AND. ALLOCATED(u1%CmdStiff)) THEN
  DO i2 = LBOUND(u_out%CmdStiff,2),UBOUND(u_out%CmdStiff,2)
    DO i1 = LBOUND(u_out%CmdStiff,1),UBOUND(u_out%CmdStiff,1)
      b = (t(3)**2*(u1%CmdStiff(i1,i2) - u2%CmdStiff(i1,i2)) + t(2)**2*(-u1%CmdStiff(i1,i2) + u3%CmdStiff(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%CmdStiff(i1,i2) + t(3)*u2%CmdStiff(i1,i2) - t(2)*u3%CmdStiff(i1,i2) ) * scaleFactor
      u_out%CmdStiff(i1,i2) = u1%CmdStiff(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdDamp) .AND. ALLOCATED(u1%CmdDamp)) THEN
  DO i2 = LBOUND(u_out%CmdDamp,2),UBOUND(u_out%CmdDamp,2)
    DO i1 = LBOUND(u_out%CmdDamp,1),UBOUND(u_out%CmdDamp,1)
      b = (t(3)**2*(u1%CmdDamp(i1,i2) - u2%CmdDamp(i1,i2)) + t(2)**2*(-u1%CmdDamp(i1,i2) + u3%CmdDamp(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%CmdDamp(i1,i2) + t(3)*u2%CmdDamp(i1,i2) - t(2)*u3%CmdDamp(i1,i2) ) * scaleFactor
      u_out%CmdDamp(i1,i2) = u1%CmdDamp(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdBrake) .AND. ALLOCATED(u1%CmdBrake)) THEN
  DO i2 = LBOUND(u_out%CmdBrake,2),UBOUND(u_out%CmdBrake,2)
    DO i1 = LBOUND(u_out%CmdBrake,1),UBOUND(u_out%CmdBrake,1)
      b = (t(3)**2*(u1%CmdBrake(i1,i2) - u2%CmdBrake(i1,i2)) + t(2)**2*(-u1%CmdBrake(i1,i2) + u3%CmdBrake(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%CmdBrake(i1,i2) + t(3)*u2%CmdBrake(i1,i2) - t(2)*u3%CmdBrake(i1,i2) ) * scaleFactor
      u_out%CmdBrake(i1,i2) = u1%CmdBrake(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CmdForce) .AND. ALLOCATED(u1%CmdForce)) THEN
  DO i2 = LBOUND(u_out%CmdForce,2),UBOUND(u_out%CmdForce,2)
    DO i1 = LBOUND(u_out%CmdForce,1),UBOUND(u_out%CmdForce,1)
      b = (t(3)**2*(u1%CmdForce(i1,i2) - u2%CmdForce(i1,i2)) + t(2)**2*(-u1%CmdForce(i1,i2) + u3%CmdForce(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%CmdForce(i1,i2) + t(3)*u2%CmdForce(i1,i2) - t(2)*u3%CmdForce(i1,i2) ) * scaleFactor
      u_out%CmdForce(i1,i2) = u1%CmdForce(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE StC_Input_ExtrapInterp2


 SUBROUTINE StC_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(StC_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(StC_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'StC_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL StC_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL StC_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL StC_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE StC_Output_ExtrapInterp


 SUBROUTINE StC_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(StC_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(StC_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(StC_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'StC_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%Mesh) .AND. ALLOCATED(y1%Mesh)) THEN
  DO i1 = LBOUND(y_out%Mesh,1),UBOUND(y_out%Mesh,1)
      CALL MeshExtrapInterp1(y1%Mesh(i1), y2%Mesh(i1), tin, y_out%Mesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%MeasDisp) .AND. ALLOCATED(y1%MeasDisp)) THEN
  DO i2 = LBOUND(y_out%MeasDisp,2),UBOUND(y_out%MeasDisp,2)
    DO i1 = LBOUND(y_out%MeasDisp,1),UBOUND(y_out%MeasDisp,1)
      b = -(y1%MeasDisp(i1,i2) - y2%MeasDisp(i1,i2))
      y_out%MeasDisp(i1,i2) = y1%MeasDisp(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MeasVel) .AND. ALLOCATED(y1%MeasVel)) THEN
  DO i2 = LBOUND(y_out%MeasVel,2),UBOUND(y_out%MeasVel,2)
    DO i1 = LBOUND(y_out%MeasVel,1),UBOUND(y_out%MeasVel,1)
      b = -(y1%MeasVel(i1,i2) - y2%MeasVel(i1,i2))
      y_out%MeasVel(i1,i2) = y1%MeasVel(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE StC_Output_ExtrapInterp1


 SUBROUTINE StC_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(StC_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(StC_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(StC_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(StC_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'StC_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%Mesh) .AND. ALLOCATED(y1%Mesh)) THEN
  DO i1 = LBOUND(y_out%Mesh,1),UBOUND(y_out%Mesh,1)
      CALL MeshExtrapInterp2(y1%Mesh(i1), y2%Mesh(i1), y3%Mesh(i1), tin, y_out%Mesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%MeasDisp) .AND. ALLOCATED(y1%MeasDisp)) THEN
  DO i2 = LBOUND(y_out%MeasDisp,2),UBOUND(y_out%MeasDisp,2)
    DO i1 = LBOUND(y_out%MeasDisp,1),UBOUND(y_out%MeasDisp,1)
      b = (t(3)**2*(y1%MeasDisp(i1,i2) - y2%MeasDisp(i1,i2)) + t(2)**2*(-y1%MeasDisp(i1,i2) + y3%MeasDisp(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%MeasDisp(i1,i2) + t(3)*y2%MeasDisp(i1,i2) - t(2)*y3%MeasDisp(i1,i2) ) * scaleFactor
      y_out%MeasDisp(i1,i2) = y1%MeasDisp(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MeasVel) .AND. ALLOCATED(y1%MeasVel)) THEN
  DO i2 = LBOUND(y_out%MeasVel,2),UBOUND(y_out%MeasVel,2)
    DO i1 = LBOUND(y_out%MeasVel,1),UBOUND(y_out%MeasVel,1)
      b = (t(3)**2*(y1%MeasVel(i1,i2) - y2%MeasVel(i1,i2)) + t(2)**2*(-y1%MeasVel(i1,i2) + y3%MeasVel(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%MeasVel(i1,i2) + t(3)*y2%MeasVel(i1,i2) - t(2)*y3%MeasVel(i1,i2) ) * scaleFactor
      y_out%MeasVel(i1,i2) = y1%MeasVel(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE StC_Output_ExtrapInterp2

END MODULE StrucCtrl_Types
!ENDOFREGISTRYGENERATEDFILE
