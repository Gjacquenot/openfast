!STARTOFREGISTRYGENERATEDFILE 'ServoDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! ServoDyn_Types
!.................................................................................................................................
! This file is part of ServoDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in ServoDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE ServoDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE StrucCtrl_Types
USE NWTC_Library
IMPLICIT NONE
! =========  SrvD_InitInputType  =======
  TYPE, PUBLIC :: SrvD_InitInputType
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
    INTEGER(IntKi)  :: NumBl      !< Number of blades on the turbine [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchInit      !< Initial blade pitch [-]
    REAL(ReKi) , DIMENSION(1:3)  :: Gravity      !< Gravitational acceleration vector [m/s^2]
    REAL(ReKi) , DIMENSION(1:3)  :: NacRefPos      !< nacelle origin for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3)  :: NacTransDisp      !< nacelle displacement from origin at init for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: NacOrient      !< nacelle orientation for setting up mesh [-]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: NacRefOrient      !< nacelle reference orientation for setting up mesh [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TwrBaseRefPos      !< tower base origin for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3)  :: TwrBaseTransDisp      !< tower base translation from origin at init for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: TwrBaseOrient      !< tower base orientation for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: TwrBaseRefOrient      !< tower reference orientation for setting up mesh [m]
    REAL(ReKi) , DIMENSION(1:3)  :: PtfmRefPos      !< platform origin for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3)  :: PtfmTransDisp      !< platform displacement from origin for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: PtfmOrient      !< platform orientation for setting up mesh [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: PtfmRefOrient      !< platform reference orientation for setting up mesh [m]
    REAL(DbKi)  :: Tmax      !< max time from glue code [s]
    REAL(ReKi)  :: AvgWindSpeed      !< average wind speed for the simulation [m/s]
    REAL(ReKi)  :: AirDens      !< air density [kg/m^3]
    INTEGER(IntKi)  :: NumSC2CtrlGlob      !< number of global controller inputs [from supercontroller] [-]
    INTEGER(IntKi)  :: NumSC2Ctrl      !< number of turbine specific controller inputs [from supercontroller] [-]
    INTEGER(IntKi)  :: NumCtrl2SC      !< number of controller outputs [to supercontroller] [-]
    INTEGER(IntKi)  :: TrimCase      !< Controller parameter to be trimmed {1:yaw; 2:torque; 3:pitch} [used only if CalcSteady=True] [-]
    REAL(ReKi)  :: TrimGain      !< Proportional gain for the rotational speed error (>0) [used only if TrimCase>0] [rad/(rad/s) for yaw or pitch; Nm/(rad/s) for torque]
    REAL(ReKi)  :: RotSpeedRef      !< Reference rotor speed [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BladeRootRefPos      !< X-Y-Z reference position of each blade root (3 x NumBlades) [m]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: BladeRootTransDisp      !< X-Y-Z translation from reference position at init of each blade root (3 x NumBlades) [m]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: BladeRootOrient      !< DCM reference orientation of blade roots (3x3 x NumBlades) [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: BladeRootRefOrient      !< DCM reference orientation of blade roots (3x3 x NumBlades) [-]
    LOGICAL  :: UseInputFile = .TRUE.      !< read input from input file [-]
    TYPE(FileInfoType)  :: PassedPrimaryInputData      !< Primary input file as FileInfoType (set by driver/glue code) [-]
    INTEGER(IntKi)  :: NumCableControl      !< Number of cable control channels requested [-]
    CHARACTER(64) , DIMENSION(:), ALLOCATABLE  :: CableControlRequestor      !< Array with text info about which module requested the cable control channel (size of NumCableControl).  This is just for diagnostics. [-]
    INTEGER(IntKi)  :: InterpOrder      !< Interpolation order from glue code -- required to set m%u_xStC sizes [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: fromSCGlob      !< Initial global inputs to the controller [from the supercontroller] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: fromSC      !< Initial turbine specific inputs to the controller [from the supercontroller] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LidSpeed      !< Number of Lidar measurement distances [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsX      !< Lidar X direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsY      !< Lidar Y direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsZ      !< Lidar Z direction measurement points [m]
    INTEGER(IntKi)  :: SensorType      !< Lidar sensor type [-]
    INTEGER(IntKi)  :: NumBeam      !< Number of beams [-]
    INTEGER(IntKi)  :: NumPulseGate      !< Number of pulse gates [-]
    REAL(ReKi)  :: PulseSpacing      !< Distance between range gates [-]
    REAL(ReKi)  :: URefLid      !< Reference average wind speed for the lidar [m/s]
  END TYPE SrvD_InitInputType
! =======================
! =========  SrvD_InitOutputType  =======
  TYPE, PUBLIC :: SrvD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
    INTEGER(IntKi)  :: CouplingScheme      !< Switch that indicates if a particular coupling scheme is required [-]
    LOGICAL  :: UseHSSBrake      !< flag to determine if high-speed shaft brake is potentially used (true=yes) [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Flag that tells FAST/MBC3 if the outputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
  END TYPE SrvD_InitOutputType
! =======================
! =========  SrvD_InputFile  =======
  TYPE, PUBLIC :: SrvD_InputFile
    REAL(DbKi)  :: DT      !< Communication interval for controllers [s]
    LOGICAL  :: Echo      !< Echo the input file out [-]
    INTEGER(IntKi)  :: PCMode      !< Pitch control mode [-]
    REAL(DbKi)  :: TPCOn      !< Time to enable active pitch control [unused when PCMode=0] [s]
    REAL(DbKi) , DIMENSION(1:3)  :: TPitManS      !< Time to start override pitch maneuver for blade (K) and end standard pitch control [s]
    REAL(ReKi) , DIMENSION(1:3)  :: PitManRat      !< Pitch rates at which override pitch maneuvers head toward final pitch angles [rad/s]
    REAL(ReKi) , DIMENSION(1:3)  :: BlPitchF      !< Blade (K) final pitch for pitch maneuvers [radians]
    INTEGER(IntKi)  :: VSContrl      !< Variable-speed control mode [-]
    INTEGER(IntKi)  :: GenModel      !< Generator model [used only when VSContrl=0] [-]
    REAL(ReKi)  :: GenEff      !< Generator efficiency [ignored by the Thevenin and user-defined generator models] [-]
    LOGICAL  :: GenTiStr      !< Method to start the generator {T: timed using TimGenOn, F: generator speed using SpdGenOn} [-]
    LOGICAL  :: GenTiStp      !< Method to stop the generator {T: timed using TimGenOf, F: when generator power = 0} [-]
    REAL(ReKi)  :: SpdGenOn      !< Generator speed to turn on the generator for a startup (HSS speed) [used only when GenTiStr=False] [rad/s]
    REAL(DbKi)  :: TimGenOn      !< Time to turn on the generator for a startup [used only when GenTiStr=True] [s]
    REAL(DbKi)  :: TimGenOf      !< Time to turn off the generator [used only when GenTiStp=True] [s]
    REAL(ReKi)  :: VS_RtGnSp      !< Rated generator speed for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [rad/s]
    REAL(ReKi)  :: VS_RtTq      !< Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [N-m]
    REAL(ReKi)  :: VS_Rgn2K      !< Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [N-m/(rad/s)^2]
    REAL(ReKi)  :: VS_SlPc      !< Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control [used only when VSContrl=1] [-]
    REAL(ReKi)  :: SIG_SlPc      !< Rated generator slip percentage [used only when VSContrl=0 and GenModel=1] [-]
    REAL(ReKi)  :: SIG_SySp      !< Synchronous (zero-torque) generator speed [used only when VSContrl=0 and GenModel=1] [rad/s]
    REAL(ReKi)  :: SIG_RtTq      !< Rated torque [used only when VSContrl=0 and GenModel=1] [N-m]
    REAL(ReKi)  :: SIG_PORt      !< Pull-out ratio (Tpullout/Trated) [used only when VSContrl=0 and GenModel=1] [-]
    REAL(ReKi)  :: TEC_Freq      !< Line frequency [50 or 60] [used only when VSContrl=0 and GenModel=2] [Hz]
    INTEGER(IntKi)  :: TEC_NPol      !< Number of poles [even integer > 0] [used only when VSContrl=0 and GenModel=2] [-]
    REAL(ReKi)  :: TEC_SRes      !< Stator resistance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_RRes      !< Rotor resistance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_VLL      !< Line-to-line RMS voltage [used only when VSContrl=0 and GenModel=2] [volts]
    REAL(ReKi)  :: TEC_SLR      !< Stator leakage reactance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_RLR      !< Rotor leakage reactance [used only when VSContrl=0 and GenModel=2] [ohms]
    REAL(ReKi)  :: TEC_MR      !< Magnetizing reactance [used only when VSContrl=0 and GenModel=2] [ohms]
    INTEGER(IntKi)  :: HSSBrMode      !< HSS brake model [-]
    REAL(DbKi)  :: THSSBrDp      !< Time to initiate deployment of the HSS brake [s]
    REAL(DbKi)  :: HSSBrDT      !< Time for HSS-brake to reach full deployment once initiated [used only when HSSBrMode=1] [s]
    REAL(ReKi)  :: HSSBrTqF      !< Fully deployed HSS-brake torque [N-m]
    INTEGER(IntKi)  :: YCMode      !< Yaw control mode [-]
    REAL(DbKi)  :: TYCOn      !< Time to enable active yaw control [unused when YCMode=0] [s]
    REAL(ReKi)  :: YawNeut      !< Neutral yaw position--yaw spring force is zero at this yaw [radians]
    REAL(ReKi)  :: YawSpr      !< Nacelle-yaw spring constant [N-m/rad]
    REAL(ReKi)  :: YawDamp      !< Nacelle-yaw constant [N-m/(rad/s)]
    REAL(DbKi)  :: TYawManS      !< Time to start override yaw maneuver and end standard yaw control [s]
    REAL(ReKi)  :: YawManRat      !< Yaw maneuver rate (in absolute value) [rad/s]
    REAL(ReKi)  :: NacYawF      !< Final yaw angle for override yaw maneuvers [radians]
    LOGICAL  :: SumPrint      !< Print summary data to <RootName>.sum [-]
    INTEGER(IntKi)  :: OutFile      !< Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) [-]
    LOGICAL  :: TabDelim      !< Use tab delimiters in text tabular output file? [-]
    CHARACTER(20)  :: OutFmt      !< Format used for text tabular output (except time) [-]
    REAL(DbKi)  :: Tstart      !< Time to start module's tabular output [s]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< List of user-requested output channels [-]
    CHARACTER(1024)  :: DLL_FileName      !< Name of the DLL file including the full path [-]
    CHARACTER(1024)  :: DLL_ProcName      !< Name of the procedure in the DLL that will be called [-]
    CHARACTER(1024)  :: DLL_InFile      !< Name of input file used in DLL [-]
    REAL(DbKi)  :: DLL_DT      !< interval for calling DLL (must be integer multiple number of DT steps) [s]
    LOGICAL  :: DLL_Ramp      !< whether the DLL pitch should be a ramp (true) or step change (false) when DLL_DT <> DT. If true, introduces a time delay. [-]
    REAL(ReKi)  :: BPCutoff      !< The cutoff frequency for the blade pitch low-pass filter. Large values => no filter. [Hz]
    REAL(ReKi)  :: NacYaw_North      !< Reference yaw angle of the nacelle when the upwind end points due North [used only with DLL Interface] [radians]
    INTEGER(IntKi)  :: Ptch_Cntrl      !< Record 28: Use individual pitch control {0: collective pitch; 1: individual pitch control} [used only with DLL Interface] [-]
    REAL(ReKi)  :: Ptch_SetPnt      !< Record  5: Below-rated pitch angle set-point [used only with DLL Interface] [radians]
    REAL(ReKi)  :: Ptch_Min      !< Record  6: Minimum pitch angle [used only with DLL Interface] [radians]
    REAL(ReKi)  :: Ptch_Max      !< Record  7: Maximum pitch angle [used only with DLL Interface] [radians]
    REAL(ReKi)  :: PtchRate_Min      !< Record  8: Minimum pitch rate (most negative value allowed) [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: PtchRate_Max      !< Record  9: Maximum pitch rate [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: Gain_OM      !< Record 16: Optimal mode gain [used only with DLL Interface] [Nm/(rad/s)^2]
    REAL(ReKi)  :: GenSpd_MinOM      !< Record 17: Minimum generator speed [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: GenSpd_MaxOM      !< Record 18: Optimal mode maximum speed [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: GenSpd_Dem      !< Record 19: Demanded generator speed above rated [used only with DLL Interface] [rad/s]
    REAL(ReKi)  :: GenTrq_Dem      !< Record 22: Demanded generator torque above rated [used only with DLL Interface] [Nm]
    REAL(ReKi)  :: GenPwr_Dem      !< Record 13: Demanded power [used only with DLL Interface] [W]
    INTEGER(IntKi)  :: DLL_NumTrq      !< Record 26: No. of points in torque-speed look-up table {0 = none and use the optimal mode PARAMETERs instead, nonzero = ignore the optimal mode PARAMETERs by setting Gain_OM (Record 16) to 0.0} [used only with DLL Interface] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenSpd_TLU      !< Records R:2:R+2*DLL_NumTrq-2: Generator speed values in look-up table [used only with DLL Interface] [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenTrq_TLU      !< Records R+1:2:R+2*DLL_NumTrq-1: Generator torque values in look-up table [used only with DLL Interface] [Nm]
    LOGICAL  :: UseLegacyInterface      !< Flag that determines if the legacy Bladed interface is (legacy=DISCON with avrSWAP instead of CONTROLLER) [-]
    INTEGER(IntKi)  :: NumBStC      !< Number of blade structural controllers (integer) [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: BStCfiles      !< Name of the files for blade structural controllers (quoted strings) [unused when NumBStC==0] [-]
    INTEGER(IntKi)  :: NumNStC      !< Number of nacelle structural controllers (integer) [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: NStCfiles      !< Name of the files for nacelle structural controllers (quoted strings) [unused when NumNStC==0] [-]
    INTEGER(IntKi)  :: NumTStC      !< Number of tower structural controllers (integer) [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: TStCfiles      !< Name of the files for tower structural controllers (quoted strings) [unused when NumTStC==0] [-]
    INTEGER(IntKi)  :: NumSStC      !< Number of substructure structural controllers (integer) [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: SStCfiles      !< Name of the files for subtructure structural controllers (quoted strings) [unused when NumSStC==0] [-]
    INTEGER(IntKi)  :: AfCmode      !< Airfoil control mode {0: none, 1: sine wave cycle, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} [-]
    REAL(ReKi)  :: AfC_Mean      !< Mean level for cosine cycling or steady value [used only with AfCmode==1] [-]
    REAL(ReKi)  :: AfC_Amp      !< Amplitude for for cosine cycling of flap signal (-) [used only with AfCmode==1] [-]
    REAL(ReKi)  :: AfC_Phase      !< Phase relative to the blade azimuth (0 is vertical) for for cosine cycling of flap signal (deg) [used only with AfCmode==1] [deg]
    INTEGER(IntKi)  :: CCmode      !< Cable control control mode {0: none, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} [-]
    LOGICAL  :: EXavrSWAP      !< Use extendend AVR swap [-]
  END TYPE SrvD_InputFile
! =======================
! =========  BladedDLLType  =======
  TYPE, PUBLIC :: BladedDLLType
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: avrSWAP      !< The swap array: used to pass data to and from the DLL controller [see Bladed DLL documentation]
    REAL(ReKi)  :: HSSBrTrqDemand      !< Demanded braking torque - from Bladed DLL [-]
    REAL(ReKi)  :: YawRateCom      !< Nacelle yaw rate demanded from Bladed DLL [rad/s]
    REAL(ReKi)  :: GenTrq      !< Electrical generator torque from Bladed DLL [N-m]
    INTEGER(IntKi)  :: GenState      !< Generator state from Bladed DLL [-]
    REAL(ReKi) , DIMENSION(1:3)  :: BlPitchCom      !< Commanded blade pitch angles [radians]
    REAL(ReKi) , DIMENSION(1:3)  :: PrevBlPitch      !< Previously commanded blade pitch angles [radians]
    REAL(ReKi) , DIMENSION(1:3)  :: BlAirfoilCom      !< Commanded Airfoil UserProp for blade.  Passed to AD15 for airfoil interpolation (must be same units as given in AD15 airfoil tables) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: PrevBlAirfoilCom      !< Previously commanded Airfoil UserProp for blade.  Passed to AD15 for airfoil interpolation (must be same units as given in AD15 airfoil tables) [-]
    REAL(ReKi)  :: ElecPwr_prev      !< Electrical power (from previous step), sent to Bladed DLL [W]
    REAL(ReKi)  :: GenTrq_prev      !< Electrical generator torque (from previous step), sent to Bladed DLL [N-m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: toSC      !< controller output to supercontroller [-]
    LOGICAL  :: initialized      !< flag that determines if DLL has been called (for difference between CalcOutput and UpdateStates) [-]
    INTEGER(IntKi)  :: NumLogChannels      !< number of log channels from controller [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: LogChannels_OutParam      !< Names and units (and other characteristics) of logging outputs from DLL [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LogChannels      !< logging outputs from controller [-]
    INTEGER(IntKi)  :: ErrStat      !< error message from external controller API [-]
    CHARACTER(ErrMsgLen)  :: ErrMsg      !< error message from external controller API [-]
    REAL(R8Ki)  :: CurrentTime      !< Current Simulation Time [s]
    INTEGER(IntKi)  :: SimStatus      !< simulation status (see avrSWAP(1): Status flag set as follows: 0 if this is the first call, 1 for all subsequent time steps, -1 if this is the final call at the end of the simulation) [-]
    INTEGER(IntKi)  :: ShaftBrakeStatusBinaryFlag      !< binary flag indicating (on/off) status for shaft brake 1, shaft brake 2, generator brake, shaft brake 3, or brake torque set separately (0, 1, or 16 allowed in FAST) [-]
    LOGICAL  :: HSSBrDeployed      !< Whether the HSS brake has been deployed [-]
    REAL(R8Ki)  :: TimeHSSBrFullyDeployed      !< Time at which the controller high-speed shaft is fully deployed [s]
    REAL(R8Ki)  :: TimeHSSBrDeployed      !< Time at which the controller high-speed shaft is first deployed [s]
    LOGICAL  :: OverrideYawRateWithTorque      !< acts similiar to Yaw_Cntrl [-]
    REAL(ReKi)  :: YawTorqueDemand      !< Demanded yaw actuator torque (override of yaw rate control) [Nm]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchInput      !< Input blade pitch angles [radians]
    REAL(ReKi)  :: YawAngleFromNorth      !< Yaw angle of the nacelle relative to North (see NacYaw_North) [rad]
    REAL(ReKi)  :: HorWindV      !< Horizontal hub-height wind velocity magnitude [m/s]
    REAL(ReKi)  :: HSS_Spd      !< High-speed shaft (HSS) speed [rad/s]
    REAL(ReKi)  :: YawErr      !< Yaw error [radians]
    REAL(ReKi)  :: RotSpeed      !< Rotor azimuth angular speed [rad/s]
    REAL(ReKi)  :: YawBrTAxp      !< Tower-top / yaw bearing fore-aft (translational) acceleration (absolute) [m/s^2]
    REAL(ReKi)  :: YawBrTAyp      !< Tower-top / yaw bearing side-to-side (translational) acceleration (absolute) [m/s^2]
    REAL(ReKi)  :: LSSTipMys      !< Nonrotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMzs      !< Nonrotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMya      !< Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMza      !< Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipPxa      !< Rotor azimuth angle (position) [radians]
    REAL(ReKi)  :: Yaw      !< Current nacelle yaw [radians]
    REAL(ReKi)  :: YawRate      !< Current nacelle yaw rate [rad/s]
    REAL(ReKi)  :: YawBrMyn      !< Rotating (with nacelle) tower-top / yaw bearing pitch moment [N-m]
    REAL(ReKi)  :: YawBrMzn      !< Tower-top / yaw bearing yaw moment [N-m]
    REAL(ReKi)  :: NcIMURAxs      !< Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: NcIMURAys      !< Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: NcIMURAzs      !< Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: RotPwr      !< Rotor power (this is equivalent to the low-speed shaft power) [W]
    REAL(ReKi)  :: LSSTipMxa      !< Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi) , DIMENSION(1:3)  :: RootMyc      !< Out-of-plane moment (i.e., the moment caused by out-of-plane forces) at the blade root for each of the blades (max 3) [N-m]
    REAL(ReKi) , DIMENSION(1:3)  :: RootMxc      !< In-plane moment (i.e., the moment caused by in-plane forces) at the blade root [N-m]
    REAL(ReKi)  :: LSShftFxa      !< Rotating low-speed shaft force x [N]
    REAL(ReKi)  :: LSShftFys      !< Nonrotating low-speed shaft force y [N]
    REAL(ReKi)  :: LSShftFzs      !< Nonrotating low-speed shaft force z [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LidSpeed      !< Lidar measured wind speed [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsX      !< Lidar X direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsY      !< Lidar Y direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsZ      !< Lidar Z direction measurement points [m]
    INTEGER(IntKi)  :: SensorType      !< Lidar sensor type [-]
    INTEGER(IntKi)  :: NumBeam      !< Number of beams [-]
    INTEGER(IntKi)  :: NumPulseGate      !< Number of pulse gates [-]
    INTEGER(IntKi)  :: PulseSpacing      !< Distance between range gates [-]
    INTEGER(IntKi)  :: URefLid      !< Reference average wind speed for the lidar [m/s]
    REAL(DbKi)  :: DLL_DT      !< interval for calling DLL (integer multiple number of DT) [s]
    CHARACTER(1024)  :: DLL_InFile      !< Name of input file used in DLL [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    REAL(ReKi)  :: GenTrq_Dem      !< Demanded generator torque above rated [Nm]
    REAL(ReKi)  :: GenSpd_Dem      !< Demanded generator speed above rated [rad/s]
    REAL(ReKi)  :: Ptch_Max      !< Maximum pitch angle [rad]
    REAL(ReKi)  :: Ptch_Min      !< Minimum pitch angle [rad]
    REAL(ReKi)  :: Ptch_SetPnt      !< Below-rated pitch angle set-point [rad]
    REAL(ReKi)  :: PtchRate_Max      !< Maximum pitch rate [rad/s]
    REAL(ReKi)  :: PtchRate_Min      !< Minimum pitch rate (most negative value allowed) [rad/s]
    REAL(ReKi)  :: GenPwr_Dem      !< Demanded power (This is not valid for variable-speed, pitch-regulated controllers.) [W]
    REAL(ReKi)  :: Gain_OM      !< Optimal mode gain [Nm/(rad/s)^2]
    REAL(ReKi)  :: GenSpd_MaxOM      !< Optimal mode maximum speed [rad/s]
    REAL(ReKi)  :: GenSpd_MinOM      !< Minimum generator speed [rad/s]
    INTEGER(IntKi)  :: Ptch_Cntrl      !< Pitch control: 0 = collective;  1 = individual [-]
    INTEGER(IntKi)  :: DLL_NumTrq      !< No. of points in torque-speed look-up table, 0 = none and use the optimal mode PARAMETERs instead;  nonzero = ignore the optimal mode PARAMETERs by setting Record 16 to 0.0 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenSpd_TLU      !< Table (array) containing DLL_NumTrq generator speeds  for the torque-speed table look-up (TLU) -- this should be defined using an array constructor; for example,  if DLL_NumTrq = 3,  GenSpd_TLU(DLL_NumTrq)    = (/ 0.0, 99.9,  999.9 /) [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: GenTrq_TLU      !< Table (array) containing DLL_NumTrq generator torques for the torque-speed table look-up (TLU) -- this should be defined using an array constructor, for example,  if DLL_NumTrq = 3,  GenTrq_TLU(DLL_NumTrq)    = (/ 0.0, 10,  200.0 /) [Nm]
    INTEGER(IntKi)  :: Yaw_Cntrl      !< Yaw control: 0 = rate;  1 = torque [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: PrevCableDeltaL      !< Previous value for ramping for cable tensioning DeltaL using extended avrSWAP [see EXavrSWAP documentation in BladededInterface_EX] [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: PrevCableDeltaLdot      !< Previous value for ramping for cable tensioning DeltaLdot using extended avrSWAP [see EXavrSWAP documentation in BladededInterface_EX] [m/s]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CableDeltaL      !< The swap array: used to pass data from the DLL controller for cable tensioning DeltaL using extended avrSWAP [see EXavrSWAP documentation in BladededInterface_EX] [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CableDeltaLdot      !< The swap array: used to pass data from the DLL controller for cable tensioning DeltaLdot using extended avrSWAP [see EXavrSWAP documentation in BladededInterface_EX] [m/s]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: PrevStCCmdStiff      !< Previous value for ramping StC stiffness from controller (3,NumStC_Control) [N/m]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: PrevStCCmdDamp      !< Previous value for ramping StC damping from controller (3,NumStC_Control) [N/(m/s)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: PrevStCCmdBrake      !< Previous value for ramping StC braking signal (3,NumStC_Control) [N/(m/s)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: PrevStCCmdForce      !< Previous value for ramping StC force   signal (3,NumStC_Control) [N/(m/s)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: StCCmdStiff      !< StC stiffness from controller (3,NumStC_Control) [N/m]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: StCCmdDamp      !< StC damping from controller (3,NumStC_Control) [N/(m/s)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: StCCmdBrake      !< StC braking signal (3,NumStC_Control) [N]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: StCCmdForce      !< StC commanded force signal (3,NumStC_Control) [N]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: StCMeasDisp      !< StC measured local displacement signal from StC (3,NumStC_Control) [m]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: StCMeasVel      !< StC measured local velocity     signal from StC (3,NumStC_Control) [m/s]
  END TYPE BladedDLLType
! =======================
! =========  SrvD_ContinuousStateType  =======
  TYPE, PUBLIC :: SrvD_ContinuousStateType
    REAL(ReKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
    TYPE(StC_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: BStC      !< StC module states - blade [-]
    TYPE(StC_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: NStC      !< StC module states - nacelle [-]
    TYPE(StC_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: TStC      !< StC module states - tower [-]
    TYPE(StC_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: SStC      !< StC module inputs - substructure [-]
  END TYPE SrvD_ContinuousStateType
! =======================
! =========  SrvD_DiscreteStateType  =======
  TYPE, PUBLIC :: SrvD_DiscreteStateType
    REAL(ReKi)  :: CtrlOffset      !< Controller offset parameter [N-m]
    TYPE(StC_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: BStC      !< StC module states - blade [-]
    TYPE(StC_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: NStC      !< StC module states - nacelle [-]
    TYPE(StC_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: TStC      !< StC module states - tower [-]
    TYPE(StC_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: SStC      !< StC module inputs - substructure [-]
  END TYPE SrvD_DiscreteStateType
! =======================
! =========  SrvD_ConstraintStateType  =======
  TYPE, PUBLIC :: SrvD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
    TYPE(StC_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: BStC      !< StC module states - blade [-]
    TYPE(StC_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: NStC      !< StC module states - nacelle [-]
    TYPE(StC_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: TStC      !< StC module states - tower [-]
    TYPE(StC_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: SStC      !< StC module inputs - substructure [-]
  END TYPE SrvD_ConstraintStateType
! =======================
! =========  SrvD_OtherStateType  =======
  TYPE, PUBLIC :: SrvD_OtherStateType
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: BegPitMan      !< Whether the override pitch maneuver actually began [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchI      !< Initial blade pitch angles at the start of the override pitch maneuver [radians]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TPitManE      !< Time to end pitch maneuvers for each blade [s]
    LOGICAL  :: BegYawMan      !< Whether the yaw maneuver actually began [-]
    REAL(ReKi)  :: NacYawI      !< Initial yaw angle at the start of the override yaw maneuver [radians]
    REAL(DbKi)  :: TYawManE      !< Time to end override yaw maneuver [s]
    REAL(ReKi)  :: YawPosComInt      !< Internal variable that integrates the commanded yaw rate and passes it to YawPosCom [radians]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: BegTpBr      !< Whether the tip brakes actually deployed [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TTpBrDp      !< Times to initiate deployment of tip brakes [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TTpBrFl      !< Times at which tip brakes are fully deployed [s]
    LOGICAL  :: Off4Good      !< Is the generator offline for rest of simulation? [-]
    LOGICAL  :: GenOnLine      !< Is the generator online? [-]
    TYPE(StC_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: BStC      !< StC module states - blade [-]
    TYPE(StC_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: NStC      !< StC module states - nacelle [-]
    TYPE(StC_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: TStC      !< StC module states - tower [-]
    TYPE(StC_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: SStC      !< StC module inputs - substructure [-]
  END TYPE SrvD_OtherStateType
! =======================
! =========  SrvD_ModuleMapType  =======
  TYPE, PUBLIC :: SrvD_ModuleMapType
    TYPE(MeshMapType) , DIMENSION(:,:), ALLOCATABLE  :: u_BStC_Mot2_BStC      !< Map motions: u%BStCMotionMesh to m%u_BSTC%MotionMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: u_NStC_Mot2_NStC      !< Map motions: u%NStCMotionMesh to m%u_NStC%MotionMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: u_TStC_Mot2_TStC      !< Map motions: u%TStCMotionMesh to m%u_TStC%MotionMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: u_SStC_Mot2_SStC      !< Map motions: u%SStCMotionMesh to m%u_SStC%MotionMesh [-]
    TYPE(MeshMapType) , DIMENSION(:,:), ALLOCATABLE  :: BStC_Frc2_y_BStC      !< Map loads: m%y_BStCLoadMesh to y%BSTC%LoadMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: NStC_Frc2_y_NStC      !< Map loads: m%y_NStCLoadMesh to y%NStC%LoadMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: TStC_Frc2_y_TStC      !< Map loads: m%y_TStCLoadMesh to y%TStC%LoadMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: SStC_Frc2_y_SStC      !< Map loads: m%y_SStCLoadMesh to y%SStC%LoadMesh [-]
  END TYPE SrvD_ModuleMapType
! =======================
! =========  SrvD_MiscVarType  =======
  TYPE, PUBLIC :: SrvD_MiscVarType
    REAL(DbKi)  :: LastTimeCalled      !< last time the CalcOutput/Bladed DLL was called [s]
    TYPE(BladedDLLType)  :: dll_data      !< data used for Bladed DLL [-]
    LOGICAL  :: FirstWarn      !< Whether or not this is the first warning about the DLL being called without Explicit-Loose coupling. [-]
    REAL(DbKi)  :: LastTimeFiltered      !< last time the CalcOutput/Bladed DLL was filtered [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: xd_BlPitchFilter      !< blade pitch filter [-]
    TYPE(StC_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: BStC      !< StC module misc vars - blade [-]
    TYPE(StC_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: NStC      !< StC module misc vars - nacelle [-]
    TYPE(StC_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: TStC      !< StC module misc vars - tower [-]
    TYPE(StC_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: SStC      !< StC module misc vars - substructure [-]
    TYPE(StC_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_BStC      !< StC module inputs - blade          size:(interpOrder,NumBStC) [-]
    TYPE(StC_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_NStC      !< StC module inputs - nacelle        size:(interpOrder,NumNStC) [-]
    TYPE(StC_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_TStC      !< StC module inputs - tower          size:(interpOrder,NumTStC) [-]
    TYPE(StC_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_SStC      !< StC module inputs - substructure   size:(interpOrder,NumSStC) [-]
    TYPE(StC_OutputType) , DIMENSION(:), ALLOCATABLE  :: y_BStC      !< StC module outputs - blade [-]
    TYPE(StC_OutputType) , DIMENSION(:), ALLOCATABLE  :: y_NStC      !< StC module outputs - nacelle [-]
    TYPE(StC_OutputType) , DIMENSION(:), ALLOCATABLE  :: y_TStC      !< StC module outputs - tower [-]
    TYPE(StC_OutputType) , DIMENSION(:), ALLOCATABLE  :: y_SStC      !< StC module outputs - substructure [-]
    TYPE(SrvD_ModuleMapType)  :: SrvD_MeshMap      !< Mesh mapping from inputs/output meshes to StC input/output meshes [-]
    INTEGER(IntKi)  :: PrevTstepNcall = -1      !< Previous timestep N for tracking when in predictor/corrector loop for setting StC u values [-]
  END TYPE SrvD_MiscVarType
! =======================
! =========  SrvD_ParameterType  =======
  TYPE, PUBLIC :: SrvD_ParameterType
    REAL(DbKi)  :: DT      !< Time step for continuous state integration & discrete state update [seconds]
    REAL(DbKi)  :: HSSBrDT      !< Time it takes for HSS brake to reach full deployment once deployed [seconds]
    REAL(ReKi)  :: HSSBrTqF      !< Fully deployed HSS brake torque [-]
    REAL(ReKi)  :: SIG_POSl      !< Pullout slip [-]
    REAL(ReKi)  :: SIG_POTq      !< Pullout torque [-]
    REAL(ReKi)  :: SIG_SlPc      !< Rated generator slip percentage [-]
    REAL(ReKi)  :: SIG_Slop      !< Torque/Speed slope for simple induction generator [-]
    REAL(ReKi)  :: SIG_SySp      !< Synchronous (zero-torque) generator speed [rad/s]
    REAL(ReKi)  :: TEC_A0      !< A0 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_C0      !< C0 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_C1      !< C1 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_C2      !< C2 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_K2      !< K2 term for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_MR      !< Magnetizing reactance for Thevenin-equivalent circuit [ohms]
    REAL(ReKi)  :: TEC_Re1      !< Thevenin's equivalent stator resistance (ohms) [ohms]
    REAL(ReKi)  :: TEC_RLR      !< Rotor leakage reactance for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_RRes      !< Rotor resistance for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_SRes      !< Stator resistance for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_SySp      !< Synchronous speed for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_V1a      !< Source voltage for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_VLL      !< Line-to-line RMS voltage for Thevenin-equivalent circuit [-]
    REAL(ReKi)  :: TEC_Xe1      !< Thevenin's equivalent stator leakage reactance (ohms) [ohms]
    REAL(ReKi)  :: GenEff      !< Generator efficiency [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchInit      !< Initial blade pitch angles [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchF      !< Final blade pitch [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PitManRat      !< Pitch rates at which override pitch maneuvers head toward final pitch angles (does not include sign) [rad/s]
    REAL(ReKi)  :: YawManRat      !< Yaw rate at which override yaw maneuver head toward for final yaw angle (does not include sign) [rad/s]
    REAL(ReKi)  :: NacYawF      !< Final yaw angle after override yaw maneuver [-]
    REAL(ReKi)  :: SpdGenOn      !< Generator speed to turn on the generator for a startup [-]
    REAL(DbKi)  :: THSSBrDp      !< Time to initiate deployment of the shaft brake [s]
    REAL(DbKi)  :: THSSBrFl      !< Time at which shaft brake is fully deployed [s]
    REAL(DbKi)  :: TimGenOf      !< Time to turn off generator for braking or modeling a run-away [s]
    REAL(DbKi)  :: TimGenOn      !< Time to turn on generator for startup [s]
    REAL(DbKi)  :: TPCOn      !< Time to enable active pitch control [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TPitManS      !< Time to start pitch maneuvers for each blade [s]
    REAL(DbKi)  :: TYawManS      !< Time to start override yaw maneuver [s]
    REAL(DbKi)  :: TYCOn      !< Time to enable active yaw control [s]
    REAL(ReKi)  :: VS_RtGnSp      !< Rated generator speed (HSS side) [rad/s]
    REAL(ReKi)  :: VS_RtTq      !< Rated generator torque/constant generator torque in Region 3 (HSS side) [N-m]
    REAL(ReKi)  :: VS_Slope      !< Torque/speed slope of region 2 1/2 induction generator [-]
    REAL(ReKi)  :: VS_SlPc      !< Rated generator slip percentage in Region 2 1/2 [-]
    REAL(ReKi)  :: VS_SySp      !< Synchronous speed of region 2 1/2 induction generator [-]
    REAL(ReKi)  :: VS_TrGnSp      !< Transitional generator speed between regions 2 and 2 1/2 [-]
    REAL(ReKi)  :: YawPosCom      !< Commanded yaw angle from user-defined routines [rad]
    REAL(ReKi)  :: YawRateCom      !< Commanded yaw rate  from user-defined routines [rad/s]
    INTEGER(IntKi)  :: GenModel      !< Generator model [-]
    INTEGER(IntKi)  :: HSSBrMode      !< HSS brake model [-]
    INTEGER(IntKi)  :: PCMode      !< Pitch control mode [-]
    INTEGER(IntKi)  :: VSContrl      !< Variable-speed-generator control switch [-]
    INTEGER(IntKi)  :: YCMode      !< Yaw control mode [-]
    LOGICAL  :: GenTiStp      !< Stop generator based upon T: time or F: generator power = 0 [-]
    LOGICAL  :: GenTiStr      !< Start generator based upon T: time or F: generator speed [-]
    REAL(ReKi)  :: VS_Rgn2K      !< Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) [used only when VSContrl=1] [N-m/(rad/s)^2]
    REAL(ReKi)  :: YawNeut      !< Neutral yaw position--yaw spring force is zero at this yaw [radians]
    REAL(ReKi)  :: YawSpr      !< Nacelle-yaw spring constant [N-m/rad]
    REAL(ReKi)  :: YawDamp      !< Nacelle-yaw constant [N-m/(rad/s)]
    REAL(DbKi)  :: TpBrDT      !< Time for tip-brake to reach full deployment once released [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TBDepISp      !< Deployment-initiation speed for the tip brakes [rad/s]
    REAL(ReKi)  :: TBDrConN      !< Tip-brake drag constant during normal operation, Cd*Area [-]
    REAL(ReKi)  :: TBDrConD      !< Tip-brake drag constant during fully-deployed operation, Cd*Area [-]
    INTEGER(IntKi)  :: NumBl      !< Number of blades on the turbine [-]
    INTEGER(IntKi)  :: NumBStC      !< Number of blade structural controllers (integer) [-]
    INTEGER(IntKi)  :: NumNStC      !< Number of nacelle structural controllers (integer) [-]
    INTEGER(IntKi)  :: NumTStC      !< Number of tower structural controllers (integer) [-]
    INTEGER(IntKi)  :: NumSStC      !< Number of substructure structural controllers (integer) [-]
    INTEGER(IntKi)  :: AfCmode      !< Airfoil control mode {0: none, 1: sine wave cycle, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} [-]
    REAL(ReKi)  :: AfC_Mean      !< Mean level for cosine cycling or steady value [used only with AfCmode==1] [-]
    REAL(ReKi)  :: AfC_Amp      !< Amplitude for for cosine cycling of flap signal (-) [used only with AfCmode==1] [-]
    REAL(ReKi)  :: AfC_Phase      !< Phase relative to the blade azimuth (0 is vertical) for for cosine cycling of flap signal (deg) [used only with AfCmode==1] [deg]
    INTEGER(IntKi)  :: CCmode      !< Cable control control mode {0: none, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} [-]
    INTEGER(IntKi)  :: StCCmode      !< Structural control control mode {0: none, 4: user-defined from Simulink/Labview, 5: user-defined from Bladed-style DLL} [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    INTEGER(IntKi)  :: NumOuts_DLL      !< Number of logging channels output from the DLL (set at initialization) [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      !< Column delimiter for output text files [-]
    LOGICAL  :: UseBladedInterface      !< Flag that determines if BladedInterface was used [-]
    LOGICAL  :: UseLegacyInterface      !< Flag that determines if the legacy Bladed interface is (legacy=DISCON with avrSWAP instead of CONTROLLER) [-]
    TYPE(DLL_Type)  :: DLL_Trgt      !< The addresses and names of the Bladed DLL and its procedure [-]
    LOGICAL  :: DLL_Ramp      !< determines if there is a DLL_DT-ramp time delay (true only when DLL_DT /= DT) [-]
    REAL(ReKi)  :: BlAlpha      !< parameter for low-pass filter of blade pitch commands from the controller DLL [-]
    INTEGER(IntKi)  :: DLL_n      !< number of steps between the controller being called and SrvD being called [-]
    INTEGER(IntKi)  :: avcOUTNAME_LEN      !< Length of the avcOUTNAME character array passed to/from the DLL [-]
    REAL(ReKi)  :: NacYaw_North      !< Reference yaw angle of the nacelle when the upwind end points due North [rad]
    REAL(ReKi)  :: AvgWindSpeed      !< average wind speed for the simulation [m/s]
    REAL(ReKi)  :: AirDens      !< air density [kg/m^3]
    INTEGER(IntKi)  :: TrimCase      !< Controller parameter to be trimmed {1:yaw; 2:torque; 3:pitch} [used only if CalcSteady=True] [-]
    REAL(ReKi)  :: TrimGain      !< Proportional gain for the rotational speed error (>0) [used only if TrimCase>0] [rad/(rad/s) for yaw or pitch; Nm/(rad/s) for torque]
    REAL(ReKi)  :: RotSpeedRef      !< Reference rotor speed [rad/s]
    TYPE(StC_ParameterType) , DIMENSION(:), ALLOCATABLE  :: BStC      !< StC module parameters - blade [-]
    TYPE(StC_ParameterType) , DIMENSION(:), ALLOCATABLE  :: NStC      !< StC module parameters - nacelle [-]
    TYPE(StC_ParameterType) , DIMENSION(:), ALLOCATABLE  :: TStC      !< StC module parameters - tower [-]
    TYPE(StC_ParameterType) , DIMENSION(:), ALLOCATABLE  :: SStC      !< StC module parameters - substructure [-]
    INTEGER(IntKi)  :: InterpOrder      !< Interpolation order from glue code -- required to set m%u_xStC sizes [-]
    LOGICAL  :: EXavrSWAP      !< Use extendend avr SWAP [-]
    INTEGER(IntKi)  :: NumCableControl      !< Number of cable control channels requested [-]
    INTEGER(IntKi)  :: NumStC_Control      !< Number of cable StC channels requested [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: StCMeasNumPerChan      !< Number of cable StC channel to average on each control channel sent to DLL [-]
    LOGICAL  :: UseSC      !< Supercontroller on/off flag [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_x_indx      !< matrix to help fill/pack the x vector in computing the jacobian [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
    INTEGER(IntKi)  :: Jac_nu      !< number of inputs in jacobian matrix [-]
    INTEGER(IntKi)  :: Jac_ny      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: Jac_nx      !< the number of continuous states in jacobian matrix [-]
    INTEGER(IntKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Jac_Idx_BStC_u      !< the start and end indices of blade        StC u jacobian [ start/end, blade, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_NStC_u      !< the start and end indices of nacelle      StC u jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_TStC_u      !< the start and end indices of tower        StC u jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_SStC_u      !< the start and end indices of substructure StC u jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Jac_Idx_BStC_x      !< the start and end indices of blade        StC x jacobian [ start/end, blade, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_NStC_x      !< the start and end indices of nacelle      StC x jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_TStC_x      !< the start and end indices of tower        StC x jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_SStC_x      !< the start and end indices of substructure StC x jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Jac_Idx_BStC_y      !< the start and end indices of blade        StC y jacobian [ start/end, blade, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_NStC_y      !< the start and end indices of nacelle      StC y jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_TStC_y      !< the start and end indices of tower        StC y jacobian [ start/end, instance ] [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_Idx_SStC_y      !< the start and end indices of substructure StC y jacobian [ start/end, instance ] [-]
    INTEGER(IntKi)  :: SensorType      !< Lidar sensor type [-]
    INTEGER(IntKi)  :: NumBeam      !< Number of beams [-]
    INTEGER(IntKi)  :: NumPulseGate      !< Number of pulse gates [-]
    REAL(ReKi)  :: PulseSpacing      !< Distance between range gates [m]
    REAL(ReKi)  :: URefLid      !< Reference average wind speed for the lidar [m/s]
  END TYPE SrvD_ParameterType
! =======================
! =========  SrvD_InputType  =======
  TYPE, PUBLIC :: SrvD_InputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitch      !< Current blade pitch angles [radians]
    REAL(ReKi)  :: Yaw      !< Current nacelle yaw [radians]
    REAL(ReKi)  :: YawRate      !< Current nacelle yaw rate [rad/s]
    REAL(ReKi)  :: LSS_Spd      !< Low-speed shaft (LSS) speed at entrance to gearbox [rad/s]
    REAL(ReKi)  :: HSS_Spd      !< High-speed shaft (HSS) speed [rad/s]
    REAL(ReKi)  :: RotSpeed      !< Rotor azimuth angular speed [rad/s]
    REAL(ReKi)  :: ExternalYawPosCom      !< Commanded nacelle yaw position from Simulink or Labview [radians]
    REAL(ReKi)  :: ExternalYawRateCom      !< Commanded nacelle yaw rate from Simulink or Labview [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ExternalBlPitchCom      !< Commanded blade pitch from Simulink or LabVIEW [radians]
    REAL(ReKi)  :: ExternalGenTrq      !< Electrical generator torque from Simulink or LabVIEW [N-m]
    REAL(ReKi)  :: ExternalElecPwr      !< Electrical power from Simulink or LabVIEW [W]
    REAL(ReKi)  :: ExternalHSSBrFrac      !< Fraction of full braking torque: 0 (off) <= HSSBrFrac <= 1 (full) from Simulink or LabVIEW [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ExternalBlAirfoilCom      !< Commanded Airfoil UserProp for blade.  Passed to AD15 for airfoil interpolation (must be same units as given in AD15 airfoil tables) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ExternalCableDeltaL      !< Commanded Cable controlo DeltaL [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ExternalCableDeltaLdot      !< Commanded Cable controlo DeltaLdot [m/s]
    REAL(ReKi)  :: TwrAccel      !< Tower acceleration for tower feedback control (user routine only) [m/s^2]
    REAL(ReKi)  :: YawErr      !< Yaw error [radians]
    REAL(ReKi)  :: WindDir      !< Wind direction [radians]
    REAL(ReKi) , DIMENSION(1:3)  :: RootMyc      !< Out-of-plane moment (i.e., the moment caused by out-of-plane forces) at the blade root for each of the blades (max 3) [N-m]
    REAL(ReKi)  :: YawBrTAxp      !< Tower-top / yaw bearing fore-aft (translational) acceleration (absolute) [m/s^2]
    REAL(ReKi)  :: YawBrTAyp      !< Tower-top / yaw bearing side-to-side (translational) acceleration (absolute) [m/s^2]
    REAL(ReKi)  :: LSSTipPxa      !< Rotor azimuth angle (position) [radians]
    REAL(ReKi) , DIMENSION(1:3)  :: RootMxc      !< In-plane moment (i.e., the moment caused by in-plane forces) at the blade root [N-m]
    REAL(ReKi)  :: LSSTipMxa      !< Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMya      !< Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMza      !< Rotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMys      !< Nonrotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: LSSTipMzs      !< Nonrotating low-speed shaft bending moment at the shaft tip (teeter pin for 2-blader, apex of rotation for 3-blader) [N-m]
    REAL(ReKi)  :: YawBrMyn      !< Rotating (with nacelle) tower-top / yaw bearing pitch moment [N-m]
    REAL(ReKi)  :: YawBrMzn      !< Tower-top / yaw bearing yaw moment [N-m]
    REAL(ReKi)  :: NcIMURAxs      !< Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: NcIMURAys      !< Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: NcIMURAzs      !< Nacelle inertial measurement unit angular (rotational) acceleration (absolute) [rad/s^2]
    REAL(ReKi)  :: RotPwr      !< Rotor power (this is equivalent to the low-speed shaft power) [W]
    REAL(ReKi)  :: HorWindV      !< Horizontal hub-height wind velocity magnitude [m/s]
    REAL(ReKi)  :: YawAngle      !< Estimate of yaw (nacelle + platform) [radians]
    REAL(ReKi)  :: LSShftFxa      !< Rotating low-speed shaft force x [N]
    REAL(ReKi)  :: LSShftFys      !< Nonrotating low-speed shaft force y [N]
    REAL(ReKi)  :: LSShftFzs      !< Nonrotating low-speed shaft force z [N]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: fromSC      !< A swap array: used to pass turbine specific input data to the DLL controller from the supercontroller [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: fromSCglob      !< A swap array: used to pass global input data to the DLL controller from the supercontroller [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: Lidar      !< A swap array: used to pass input data to the DLL controller from the Lidar [-]
    TYPE(MeshType)  :: PtfmMotionMesh      !< Platform motion mesh at platform reference point [-]
    TYPE(MeshType) , DIMENSION(:,:), ALLOCATABLE  :: BStCMotionMesh      !< StC module blade        input motion mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: NStCMotionMesh      !< StC module nacelle      input motion mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: TStCMotionMesh      !< StC module tower        input motion mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: SStCMotionMesh      !< StC module substructure input motion mesh [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LidSpeed      !< Lidar measured wind speeds [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsX      !< Lidar X direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsY      !< Lidar Y direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsZ      !< Lidar Z direction measurement points [m]
  END TYPE SrvD_InputType
! =======================
! =========  SrvD_OutputType  =======
  TYPE, PUBLIC :: SrvD_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlPitchCom      !< Commanded blade pitch angles [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlAirfoilCom      !< Commanded Airfoil UserProp for blade.  Passed to AD15 for airfoil interpolation (must be same units as given in AD15 airfoil tables) [-]
    REAL(ReKi)  :: YawMom      !< Torque transmitted through the yaw bearing [N-m]
    REAL(ReKi)  :: GenTrq      !< Electrical generator torque [N-m]
    REAL(ReKi)  :: HSSBrTrqC      !< Commanded HSS brake torque [N-m]
    REAL(ReKi)  :: ElecPwr      !< Electrical power [W]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TBDrCon      !< Instantaneous tip-brake drag constant, Cd*Area [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: Lidar      !< A swap array: used to pass output data from the DLL controller to the Lidar [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CableDeltaL      !< Cable control -- Length change request (passed to MD or SD) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CableDeltaLdot      !< Cable control -- Length change rate request (passed to MD or SD) [m/s]
    TYPE(MeshType) , DIMENSION(:,:), ALLOCATABLE  :: BStCLoadMesh      !< StC module blade        output load mesh (NumBl,NumBStC) [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: NStCLoadMesh      !< StC module nacelle      output load mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: TStCLoadMesh      !< StC module tower        output load mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: SStCLoadMesh      !< StC module substructure output load mesh [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: toSC      !< A swap array: used to pass output data from the DLL controller to the supercontroller [-]
  END TYPE SrvD_OutputType
! =======================
CONTAINS
 SUBROUTINE SrvD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(SrvD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%Linearize = SrcInitInputData%Linearize
    DstInitInputData%NumBl = SrcInitInputData%NumBl
    DstInitInputData%RootName = SrcInitInputData%RootName
IF (ALLOCATED(SrcInitInputData%BlPitchInit)) THEN
  i1_l = LBOUND(SrcInitInputData%BlPitchInit,1)
  i1_u = UBOUND(SrcInitInputData%BlPitchInit,1)
  IF (.NOT. ALLOCATED(DstInitInputData%BlPitchInit)) THEN 
    ALLOCATE(DstInitInputData%BlPitchInit(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%BlPitchInit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%BlPitchInit = SrcInitInputData%BlPitchInit
ENDIF
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%NacRefPos = SrcInitInputData%NacRefPos
    DstInitInputData%NacTransDisp = SrcInitInputData%NacTransDisp
    DstInitInputData%NacOrient = SrcInitInputData%NacOrient
    DstInitInputData%NacRefOrient = SrcInitInputData%NacRefOrient
    DstInitInputData%TwrBaseRefPos = SrcInitInputData%TwrBaseRefPos
    DstInitInputData%TwrBaseTransDisp = SrcInitInputData%TwrBaseTransDisp
    DstInitInputData%TwrBaseOrient = SrcInitInputData%TwrBaseOrient
    DstInitInputData%TwrBaseRefOrient = SrcInitInputData%TwrBaseRefOrient
    DstInitInputData%PtfmRefPos = SrcInitInputData%PtfmRefPos
    DstInitInputData%PtfmTransDisp = SrcInitInputData%PtfmTransDisp
    DstInitInputData%PtfmOrient = SrcInitInputData%PtfmOrient
    DstInitInputData%PtfmRefOrient = SrcInitInputData%PtfmRefOrient
    DstInitInputData%Tmax = SrcInitInputData%Tmax
    DstInitInputData%AvgWindSpeed = SrcInitInputData%AvgWindSpeed
    DstInitInputData%AirDens = SrcInitInputData%AirDens
    DstInitInputData%NumSC2CtrlGlob = SrcInitInputData%NumSC2CtrlGlob
    DstInitInputData%NumSC2Ctrl = SrcInitInputData%NumSC2Ctrl
    DstInitInputData%NumCtrl2SC = SrcInitInputData%NumCtrl2SC
    DstInitInputData%TrimCase = SrcInitInputData%TrimCase
    DstInitInputData%TrimGain = SrcInitInputData%TrimGain
    DstInitInputData%RotSpeedRef = SrcInitInputData%RotSpeedRef
IF (ALLOCATED(SrcInitInputData%BladeRootRefPos)) THEN
  i1_l = LBOUND(SrcInitInputData%BladeRootRefPos,1)
  i1_u = UBOUND(SrcInitInputData%BladeRootRefPos,1)
  i2_l = LBOUND(SrcInitInputData%BladeRootRefPos,2)
  i2_u = UBOUND(SrcInitInputData%BladeRootRefPos,2)
  IF (.NOT. ALLOCATED(DstInitInputData%BladeRootRefPos)) THEN 
    ALLOCATE(DstInitInputData%BladeRootRefPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%BladeRootRefPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%BladeRootRefPos = SrcInitInputData%BladeRootRefPos
ENDIF
IF (ALLOCATED(SrcInitInputData%BladeRootTransDisp)) THEN
  i1_l = LBOUND(SrcInitInputData%BladeRootTransDisp,1)
  i1_u = UBOUND(SrcInitInputData%BladeRootTransDisp,1)
  i2_l = LBOUND(SrcInitInputData%BladeRootTransDisp,2)
  i2_u = UBOUND(SrcInitInputData%BladeRootTransDisp,2)
  IF (.NOT. ALLOCATED(DstInitInputData%BladeRootTransDisp)) THEN 
    ALLOCATE(DstInitInputData%BladeRootTransDisp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%BladeRootTransDisp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%BladeRootTransDisp = SrcInitInputData%BladeRootTransDisp
ENDIF
IF (ALLOCATED(SrcInitInputData%BladeRootOrient)) THEN
  i1_l = LBOUND(SrcInitInputData%BladeRootOrient,1)
  i1_u = UBOUND(SrcInitInputData%BladeRootOrient,1)
  i2_l = LBOUND(SrcInitInputData%BladeRootOrient,2)
  i2_u = UBOUND(SrcInitInputData%BladeRootOrient,2)
  i3_l = LBOUND(SrcInitInputData%BladeRootOrient,3)
  i3_u = UBOUND(SrcInitInputData%BladeRootOrient,3)
  IF (.NOT. ALLOCATED(DstInitInputData%BladeRootOrient)) THEN 
    ALLOCATE(DstInitInputData%BladeRootOrient(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%BladeRootOrient.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%BladeRootOrient = SrcInitInputData%BladeRootOrient
ENDIF
IF (ALLOCATED(SrcInitInputData%BladeRootRefOrient)) THEN
  i1_l = LBOUND(SrcInitInputData%BladeRootRefOrient,1)
  i1_u = UBOUND(SrcInitInputData%BladeRootRefOrient,1)
  i2_l = LBOUND(SrcInitInputData%BladeRootRefOrient,2)
  i2_u = UBOUND(SrcInitInputData%BladeRootRefOrient,2)
  i3_l = LBOUND(SrcInitInputData%BladeRootRefOrient,3)
  i3_u = UBOUND(SrcInitInputData%BladeRootRefOrient,3)
  IF (.NOT. ALLOCATED(DstInitInputData%BladeRootRefOrient)) THEN 
    ALLOCATE(DstInitInputData%BladeRootRefOrient(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%BladeRootRefOrient.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%BladeRootRefOrient = SrcInitInputData%BladeRootRefOrient
ENDIF
    DstInitInputData%UseInputFile = SrcInitInputData%UseInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedPrimaryInputData, DstInitInputData%PassedPrimaryInputData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%NumCableControl = SrcInitInputData%NumCableControl
IF (ALLOCATED(SrcInitInputData%CableControlRequestor)) THEN
  i1_l = LBOUND(SrcInitInputData%CableControlRequestor,1)
  i1_u = UBOUND(SrcInitInputData%CableControlRequestor,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CableControlRequestor)) THEN 
    ALLOCATE(DstInitInputData%CableControlRequestor(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CableControlRequestor.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%CableControlRequestor = SrcInitInputData%CableControlRequestor
ENDIF
    DstInitInputData%InterpOrder = SrcInitInputData%InterpOrder
IF (ALLOCATED(SrcInitInputData%fromSCGlob)) THEN
  i1_l = LBOUND(SrcInitInputData%fromSCGlob,1)
  i1_u = UBOUND(SrcInitInputData%fromSCGlob,1)
  IF (.NOT. ALLOCATED(DstInitInputData%fromSCGlob)) THEN 
    ALLOCATE(DstInitInputData%fromSCGlob(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%fromSCGlob.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%fromSCGlob = SrcInitInputData%fromSCGlob
ENDIF
IF (ALLOCATED(SrcInitInputData%fromSC)) THEN
  i1_l = LBOUND(SrcInitInputData%fromSC,1)
  i1_u = UBOUND(SrcInitInputData%fromSC,1)
  IF (.NOT. ALLOCATED(DstInitInputData%fromSC)) THEN 
    ALLOCATE(DstInitInputData%fromSC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%fromSC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%fromSC = SrcInitInputData%fromSC
ENDIF
IF (ALLOCATED(SrcInitInputData%LidSpeed)) THEN
  i1_l = LBOUND(SrcInitInputData%LidSpeed,1)
  i1_u = UBOUND(SrcInitInputData%LidSpeed,1)
  IF (.NOT. ALLOCATED(DstInitInputData%LidSpeed)) THEN 
    ALLOCATE(DstInitInputData%LidSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%LidSpeed.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%LidSpeed = SrcInitInputData%LidSpeed
ENDIF
IF (ALLOCATED(SrcInitInputData%MsrPositionsX)) THEN
  i1_l = LBOUND(SrcInitInputData%MsrPositionsX,1)
  i1_u = UBOUND(SrcInitInputData%MsrPositionsX,1)
  IF (.NOT. ALLOCATED(DstInitInputData%MsrPositionsX)) THEN 
    ALLOCATE(DstInitInputData%MsrPositionsX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MsrPositionsX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%MsrPositionsX = SrcInitInputData%MsrPositionsX
ENDIF
IF (ALLOCATED(SrcInitInputData%MsrPositionsY)) THEN
  i1_l = LBOUND(SrcInitInputData%MsrPositionsY,1)
  i1_u = UBOUND(SrcInitInputData%MsrPositionsY,1)
  IF (.NOT. ALLOCATED(DstInitInputData%MsrPositionsY)) THEN 
    ALLOCATE(DstInitInputData%MsrPositionsY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MsrPositionsY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%MsrPositionsY = SrcInitInputData%MsrPositionsY
ENDIF
IF (ALLOCATED(SrcInitInputData%MsrPositionsZ)) THEN
  i1_l = LBOUND(SrcInitInputData%MsrPositionsZ,1)
  i1_u = UBOUND(SrcInitInputData%MsrPositionsZ,1)
  IF (.NOT. ALLOCATED(DstInitInputData%MsrPositionsZ)) THEN 
    ALLOCATE(DstInitInputData%MsrPositionsZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%MsrPositionsZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%MsrPositionsZ = SrcInitInputData%MsrPositionsZ
ENDIF
    DstInitInputData%SensorType = SrcInitInputData%SensorType
    DstInitInputData%NumBeam = SrcInitInputData%NumBeam
    DstInitInputData%NumPulseGate = SrcInitInputData%NumPulseGate
    DstInitInputData%PulseSpacing = SrcInitInputData%PulseSpacing
    DstInitInputData%URefLid = SrcInitInputData%URefLid
 END SUBROUTINE SrvD_CopyInitInput

 SUBROUTINE SrvD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SrvD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%BlPitchInit)) THEN
  DEALLOCATE(InitInputData%BlPitchInit)
ENDIF
IF (ALLOCATED(InitInputData%BladeRootRefPos)) THEN
  DEALLOCATE(InitInputData%BladeRootRefPos)
ENDIF
IF (ALLOCATED(InitInputData%BladeRootTransDisp)) THEN
  DEALLOCATE(InitInputData%BladeRootTransDisp)
ENDIF
IF (ALLOCATED(InitInputData%BladeRootOrient)) THEN
  DEALLOCATE(InitInputData%BladeRootOrient)
ENDIF
IF (ALLOCATED(InitInputData%BladeRootRefOrient)) THEN
  DEALLOCATE(InitInputData%BladeRootRefOrient)
ENDIF
  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedPrimaryInputData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitInputData%CableControlRequestor)) THEN
  DEALLOCATE(InitInputData%CableControlRequestor)
ENDIF
IF (ALLOCATED(InitInputData%fromSCGlob)) THEN
  DEALLOCATE(InitInputData%fromSCGlob)
ENDIF
IF (ALLOCATED(InitInputData%fromSC)) THEN
  DEALLOCATE(InitInputData%fromSC)
ENDIF
IF (ALLOCATED(InitInputData%LidSpeed)) THEN
  DEALLOCATE(InitInputData%LidSpeed)
ENDIF
IF (ALLOCATED(InitInputData%MsrPositionsX)) THEN
  DEALLOCATE(InitInputData%MsrPositionsX)
ENDIF
IF (ALLOCATED(InitInputData%MsrPositionsY)) THEN
  DEALLOCATE(InitInputData%MsrPositionsY)
ENDIF
IF (ALLOCATED(InitInputData%MsrPositionsZ)) THEN
  DEALLOCATE(InitInputData%MsrPositionsZ)
ENDIF
 END SUBROUTINE SrvD_DestroyInitInput


subroutine SrvD_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegPack(Buf, InData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchInit
   call RegPack(Buf, allocated(InData%BlPitchInit))
   if (allocated(InData%BlPitchInit)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitchInit), ubound(InData%BlPitchInit))
      call RegPack(Buf, InData%BlPitchInit)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacRefPos
   call RegPack(Buf, InData%NacRefPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacTransDisp
   call RegPack(Buf, InData%NacTransDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacOrient
   call RegPack(Buf, InData%NacOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacRefOrient
   call RegPack(Buf, InData%NacRefOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseRefPos
   call RegPack(Buf, InData%TwrBaseRefPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseTransDisp
   call RegPack(Buf, InData%TwrBaseTransDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseOrient
   call RegPack(Buf, InData%TwrBaseOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseRefOrient
   call RegPack(Buf, InData%TwrBaseRefOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefPos
   call RegPack(Buf, InData%PtfmRefPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmTransDisp
   call RegPack(Buf, InData%PtfmTransDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmOrient
   call RegPack(Buf, InData%PtfmOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefOrient
   call RegPack(Buf, InData%PtfmRefOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegPack(Buf, InData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgWindSpeed
   call RegPack(Buf, InData%AvgWindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2CtrlGlob
   call RegPack(Buf, InData%NumSC2CtrlGlob)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2Ctrl
   call RegPack(Buf, InData%NumSC2Ctrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCtrl2SC
   call RegPack(Buf, InData%NumCtrl2SC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimCase
   call RegPack(Buf, InData%TrimCase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimGain
   call RegPack(Buf, InData%TrimGain)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeedRef
   call RegPack(Buf, InData%RotSpeedRef)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootRefPos
   call RegPack(Buf, allocated(InData%BladeRootRefPos))
   if (allocated(InData%BladeRootRefPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%BladeRootRefPos), ubound(InData%BladeRootRefPos))
      call RegPack(Buf, InData%BladeRootRefPos)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootTransDisp
   call RegPack(Buf, allocated(InData%BladeRootTransDisp))
   if (allocated(InData%BladeRootTransDisp)) then
      call RegPackBounds(Buf, 2, lbound(InData%BladeRootTransDisp), ubound(InData%BladeRootTransDisp))
      call RegPack(Buf, InData%BladeRootTransDisp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootOrient
   call RegPack(Buf, allocated(InData%BladeRootOrient))
   if (allocated(InData%BladeRootOrient)) then
      call RegPackBounds(Buf, 3, lbound(InData%BladeRootOrient), ubound(InData%BladeRootOrient))
      call RegPack(Buf, InData%BladeRootOrient)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootRefOrient
   call RegPack(Buf, allocated(InData%BladeRootRefOrient))
   if (allocated(InData%BladeRootRefOrient)) then
      call RegPackBounds(Buf, 3, lbound(InData%BladeRootRefOrient), ubound(InData%BladeRootRefOrient))
      call RegPack(Buf, InData%BladeRootRefOrient)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegPack(Buf, InData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedPrimaryInputData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCableControl
   call RegPack(Buf, InData%NumCableControl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableControlRequestor
   call RegPack(Buf, allocated(InData%CableControlRequestor))
   if (allocated(InData%CableControlRequestor)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableControlRequestor), ubound(InData%CableControlRequestor))
      call RegPack(Buf, InData%CableControlRequestor)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InterpOrder
   call RegPack(Buf, InData%InterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSCGlob
   call RegPack(Buf, allocated(InData%fromSCGlob))
   if (allocated(InData%fromSCGlob)) then
      call RegPackBounds(Buf, 1, lbound(InData%fromSCGlob), ubound(InData%fromSCGlob))
      call RegPack(Buf, InData%fromSCGlob)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSC
   call RegPack(Buf, allocated(InData%fromSC))
   if (allocated(InData%fromSC)) then
      call RegPackBounds(Buf, 1, lbound(InData%fromSC), ubound(InData%fromSC))
      call RegPack(Buf, InData%fromSC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidSpeed
   call RegPack(Buf, allocated(InData%LidSpeed))
   if (allocated(InData%LidSpeed)) then
      call RegPackBounds(Buf, 1, lbound(InData%LidSpeed), ubound(InData%LidSpeed))
      call RegPack(Buf, InData%LidSpeed)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsX
   call RegPack(Buf, allocated(InData%MsrPositionsX))
   if (allocated(InData%MsrPositionsX)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsX), ubound(InData%MsrPositionsX))
      call RegPack(Buf, InData%MsrPositionsX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsY
   call RegPack(Buf, allocated(InData%MsrPositionsY))
   if (allocated(InData%MsrPositionsY)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsY), ubound(InData%MsrPositionsY))
      call RegPack(Buf, InData%MsrPositionsY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsZ
   call RegPack(Buf, allocated(InData%MsrPositionsZ))
   if (allocated(InData%MsrPositionsZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsZ), ubound(InData%MsrPositionsZ))
      call RegPack(Buf, InData%MsrPositionsZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegPack(Buf, InData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegPack(Buf, InData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegPack(Buf, InData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegPack(Buf, InData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegPack(Buf, InData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegUnpack(Buf, OutData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchInit
   if (allocated(OutData%BlPitchInit)) deallocate(OutData%BlPitchInit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitchInit(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitchInit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitchInit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacRefPos
   call RegUnpack(Buf, OutData%NacRefPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacTransDisp
   call RegUnpack(Buf, OutData%NacTransDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacOrient
   call RegUnpack(Buf, OutData%NacOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacRefOrient
   call RegUnpack(Buf, OutData%NacRefOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseRefPos
   call RegUnpack(Buf, OutData%TwrBaseRefPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseTransDisp
   call RegUnpack(Buf, OutData%TwrBaseTransDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseOrient
   call RegUnpack(Buf, OutData%TwrBaseOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBaseRefOrient
   call RegUnpack(Buf, OutData%TwrBaseRefOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefPos
   call RegUnpack(Buf, OutData%PtfmRefPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmTransDisp
   call RegUnpack(Buf, OutData%PtfmTransDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmOrient
   call RegUnpack(Buf, OutData%PtfmOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefOrient
   call RegUnpack(Buf, OutData%PtfmRefOrient)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegUnpack(Buf, OutData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgWindSpeed
   call RegUnpack(Buf, OutData%AvgWindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2CtrlGlob
   call RegUnpack(Buf, OutData%NumSC2CtrlGlob)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2Ctrl
   call RegUnpack(Buf, OutData%NumSC2Ctrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCtrl2SC
   call RegUnpack(Buf, OutData%NumCtrl2SC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimCase
   call RegUnpack(Buf, OutData%TrimCase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimGain
   call RegUnpack(Buf, OutData%TrimGain)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeedRef
   call RegUnpack(Buf, OutData%RotSpeedRef)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootRefPos
   if (allocated(OutData%BladeRootRefPos)) deallocate(OutData%BladeRootRefPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootRefPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootRefPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootRefPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeRootTransDisp
   if (allocated(OutData%BladeRootTransDisp)) deallocate(OutData%BladeRootTransDisp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootTransDisp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootTransDisp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootTransDisp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeRootOrient
   if (allocated(OutData%BladeRootOrient)) deallocate(OutData%BladeRootOrient)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootOrient(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootOrient.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootOrient)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeRootRefOrient
   if (allocated(OutData%BladeRootRefOrient)) deallocate(OutData%BladeRootRefOrient)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootRefOrient(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootRefOrient.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootRefOrient)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UseInputFile
   call RegUnpack(Buf, OutData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedPrimaryInputData) ! PassedPrimaryInputData 
   ! NumCableControl
   call RegUnpack(Buf, OutData%NumCableControl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableControlRequestor
   if (allocated(OutData%CableControlRequestor)) deallocate(OutData%CableControlRequestor)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableControlRequestor(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableControlRequestor.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableControlRequestor)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InterpOrder
   call RegUnpack(Buf, OutData%InterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSCGlob
   if (allocated(OutData%fromSCGlob)) deallocate(OutData%fromSCGlob)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%fromSCGlob(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%fromSCGlob.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%fromSCGlob)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! fromSC
   if (allocated(OutData%fromSC)) deallocate(OutData%fromSC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%fromSC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%fromSC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%fromSC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LidSpeed
   if (allocated(OutData%LidSpeed)) deallocate(OutData%LidSpeed)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LidSpeed(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LidSpeed.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LidSpeed)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsX
   if (allocated(OutData%MsrPositionsX)) deallocate(OutData%MsrPositionsX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsY
   if (allocated(OutData%MsrPositionsY)) deallocate(OutData%MsrPositionsY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsZ
   if (allocated(OutData%MsrPositionsZ)) deallocate(OutData%MsrPositionsZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SensorType
   call RegUnpack(Buf, OutData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegUnpack(Buf, OutData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegUnpack(Buf, OutData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegUnpack(Buf, OutData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegUnpack(Buf, OutData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SrvD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SrvD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitOutputData%CouplingScheme = SrcInitOutputData%CouplingScheme
    DstInitOutputData%UseHSSBrake = SrcInitOutputData%UseHSSBrake
IF (ALLOCATED(SrcInitOutputData%LinNames_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_y,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_y)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_y = SrcInitOutputData%LinNames_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_x,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_x)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_x = SrcInitOutputData%LinNames_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_u,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_u)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_u = SrcInitOutputData%LinNames_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_y,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_y)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_y = SrcInitOutputData%RotFrame_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_x,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_x)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_x = SrcInitOutputData%RotFrame_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_u,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_u)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_u = SrcInitOutputData%RotFrame_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%IsLoad_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%IsLoad_u,1)
  i1_u = UBOUND(SrcInitOutputData%IsLoad_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%IsLoad_u)) THEN 
    ALLOCATE(DstInitOutputData%IsLoad_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%IsLoad_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%IsLoad_u = SrcInitOutputData%IsLoad_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%DerivOrder_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%DerivOrder_x,1)
  i1_u = UBOUND(SrcInitOutputData%DerivOrder_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%DerivOrder_x)) THEN 
    ALLOCATE(DstInitOutputData%DerivOrder_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%DerivOrder_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%DerivOrder_x = SrcInitOutputData%DerivOrder_x
ENDIF
 END SUBROUTINE SrvD_CopyInitOutput

 SUBROUTINE SrvD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SrvD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%LinNames_y)) THEN
  DEALLOCATE(InitOutputData%LinNames_y)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_x)) THEN
  DEALLOCATE(InitOutputData%LinNames_x)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_u)) THEN
  DEALLOCATE(InitOutputData%LinNames_u)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_y)) THEN
  DEALLOCATE(InitOutputData%RotFrame_y)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_x)) THEN
  DEALLOCATE(InitOutputData%RotFrame_x)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_u)) THEN
  DEALLOCATE(InitOutputData%RotFrame_u)
ENDIF
IF (ALLOCATED(InitOutputData%IsLoad_u)) THEN
  DEALLOCATE(InitOutputData%IsLoad_u)
ENDIF
IF (ALLOCATED(InitOutputData%DerivOrder_x)) THEN
  DEALLOCATE(InitOutputData%DerivOrder_x)
ENDIF
 END SUBROUTINE SrvD_DestroyInitOutput


subroutine SrvD_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! CouplingScheme
   call RegPack(Buf, InData%CouplingScheme)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseHSSBrake
   call RegPack(Buf, InData%UseHSSBrake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_y
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_x
   call RegPack(Buf, allocated(InData%LinNames_x))
   if (allocated(InData%LinNames_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_x), ubound(InData%LinNames_x))
      call RegPack(Buf, InData%LinNames_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_u
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_y
   call RegPack(Buf, allocated(InData%RotFrame_y))
   if (allocated(InData%RotFrame_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_y), ubound(InData%RotFrame_y))
      call RegPack(Buf, InData%RotFrame_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_x
   call RegPack(Buf, allocated(InData%RotFrame_x))
   if (allocated(InData%RotFrame_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_x), ubound(InData%RotFrame_x))
      call RegPack(Buf, InData%RotFrame_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_u
   call RegPack(Buf, allocated(InData%RotFrame_u))
   if (allocated(InData%RotFrame_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_u), ubound(InData%RotFrame_u))
      call RegPack(Buf, InData%RotFrame_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsLoad_u
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DerivOrder_x
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! CouplingScheme
   call RegUnpack(Buf, OutData%CouplingScheme)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseHSSBrake
   call RegUnpack(Buf, OutData%UseHSSBrake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_y
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_x
   if (allocated(OutData%LinNames_x)) deallocate(OutData%LinNames_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_u
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_y
   if (allocated(OutData%RotFrame_y)) deallocate(OutData%RotFrame_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_x
   if (allocated(OutData%RotFrame_x)) deallocate(OutData%RotFrame_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_u
   if (allocated(OutData%RotFrame_u)) deallocate(OutData%RotFrame_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsLoad_u
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DerivOrder_x
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SrvD_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(SrvD_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%DT = SrcInputFileData%DT
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%PCMode = SrcInputFileData%PCMode
    DstInputFileData%TPCOn = SrcInputFileData%TPCOn
    DstInputFileData%TPitManS = SrcInputFileData%TPitManS
    DstInputFileData%PitManRat = SrcInputFileData%PitManRat
    DstInputFileData%BlPitchF = SrcInputFileData%BlPitchF
    DstInputFileData%VSContrl = SrcInputFileData%VSContrl
    DstInputFileData%GenModel = SrcInputFileData%GenModel
    DstInputFileData%GenEff = SrcInputFileData%GenEff
    DstInputFileData%GenTiStr = SrcInputFileData%GenTiStr
    DstInputFileData%GenTiStp = SrcInputFileData%GenTiStp
    DstInputFileData%SpdGenOn = SrcInputFileData%SpdGenOn
    DstInputFileData%TimGenOn = SrcInputFileData%TimGenOn
    DstInputFileData%TimGenOf = SrcInputFileData%TimGenOf
    DstInputFileData%VS_RtGnSp = SrcInputFileData%VS_RtGnSp
    DstInputFileData%VS_RtTq = SrcInputFileData%VS_RtTq
    DstInputFileData%VS_Rgn2K = SrcInputFileData%VS_Rgn2K
    DstInputFileData%VS_SlPc = SrcInputFileData%VS_SlPc
    DstInputFileData%SIG_SlPc = SrcInputFileData%SIG_SlPc
    DstInputFileData%SIG_SySp = SrcInputFileData%SIG_SySp
    DstInputFileData%SIG_RtTq = SrcInputFileData%SIG_RtTq
    DstInputFileData%SIG_PORt = SrcInputFileData%SIG_PORt
    DstInputFileData%TEC_Freq = SrcInputFileData%TEC_Freq
    DstInputFileData%TEC_NPol = SrcInputFileData%TEC_NPol
    DstInputFileData%TEC_SRes = SrcInputFileData%TEC_SRes
    DstInputFileData%TEC_RRes = SrcInputFileData%TEC_RRes
    DstInputFileData%TEC_VLL = SrcInputFileData%TEC_VLL
    DstInputFileData%TEC_SLR = SrcInputFileData%TEC_SLR
    DstInputFileData%TEC_RLR = SrcInputFileData%TEC_RLR
    DstInputFileData%TEC_MR = SrcInputFileData%TEC_MR
    DstInputFileData%HSSBrMode = SrcInputFileData%HSSBrMode
    DstInputFileData%THSSBrDp = SrcInputFileData%THSSBrDp
    DstInputFileData%HSSBrDT = SrcInputFileData%HSSBrDT
    DstInputFileData%HSSBrTqF = SrcInputFileData%HSSBrTqF
    DstInputFileData%YCMode = SrcInputFileData%YCMode
    DstInputFileData%TYCOn = SrcInputFileData%TYCOn
    DstInputFileData%YawNeut = SrcInputFileData%YawNeut
    DstInputFileData%YawSpr = SrcInputFileData%YawSpr
    DstInputFileData%YawDamp = SrcInputFileData%YawDamp
    DstInputFileData%TYawManS = SrcInputFileData%TYawManS
    DstInputFileData%YawManRat = SrcInputFileData%YawManRat
    DstInputFileData%NacYawF = SrcInputFileData%NacYawF
    DstInputFileData%SumPrint = SrcInputFileData%SumPrint
    DstInputFileData%OutFile = SrcInputFileData%OutFile
    DstInputFileData%TabDelim = SrcInputFileData%TabDelim
    DstInputFileData%OutFmt = SrcInputFileData%OutFmt
    DstInputFileData%Tstart = SrcInputFileData%Tstart
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
    DstInputFileData%DLL_FileName = SrcInputFileData%DLL_FileName
    DstInputFileData%DLL_ProcName = SrcInputFileData%DLL_ProcName
    DstInputFileData%DLL_InFile = SrcInputFileData%DLL_InFile
    DstInputFileData%DLL_DT = SrcInputFileData%DLL_DT
    DstInputFileData%DLL_Ramp = SrcInputFileData%DLL_Ramp
    DstInputFileData%BPCutoff = SrcInputFileData%BPCutoff
    DstInputFileData%NacYaw_North = SrcInputFileData%NacYaw_North
    DstInputFileData%Ptch_Cntrl = SrcInputFileData%Ptch_Cntrl
    DstInputFileData%Ptch_SetPnt = SrcInputFileData%Ptch_SetPnt
    DstInputFileData%Ptch_Min = SrcInputFileData%Ptch_Min
    DstInputFileData%Ptch_Max = SrcInputFileData%Ptch_Max
    DstInputFileData%PtchRate_Min = SrcInputFileData%PtchRate_Min
    DstInputFileData%PtchRate_Max = SrcInputFileData%PtchRate_Max
    DstInputFileData%Gain_OM = SrcInputFileData%Gain_OM
    DstInputFileData%GenSpd_MinOM = SrcInputFileData%GenSpd_MinOM
    DstInputFileData%GenSpd_MaxOM = SrcInputFileData%GenSpd_MaxOM
    DstInputFileData%GenSpd_Dem = SrcInputFileData%GenSpd_Dem
    DstInputFileData%GenTrq_Dem = SrcInputFileData%GenTrq_Dem
    DstInputFileData%GenPwr_Dem = SrcInputFileData%GenPwr_Dem
    DstInputFileData%DLL_NumTrq = SrcInputFileData%DLL_NumTrq
IF (ALLOCATED(SrcInputFileData%GenSpd_TLU)) THEN
  i1_l = LBOUND(SrcInputFileData%GenSpd_TLU,1)
  i1_u = UBOUND(SrcInputFileData%GenSpd_TLU,1)
  IF (.NOT. ALLOCATED(DstInputFileData%GenSpd_TLU)) THEN 
    ALLOCATE(DstInputFileData%GenSpd_TLU(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GenSpd_TLU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%GenSpd_TLU = SrcInputFileData%GenSpd_TLU
ENDIF
IF (ALLOCATED(SrcInputFileData%GenTrq_TLU)) THEN
  i1_l = LBOUND(SrcInputFileData%GenTrq_TLU,1)
  i1_u = UBOUND(SrcInputFileData%GenTrq_TLU,1)
  IF (.NOT. ALLOCATED(DstInputFileData%GenTrq_TLU)) THEN 
    ALLOCATE(DstInputFileData%GenTrq_TLU(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GenTrq_TLU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%GenTrq_TLU = SrcInputFileData%GenTrq_TLU
ENDIF
    DstInputFileData%UseLegacyInterface = SrcInputFileData%UseLegacyInterface
    DstInputFileData%NumBStC = SrcInputFileData%NumBStC
IF (ALLOCATED(SrcInputFileData%BStCfiles)) THEN
  i1_l = LBOUND(SrcInputFileData%BStCfiles,1)
  i1_u = UBOUND(SrcInputFileData%BStCfiles,1)
  IF (.NOT. ALLOCATED(DstInputFileData%BStCfiles)) THEN 
    ALLOCATE(DstInputFileData%BStCfiles(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%BStCfiles.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%BStCfiles = SrcInputFileData%BStCfiles
ENDIF
    DstInputFileData%NumNStC = SrcInputFileData%NumNStC
IF (ALLOCATED(SrcInputFileData%NStCfiles)) THEN
  i1_l = LBOUND(SrcInputFileData%NStCfiles,1)
  i1_u = UBOUND(SrcInputFileData%NStCfiles,1)
  IF (.NOT. ALLOCATED(DstInputFileData%NStCfiles)) THEN 
    ALLOCATE(DstInputFileData%NStCfiles(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%NStCfiles.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%NStCfiles = SrcInputFileData%NStCfiles
ENDIF
    DstInputFileData%NumTStC = SrcInputFileData%NumTStC
IF (ALLOCATED(SrcInputFileData%TStCfiles)) THEN
  i1_l = LBOUND(SrcInputFileData%TStCfiles,1)
  i1_u = UBOUND(SrcInputFileData%TStCfiles,1)
  IF (.NOT. ALLOCATED(DstInputFileData%TStCfiles)) THEN 
    ALLOCATE(DstInputFileData%TStCfiles(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%TStCfiles.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%TStCfiles = SrcInputFileData%TStCfiles
ENDIF
    DstInputFileData%NumSStC = SrcInputFileData%NumSStC
IF (ALLOCATED(SrcInputFileData%SStCfiles)) THEN
  i1_l = LBOUND(SrcInputFileData%SStCfiles,1)
  i1_u = UBOUND(SrcInputFileData%SStCfiles,1)
  IF (.NOT. ALLOCATED(DstInputFileData%SStCfiles)) THEN 
    ALLOCATE(DstInputFileData%SStCfiles(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%SStCfiles.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%SStCfiles = SrcInputFileData%SStCfiles
ENDIF
    DstInputFileData%AfCmode = SrcInputFileData%AfCmode
    DstInputFileData%AfC_Mean = SrcInputFileData%AfC_Mean
    DstInputFileData%AfC_Amp = SrcInputFileData%AfC_Amp
    DstInputFileData%AfC_Phase = SrcInputFileData%AfC_Phase
    DstInputFileData%CCmode = SrcInputFileData%CCmode
    DstInputFileData%EXavrSWAP = SrcInputFileData%EXavrSWAP
 END SUBROUTINE SrvD_CopyInputFile

 SUBROUTINE SrvD_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(SrvD_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
IF (ALLOCATED(InputFileData%GenSpd_TLU)) THEN
  DEALLOCATE(InputFileData%GenSpd_TLU)
ENDIF
IF (ALLOCATED(InputFileData%GenTrq_TLU)) THEN
  DEALLOCATE(InputFileData%GenTrq_TLU)
ENDIF
IF (ALLOCATED(InputFileData%BStCfiles)) THEN
  DEALLOCATE(InputFileData%BStCfiles)
ENDIF
IF (ALLOCATED(InputFileData%NStCfiles)) THEN
  DEALLOCATE(InputFileData%NStCfiles)
ENDIF
IF (ALLOCATED(InputFileData%TStCfiles)) THEN
  DEALLOCATE(InputFileData%TStCfiles)
ENDIF
IF (ALLOCATED(InputFileData%SStCfiles)) THEN
  DEALLOCATE(InputFileData%SStCfiles)
ENDIF
 END SUBROUTINE SrvD_DestroyInputFile


subroutine SrvD_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackInputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCMode
   call RegPack(Buf, InData%PCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPCOn
   call RegPack(Buf, InData%TPCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPitManS
   call RegPack(Buf, InData%TPitManS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PitManRat
   call RegPack(Buf, InData%PitManRat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchF
   call RegPack(Buf, InData%BlPitchF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VSContrl
   call RegPack(Buf, InData%VSContrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenModel
   call RegPack(Buf, InData%GenModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenEff
   call RegPack(Buf, InData%GenEff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStr
   call RegPack(Buf, InData%GenTiStr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStp
   call RegPack(Buf, InData%GenTiStp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdGenOn
   call RegPack(Buf, InData%SpdGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOn
   call RegPack(Buf, InData%TimGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOf
   call RegPack(Buf, InData%TimGenOf)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtGnSp
   call RegPack(Buf, InData%VS_RtGnSp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtTq
   call RegPack(Buf, InData%VS_RtTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_Rgn2K
   call RegPack(Buf, InData%VS_Rgn2K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_SlPc
   call RegPack(Buf, InData%VS_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SlPc
   call RegPack(Buf, InData%SIG_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SySp
   call RegPack(Buf, InData%SIG_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_RtTq
   call RegPack(Buf, InData%SIG_RtTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_PORt
   call RegPack(Buf, InData%SIG_PORt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_Freq
   call RegPack(Buf, InData%TEC_Freq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_NPol
   call RegPack(Buf, InData%TEC_NPol)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SRes
   call RegPack(Buf, InData%TEC_SRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RRes
   call RegPack(Buf, InData%TEC_RRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_VLL
   call RegPack(Buf, InData%TEC_VLL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SLR
   call RegPack(Buf, InData%TEC_SLR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RLR
   call RegPack(Buf, InData%TEC_RLR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_MR
   call RegPack(Buf, InData%TEC_MR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrMode
   call RegPack(Buf, InData%HSSBrMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! THSSBrDp
   call RegPack(Buf, InData%THSSBrDp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrDT
   call RegPack(Buf, InData%HSSBrDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTqF
   call RegPack(Buf, InData%HSSBrTqF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YCMode
   call RegPack(Buf, InData%YCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYCOn
   call RegPack(Buf, InData%TYCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawNeut
   call RegPack(Buf, InData%YawNeut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawSpr
   call RegPack(Buf, InData%YawSpr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawDamp
   call RegPack(Buf, InData%YawDamp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYawManS
   call RegPack(Buf, InData%TYawManS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawManRat
   call RegPack(Buf, InData%YawManRat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYawF
   call RegPack(Buf, InData%NacYawF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegPack(Buf, InData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFile
   call RegPack(Buf, InData%OutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TabDelim
   call RegPack(Buf, InData%TabDelim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tstart
   call RegPack(Buf, InData%Tstart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_FileName
   call RegPack(Buf, InData%DLL_FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_ProcName
   call RegPack(Buf, InData%DLL_ProcName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_InFile
   call RegPack(Buf, InData%DLL_InFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_DT
   call RegPack(Buf, InData%DLL_DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_Ramp
   call RegPack(Buf, InData%DLL_Ramp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BPCutoff
   call RegPack(Buf, InData%BPCutoff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYaw_North
   call RegPack(Buf, InData%NacYaw_North)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Cntrl
   call RegPack(Buf, InData%Ptch_Cntrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_SetPnt
   call RegPack(Buf, InData%Ptch_SetPnt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Min
   call RegPack(Buf, InData%Ptch_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Max
   call RegPack(Buf, InData%Ptch_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Min
   call RegPack(Buf, InData%PtchRate_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Max
   call RegPack(Buf, InData%PtchRate_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gain_OM
   call RegPack(Buf, InData%Gain_OM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MinOM
   call RegPack(Buf, InData%GenSpd_MinOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MaxOM
   call RegPack(Buf, InData%GenSpd_MaxOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_Dem
   call RegPack(Buf, InData%GenSpd_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_Dem
   call RegPack(Buf, InData%GenTrq_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenPwr_Dem
   call RegPack(Buf, InData%GenPwr_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_NumTrq
   call RegPack(Buf, InData%DLL_NumTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_TLU
   call RegPack(Buf, allocated(InData%GenSpd_TLU))
   if (allocated(InData%GenSpd_TLU)) then
      call RegPackBounds(Buf, 1, lbound(InData%GenSpd_TLU), ubound(InData%GenSpd_TLU))
      call RegPack(Buf, InData%GenSpd_TLU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_TLU
   call RegPack(Buf, allocated(InData%GenTrq_TLU))
   if (allocated(InData%GenTrq_TLU)) then
      call RegPackBounds(Buf, 1, lbound(InData%GenTrq_TLU), ubound(InData%GenTrq_TLU))
      call RegPack(Buf, InData%GenTrq_TLU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseLegacyInterface
   call RegPack(Buf, InData%UseLegacyInterface)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBStC
   call RegPack(Buf, InData%NumBStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStCfiles
   call RegPack(Buf, allocated(InData%BStCfiles))
   if (allocated(InData%BStCfiles)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStCfiles), ubound(InData%BStCfiles))
      call RegPack(Buf, InData%BStCfiles)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumNStC
   call RegPack(Buf, InData%NumNStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStCfiles
   call RegPack(Buf, allocated(InData%NStCfiles))
   if (allocated(InData%NStCfiles)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStCfiles), ubound(InData%NStCfiles))
      call RegPack(Buf, InData%NStCfiles)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTStC
   call RegPack(Buf, InData%NumTStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStCfiles
   call RegPack(Buf, allocated(InData%TStCfiles))
   if (allocated(InData%TStCfiles)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStCfiles), ubound(InData%TStCfiles))
      call RegPack(Buf, InData%TStCfiles)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSStC
   call RegPack(Buf, InData%NumSStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStCfiles
   call RegPack(Buf, allocated(InData%SStCfiles))
   if (allocated(InData%SStCfiles)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStCfiles), ubound(InData%SStCfiles))
      call RegPack(Buf, InData%SStCfiles)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfCmode
   call RegPack(Buf, InData%AfCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Mean
   call RegPack(Buf, InData%AfC_Mean)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Amp
   call RegPack(Buf, InData%AfC_Amp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Phase
   call RegPack(Buf, InData%AfC_Phase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CCmode
   call RegPack(Buf, InData%CCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EXavrSWAP
   call RegPack(Buf, InData%EXavrSWAP)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackInputFile'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCMode
   call RegUnpack(Buf, OutData%PCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPCOn
   call RegUnpack(Buf, OutData%TPCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPitManS
   call RegUnpack(Buf, OutData%TPitManS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PitManRat
   call RegUnpack(Buf, OutData%PitManRat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchF
   call RegUnpack(Buf, OutData%BlPitchF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VSContrl
   call RegUnpack(Buf, OutData%VSContrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenModel
   call RegUnpack(Buf, OutData%GenModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenEff
   call RegUnpack(Buf, OutData%GenEff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStr
   call RegUnpack(Buf, OutData%GenTiStr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStp
   call RegUnpack(Buf, OutData%GenTiStp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdGenOn
   call RegUnpack(Buf, OutData%SpdGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOn
   call RegUnpack(Buf, OutData%TimGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOf
   call RegUnpack(Buf, OutData%TimGenOf)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtGnSp
   call RegUnpack(Buf, OutData%VS_RtGnSp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtTq
   call RegUnpack(Buf, OutData%VS_RtTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_Rgn2K
   call RegUnpack(Buf, OutData%VS_Rgn2K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_SlPc
   call RegUnpack(Buf, OutData%VS_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SlPc
   call RegUnpack(Buf, OutData%SIG_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SySp
   call RegUnpack(Buf, OutData%SIG_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_RtTq
   call RegUnpack(Buf, OutData%SIG_RtTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_PORt
   call RegUnpack(Buf, OutData%SIG_PORt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_Freq
   call RegUnpack(Buf, OutData%TEC_Freq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_NPol
   call RegUnpack(Buf, OutData%TEC_NPol)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SRes
   call RegUnpack(Buf, OutData%TEC_SRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RRes
   call RegUnpack(Buf, OutData%TEC_RRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_VLL
   call RegUnpack(Buf, OutData%TEC_VLL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SLR
   call RegUnpack(Buf, OutData%TEC_SLR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RLR
   call RegUnpack(Buf, OutData%TEC_RLR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_MR
   call RegUnpack(Buf, OutData%TEC_MR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrMode
   call RegUnpack(Buf, OutData%HSSBrMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! THSSBrDp
   call RegUnpack(Buf, OutData%THSSBrDp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrDT
   call RegUnpack(Buf, OutData%HSSBrDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTqF
   call RegUnpack(Buf, OutData%HSSBrTqF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YCMode
   call RegUnpack(Buf, OutData%YCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYCOn
   call RegUnpack(Buf, OutData%TYCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawNeut
   call RegUnpack(Buf, OutData%YawNeut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawSpr
   call RegUnpack(Buf, OutData%YawSpr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawDamp
   call RegUnpack(Buf, OutData%YawDamp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYawManS
   call RegUnpack(Buf, OutData%TYawManS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawManRat
   call RegUnpack(Buf, OutData%YawManRat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYawF
   call RegUnpack(Buf, OutData%NacYawF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFile
   call RegUnpack(Buf, OutData%OutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TabDelim
   call RegUnpack(Buf, OutData%TabDelim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tstart
   call RegUnpack(Buf, OutData%Tstart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DLL_FileName
   call RegUnpack(Buf, OutData%DLL_FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_ProcName
   call RegUnpack(Buf, OutData%DLL_ProcName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_InFile
   call RegUnpack(Buf, OutData%DLL_InFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_DT
   call RegUnpack(Buf, OutData%DLL_DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_Ramp
   call RegUnpack(Buf, OutData%DLL_Ramp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BPCutoff
   call RegUnpack(Buf, OutData%BPCutoff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYaw_North
   call RegUnpack(Buf, OutData%NacYaw_North)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Cntrl
   call RegUnpack(Buf, OutData%Ptch_Cntrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_SetPnt
   call RegUnpack(Buf, OutData%Ptch_SetPnt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Min
   call RegUnpack(Buf, OutData%Ptch_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Max
   call RegUnpack(Buf, OutData%Ptch_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Min
   call RegUnpack(Buf, OutData%PtchRate_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Max
   call RegUnpack(Buf, OutData%PtchRate_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gain_OM
   call RegUnpack(Buf, OutData%Gain_OM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MinOM
   call RegUnpack(Buf, OutData%GenSpd_MinOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MaxOM
   call RegUnpack(Buf, OutData%GenSpd_MaxOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_Dem
   call RegUnpack(Buf, OutData%GenSpd_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_Dem
   call RegUnpack(Buf, OutData%GenTrq_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenPwr_Dem
   call RegUnpack(Buf, OutData%GenPwr_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_NumTrq
   call RegUnpack(Buf, OutData%DLL_NumTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_TLU
   if (allocated(OutData%GenSpd_TLU)) deallocate(OutData%GenSpd_TLU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GenSpd_TLU(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GenSpd_TLU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GenSpd_TLU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GenTrq_TLU
   if (allocated(OutData%GenTrq_TLU)) deallocate(OutData%GenTrq_TLU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GenTrq_TLU(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GenTrq_TLU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GenTrq_TLU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UseLegacyInterface
   call RegUnpack(Buf, OutData%UseLegacyInterface)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBStC
   call RegUnpack(Buf, OutData%NumBStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStCfiles
   if (allocated(OutData%BStCfiles)) deallocate(OutData%BStCfiles)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStCfiles(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStCfiles.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BStCfiles)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumNStC
   call RegUnpack(Buf, OutData%NumNStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStCfiles
   if (allocated(OutData%NStCfiles)) deallocate(OutData%NStCfiles)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStCfiles(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStCfiles.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NStCfiles)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumTStC
   call RegUnpack(Buf, OutData%NumTStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStCfiles
   if (allocated(OutData%TStCfiles)) deallocate(OutData%TStCfiles)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStCfiles(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStCfiles.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TStCfiles)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumSStC
   call RegUnpack(Buf, OutData%NumSStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStCfiles
   if (allocated(OutData%SStCfiles)) deallocate(OutData%SStCfiles)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStCfiles(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStCfiles.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SStCfiles)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AfCmode
   call RegUnpack(Buf, OutData%AfCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Mean
   call RegUnpack(Buf, OutData%AfC_Mean)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Amp
   call RegUnpack(Buf, OutData%AfC_Amp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Phase
   call RegUnpack(Buf, OutData%AfC_Phase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CCmode
   call RegUnpack(Buf, OutData%CCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EXavrSWAP
   call RegUnpack(Buf, OutData%EXavrSWAP)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SrvD_CopyBladedDLLType( SrcBladedDLLTypeData, DstBladedDLLTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BladedDLLType), INTENT(IN) :: SrcBladedDLLTypeData
   TYPE(BladedDLLType), INTENT(INOUT) :: DstBladedDLLTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyBladedDLLType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBladedDLLTypeData%avrSWAP)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%avrSWAP,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%avrSWAP,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%avrSWAP)) THEN 
    ALLOCATE(DstBladedDLLTypeData%avrSWAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%avrSWAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%avrSWAP = SrcBladedDLLTypeData%avrSWAP
ENDIF
    DstBladedDLLTypeData%HSSBrTrqDemand = SrcBladedDLLTypeData%HSSBrTrqDemand
    DstBladedDLLTypeData%YawRateCom = SrcBladedDLLTypeData%YawRateCom
    DstBladedDLLTypeData%GenTrq = SrcBladedDLLTypeData%GenTrq
    DstBladedDLLTypeData%GenState = SrcBladedDLLTypeData%GenState
    DstBladedDLLTypeData%BlPitchCom = SrcBladedDLLTypeData%BlPitchCom
    DstBladedDLLTypeData%PrevBlPitch = SrcBladedDLLTypeData%PrevBlPitch
    DstBladedDLLTypeData%BlAirfoilCom = SrcBladedDLLTypeData%BlAirfoilCom
    DstBladedDLLTypeData%PrevBlAirfoilCom = SrcBladedDLLTypeData%PrevBlAirfoilCom
    DstBladedDLLTypeData%ElecPwr_prev = SrcBladedDLLTypeData%ElecPwr_prev
    DstBladedDLLTypeData%GenTrq_prev = SrcBladedDLLTypeData%GenTrq_prev
IF (ALLOCATED(SrcBladedDLLTypeData%toSC)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%toSC,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%toSC,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%toSC)) THEN 
    ALLOCATE(DstBladedDLLTypeData%toSC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%toSC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%toSC = SrcBladedDLLTypeData%toSC
ENDIF
    DstBladedDLLTypeData%initialized = SrcBladedDLLTypeData%initialized
    DstBladedDLLTypeData%NumLogChannels = SrcBladedDLLTypeData%NumLogChannels
IF (ALLOCATED(SrcBladedDLLTypeData%LogChannels_OutParam)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%LogChannels_OutParam,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%LogChannels_OutParam,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%LogChannels_OutParam)) THEN 
    ALLOCATE(DstBladedDLLTypeData%LogChannels_OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%LogChannels_OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcBladedDLLTypeData%LogChannels_OutParam,1), UBOUND(SrcBladedDLLTypeData%LogChannels_OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcBladedDLLTypeData%LogChannels_OutParam(i1), DstBladedDLLTypeData%LogChannels_OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%LogChannels)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%LogChannels,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%LogChannels,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%LogChannels)) THEN 
    ALLOCATE(DstBladedDLLTypeData%LogChannels(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%LogChannels.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%LogChannels = SrcBladedDLLTypeData%LogChannels
ENDIF
    DstBladedDLLTypeData%ErrStat = SrcBladedDLLTypeData%ErrStat
    DstBladedDLLTypeData%ErrMsg = SrcBladedDLLTypeData%ErrMsg
    DstBladedDLLTypeData%CurrentTime = SrcBladedDLLTypeData%CurrentTime
    DstBladedDLLTypeData%SimStatus = SrcBladedDLLTypeData%SimStatus
    DstBladedDLLTypeData%ShaftBrakeStatusBinaryFlag = SrcBladedDLLTypeData%ShaftBrakeStatusBinaryFlag
    DstBladedDLLTypeData%HSSBrDeployed = SrcBladedDLLTypeData%HSSBrDeployed
    DstBladedDLLTypeData%TimeHSSBrFullyDeployed = SrcBladedDLLTypeData%TimeHSSBrFullyDeployed
    DstBladedDLLTypeData%TimeHSSBrDeployed = SrcBladedDLLTypeData%TimeHSSBrDeployed
    DstBladedDLLTypeData%OverrideYawRateWithTorque = SrcBladedDLLTypeData%OverrideYawRateWithTorque
    DstBladedDLLTypeData%YawTorqueDemand = SrcBladedDLLTypeData%YawTorqueDemand
IF (ALLOCATED(SrcBladedDLLTypeData%BlPitchInput)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%BlPitchInput,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%BlPitchInput,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%BlPitchInput)) THEN 
    ALLOCATE(DstBladedDLLTypeData%BlPitchInput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%BlPitchInput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%BlPitchInput = SrcBladedDLLTypeData%BlPitchInput
ENDIF
    DstBladedDLLTypeData%YawAngleFromNorth = SrcBladedDLLTypeData%YawAngleFromNorth
    DstBladedDLLTypeData%HorWindV = SrcBladedDLLTypeData%HorWindV
    DstBladedDLLTypeData%HSS_Spd = SrcBladedDLLTypeData%HSS_Spd
    DstBladedDLLTypeData%YawErr = SrcBladedDLLTypeData%YawErr
    DstBladedDLLTypeData%RotSpeed = SrcBladedDLLTypeData%RotSpeed
    DstBladedDLLTypeData%YawBrTAxp = SrcBladedDLLTypeData%YawBrTAxp
    DstBladedDLLTypeData%YawBrTAyp = SrcBladedDLLTypeData%YawBrTAyp
    DstBladedDLLTypeData%LSSTipMys = SrcBladedDLLTypeData%LSSTipMys
    DstBladedDLLTypeData%LSSTipMzs = SrcBladedDLLTypeData%LSSTipMzs
    DstBladedDLLTypeData%LSSTipMya = SrcBladedDLLTypeData%LSSTipMya
    DstBladedDLLTypeData%LSSTipMza = SrcBladedDLLTypeData%LSSTipMza
    DstBladedDLLTypeData%LSSTipPxa = SrcBladedDLLTypeData%LSSTipPxa
    DstBladedDLLTypeData%Yaw = SrcBladedDLLTypeData%Yaw
    DstBladedDLLTypeData%YawRate = SrcBladedDLLTypeData%YawRate
    DstBladedDLLTypeData%YawBrMyn = SrcBladedDLLTypeData%YawBrMyn
    DstBladedDLLTypeData%YawBrMzn = SrcBladedDLLTypeData%YawBrMzn
    DstBladedDLLTypeData%NcIMURAxs = SrcBladedDLLTypeData%NcIMURAxs
    DstBladedDLLTypeData%NcIMURAys = SrcBladedDLLTypeData%NcIMURAys
    DstBladedDLLTypeData%NcIMURAzs = SrcBladedDLLTypeData%NcIMURAzs
    DstBladedDLLTypeData%RotPwr = SrcBladedDLLTypeData%RotPwr
    DstBladedDLLTypeData%LSSTipMxa = SrcBladedDLLTypeData%LSSTipMxa
    DstBladedDLLTypeData%RootMyc = SrcBladedDLLTypeData%RootMyc
    DstBladedDLLTypeData%RootMxc = SrcBladedDLLTypeData%RootMxc
    DstBladedDLLTypeData%LSShftFxa = SrcBladedDLLTypeData%LSShftFxa
    DstBladedDLLTypeData%LSShftFys = SrcBladedDLLTypeData%LSShftFys
    DstBladedDLLTypeData%LSShftFzs = SrcBladedDLLTypeData%LSShftFzs
IF (ALLOCATED(SrcBladedDLLTypeData%LidSpeed)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%LidSpeed,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%LidSpeed,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%LidSpeed)) THEN 
    ALLOCATE(DstBladedDLLTypeData%LidSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%LidSpeed.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%LidSpeed = SrcBladedDLLTypeData%LidSpeed
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%MsrPositionsX)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%MsrPositionsX,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%MsrPositionsX,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%MsrPositionsX)) THEN 
    ALLOCATE(DstBladedDLLTypeData%MsrPositionsX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%MsrPositionsX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%MsrPositionsX = SrcBladedDLLTypeData%MsrPositionsX
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%MsrPositionsY)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%MsrPositionsY,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%MsrPositionsY,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%MsrPositionsY)) THEN 
    ALLOCATE(DstBladedDLLTypeData%MsrPositionsY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%MsrPositionsY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%MsrPositionsY = SrcBladedDLLTypeData%MsrPositionsY
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%MsrPositionsZ)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%MsrPositionsZ,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%MsrPositionsZ,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%MsrPositionsZ)) THEN 
    ALLOCATE(DstBladedDLLTypeData%MsrPositionsZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%MsrPositionsZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%MsrPositionsZ = SrcBladedDLLTypeData%MsrPositionsZ
ENDIF
    DstBladedDLLTypeData%SensorType = SrcBladedDLLTypeData%SensorType
    DstBladedDLLTypeData%NumBeam = SrcBladedDLLTypeData%NumBeam
    DstBladedDLLTypeData%NumPulseGate = SrcBladedDLLTypeData%NumPulseGate
    DstBladedDLLTypeData%PulseSpacing = SrcBladedDLLTypeData%PulseSpacing
    DstBladedDLLTypeData%URefLid = SrcBladedDLLTypeData%URefLid
    DstBladedDLLTypeData%DLL_DT = SrcBladedDLLTypeData%DLL_DT
    DstBladedDLLTypeData%DLL_InFile = SrcBladedDLLTypeData%DLL_InFile
    DstBladedDLLTypeData%RootName = SrcBladedDLLTypeData%RootName
    DstBladedDLLTypeData%GenTrq_Dem = SrcBladedDLLTypeData%GenTrq_Dem
    DstBladedDLLTypeData%GenSpd_Dem = SrcBladedDLLTypeData%GenSpd_Dem
    DstBladedDLLTypeData%Ptch_Max = SrcBladedDLLTypeData%Ptch_Max
    DstBladedDLLTypeData%Ptch_Min = SrcBladedDLLTypeData%Ptch_Min
    DstBladedDLLTypeData%Ptch_SetPnt = SrcBladedDLLTypeData%Ptch_SetPnt
    DstBladedDLLTypeData%PtchRate_Max = SrcBladedDLLTypeData%PtchRate_Max
    DstBladedDLLTypeData%PtchRate_Min = SrcBladedDLLTypeData%PtchRate_Min
    DstBladedDLLTypeData%GenPwr_Dem = SrcBladedDLLTypeData%GenPwr_Dem
    DstBladedDLLTypeData%Gain_OM = SrcBladedDLLTypeData%Gain_OM
    DstBladedDLLTypeData%GenSpd_MaxOM = SrcBladedDLLTypeData%GenSpd_MaxOM
    DstBladedDLLTypeData%GenSpd_MinOM = SrcBladedDLLTypeData%GenSpd_MinOM
    DstBladedDLLTypeData%Ptch_Cntrl = SrcBladedDLLTypeData%Ptch_Cntrl
    DstBladedDLLTypeData%DLL_NumTrq = SrcBladedDLLTypeData%DLL_NumTrq
IF (ALLOCATED(SrcBladedDLLTypeData%GenSpd_TLU)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%GenSpd_TLU,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%GenSpd_TLU,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%GenSpd_TLU)) THEN 
    ALLOCATE(DstBladedDLLTypeData%GenSpd_TLU(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%GenSpd_TLU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%GenSpd_TLU = SrcBladedDLLTypeData%GenSpd_TLU
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%GenTrq_TLU)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%GenTrq_TLU,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%GenTrq_TLU,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%GenTrq_TLU)) THEN 
    ALLOCATE(DstBladedDLLTypeData%GenTrq_TLU(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%GenTrq_TLU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%GenTrq_TLU = SrcBladedDLLTypeData%GenTrq_TLU
ENDIF
    DstBladedDLLTypeData%Yaw_Cntrl = SrcBladedDLLTypeData%Yaw_Cntrl
IF (ALLOCATED(SrcBladedDLLTypeData%PrevCableDeltaL)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%PrevCableDeltaL,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%PrevCableDeltaL,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%PrevCableDeltaL)) THEN 
    ALLOCATE(DstBladedDLLTypeData%PrevCableDeltaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%PrevCableDeltaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%PrevCableDeltaL = SrcBladedDLLTypeData%PrevCableDeltaL
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%PrevCableDeltaLdot)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%PrevCableDeltaLdot,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%PrevCableDeltaLdot,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%PrevCableDeltaLdot)) THEN 
    ALLOCATE(DstBladedDLLTypeData%PrevCableDeltaLdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%PrevCableDeltaLdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%PrevCableDeltaLdot = SrcBladedDLLTypeData%PrevCableDeltaLdot
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%CableDeltaL)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%CableDeltaL,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%CableDeltaL,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%CableDeltaL)) THEN 
    ALLOCATE(DstBladedDLLTypeData%CableDeltaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%CableDeltaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%CableDeltaL = SrcBladedDLLTypeData%CableDeltaL
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%CableDeltaLdot)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%CableDeltaLdot,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%CableDeltaLdot,1)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%CableDeltaLdot)) THEN 
    ALLOCATE(DstBladedDLLTypeData%CableDeltaLdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%CableDeltaLdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%CableDeltaLdot = SrcBladedDLLTypeData%CableDeltaLdot
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%PrevStCCmdStiff)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdStiff,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdStiff,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdStiff,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdStiff,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%PrevStCCmdStiff)) THEN 
    ALLOCATE(DstBladedDLLTypeData%PrevStCCmdStiff(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%PrevStCCmdStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%PrevStCCmdStiff = SrcBladedDLLTypeData%PrevStCCmdStiff
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%PrevStCCmdDamp)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdDamp,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdDamp,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdDamp,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdDamp,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%PrevStCCmdDamp)) THEN 
    ALLOCATE(DstBladedDLLTypeData%PrevStCCmdDamp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%PrevStCCmdDamp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%PrevStCCmdDamp = SrcBladedDLLTypeData%PrevStCCmdDamp
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%PrevStCCmdBrake)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdBrake,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdBrake,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdBrake,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdBrake,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%PrevStCCmdBrake)) THEN 
    ALLOCATE(DstBladedDLLTypeData%PrevStCCmdBrake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%PrevStCCmdBrake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%PrevStCCmdBrake = SrcBladedDLLTypeData%PrevStCCmdBrake
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%PrevStCCmdForce)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdForce,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdForce,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%PrevStCCmdForce,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%PrevStCCmdForce,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%PrevStCCmdForce)) THEN 
    ALLOCATE(DstBladedDLLTypeData%PrevStCCmdForce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%PrevStCCmdForce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%PrevStCCmdForce = SrcBladedDLLTypeData%PrevStCCmdForce
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%StCCmdStiff)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%StCCmdStiff,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%StCCmdStiff,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%StCCmdStiff,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%StCCmdStiff,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%StCCmdStiff)) THEN 
    ALLOCATE(DstBladedDLLTypeData%StCCmdStiff(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%StCCmdStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%StCCmdStiff = SrcBladedDLLTypeData%StCCmdStiff
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%StCCmdDamp)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%StCCmdDamp,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%StCCmdDamp,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%StCCmdDamp,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%StCCmdDamp,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%StCCmdDamp)) THEN 
    ALLOCATE(DstBladedDLLTypeData%StCCmdDamp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%StCCmdDamp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%StCCmdDamp = SrcBladedDLLTypeData%StCCmdDamp
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%StCCmdBrake)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%StCCmdBrake,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%StCCmdBrake,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%StCCmdBrake,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%StCCmdBrake,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%StCCmdBrake)) THEN 
    ALLOCATE(DstBladedDLLTypeData%StCCmdBrake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%StCCmdBrake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%StCCmdBrake = SrcBladedDLLTypeData%StCCmdBrake
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%StCCmdForce)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%StCCmdForce,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%StCCmdForce,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%StCCmdForce,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%StCCmdForce,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%StCCmdForce)) THEN 
    ALLOCATE(DstBladedDLLTypeData%StCCmdForce(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%StCCmdForce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%StCCmdForce = SrcBladedDLLTypeData%StCCmdForce
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%StCMeasDisp)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%StCMeasDisp,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%StCMeasDisp,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%StCMeasDisp,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%StCMeasDisp,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%StCMeasDisp)) THEN 
    ALLOCATE(DstBladedDLLTypeData%StCMeasDisp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%StCMeasDisp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%StCMeasDisp = SrcBladedDLLTypeData%StCMeasDisp
ENDIF
IF (ALLOCATED(SrcBladedDLLTypeData%StCMeasVel)) THEN
  i1_l = LBOUND(SrcBladedDLLTypeData%StCMeasVel,1)
  i1_u = UBOUND(SrcBladedDLLTypeData%StCMeasVel,1)
  i2_l = LBOUND(SrcBladedDLLTypeData%StCMeasVel,2)
  i2_u = UBOUND(SrcBladedDLLTypeData%StCMeasVel,2)
  IF (.NOT. ALLOCATED(DstBladedDLLTypeData%StCMeasVel)) THEN 
    ALLOCATE(DstBladedDLLTypeData%StCMeasVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladedDLLTypeData%StCMeasVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladedDLLTypeData%StCMeasVel = SrcBladedDLLTypeData%StCMeasVel
ENDIF
 END SUBROUTINE SrvD_CopyBladedDLLType

 SUBROUTINE SrvD_DestroyBladedDLLType( BladedDLLTypeData, ErrStat, ErrMsg )
  TYPE(BladedDLLType), INTENT(INOUT) :: BladedDLLTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyBladedDLLType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(BladedDLLTypeData%avrSWAP)) THEN
  DEALLOCATE(BladedDLLTypeData%avrSWAP)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%toSC)) THEN
  DEALLOCATE(BladedDLLTypeData%toSC)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%LogChannels_OutParam)) THEN
DO i1 = LBOUND(BladedDLLTypeData%LogChannels_OutParam,1), UBOUND(BladedDLLTypeData%LogChannels_OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( BladedDLLTypeData%LogChannels_OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(BladedDLLTypeData%LogChannels_OutParam)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%LogChannels)) THEN
  DEALLOCATE(BladedDLLTypeData%LogChannels)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%BlPitchInput)) THEN
  DEALLOCATE(BladedDLLTypeData%BlPitchInput)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%LidSpeed)) THEN
  DEALLOCATE(BladedDLLTypeData%LidSpeed)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%MsrPositionsX)) THEN
  DEALLOCATE(BladedDLLTypeData%MsrPositionsX)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%MsrPositionsY)) THEN
  DEALLOCATE(BladedDLLTypeData%MsrPositionsY)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%MsrPositionsZ)) THEN
  DEALLOCATE(BladedDLLTypeData%MsrPositionsZ)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%GenSpd_TLU)) THEN
  DEALLOCATE(BladedDLLTypeData%GenSpd_TLU)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%GenTrq_TLU)) THEN
  DEALLOCATE(BladedDLLTypeData%GenTrq_TLU)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%PrevCableDeltaL)) THEN
  DEALLOCATE(BladedDLLTypeData%PrevCableDeltaL)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%PrevCableDeltaLdot)) THEN
  DEALLOCATE(BladedDLLTypeData%PrevCableDeltaLdot)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%CableDeltaL)) THEN
  DEALLOCATE(BladedDLLTypeData%CableDeltaL)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%CableDeltaLdot)) THEN
  DEALLOCATE(BladedDLLTypeData%CableDeltaLdot)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%PrevStCCmdStiff)) THEN
  DEALLOCATE(BladedDLLTypeData%PrevStCCmdStiff)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%PrevStCCmdDamp)) THEN
  DEALLOCATE(BladedDLLTypeData%PrevStCCmdDamp)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%PrevStCCmdBrake)) THEN
  DEALLOCATE(BladedDLLTypeData%PrevStCCmdBrake)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%PrevStCCmdForce)) THEN
  DEALLOCATE(BladedDLLTypeData%PrevStCCmdForce)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%StCCmdStiff)) THEN
  DEALLOCATE(BladedDLLTypeData%StCCmdStiff)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%StCCmdDamp)) THEN
  DEALLOCATE(BladedDLLTypeData%StCCmdDamp)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%StCCmdBrake)) THEN
  DEALLOCATE(BladedDLLTypeData%StCCmdBrake)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%StCCmdForce)) THEN
  DEALLOCATE(BladedDLLTypeData%StCCmdForce)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%StCMeasDisp)) THEN
  DEALLOCATE(BladedDLLTypeData%StCMeasDisp)
ENDIF
IF (ALLOCATED(BladedDLLTypeData%StCMeasVel)) THEN
  DEALLOCATE(BladedDLLTypeData%StCMeasVel)
ENDIF
 END SUBROUTINE SrvD_DestroyBladedDLLType


subroutine SrvD_PackBladedDLLType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BladedDLLType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackBladedDLLType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! avrSWAP
   call RegPack(Buf, allocated(InData%avrSWAP))
   if (allocated(InData%avrSWAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%avrSWAP), ubound(InData%avrSWAP))
      call RegPack(Buf, InData%avrSWAP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTrqDemand
   call RegPack(Buf, InData%HSSBrTrqDemand)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRateCom
   call RegPack(Buf, InData%YawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq
   call RegPack(Buf, InData%GenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenState
   call RegPack(Buf, InData%GenState)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchCom
   call RegPack(Buf, InData%BlPitchCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevBlPitch
   call RegPack(Buf, InData%PrevBlPitch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAirfoilCom
   call RegPack(Buf, InData%BlAirfoilCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevBlAirfoilCom
   call RegPack(Buf, InData%PrevBlAirfoilCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElecPwr_prev
   call RegPack(Buf, InData%ElecPwr_prev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_prev
   call RegPack(Buf, InData%GenTrq_prev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! toSC
   call RegPack(Buf, allocated(InData%toSC))
   if (allocated(InData%toSC)) then
      call RegPackBounds(Buf, 1, lbound(InData%toSC), ubound(InData%toSC))
      call RegPack(Buf, InData%toSC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! initialized
   call RegPack(Buf, InData%initialized)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumLogChannels
   call RegPack(Buf, InData%NumLogChannels)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LogChannels_OutParam
   call RegPack(Buf, allocated(InData%LogChannels_OutParam))
   if (allocated(InData%LogChannels_OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%LogChannels_OutParam), ubound(InData%LogChannels_OutParam))
      LB(1:1) = lbound(InData%LogChannels_OutParam)
      UB(1:1) = ubound(InData%LogChannels_OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%LogChannels_OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LogChannels
   call RegPack(Buf, allocated(InData%LogChannels))
   if (allocated(InData%LogChannels)) then
      call RegPackBounds(Buf, 1, lbound(InData%LogChannels), ubound(InData%LogChannels))
      call RegPack(Buf, InData%LogChannels)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ErrStat
   call RegPack(Buf, InData%ErrStat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ErrMsg
   call RegPack(Buf, InData%ErrMsg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CurrentTime
   call RegPack(Buf, InData%CurrentTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SimStatus
   call RegPack(Buf, InData%SimStatus)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShaftBrakeStatusBinaryFlag
   call RegPack(Buf, InData%ShaftBrakeStatusBinaryFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrDeployed
   call RegPack(Buf, InData%HSSBrDeployed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeHSSBrFullyDeployed
   call RegPack(Buf, InData%TimeHSSBrFullyDeployed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeHSSBrDeployed
   call RegPack(Buf, InData%TimeHSSBrDeployed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OverrideYawRateWithTorque
   call RegPack(Buf, InData%OverrideYawRateWithTorque)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawTorqueDemand
   call RegPack(Buf, InData%YawTorqueDemand)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchInput
   call RegPack(Buf, allocated(InData%BlPitchInput))
   if (allocated(InData%BlPitchInput)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitchInput), ubound(InData%BlPitchInput))
      call RegPack(Buf, InData%BlPitchInput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawAngleFromNorth
   call RegPack(Buf, InData%YawAngleFromNorth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HorWindV
   call RegPack(Buf, InData%HorWindV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSS_Spd
   call RegPack(Buf, InData%HSS_Spd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr
   call RegPack(Buf, InData%YawErr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeed
   call RegPack(Buf, InData%RotSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAxp
   call RegPack(Buf, InData%YawBrTAxp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAyp
   call RegPack(Buf, InData%YawBrTAyp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMys
   call RegPack(Buf, InData%LSSTipMys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMzs
   call RegPack(Buf, InData%LSSTipMzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMya
   call RegPack(Buf, InData%LSSTipMya)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMza
   call RegPack(Buf, InData%LSSTipMza)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipPxa
   call RegPack(Buf, InData%LSSTipPxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Yaw
   call RegPack(Buf, InData%Yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRate
   call RegPack(Buf, InData%YawRate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMyn
   call RegPack(Buf, InData%YawBrMyn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMzn
   call RegPack(Buf, InData%YawBrMzn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAxs
   call RegPack(Buf, InData%NcIMURAxs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAys
   call RegPack(Buf, InData%NcIMURAys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAzs
   call RegPack(Buf, InData%NcIMURAzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotPwr
   call RegPack(Buf, InData%RotPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMxa
   call RegPack(Buf, InData%LSSTipMxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMyc
   call RegPack(Buf, InData%RootMyc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMxc
   call RegPack(Buf, InData%RootMxc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFxa
   call RegPack(Buf, InData%LSShftFxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFys
   call RegPack(Buf, InData%LSShftFys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFzs
   call RegPack(Buf, InData%LSShftFzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidSpeed
   call RegPack(Buf, allocated(InData%LidSpeed))
   if (allocated(InData%LidSpeed)) then
      call RegPackBounds(Buf, 1, lbound(InData%LidSpeed), ubound(InData%LidSpeed))
      call RegPack(Buf, InData%LidSpeed)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsX
   call RegPack(Buf, allocated(InData%MsrPositionsX))
   if (allocated(InData%MsrPositionsX)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsX), ubound(InData%MsrPositionsX))
      call RegPack(Buf, InData%MsrPositionsX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsY
   call RegPack(Buf, allocated(InData%MsrPositionsY))
   if (allocated(InData%MsrPositionsY)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsY), ubound(InData%MsrPositionsY))
      call RegPack(Buf, InData%MsrPositionsY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsZ
   call RegPack(Buf, allocated(InData%MsrPositionsZ))
   if (allocated(InData%MsrPositionsZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsZ), ubound(InData%MsrPositionsZ))
      call RegPack(Buf, InData%MsrPositionsZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegPack(Buf, InData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegPack(Buf, InData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegPack(Buf, InData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegPack(Buf, InData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegPack(Buf, InData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_DT
   call RegPack(Buf, InData%DLL_DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_InFile
   call RegPack(Buf, InData%DLL_InFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_Dem
   call RegPack(Buf, InData%GenTrq_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_Dem
   call RegPack(Buf, InData%GenSpd_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Max
   call RegPack(Buf, InData%Ptch_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Min
   call RegPack(Buf, InData%Ptch_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_SetPnt
   call RegPack(Buf, InData%Ptch_SetPnt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Max
   call RegPack(Buf, InData%PtchRate_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Min
   call RegPack(Buf, InData%PtchRate_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenPwr_Dem
   call RegPack(Buf, InData%GenPwr_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gain_OM
   call RegPack(Buf, InData%Gain_OM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MaxOM
   call RegPack(Buf, InData%GenSpd_MaxOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MinOM
   call RegPack(Buf, InData%GenSpd_MinOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Cntrl
   call RegPack(Buf, InData%Ptch_Cntrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_NumTrq
   call RegPack(Buf, InData%DLL_NumTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_TLU
   call RegPack(Buf, allocated(InData%GenSpd_TLU))
   if (allocated(InData%GenSpd_TLU)) then
      call RegPackBounds(Buf, 1, lbound(InData%GenSpd_TLU), ubound(InData%GenSpd_TLU))
      call RegPack(Buf, InData%GenSpd_TLU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_TLU
   call RegPack(Buf, allocated(InData%GenTrq_TLU))
   if (allocated(InData%GenTrq_TLU)) then
      call RegPackBounds(Buf, 1, lbound(InData%GenTrq_TLU), ubound(InData%GenTrq_TLU))
      call RegPack(Buf, InData%GenTrq_TLU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Yaw_Cntrl
   call RegPack(Buf, InData%Yaw_Cntrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevCableDeltaL
   call RegPack(Buf, allocated(InData%PrevCableDeltaL))
   if (allocated(InData%PrevCableDeltaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%PrevCableDeltaL), ubound(InData%PrevCableDeltaL))
      call RegPack(Buf, InData%PrevCableDeltaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevCableDeltaLdot
   call RegPack(Buf, allocated(InData%PrevCableDeltaLdot))
   if (allocated(InData%PrevCableDeltaLdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%PrevCableDeltaLdot), ubound(InData%PrevCableDeltaLdot))
      call RegPack(Buf, InData%PrevCableDeltaLdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaL
   call RegPack(Buf, allocated(InData%CableDeltaL))
   if (allocated(InData%CableDeltaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableDeltaL), ubound(InData%CableDeltaL))
      call RegPack(Buf, InData%CableDeltaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaLdot
   call RegPack(Buf, allocated(InData%CableDeltaLdot))
   if (allocated(InData%CableDeltaLdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableDeltaLdot), ubound(InData%CableDeltaLdot))
      call RegPack(Buf, InData%CableDeltaLdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevStCCmdStiff
   call RegPack(Buf, allocated(InData%PrevStCCmdStiff))
   if (allocated(InData%PrevStCCmdStiff)) then
      call RegPackBounds(Buf, 2, lbound(InData%PrevStCCmdStiff), ubound(InData%PrevStCCmdStiff))
      call RegPack(Buf, InData%PrevStCCmdStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevStCCmdDamp
   call RegPack(Buf, allocated(InData%PrevStCCmdDamp))
   if (allocated(InData%PrevStCCmdDamp)) then
      call RegPackBounds(Buf, 2, lbound(InData%PrevStCCmdDamp), ubound(InData%PrevStCCmdDamp))
      call RegPack(Buf, InData%PrevStCCmdDamp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevStCCmdBrake
   call RegPack(Buf, allocated(InData%PrevStCCmdBrake))
   if (allocated(InData%PrevStCCmdBrake)) then
      call RegPackBounds(Buf, 2, lbound(InData%PrevStCCmdBrake), ubound(InData%PrevStCCmdBrake))
      call RegPack(Buf, InData%PrevStCCmdBrake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevStCCmdForce
   call RegPack(Buf, allocated(InData%PrevStCCmdForce))
   if (allocated(InData%PrevStCCmdForce)) then
      call RegPackBounds(Buf, 2, lbound(InData%PrevStCCmdForce), ubound(InData%PrevStCCmdForce))
      call RegPack(Buf, InData%PrevStCCmdForce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCCmdStiff
   call RegPack(Buf, allocated(InData%StCCmdStiff))
   if (allocated(InData%StCCmdStiff)) then
      call RegPackBounds(Buf, 2, lbound(InData%StCCmdStiff), ubound(InData%StCCmdStiff))
      call RegPack(Buf, InData%StCCmdStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCCmdDamp
   call RegPack(Buf, allocated(InData%StCCmdDamp))
   if (allocated(InData%StCCmdDamp)) then
      call RegPackBounds(Buf, 2, lbound(InData%StCCmdDamp), ubound(InData%StCCmdDamp))
      call RegPack(Buf, InData%StCCmdDamp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCCmdBrake
   call RegPack(Buf, allocated(InData%StCCmdBrake))
   if (allocated(InData%StCCmdBrake)) then
      call RegPackBounds(Buf, 2, lbound(InData%StCCmdBrake), ubound(InData%StCCmdBrake))
      call RegPack(Buf, InData%StCCmdBrake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCCmdForce
   call RegPack(Buf, allocated(InData%StCCmdForce))
   if (allocated(InData%StCCmdForce)) then
      call RegPackBounds(Buf, 2, lbound(InData%StCCmdForce), ubound(InData%StCCmdForce))
      call RegPack(Buf, InData%StCCmdForce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCMeasDisp
   call RegPack(Buf, allocated(InData%StCMeasDisp))
   if (allocated(InData%StCMeasDisp)) then
      call RegPackBounds(Buf, 2, lbound(InData%StCMeasDisp), ubound(InData%StCMeasDisp))
      call RegPack(Buf, InData%StCMeasDisp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCMeasVel
   call RegPack(Buf, allocated(InData%StCMeasVel))
   if (allocated(InData%StCMeasVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%StCMeasVel), ubound(InData%StCMeasVel))
      call RegPack(Buf, InData%StCMeasVel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackBladedDLLType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BladedDLLType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackBladedDLLType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! avrSWAP
   if (allocated(OutData%avrSWAP)) deallocate(OutData%avrSWAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%avrSWAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%avrSWAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%avrSWAP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HSSBrTrqDemand
   call RegUnpack(Buf, OutData%HSSBrTrqDemand)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRateCom
   call RegUnpack(Buf, OutData%YawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq
   call RegUnpack(Buf, OutData%GenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenState
   call RegUnpack(Buf, OutData%GenState)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchCom
   call RegUnpack(Buf, OutData%BlPitchCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevBlPitch
   call RegUnpack(Buf, OutData%PrevBlPitch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAirfoilCom
   call RegUnpack(Buf, OutData%BlAirfoilCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevBlAirfoilCom
   call RegUnpack(Buf, OutData%PrevBlAirfoilCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElecPwr_prev
   call RegUnpack(Buf, OutData%ElecPwr_prev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_prev
   call RegUnpack(Buf, OutData%GenTrq_prev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! toSC
   if (allocated(OutData%toSC)) deallocate(OutData%toSC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%toSC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%toSC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%toSC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! initialized
   call RegUnpack(Buf, OutData%initialized)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumLogChannels
   call RegUnpack(Buf, OutData%NumLogChannels)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LogChannels_OutParam
   if (allocated(OutData%LogChannels_OutParam)) deallocate(OutData%LogChannels_OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LogChannels_OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LogChannels_OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%LogChannels_OutParam(i1)) ! LogChannels_OutParam 
      end do
   end if
   ! LogChannels
   if (allocated(OutData%LogChannels)) deallocate(OutData%LogChannels)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LogChannels(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LogChannels.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LogChannels)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ErrStat
   call RegUnpack(Buf, OutData%ErrStat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ErrMsg
   call RegUnpack(Buf, OutData%ErrMsg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CurrentTime
   call RegUnpack(Buf, OutData%CurrentTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SimStatus
   call RegUnpack(Buf, OutData%SimStatus)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShaftBrakeStatusBinaryFlag
   call RegUnpack(Buf, OutData%ShaftBrakeStatusBinaryFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrDeployed
   call RegUnpack(Buf, OutData%HSSBrDeployed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeHSSBrFullyDeployed
   call RegUnpack(Buf, OutData%TimeHSSBrFullyDeployed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeHSSBrDeployed
   call RegUnpack(Buf, OutData%TimeHSSBrDeployed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OverrideYawRateWithTorque
   call RegUnpack(Buf, OutData%OverrideYawRateWithTorque)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawTorqueDemand
   call RegUnpack(Buf, OutData%YawTorqueDemand)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchInput
   if (allocated(OutData%BlPitchInput)) deallocate(OutData%BlPitchInput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitchInput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitchInput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitchInput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! YawAngleFromNorth
   call RegUnpack(Buf, OutData%YawAngleFromNorth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HorWindV
   call RegUnpack(Buf, OutData%HorWindV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSS_Spd
   call RegUnpack(Buf, OutData%HSS_Spd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr
   call RegUnpack(Buf, OutData%YawErr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeed
   call RegUnpack(Buf, OutData%RotSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAxp
   call RegUnpack(Buf, OutData%YawBrTAxp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAyp
   call RegUnpack(Buf, OutData%YawBrTAyp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMys
   call RegUnpack(Buf, OutData%LSSTipMys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMzs
   call RegUnpack(Buf, OutData%LSSTipMzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMya
   call RegUnpack(Buf, OutData%LSSTipMya)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMza
   call RegUnpack(Buf, OutData%LSSTipMza)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipPxa
   call RegUnpack(Buf, OutData%LSSTipPxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Yaw
   call RegUnpack(Buf, OutData%Yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRate
   call RegUnpack(Buf, OutData%YawRate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMyn
   call RegUnpack(Buf, OutData%YawBrMyn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMzn
   call RegUnpack(Buf, OutData%YawBrMzn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAxs
   call RegUnpack(Buf, OutData%NcIMURAxs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAys
   call RegUnpack(Buf, OutData%NcIMURAys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAzs
   call RegUnpack(Buf, OutData%NcIMURAzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotPwr
   call RegUnpack(Buf, OutData%RotPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMxa
   call RegUnpack(Buf, OutData%LSSTipMxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMyc
   call RegUnpack(Buf, OutData%RootMyc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMxc
   call RegUnpack(Buf, OutData%RootMxc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFxa
   call RegUnpack(Buf, OutData%LSShftFxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFys
   call RegUnpack(Buf, OutData%LSShftFys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFzs
   call RegUnpack(Buf, OutData%LSShftFzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidSpeed
   if (allocated(OutData%LidSpeed)) deallocate(OutData%LidSpeed)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LidSpeed(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LidSpeed.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LidSpeed)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsX
   if (allocated(OutData%MsrPositionsX)) deallocate(OutData%MsrPositionsX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsY
   if (allocated(OutData%MsrPositionsY)) deallocate(OutData%MsrPositionsY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsZ
   if (allocated(OutData%MsrPositionsZ)) deallocate(OutData%MsrPositionsZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SensorType
   call RegUnpack(Buf, OutData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegUnpack(Buf, OutData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegUnpack(Buf, OutData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegUnpack(Buf, OutData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegUnpack(Buf, OutData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_DT
   call RegUnpack(Buf, OutData%DLL_DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_InFile
   call RegUnpack(Buf, OutData%DLL_InFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq_Dem
   call RegUnpack(Buf, OutData%GenTrq_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_Dem
   call RegUnpack(Buf, OutData%GenSpd_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Max
   call RegUnpack(Buf, OutData%Ptch_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Min
   call RegUnpack(Buf, OutData%Ptch_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_SetPnt
   call RegUnpack(Buf, OutData%Ptch_SetPnt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Max
   call RegUnpack(Buf, OutData%PtchRate_Max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtchRate_Min
   call RegUnpack(Buf, OutData%PtchRate_Min)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenPwr_Dem
   call RegUnpack(Buf, OutData%GenPwr_Dem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gain_OM
   call RegUnpack(Buf, OutData%Gain_OM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MaxOM
   call RegUnpack(Buf, OutData%GenSpd_MaxOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_MinOM
   call RegUnpack(Buf, OutData%GenSpd_MinOM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ptch_Cntrl
   call RegUnpack(Buf, OutData%Ptch_Cntrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_NumTrq
   call RegUnpack(Buf, OutData%DLL_NumTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenSpd_TLU
   if (allocated(OutData%GenSpd_TLU)) deallocate(OutData%GenSpd_TLU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GenSpd_TLU(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GenSpd_TLU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GenSpd_TLU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GenTrq_TLU
   if (allocated(OutData%GenTrq_TLU)) deallocate(OutData%GenTrq_TLU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GenTrq_TLU(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GenTrq_TLU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GenTrq_TLU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Yaw_Cntrl
   call RegUnpack(Buf, OutData%Yaw_Cntrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevCableDeltaL
   if (allocated(OutData%PrevCableDeltaL)) deallocate(OutData%PrevCableDeltaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrevCableDeltaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrevCableDeltaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrevCableDeltaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrevCableDeltaLdot
   if (allocated(OutData%PrevCableDeltaLdot)) deallocate(OutData%PrevCableDeltaLdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrevCableDeltaLdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrevCableDeltaLdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrevCableDeltaLdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CableDeltaL
   if (allocated(OutData%CableDeltaL)) deallocate(OutData%CableDeltaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableDeltaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableDeltaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableDeltaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CableDeltaLdot
   if (allocated(OutData%CableDeltaLdot)) deallocate(OutData%CableDeltaLdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableDeltaLdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableDeltaLdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableDeltaLdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrevStCCmdStiff
   if (allocated(OutData%PrevStCCmdStiff)) deallocate(OutData%PrevStCCmdStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrevStCCmdStiff(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrevStCCmdStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrevStCCmdStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrevStCCmdDamp
   if (allocated(OutData%PrevStCCmdDamp)) deallocate(OutData%PrevStCCmdDamp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrevStCCmdDamp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrevStCCmdDamp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrevStCCmdDamp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrevStCCmdBrake
   if (allocated(OutData%PrevStCCmdBrake)) deallocate(OutData%PrevStCCmdBrake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrevStCCmdBrake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrevStCCmdBrake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrevStCCmdBrake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PrevStCCmdForce
   if (allocated(OutData%PrevStCCmdForce)) deallocate(OutData%PrevStCCmdForce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrevStCCmdForce(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrevStCCmdForce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrevStCCmdForce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StCCmdStiff
   if (allocated(OutData%StCCmdStiff)) deallocate(OutData%StCCmdStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCCmdStiff(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCCmdStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCCmdStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StCCmdDamp
   if (allocated(OutData%StCCmdDamp)) deallocate(OutData%StCCmdDamp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCCmdDamp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCCmdDamp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCCmdDamp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StCCmdBrake
   if (allocated(OutData%StCCmdBrake)) deallocate(OutData%StCCmdBrake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCCmdBrake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCCmdBrake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCCmdBrake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StCCmdForce
   if (allocated(OutData%StCCmdForce)) deallocate(OutData%StCCmdForce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCCmdForce(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCCmdForce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCCmdForce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StCMeasDisp
   if (allocated(OutData%StCMeasDisp)) deallocate(OutData%StCMeasDisp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCMeasDisp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCMeasDisp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCMeasDisp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StCMeasVel
   if (allocated(OutData%StCMeasVel)) deallocate(OutData%StCMeasVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCMeasVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCMeasVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCMeasVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SrvD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(SrvD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
IF (ALLOCATED(SrcContStateData%BStC)) THEN
  i1_l = LBOUND(SrcContStateData%BStC,1)
  i1_u = UBOUND(SrcContStateData%BStC,1)
  IF (.NOT. ALLOCATED(DstContStateData%BStC)) THEN 
    ALLOCATE(DstContStateData%BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%BStC,1), UBOUND(SrcContStateData%BStC,1)
      CALL StC_CopyContState( SrcContStateData%BStC(i1), DstContStateData%BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcContStateData%NStC)) THEN
  i1_l = LBOUND(SrcContStateData%NStC,1)
  i1_u = UBOUND(SrcContStateData%NStC,1)
  IF (.NOT. ALLOCATED(DstContStateData%NStC)) THEN 
    ALLOCATE(DstContStateData%NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%NStC,1), UBOUND(SrcContStateData%NStC,1)
      CALL StC_CopyContState( SrcContStateData%NStC(i1), DstContStateData%NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcContStateData%TStC)) THEN
  i1_l = LBOUND(SrcContStateData%TStC,1)
  i1_u = UBOUND(SrcContStateData%TStC,1)
  IF (.NOT. ALLOCATED(DstContStateData%TStC)) THEN 
    ALLOCATE(DstContStateData%TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%TStC,1), UBOUND(SrcContStateData%TStC,1)
      CALL StC_CopyContState( SrcContStateData%TStC(i1), DstContStateData%TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcContStateData%SStC)) THEN
  i1_l = LBOUND(SrcContStateData%SStC,1)
  i1_u = UBOUND(SrcContStateData%SStC,1)
  IF (.NOT. ALLOCATED(DstContStateData%SStC)) THEN 
    ALLOCATE(DstContStateData%SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%SStC,1), UBOUND(SrcContStateData%SStC,1)
      CALL StC_CopyContState( SrcContStateData%SStC(i1), DstContStateData%SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE SrvD_CopyContState

 SUBROUTINE SrvD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SrvD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%BStC)) THEN
DO i1 = LBOUND(ContStateData%BStC,1), UBOUND(ContStateData%BStC,1)
  CALL StC_DestroyContState( ContStateData%BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%BStC)
ENDIF
IF (ALLOCATED(ContStateData%NStC)) THEN
DO i1 = LBOUND(ContStateData%NStC,1), UBOUND(ContStateData%NStC,1)
  CALL StC_DestroyContState( ContStateData%NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%NStC)
ENDIF
IF (ALLOCATED(ContStateData%TStC)) THEN
DO i1 = LBOUND(ContStateData%TStC,1), UBOUND(ContStateData%TStC,1)
  CALL StC_DestroyContState( ContStateData%TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%TStC)
ENDIF
IF (ALLOCATED(ContStateData%SStC)) THEN
DO i1 = LBOUND(ContStateData%SStC,1), UBOUND(ContStateData%SStC,1)
  CALL StC_DestroyContState( ContStateData%SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%SStC)
ENDIF
 END SUBROUTINE SrvD_DestroyContState


subroutine SrvD_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyContState
   call RegPack(Buf, InData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   call RegPack(Buf, allocated(InData%BStC))
   if (allocated(InData%BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStC), ubound(InData%BStC))
      LB(1:1) = lbound(InData%BStC)
      UB(1:1) = ubound(InData%BStC)
      do i1 = LB(1), UB(1)
         call StC_PackContState(Buf, InData%BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC
   call RegPack(Buf, allocated(InData%NStC))
   if (allocated(InData%NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC), ubound(InData%NStC))
      LB(1:1) = lbound(InData%NStC)
      UB(1:1) = ubound(InData%NStC)
      do i1 = LB(1), UB(1)
         call StC_PackContState(Buf, InData%NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC
   call RegPack(Buf, allocated(InData%TStC))
   if (allocated(InData%TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC), ubound(InData%TStC))
      LB(1:1) = lbound(InData%TStC)
      UB(1:1) = ubound(InData%TStC)
      do i1 = LB(1), UB(1)
         call StC_PackContState(Buf, InData%TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC
   call RegPack(Buf, allocated(InData%SStC))
   if (allocated(InData%SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC), ubound(InData%SStC))
      LB(1:1) = lbound(InData%SStC)
      UB(1:1) = ubound(InData%SStC)
      do i1 = LB(1), UB(1)
         call StC_PackContState(Buf, InData%SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyContState
   call RegUnpack(Buf, OutData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   if (allocated(OutData%BStC)) deallocate(OutData%BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackContState(Buf, OutData%BStC(i1)) ! BStC 
      end do
   end if
   ! NStC
   if (allocated(OutData%NStC)) deallocate(OutData%NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackContState(Buf, OutData%NStC(i1)) ! NStC 
      end do
   end if
   ! TStC
   if (allocated(OutData%TStC)) deallocate(OutData%TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackContState(Buf, OutData%TStC(i1)) ! TStC 
      end do
   end if
   ! SStC
   if (allocated(OutData%SStC)) deallocate(OutData%SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackContState(Buf, OutData%SStC(i1)) ! SStC 
      end do
   end if
end subroutine
 SUBROUTINE SrvD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(SrvD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%CtrlOffset = SrcDiscStateData%CtrlOffset
IF (ALLOCATED(SrcDiscStateData%BStC)) THEN
  i1_l = LBOUND(SrcDiscStateData%BStC,1)
  i1_u = UBOUND(SrcDiscStateData%BStC,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%BStC)) THEN 
    ALLOCATE(DstDiscStateData%BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%BStC,1), UBOUND(SrcDiscStateData%BStC,1)
      CALL StC_CopyDiscState( SrcDiscStateData%BStC(i1), DstDiscStateData%BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcDiscStateData%NStC)) THEN
  i1_l = LBOUND(SrcDiscStateData%NStC,1)
  i1_u = UBOUND(SrcDiscStateData%NStC,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%NStC)) THEN 
    ALLOCATE(DstDiscStateData%NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%NStC,1), UBOUND(SrcDiscStateData%NStC,1)
      CALL StC_CopyDiscState( SrcDiscStateData%NStC(i1), DstDiscStateData%NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcDiscStateData%TStC)) THEN
  i1_l = LBOUND(SrcDiscStateData%TStC,1)
  i1_u = UBOUND(SrcDiscStateData%TStC,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%TStC)) THEN 
    ALLOCATE(DstDiscStateData%TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%TStC,1), UBOUND(SrcDiscStateData%TStC,1)
      CALL StC_CopyDiscState( SrcDiscStateData%TStC(i1), DstDiscStateData%TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcDiscStateData%SStC)) THEN
  i1_l = LBOUND(SrcDiscStateData%SStC,1)
  i1_u = UBOUND(SrcDiscStateData%SStC,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%SStC)) THEN 
    ALLOCATE(DstDiscStateData%SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%SStC,1), UBOUND(SrcDiscStateData%SStC,1)
      CALL StC_CopyDiscState( SrcDiscStateData%SStC(i1), DstDiscStateData%SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE SrvD_CopyDiscState

 SUBROUTINE SrvD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SrvD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%BStC)) THEN
DO i1 = LBOUND(DiscStateData%BStC,1), UBOUND(DiscStateData%BStC,1)
  CALL StC_DestroyDiscState( DiscStateData%BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%BStC)
ENDIF
IF (ALLOCATED(DiscStateData%NStC)) THEN
DO i1 = LBOUND(DiscStateData%NStC,1), UBOUND(DiscStateData%NStC,1)
  CALL StC_DestroyDiscState( DiscStateData%NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%NStC)
ENDIF
IF (ALLOCATED(DiscStateData%TStC)) THEN
DO i1 = LBOUND(DiscStateData%TStC,1), UBOUND(DiscStateData%TStC,1)
  CALL StC_DestroyDiscState( DiscStateData%TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%TStC)
ENDIF
IF (ALLOCATED(DiscStateData%SStC)) THEN
DO i1 = LBOUND(DiscStateData%SStC,1), UBOUND(DiscStateData%SStC,1)
  CALL StC_DestroyDiscState( DiscStateData%SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%SStC)
ENDIF
 END SUBROUTINE SrvD_DestroyDiscState


subroutine SrvD_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! CtrlOffset
   call RegPack(Buf, InData%CtrlOffset)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   call RegPack(Buf, allocated(InData%BStC))
   if (allocated(InData%BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStC), ubound(InData%BStC))
      LB(1:1) = lbound(InData%BStC)
      UB(1:1) = ubound(InData%BStC)
      do i1 = LB(1), UB(1)
         call StC_PackDiscState(Buf, InData%BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC
   call RegPack(Buf, allocated(InData%NStC))
   if (allocated(InData%NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC), ubound(InData%NStC))
      LB(1:1) = lbound(InData%NStC)
      UB(1:1) = ubound(InData%NStC)
      do i1 = LB(1), UB(1)
         call StC_PackDiscState(Buf, InData%NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC
   call RegPack(Buf, allocated(InData%TStC))
   if (allocated(InData%TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC), ubound(InData%TStC))
      LB(1:1) = lbound(InData%TStC)
      UB(1:1) = ubound(InData%TStC)
      do i1 = LB(1), UB(1)
         call StC_PackDiscState(Buf, InData%TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC
   call RegPack(Buf, allocated(InData%SStC))
   if (allocated(InData%SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC), ubound(InData%SStC))
      LB(1:1) = lbound(InData%SStC)
      UB(1:1) = ubound(InData%SStC)
      do i1 = LB(1), UB(1)
         call StC_PackDiscState(Buf, InData%SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! CtrlOffset
   call RegUnpack(Buf, OutData%CtrlOffset)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   if (allocated(OutData%BStC)) deallocate(OutData%BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackDiscState(Buf, OutData%BStC(i1)) ! BStC 
      end do
   end if
   ! NStC
   if (allocated(OutData%NStC)) deallocate(OutData%NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackDiscState(Buf, OutData%NStC(i1)) ! NStC 
      end do
   end if
   ! TStC
   if (allocated(OutData%TStC)) deallocate(OutData%TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackDiscState(Buf, OutData%TStC(i1)) ! TStC 
      end do
   end if
   ! SStC
   if (allocated(OutData%SStC)) deallocate(OutData%SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackDiscState(Buf, OutData%SStC(i1)) ! SStC 
      end do
   end if
end subroutine
 SUBROUTINE SrvD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(SrvD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
IF (ALLOCATED(SrcConstrStateData%BStC)) THEN
  i1_l = LBOUND(SrcConstrStateData%BStC,1)
  i1_u = UBOUND(SrcConstrStateData%BStC,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%BStC)) THEN 
    ALLOCATE(DstConstrStateData%BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%BStC,1), UBOUND(SrcConstrStateData%BStC,1)
      CALL StC_CopyConstrState( SrcConstrStateData%BStC(i1), DstConstrStateData%BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcConstrStateData%NStC)) THEN
  i1_l = LBOUND(SrcConstrStateData%NStC,1)
  i1_u = UBOUND(SrcConstrStateData%NStC,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%NStC)) THEN 
    ALLOCATE(DstConstrStateData%NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%NStC,1), UBOUND(SrcConstrStateData%NStC,1)
      CALL StC_CopyConstrState( SrcConstrStateData%NStC(i1), DstConstrStateData%NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcConstrStateData%TStC)) THEN
  i1_l = LBOUND(SrcConstrStateData%TStC,1)
  i1_u = UBOUND(SrcConstrStateData%TStC,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%TStC)) THEN 
    ALLOCATE(DstConstrStateData%TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%TStC,1), UBOUND(SrcConstrStateData%TStC,1)
      CALL StC_CopyConstrState( SrcConstrStateData%TStC(i1), DstConstrStateData%TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcConstrStateData%SStC)) THEN
  i1_l = LBOUND(SrcConstrStateData%SStC,1)
  i1_u = UBOUND(SrcConstrStateData%SStC,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%SStC)) THEN 
    ALLOCATE(DstConstrStateData%SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%SStC,1), UBOUND(SrcConstrStateData%SStC,1)
      CALL StC_CopyConstrState( SrcConstrStateData%SStC(i1), DstConstrStateData%SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE SrvD_CopyConstrState

 SUBROUTINE SrvD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SrvD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ConstrStateData%BStC)) THEN
DO i1 = LBOUND(ConstrStateData%BStC,1), UBOUND(ConstrStateData%BStC,1)
  CALL StC_DestroyConstrState( ConstrStateData%BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%BStC)
ENDIF
IF (ALLOCATED(ConstrStateData%NStC)) THEN
DO i1 = LBOUND(ConstrStateData%NStC,1), UBOUND(ConstrStateData%NStC,1)
  CALL StC_DestroyConstrState( ConstrStateData%NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%NStC)
ENDIF
IF (ALLOCATED(ConstrStateData%TStC)) THEN
DO i1 = LBOUND(ConstrStateData%TStC,1), UBOUND(ConstrStateData%TStC,1)
  CALL StC_DestroyConstrState( ConstrStateData%TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%TStC)
ENDIF
IF (ALLOCATED(ConstrStateData%SStC)) THEN
DO i1 = LBOUND(ConstrStateData%SStC,1), UBOUND(ConstrStateData%SStC,1)
  CALL StC_DestroyConstrState( ConstrStateData%SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%SStC)
ENDIF
 END SUBROUTINE SrvD_DestroyConstrState


subroutine SrvD_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   call RegPack(Buf, allocated(InData%BStC))
   if (allocated(InData%BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStC), ubound(InData%BStC))
      LB(1:1) = lbound(InData%BStC)
      UB(1:1) = ubound(InData%BStC)
      do i1 = LB(1), UB(1)
         call StC_PackConstrState(Buf, InData%BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC
   call RegPack(Buf, allocated(InData%NStC))
   if (allocated(InData%NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC), ubound(InData%NStC))
      LB(1:1) = lbound(InData%NStC)
      UB(1:1) = ubound(InData%NStC)
      do i1 = LB(1), UB(1)
         call StC_PackConstrState(Buf, InData%NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC
   call RegPack(Buf, allocated(InData%TStC))
   if (allocated(InData%TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC), ubound(InData%TStC))
      LB(1:1) = lbound(InData%TStC)
      UB(1:1) = ubound(InData%TStC)
      do i1 = LB(1), UB(1)
         call StC_PackConstrState(Buf, InData%TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC
   call RegPack(Buf, allocated(InData%SStC))
   if (allocated(InData%SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC), ubound(InData%SStC))
      LB(1:1) = lbound(InData%SStC)
      UB(1:1) = ubound(InData%SStC)
      do i1 = LB(1), UB(1)
         call StC_PackConstrState(Buf, InData%SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   if (allocated(OutData%BStC)) deallocate(OutData%BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackConstrState(Buf, OutData%BStC(i1)) ! BStC 
      end do
   end if
   ! NStC
   if (allocated(OutData%NStC)) deallocate(OutData%NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackConstrState(Buf, OutData%NStC(i1)) ! NStC 
      end do
   end if
   ! TStC
   if (allocated(OutData%TStC)) deallocate(OutData%TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackConstrState(Buf, OutData%TStC(i1)) ! TStC 
      end do
   end if
   ! SStC
   if (allocated(OutData%SStC)) deallocate(OutData%SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackConstrState(Buf, OutData%SStC(i1)) ! SStC 
      end do
   end if
end subroutine
 SUBROUTINE SrvD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(SrvD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%BegPitMan)) THEN
  i1_l = LBOUND(SrcOtherStateData%BegPitMan,1)
  i1_u = UBOUND(SrcOtherStateData%BegPitMan,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%BegPitMan)) THEN 
    ALLOCATE(DstOtherStateData%BegPitMan(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%BegPitMan.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%BegPitMan = SrcOtherStateData%BegPitMan
ENDIF
IF (ALLOCATED(SrcOtherStateData%BlPitchI)) THEN
  i1_l = LBOUND(SrcOtherStateData%BlPitchI,1)
  i1_u = UBOUND(SrcOtherStateData%BlPitchI,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%BlPitchI)) THEN 
    ALLOCATE(DstOtherStateData%BlPitchI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%BlPitchI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%BlPitchI = SrcOtherStateData%BlPitchI
ENDIF
IF (ALLOCATED(SrcOtherStateData%TPitManE)) THEN
  i1_l = LBOUND(SrcOtherStateData%TPitManE,1)
  i1_u = UBOUND(SrcOtherStateData%TPitManE,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%TPitManE)) THEN 
    ALLOCATE(DstOtherStateData%TPitManE(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TPitManE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%TPitManE = SrcOtherStateData%TPitManE
ENDIF
    DstOtherStateData%BegYawMan = SrcOtherStateData%BegYawMan
    DstOtherStateData%NacYawI = SrcOtherStateData%NacYawI
    DstOtherStateData%TYawManE = SrcOtherStateData%TYawManE
    DstOtherStateData%YawPosComInt = SrcOtherStateData%YawPosComInt
IF (ALLOCATED(SrcOtherStateData%BegTpBr)) THEN
  i1_l = LBOUND(SrcOtherStateData%BegTpBr,1)
  i1_u = UBOUND(SrcOtherStateData%BegTpBr,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%BegTpBr)) THEN 
    ALLOCATE(DstOtherStateData%BegTpBr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%BegTpBr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%BegTpBr = SrcOtherStateData%BegTpBr
ENDIF
IF (ALLOCATED(SrcOtherStateData%TTpBrDp)) THEN
  i1_l = LBOUND(SrcOtherStateData%TTpBrDp,1)
  i1_u = UBOUND(SrcOtherStateData%TTpBrDp,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%TTpBrDp)) THEN 
    ALLOCATE(DstOtherStateData%TTpBrDp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TTpBrDp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%TTpBrDp = SrcOtherStateData%TTpBrDp
ENDIF
IF (ALLOCATED(SrcOtherStateData%TTpBrFl)) THEN
  i1_l = LBOUND(SrcOtherStateData%TTpBrFl,1)
  i1_u = UBOUND(SrcOtherStateData%TTpBrFl,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%TTpBrFl)) THEN 
    ALLOCATE(DstOtherStateData%TTpBrFl(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TTpBrFl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%TTpBrFl = SrcOtherStateData%TTpBrFl
ENDIF
    DstOtherStateData%Off4Good = SrcOtherStateData%Off4Good
    DstOtherStateData%GenOnLine = SrcOtherStateData%GenOnLine
IF (ALLOCATED(SrcOtherStateData%BStC)) THEN
  i1_l = LBOUND(SrcOtherStateData%BStC,1)
  i1_u = UBOUND(SrcOtherStateData%BStC,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%BStC)) THEN 
    ALLOCATE(DstOtherStateData%BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%BStC,1), UBOUND(SrcOtherStateData%BStC,1)
      CALL StC_CopyOtherState( SrcOtherStateData%BStC(i1), DstOtherStateData%BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%NStC)) THEN
  i1_l = LBOUND(SrcOtherStateData%NStC,1)
  i1_u = UBOUND(SrcOtherStateData%NStC,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%NStC)) THEN 
    ALLOCATE(DstOtherStateData%NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%NStC,1), UBOUND(SrcOtherStateData%NStC,1)
      CALL StC_CopyOtherState( SrcOtherStateData%NStC(i1), DstOtherStateData%NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%TStC)) THEN
  i1_l = LBOUND(SrcOtherStateData%TStC,1)
  i1_u = UBOUND(SrcOtherStateData%TStC,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%TStC)) THEN 
    ALLOCATE(DstOtherStateData%TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%TStC,1), UBOUND(SrcOtherStateData%TStC,1)
      CALL StC_CopyOtherState( SrcOtherStateData%TStC(i1), DstOtherStateData%TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOtherStateData%SStC)) THEN
  i1_l = LBOUND(SrcOtherStateData%SStC,1)
  i1_u = UBOUND(SrcOtherStateData%SStC,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%SStC)) THEN 
    ALLOCATE(DstOtherStateData%SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%SStC,1), UBOUND(SrcOtherStateData%SStC,1)
      CALL StC_CopyOtherState( SrcOtherStateData%SStC(i1), DstOtherStateData%SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE SrvD_CopyOtherState

 SUBROUTINE SrvD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SrvD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%BegPitMan)) THEN
  DEALLOCATE(OtherStateData%BegPitMan)
ENDIF
IF (ALLOCATED(OtherStateData%BlPitchI)) THEN
  DEALLOCATE(OtherStateData%BlPitchI)
ENDIF
IF (ALLOCATED(OtherStateData%TPitManE)) THEN
  DEALLOCATE(OtherStateData%TPitManE)
ENDIF
IF (ALLOCATED(OtherStateData%BegTpBr)) THEN
  DEALLOCATE(OtherStateData%BegTpBr)
ENDIF
IF (ALLOCATED(OtherStateData%TTpBrDp)) THEN
  DEALLOCATE(OtherStateData%TTpBrDp)
ENDIF
IF (ALLOCATED(OtherStateData%TTpBrFl)) THEN
  DEALLOCATE(OtherStateData%TTpBrFl)
ENDIF
IF (ALLOCATED(OtherStateData%BStC)) THEN
DO i1 = LBOUND(OtherStateData%BStC,1), UBOUND(OtherStateData%BStC,1)
  CALL StC_DestroyOtherState( OtherStateData%BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%BStC)
ENDIF
IF (ALLOCATED(OtherStateData%NStC)) THEN
DO i1 = LBOUND(OtherStateData%NStC,1), UBOUND(OtherStateData%NStC,1)
  CALL StC_DestroyOtherState( OtherStateData%NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%NStC)
ENDIF
IF (ALLOCATED(OtherStateData%TStC)) THEN
DO i1 = LBOUND(OtherStateData%TStC,1), UBOUND(OtherStateData%TStC,1)
  CALL StC_DestroyOtherState( OtherStateData%TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%TStC)
ENDIF
IF (ALLOCATED(OtherStateData%SStC)) THEN
DO i1 = LBOUND(OtherStateData%SStC,1), UBOUND(OtherStateData%SStC,1)
  CALL StC_DestroyOtherState( OtherStateData%SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%SStC)
ENDIF
 END SUBROUTINE SrvD_DestroyOtherState


subroutine SrvD_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! BegPitMan
   call RegPack(Buf, allocated(InData%BegPitMan))
   if (allocated(InData%BegPitMan)) then
      call RegPackBounds(Buf, 1, lbound(InData%BegPitMan), ubound(InData%BegPitMan))
      call RegPack(Buf, InData%BegPitMan)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchI
   call RegPack(Buf, allocated(InData%BlPitchI))
   if (allocated(InData%BlPitchI)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitchI), ubound(InData%BlPitchI))
      call RegPack(Buf, InData%BlPitchI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPitManE
   call RegPack(Buf, allocated(InData%TPitManE))
   if (allocated(InData%TPitManE)) then
      call RegPackBounds(Buf, 1, lbound(InData%TPitManE), ubound(InData%TPitManE))
      call RegPack(Buf, InData%TPitManE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BegYawMan
   call RegPack(Buf, InData%BegYawMan)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYawI
   call RegPack(Buf, InData%NacYawI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYawManE
   call RegPack(Buf, InData%TYawManE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawPosComInt
   call RegPack(Buf, InData%YawPosComInt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BegTpBr
   call RegPack(Buf, allocated(InData%BegTpBr))
   if (allocated(InData%BegTpBr)) then
      call RegPackBounds(Buf, 1, lbound(InData%BegTpBr), ubound(InData%BegTpBr))
      call RegPack(Buf, InData%BegTpBr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TTpBrDp
   call RegPack(Buf, allocated(InData%TTpBrDp))
   if (allocated(InData%TTpBrDp)) then
      call RegPackBounds(Buf, 1, lbound(InData%TTpBrDp), ubound(InData%TTpBrDp))
      call RegPack(Buf, InData%TTpBrDp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TTpBrFl
   call RegPack(Buf, allocated(InData%TTpBrFl))
   if (allocated(InData%TTpBrFl)) then
      call RegPackBounds(Buf, 1, lbound(InData%TTpBrFl), ubound(InData%TTpBrFl))
      call RegPack(Buf, InData%TTpBrFl)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Off4Good
   call RegPack(Buf, InData%Off4Good)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenOnLine
   call RegPack(Buf, InData%GenOnLine)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   call RegPack(Buf, allocated(InData%BStC))
   if (allocated(InData%BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStC), ubound(InData%BStC))
      LB(1:1) = lbound(InData%BStC)
      UB(1:1) = ubound(InData%BStC)
      do i1 = LB(1), UB(1)
         call StC_PackOtherState(Buf, InData%BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC
   call RegPack(Buf, allocated(InData%NStC))
   if (allocated(InData%NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC), ubound(InData%NStC))
      LB(1:1) = lbound(InData%NStC)
      UB(1:1) = ubound(InData%NStC)
      do i1 = LB(1), UB(1)
         call StC_PackOtherState(Buf, InData%NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC
   call RegPack(Buf, allocated(InData%TStC))
   if (allocated(InData%TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC), ubound(InData%TStC))
      LB(1:1) = lbound(InData%TStC)
      UB(1:1) = ubound(InData%TStC)
      do i1 = LB(1), UB(1)
         call StC_PackOtherState(Buf, InData%TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC
   call RegPack(Buf, allocated(InData%SStC))
   if (allocated(InData%SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC), ubound(InData%SStC))
      LB(1:1) = lbound(InData%SStC)
      UB(1:1) = ubound(InData%SStC)
      do i1 = LB(1), UB(1)
         call StC_PackOtherState(Buf, InData%SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! BegPitMan
   if (allocated(OutData%BegPitMan)) deallocate(OutData%BegPitMan)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BegPitMan(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BegPitMan.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BegPitMan)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlPitchI
   if (allocated(OutData%BlPitchI)) deallocate(OutData%BlPitchI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitchI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitchI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitchI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TPitManE
   if (allocated(OutData%TPitManE)) deallocate(OutData%TPitManE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TPitManE(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TPitManE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TPitManE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BegYawMan
   call RegUnpack(Buf, OutData%BegYawMan)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYawI
   call RegUnpack(Buf, OutData%NacYawI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYawManE
   call RegUnpack(Buf, OutData%TYawManE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawPosComInt
   call RegUnpack(Buf, OutData%YawPosComInt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BegTpBr
   if (allocated(OutData%BegTpBr)) deallocate(OutData%BegTpBr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BegTpBr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BegTpBr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BegTpBr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TTpBrDp
   if (allocated(OutData%TTpBrDp)) deallocate(OutData%TTpBrDp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TTpBrDp(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TTpBrDp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TTpBrDp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TTpBrFl
   if (allocated(OutData%TTpBrFl)) deallocate(OutData%TTpBrFl)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TTpBrFl(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TTpBrFl.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TTpBrFl)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Off4Good
   call RegUnpack(Buf, OutData%Off4Good)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenOnLine
   call RegUnpack(Buf, OutData%GenOnLine)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   if (allocated(OutData%BStC)) deallocate(OutData%BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOtherState(Buf, OutData%BStC(i1)) ! BStC 
      end do
   end if
   ! NStC
   if (allocated(OutData%NStC)) deallocate(OutData%NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOtherState(Buf, OutData%NStC(i1)) ! NStC 
      end do
   end if
   ! TStC
   if (allocated(OutData%TStC)) deallocate(OutData%TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOtherState(Buf, OutData%TStC(i1)) ! TStC 
      end do
   end if
   ! SStC
   if (allocated(OutData%SStC)) deallocate(OutData%SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOtherState(Buf, OutData%SStC(i1)) ! SStC 
      end do
   end if
end subroutine
 SUBROUTINE SrvD_CopyModuleMapType( SrcModuleMapTypeData, DstModuleMapTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ModuleMapType), INTENT(INOUT) :: SrcModuleMapTypeData
   TYPE(SrvD_ModuleMapType), INTENT(INOUT) :: DstModuleMapTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyModuleMapType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcModuleMapTypeData%u_BStC_Mot2_BStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,1)
  i2_l = LBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,2)
  i2_u = UBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_BStC_Mot2_BStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_BStC_Mot2_BStC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_BStC_Mot2_BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,2), UBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,2)
    DO i1 = LBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,1), UBOUND(SrcModuleMapTypeData%u_BStC_Mot2_BStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%u_BStC_Mot2_BStC(i1,i2), DstModuleMapTypeData%u_BStC_Mot2_BStC(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%u_NStC_Mot2_NStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_NStC_Mot2_NStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_NStC_Mot2_NStC,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_NStC_Mot2_NStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_NStC_Mot2_NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_NStC_Mot2_NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%u_NStC_Mot2_NStC,1), UBOUND(SrcModuleMapTypeData%u_NStC_Mot2_NStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%u_NStC_Mot2_NStC(i1), DstModuleMapTypeData%u_NStC_Mot2_NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%u_TStC_Mot2_TStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_TStC_Mot2_TStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_TStC_Mot2_TStC,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_TStC_Mot2_TStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_TStC_Mot2_TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_TStC_Mot2_TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%u_TStC_Mot2_TStC,1), UBOUND(SrcModuleMapTypeData%u_TStC_Mot2_TStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%u_TStC_Mot2_TStC(i1), DstModuleMapTypeData%u_TStC_Mot2_TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%u_SStC_Mot2_SStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_SStC_Mot2_SStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_SStC_Mot2_SStC,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_SStC_Mot2_SStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_SStC_Mot2_SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_SStC_Mot2_SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%u_SStC_Mot2_SStC,1), UBOUND(SrcModuleMapTypeData%u_SStC_Mot2_SStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%u_SStC_Mot2_SStC(i1), DstModuleMapTypeData%u_SStC_Mot2_SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%BStC_Frc2_y_BStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,1)
  i2_l = LBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,2)
  i2_u = UBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BStC_Frc2_y_BStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%BStC_Frc2_y_BStC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BStC_Frc2_y_BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,2), UBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,2)
    DO i1 = LBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,1), UBOUND(SrcModuleMapTypeData%BStC_Frc2_y_BStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BStC_Frc2_y_BStC(i1,i2), DstModuleMapTypeData%BStC_Frc2_y_BStC(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%NStC_Frc2_y_NStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%NStC_Frc2_y_NStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%NStC_Frc2_y_NStC,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%NStC_Frc2_y_NStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%NStC_Frc2_y_NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%NStC_Frc2_y_NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%NStC_Frc2_y_NStC,1), UBOUND(SrcModuleMapTypeData%NStC_Frc2_y_NStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%NStC_Frc2_y_NStC(i1), DstModuleMapTypeData%NStC_Frc2_y_NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%TStC_Frc2_y_TStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%TStC_Frc2_y_TStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%TStC_Frc2_y_TStC,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%TStC_Frc2_y_TStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%TStC_Frc2_y_TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%TStC_Frc2_y_TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%TStC_Frc2_y_TStC,1), UBOUND(SrcModuleMapTypeData%TStC_Frc2_y_TStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%TStC_Frc2_y_TStC(i1), DstModuleMapTypeData%TStC_Frc2_y_TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%SStC_Frc2_y_SStC)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%SStC_Frc2_y_SStC,1)
  i1_u = UBOUND(SrcModuleMapTypeData%SStC_Frc2_y_SStC,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%SStC_Frc2_y_SStC)) THEN 
    ALLOCATE(DstModuleMapTypeData%SStC_Frc2_y_SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%SStC_Frc2_y_SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%SStC_Frc2_y_SStC,1), UBOUND(SrcModuleMapTypeData%SStC_Frc2_y_SStC,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SStC_Frc2_y_SStC(i1), DstModuleMapTypeData%SStC_Frc2_y_SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE SrvD_CopyModuleMapType

 SUBROUTINE SrvD_DestroyModuleMapType( ModuleMapTypeData, ErrStat, ErrMsg )
  TYPE(SrvD_ModuleMapType), INTENT(INOUT) :: ModuleMapTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyModuleMapType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ModuleMapTypeData%u_BStC_Mot2_BStC)) THEN
DO i2 = LBOUND(ModuleMapTypeData%u_BStC_Mot2_BStC,2), UBOUND(ModuleMapTypeData%u_BStC_Mot2_BStC,2)
DO i1 = LBOUND(ModuleMapTypeData%u_BStC_Mot2_BStC,1), UBOUND(ModuleMapTypeData%u_BStC_Mot2_BStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%u_BStC_Mot2_BStC(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_BStC_Mot2_BStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%u_NStC_Mot2_NStC)) THEN
DO i1 = LBOUND(ModuleMapTypeData%u_NStC_Mot2_NStC,1), UBOUND(ModuleMapTypeData%u_NStC_Mot2_NStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%u_NStC_Mot2_NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_NStC_Mot2_NStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%u_TStC_Mot2_TStC)) THEN
DO i1 = LBOUND(ModuleMapTypeData%u_TStC_Mot2_TStC,1), UBOUND(ModuleMapTypeData%u_TStC_Mot2_TStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%u_TStC_Mot2_TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_TStC_Mot2_TStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%u_SStC_Mot2_SStC)) THEN
DO i1 = LBOUND(ModuleMapTypeData%u_SStC_Mot2_SStC,1), UBOUND(ModuleMapTypeData%u_SStC_Mot2_SStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%u_SStC_Mot2_SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_SStC_Mot2_SStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%BStC_Frc2_y_BStC)) THEN
DO i2 = LBOUND(ModuleMapTypeData%BStC_Frc2_y_BStC,2), UBOUND(ModuleMapTypeData%BStC_Frc2_y_BStC,2)
DO i1 = LBOUND(ModuleMapTypeData%BStC_Frc2_y_BStC,1), UBOUND(ModuleMapTypeData%BStC_Frc2_y_BStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BStC_Frc2_y_BStC(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(ModuleMapTypeData%BStC_Frc2_y_BStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%NStC_Frc2_y_NStC)) THEN
DO i1 = LBOUND(ModuleMapTypeData%NStC_Frc2_y_NStC,1), UBOUND(ModuleMapTypeData%NStC_Frc2_y_NStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%NStC_Frc2_y_NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%NStC_Frc2_y_NStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%TStC_Frc2_y_TStC)) THEN
DO i1 = LBOUND(ModuleMapTypeData%TStC_Frc2_y_TStC,1), UBOUND(ModuleMapTypeData%TStC_Frc2_y_TStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%TStC_Frc2_y_TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%TStC_Frc2_y_TStC)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%SStC_Frc2_y_SStC)) THEN
DO i1 = LBOUND(ModuleMapTypeData%SStC_Frc2_y_SStC,1), UBOUND(ModuleMapTypeData%SStC_Frc2_y_SStC,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SStC_Frc2_y_SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%SStC_Frc2_y_SStC)
ENDIF
 END SUBROUTINE SrvD_DestroyModuleMapType


subroutine SrvD_PackModuleMapType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_ModuleMapType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackModuleMapType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! u_BStC_Mot2_BStC
   call RegPack(Buf, allocated(InData%u_BStC_Mot2_BStC))
   if (allocated(InData%u_BStC_Mot2_BStC)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_BStC_Mot2_BStC), ubound(InData%u_BStC_Mot2_BStC))
      LB(1:2) = lbound(InData%u_BStC_Mot2_BStC)
      UB(1:2) = ubound(InData%u_BStC_Mot2_BStC)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_PackMeshMapType(Buf, InData%u_BStC_Mot2_BStC(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_NStC_Mot2_NStC
   call RegPack(Buf, allocated(InData%u_NStC_Mot2_NStC))
   if (allocated(InData%u_NStC_Mot2_NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_NStC_Mot2_NStC), ubound(InData%u_NStC_Mot2_NStC))
      LB(1:1) = lbound(InData%u_NStC_Mot2_NStC)
      UB(1:1) = ubound(InData%u_NStC_Mot2_NStC)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%u_NStC_Mot2_NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_TStC_Mot2_TStC
   call RegPack(Buf, allocated(InData%u_TStC_Mot2_TStC))
   if (allocated(InData%u_TStC_Mot2_TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_TStC_Mot2_TStC), ubound(InData%u_TStC_Mot2_TStC))
      LB(1:1) = lbound(InData%u_TStC_Mot2_TStC)
      UB(1:1) = ubound(InData%u_TStC_Mot2_TStC)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%u_TStC_Mot2_TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_SStC_Mot2_SStC
   call RegPack(Buf, allocated(InData%u_SStC_Mot2_SStC))
   if (allocated(InData%u_SStC_Mot2_SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_SStC_Mot2_SStC), ubound(InData%u_SStC_Mot2_SStC))
      LB(1:1) = lbound(InData%u_SStC_Mot2_SStC)
      UB(1:1) = ubound(InData%u_SStC_Mot2_SStC)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%u_SStC_Mot2_SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC_Frc2_y_BStC
   call RegPack(Buf, allocated(InData%BStC_Frc2_y_BStC))
   if (allocated(InData%BStC_Frc2_y_BStC)) then
      call RegPackBounds(Buf, 2, lbound(InData%BStC_Frc2_y_BStC), ubound(InData%BStC_Frc2_y_BStC))
      LB(1:2) = lbound(InData%BStC_Frc2_y_BStC)
      UB(1:2) = ubound(InData%BStC_Frc2_y_BStC)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_PackMeshMapType(Buf, InData%BStC_Frc2_y_BStC(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC_Frc2_y_NStC
   call RegPack(Buf, allocated(InData%NStC_Frc2_y_NStC))
   if (allocated(InData%NStC_Frc2_y_NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC_Frc2_y_NStC), ubound(InData%NStC_Frc2_y_NStC))
      LB(1:1) = lbound(InData%NStC_Frc2_y_NStC)
      UB(1:1) = ubound(InData%NStC_Frc2_y_NStC)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%NStC_Frc2_y_NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC_Frc2_y_TStC
   call RegPack(Buf, allocated(InData%TStC_Frc2_y_TStC))
   if (allocated(InData%TStC_Frc2_y_TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC_Frc2_y_TStC), ubound(InData%TStC_Frc2_y_TStC))
      LB(1:1) = lbound(InData%TStC_Frc2_y_TStC)
      UB(1:1) = ubound(InData%TStC_Frc2_y_TStC)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%TStC_Frc2_y_TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC_Frc2_y_SStC
   call RegPack(Buf, allocated(InData%SStC_Frc2_y_SStC))
   if (allocated(InData%SStC_Frc2_y_SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC_Frc2_y_SStC), ubound(InData%SStC_Frc2_y_SStC))
      LB(1:1) = lbound(InData%SStC_Frc2_y_SStC)
      UB(1:1) = ubound(InData%SStC_Frc2_y_SStC)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%SStC_Frc2_y_SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackModuleMapType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_ModuleMapType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackModuleMapType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! u_BStC_Mot2_BStC
   if (allocated(OutData%u_BStC_Mot2_BStC)) deallocate(OutData%u_BStC_Mot2_BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_BStC_Mot2_BStC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_BStC_Mot2_BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_UnpackMeshMapType(Buf, OutData%u_BStC_Mot2_BStC(i1,i2)) ! u_BStC_Mot2_BStC 
         end do
      end do
   end if
   ! u_NStC_Mot2_NStC
   if (allocated(OutData%u_NStC_Mot2_NStC)) deallocate(OutData%u_NStC_Mot2_NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_NStC_Mot2_NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_NStC_Mot2_NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%u_NStC_Mot2_NStC(i1)) ! u_NStC_Mot2_NStC 
      end do
   end if
   ! u_TStC_Mot2_TStC
   if (allocated(OutData%u_TStC_Mot2_TStC)) deallocate(OutData%u_TStC_Mot2_TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_TStC_Mot2_TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_TStC_Mot2_TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%u_TStC_Mot2_TStC(i1)) ! u_TStC_Mot2_TStC 
      end do
   end if
   ! u_SStC_Mot2_SStC
   if (allocated(OutData%u_SStC_Mot2_SStC)) deallocate(OutData%u_SStC_Mot2_SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_SStC_Mot2_SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_SStC_Mot2_SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%u_SStC_Mot2_SStC(i1)) ! u_SStC_Mot2_SStC 
      end do
   end if
   ! BStC_Frc2_y_BStC
   if (allocated(OutData%BStC_Frc2_y_BStC)) deallocate(OutData%BStC_Frc2_y_BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC_Frc2_y_BStC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC_Frc2_y_BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_UnpackMeshMapType(Buf, OutData%BStC_Frc2_y_BStC(i1,i2)) ! BStC_Frc2_y_BStC 
         end do
      end do
   end if
   ! NStC_Frc2_y_NStC
   if (allocated(OutData%NStC_Frc2_y_NStC)) deallocate(OutData%NStC_Frc2_y_NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC_Frc2_y_NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC_Frc2_y_NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%NStC_Frc2_y_NStC(i1)) ! NStC_Frc2_y_NStC 
      end do
   end if
   ! TStC_Frc2_y_TStC
   if (allocated(OutData%TStC_Frc2_y_TStC)) deallocate(OutData%TStC_Frc2_y_TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC_Frc2_y_TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC_Frc2_y_TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%TStC_Frc2_y_TStC(i1)) ! TStC_Frc2_y_TStC 
      end do
   end if
   ! SStC_Frc2_y_SStC
   if (allocated(OutData%SStC_Frc2_y_SStC)) deallocate(OutData%SStC_Frc2_y_SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC_Frc2_y_SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC_Frc2_y_SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%SStC_Frc2_y_SStC(i1)) ! SStC_Frc2_y_SStC 
      end do
   end if
end subroutine
 SUBROUTINE SrvD_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_MiscVarType), INTENT(INOUT) :: SrcMiscData
   TYPE(SrvD_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%LastTimeCalled = SrcMiscData%LastTimeCalled
      CALL SrvD_Copybladeddlltype( SrcMiscData%dll_data, DstMiscData%dll_data, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%FirstWarn = SrcMiscData%FirstWarn
    DstMiscData%LastTimeFiltered = SrcMiscData%LastTimeFiltered
IF (ALLOCATED(SrcMiscData%xd_BlPitchFilter)) THEN
  i1_l = LBOUND(SrcMiscData%xd_BlPitchFilter,1)
  i1_u = UBOUND(SrcMiscData%xd_BlPitchFilter,1)
  IF (.NOT. ALLOCATED(DstMiscData%xd_BlPitchFilter)) THEN 
    ALLOCATE(DstMiscData%xd_BlPitchFilter(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%xd_BlPitchFilter.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%xd_BlPitchFilter = SrcMiscData%xd_BlPitchFilter
ENDIF
IF (ALLOCATED(SrcMiscData%BStC)) THEN
  i1_l = LBOUND(SrcMiscData%BStC,1)
  i1_u = UBOUND(SrcMiscData%BStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%BStC)) THEN 
    ALLOCATE(DstMiscData%BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%BStC,1), UBOUND(SrcMiscData%BStC,1)
      CALL StC_CopyMisc( SrcMiscData%BStC(i1), DstMiscData%BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%NStC)) THEN
  i1_l = LBOUND(SrcMiscData%NStC,1)
  i1_u = UBOUND(SrcMiscData%NStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%NStC)) THEN 
    ALLOCATE(DstMiscData%NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%NStC,1), UBOUND(SrcMiscData%NStC,1)
      CALL StC_CopyMisc( SrcMiscData%NStC(i1), DstMiscData%NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%TStC)) THEN
  i1_l = LBOUND(SrcMiscData%TStC,1)
  i1_u = UBOUND(SrcMiscData%TStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%TStC)) THEN 
    ALLOCATE(DstMiscData%TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%TStC,1), UBOUND(SrcMiscData%TStC,1)
      CALL StC_CopyMisc( SrcMiscData%TStC(i1), DstMiscData%TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%SStC)) THEN
  i1_l = LBOUND(SrcMiscData%SStC,1)
  i1_u = UBOUND(SrcMiscData%SStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%SStC)) THEN 
    ALLOCATE(DstMiscData%SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%SStC,1), UBOUND(SrcMiscData%SStC,1)
      CALL StC_CopyMisc( SrcMiscData%SStC(i1), DstMiscData%SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%u_BStC)) THEN
  i1_l = LBOUND(SrcMiscData%u_BStC,1)
  i1_u = UBOUND(SrcMiscData%u_BStC,1)
  i2_l = LBOUND(SrcMiscData%u_BStC,2)
  i2_u = UBOUND(SrcMiscData%u_BStC,2)
  IF (.NOT. ALLOCATED(DstMiscData%u_BStC)) THEN 
    ALLOCATE(DstMiscData%u_BStC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcMiscData%u_BStC,2), UBOUND(SrcMiscData%u_BStC,2)
    DO i1 = LBOUND(SrcMiscData%u_BStC,1), UBOUND(SrcMiscData%u_BStC,1)
      CALL StC_CopyInput( SrcMiscData%u_BStC(i1,i2), DstMiscData%u_BStC(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%u_NStC)) THEN
  i1_l = LBOUND(SrcMiscData%u_NStC,1)
  i1_u = UBOUND(SrcMiscData%u_NStC,1)
  i2_l = LBOUND(SrcMiscData%u_NStC,2)
  i2_u = UBOUND(SrcMiscData%u_NStC,2)
  IF (.NOT. ALLOCATED(DstMiscData%u_NStC)) THEN 
    ALLOCATE(DstMiscData%u_NStC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcMiscData%u_NStC,2), UBOUND(SrcMiscData%u_NStC,2)
    DO i1 = LBOUND(SrcMiscData%u_NStC,1), UBOUND(SrcMiscData%u_NStC,1)
      CALL StC_CopyInput( SrcMiscData%u_NStC(i1,i2), DstMiscData%u_NStC(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%u_TStC)) THEN
  i1_l = LBOUND(SrcMiscData%u_TStC,1)
  i1_u = UBOUND(SrcMiscData%u_TStC,1)
  i2_l = LBOUND(SrcMiscData%u_TStC,2)
  i2_u = UBOUND(SrcMiscData%u_TStC,2)
  IF (.NOT. ALLOCATED(DstMiscData%u_TStC)) THEN 
    ALLOCATE(DstMiscData%u_TStC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcMiscData%u_TStC,2), UBOUND(SrcMiscData%u_TStC,2)
    DO i1 = LBOUND(SrcMiscData%u_TStC,1), UBOUND(SrcMiscData%u_TStC,1)
      CALL StC_CopyInput( SrcMiscData%u_TStC(i1,i2), DstMiscData%u_TStC(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%u_SStC)) THEN
  i1_l = LBOUND(SrcMiscData%u_SStC,1)
  i1_u = UBOUND(SrcMiscData%u_SStC,1)
  i2_l = LBOUND(SrcMiscData%u_SStC,2)
  i2_u = UBOUND(SrcMiscData%u_SStC,2)
  IF (.NOT. ALLOCATED(DstMiscData%u_SStC)) THEN 
    ALLOCATE(DstMiscData%u_SStC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcMiscData%u_SStC,2), UBOUND(SrcMiscData%u_SStC,2)
    DO i1 = LBOUND(SrcMiscData%u_SStC,1), UBOUND(SrcMiscData%u_SStC,1)
      CALL StC_CopyInput( SrcMiscData%u_SStC(i1,i2), DstMiscData%u_SStC(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%y_BStC)) THEN
  i1_l = LBOUND(SrcMiscData%y_BStC,1)
  i1_u = UBOUND(SrcMiscData%y_BStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%y_BStC)) THEN 
    ALLOCATE(DstMiscData%y_BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%y_BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%y_BStC,1), UBOUND(SrcMiscData%y_BStC,1)
      CALL StC_CopyOutput( SrcMiscData%y_BStC(i1), DstMiscData%y_BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%y_NStC)) THEN
  i1_l = LBOUND(SrcMiscData%y_NStC,1)
  i1_u = UBOUND(SrcMiscData%y_NStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%y_NStC)) THEN 
    ALLOCATE(DstMiscData%y_NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%y_NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%y_NStC,1), UBOUND(SrcMiscData%y_NStC,1)
      CALL StC_CopyOutput( SrcMiscData%y_NStC(i1), DstMiscData%y_NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%y_TStC)) THEN
  i1_l = LBOUND(SrcMiscData%y_TStC,1)
  i1_u = UBOUND(SrcMiscData%y_TStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%y_TStC)) THEN 
    ALLOCATE(DstMiscData%y_TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%y_TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%y_TStC,1), UBOUND(SrcMiscData%y_TStC,1)
      CALL StC_CopyOutput( SrcMiscData%y_TStC(i1), DstMiscData%y_TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%y_SStC)) THEN
  i1_l = LBOUND(SrcMiscData%y_SStC,1)
  i1_u = UBOUND(SrcMiscData%y_SStC,1)
  IF (.NOT. ALLOCATED(DstMiscData%y_SStC)) THEN 
    ALLOCATE(DstMiscData%y_SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%y_SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%y_SStC,1), UBOUND(SrcMiscData%y_SStC,1)
      CALL StC_CopyOutput( SrcMiscData%y_SStC(i1), DstMiscData%y_SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL SrvD_Copymodulemaptype( SrcMiscData%SrvD_MeshMap, DstMiscData%SrvD_MeshMap, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%PrevTstepNcall = SrcMiscData%PrevTstepNcall
 END SUBROUTINE SrvD_CopyMisc

 SUBROUTINE SrvD_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(SrvD_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL SrvD_DestroyBladedDLLType( MiscData%dll_data, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%xd_BlPitchFilter)) THEN
  DEALLOCATE(MiscData%xd_BlPitchFilter)
ENDIF
IF (ALLOCATED(MiscData%BStC)) THEN
DO i1 = LBOUND(MiscData%BStC,1), UBOUND(MiscData%BStC,1)
  CALL StC_DestroyMisc( MiscData%BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%BStC)
ENDIF
IF (ALLOCATED(MiscData%NStC)) THEN
DO i1 = LBOUND(MiscData%NStC,1), UBOUND(MiscData%NStC,1)
  CALL StC_DestroyMisc( MiscData%NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%NStC)
ENDIF
IF (ALLOCATED(MiscData%TStC)) THEN
DO i1 = LBOUND(MiscData%TStC,1), UBOUND(MiscData%TStC,1)
  CALL StC_DestroyMisc( MiscData%TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%TStC)
ENDIF
IF (ALLOCATED(MiscData%SStC)) THEN
DO i1 = LBOUND(MiscData%SStC,1), UBOUND(MiscData%SStC,1)
  CALL StC_DestroyMisc( MiscData%SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%SStC)
ENDIF
IF (ALLOCATED(MiscData%u_BStC)) THEN
DO i2 = LBOUND(MiscData%u_BStC,2), UBOUND(MiscData%u_BStC,2)
DO i1 = LBOUND(MiscData%u_BStC,1), UBOUND(MiscData%u_BStC,1)
  CALL StC_DestroyInput( MiscData%u_BStC(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(MiscData%u_BStC)
ENDIF
IF (ALLOCATED(MiscData%u_NStC)) THEN
DO i2 = LBOUND(MiscData%u_NStC,2), UBOUND(MiscData%u_NStC,2)
DO i1 = LBOUND(MiscData%u_NStC,1), UBOUND(MiscData%u_NStC,1)
  CALL StC_DestroyInput( MiscData%u_NStC(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(MiscData%u_NStC)
ENDIF
IF (ALLOCATED(MiscData%u_TStC)) THEN
DO i2 = LBOUND(MiscData%u_TStC,2), UBOUND(MiscData%u_TStC,2)
DO i1 = LBOUND(MiscData%u_TStC,1), UBOUND(MiscData%u_TStC,1)
  CALL StC_DestroyInput( MiscData%u_TStC(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(MiscData%u_TStC)
ENDIF
IF (ALLOCATED(MiscData%u_SStC)) THEN
DO i2 = LBOUND(MiscData%u_SStC,2), UBOUND(MiscData%u_SStC,2)
DO i1 = LBOUND(MiscData%u_SStC,1), UBOUND(MiscData%u_SStC,1)
  CALL StC_DestroyInput( MiscData%u_SStC(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(MiscData%u_SStC)
ENDIF
IF (ALLOCATED(MiscData%y_BStC)) THEN
DO i1 = LBOUND(MiscData%y_BStC,1), UBOUND(MiscData%y_BStC,1)
  CALL StC_DestroyOutput( MiscData%y_BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%y_BStC)
ENDIF
IF (ALLOCATED(MiscData%y_NStC)) THEN
DO i1 = LBOUND(MiscData%y_NStC,1), UBOUND(MiscData%y_NStC,1)
  CALL StC_DestroyOutput( MiscData%y_NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%y_NStC)
ENDIF
IF (ALLOCATED(MiscData%y_TStC)) THEN
DO i1 = LBOUND(MiscData%y_TStC,1), UBOUND(MiscData%y_TStC,1)
  CALL StC_DestroyOutput( MiscData%y_TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%y_TStC)
ENDIF
IF (ALLOCATED(MiscData%y_SStC)) THEN
DO i1 = LBOUND(MiscData%y_SStC,1), UBOUND(MiscData%y_SStC,1)
  CALL StC_DestroyOutput( MiscData%y_SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%y_SStC)
ENDIF
  CALL SrvD_DestroyModuleMapType( MiscData%SrvD_MeshMap, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SrvD_DestroyMisc


subroutine SrvD_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! LastTimeCalled
   call RegPack(Buf, InData%LastTimeCalled)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dll_data
   call SrvD_PackBladedDLLType(Buf, InData%dll_data) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstWarn
   call RegPack(Buf, InData%FirstWarn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastTimeFiltered
   call RegPack(Buf, InData%LastTimeFiltered)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_BlPitchFilter
   call RegPack(Buf, allocated(InData%xd_BlPitchFilter))
   if (allocated(InData%xd_BlPitchFilter)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_BlPitchFilter), ubound(InData%xd_BlPitchFilter))
      call RegPack(Buf, InData%xd_BlPitchFilter)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   call RegPack(Buf, allocated(InData%BStC))
   if (allocated(InData%BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStC), ubound(InData%BStC))
      LB(1:1) = lbound(InData%BStC)
      UB(1:1) = ubound(InData%BStC)
      do i1 = LB(1), UB(1)
         call StC_PackMisc(Buf, InData%BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC
   call RegPack(Buf, allocated(InData%NStC))
   if (allocated(InData%NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC), ubound(InData%NStC))
      LB(1:1) = lbound(InData%NStC)
      UB(1:1) = ubound(InData%NStC)
      do i1 = LB(1), UB(1)
         call StC_PackMisc(Buf, InData%NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC
   call RegPack(Buf, allocated(InData%TStC))
   if (allocated(InData%TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC), ubound(InData%TStC))
      LB(1:1) = lbound(InData%TStC)
      UB(1:1) = ubound(InData%TStC)
      do i1 = LB(1), UB(1)
         call StC_PackMisc(Buf, InData%TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC
   call RegPack(Buf, allocated(InData%SStC))
   if (allocated(InData%SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC), ubound(InData%SStC))
      LB(1:1) = lbound(InData%SStC)
      UB(1:1) = ubound(InData%SStC)
      do i1 = LB(1), UB(1)
         call StC_PackMisc(Buf, InData%SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_BStC
   call RegPack(Buf, allocated(InData%u_BStC))
   if (allocated(InData%u_BStC)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_BStC), ubound(InData%u_BStC))
      LB(1:2) = lbound(InData%u_BStC)
      UB(1:2) = ubound(InData%u_BStC)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_PackInput(Buf, InData%u_BStC(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_NStC
   call RegPack(Buf, allocated(InData%u_NStC))
   if (allocated(InData%u_NStC)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_NStC), ubound(InData%u_NStC))
      LB(1:2) = lbound(InData%u_NStC)
      UB(1:2) = ubound(InData%u_NStC)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_PackInput(Buf, InData%u_NStC(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_TStC
   call RegPack(Buf, allocated(InData%u_TStC))
   if (allocated(InData%u_TStC)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_TStC), ubound(InData%u_TStC))
      LB(1:2) = lbound(InData%u_TStC)
      UB(1:2) = ubound(InData%u_TStC)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_PackInput(Buf, InData%u_TStC(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_SStC
   call RegPack(Buf, allocated(InData%u_SStC))
   if (allocated(InData%u_SStC)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_SStC), ubound(InData%u_SStC))
      LB(1:2) = lbound(InData%u_SStC)
      UB(1:2) = ubound(InData%u_SStC)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_PackInput(Buf, InData%u_SStC(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_BStC
   call RegPack(Buf, allocated(InData%y_BStC))
   if (allocated(InData%y_BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_BStC), ubound(InData%y_BStC))
      LB(1:1) = lbound(InData%y_BStC)
      UB(1:1) = ubound(InData%y_BStC)
      do i1 = LB(1), UB(1)
         call StC_PackOutput(Buf, InData%y_BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_NStC
   call RegPack(Buf, allocated(InData%y_NStC))
   if (allocated(InData%y_NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_NStC), ubound(InData%y_NStC))
      LB(1:1) = lbound(InData%y_NStC)
      UB(1:1) = ubound(InData%y_NStC)
      do i1 = LB(1), UB(1)
         call StC_PackOutput(Buf, InData%y_NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_TStC
   call RegPack(Buf, allocated(InData%y_TStC))
   if (allocated(InData%y_TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_TStC), ubound(InData%y_TStC))
      LB(1:1) = lbound(InData%y_TStC)
      UB(1:1) = ubound(InData%y_TStC)
      do i1 = LB(1), UB(1)
         call StC_PackOutput(Buf, InData%y_TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_SStC
   call RegPack(Buf, allocated(InData%y_SStC))
   if (allocated(InData%y_SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_SStC), ubound(InData%y_SStC))
      LB(1:1) = lbound(InData%y_SStC)
      UB(1:1) = ubound(InData%y_SStC)
      do i1 = LB(1), UB(1)
         call StC_PackOutput(Buf, InData%y_SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SrvD_MeshMap
   call SrvD_PackModuleMapType(Buf, InData%SrvD_MeshMap) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevTstepNcall
   call RegPack(Buf, InData%PrevTstepNcall)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LastTimeCalled
   call RegUnpack(Buf, OutData%LastTimeCalled)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dll_data
   call SrvD_UnpackBladedDLLType(Buf, OutData%dll_data) ! dll_data 
   ! FirstWarn
   call RegUnpack(Buf, OutData%FirstWarn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastTimeFiltered
   call RegUnpack(Buf, OutData%LastTimeFiltered)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_BlPitchFilter
   if (allocated(OutData%xd_BlPitchFilter)) deallocate(OutData%xd_BlPitchFilter)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_BlPitchFilter(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_BlPitchFilter.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%xd_BlPitchFilter)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BStC
   if (allocated(OutData%BStC)) deallocate(OutData%BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackMisc(Buf, OutData%BStC(i1)) ! BStC 
      end do
   end if
   ! NStC
   if (allocated(OutData%NStC)) deallocate(OutData%NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackMisc(Buf, OutData%NStC(i1)) ! NStC 
      end do
   end if
   ! TStC
   if (allocated(OutData%TStC)) deallocate(OutData%TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackMisc(Buf, OutData%TStC(i1)) ! TStC 
      end do
   end if
   ! SStC
   if (allocated(OutData%SStC)) deallocate(OutData%SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackMisc(Buf, OutData%SStC(i1)) ! SStC 
      end do
   end if
   ! u_BStC
   if (allocated(OutData%u_BStC)) deallocate(OutData%u_BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_BStC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_UnpackInput(Buf, OutData%u_BStC(i1,i2)) ! u_BStC 
         end do
      end do
   end if
   ! u_NStC
   if (allocated(OutData%u_NStC)) deallocate(OutData%u_NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_NStC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_UnpackInput(Buf, OutData%u_NStC(i1,i2)) ! u_NStC 
         end do
      end do
   end if
   ! u_TStC
   if (allocated(OutData%u_TStC)) deallocate(OutData%u_TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_TStC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_UnpackInput(Buf, OutData%u_TStC(i1,i2)) ! u_TStC 
         end do
      end do
   end if
   ! u_SStC
   if (allocated(OutData%u_SStC)) deallocate(OutData%u_SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_SStC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call StC_UnpackInput(Buf, OutData%u_SStC(i1,i2)) ! u_SStC 
         end do
      end do
   end if
   ! y_BStC
   if (allocated(OutData%y_BStC)) deallocate(OutData%y_BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOutput(Buf, OutData%y_BStC(i1)) ! y_BStC 
      end do
   end if
   ! y_NStC
   if (allocated(OutData%y_NStC)) deallocate(OutData%y_NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOutput(Buf, OutData%y_NStC(i1)) ! y_NStC 
      end do
   end if
   ! y_TStC
   if (allocated(OutData%y_TStC)) deallocate(OutData%y_TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOutput(Buf, OutData%y_TStC(i1)) ! y_TStC 
      end do
   end if
   ! y_SStC
   if (allocated(OutData%y_SStC)) deallocate(OutData%y_SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackOutput(Buf, OutData%y_SStC(i1)) ! y_SStC 
      end do
   end if
   ! SrvD_MeshMap
   call SrvD_UnpackModuleMapType(Buf, OutData%SrvD_MeshMap) ! SrvD_MeshMap 
   ! PrevTstepNcall
   call RegUnpack(Buf, OutData%PrevTstepNcall)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SrvD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SrvD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%HSSBrDT = SrcParamData%HSSBrDT
    DstParamData%HSSBrTqF = SrcParamData%HSSBrTqF
    DstParamData%SIG_POSl = SrcParamData%SIG_POSl
    DstParamData%SIG_POTq = SrcParamData%SIG_POTq
    DstParamData%SIG_SlPc = SrcParamData%SIG_SlPc
    DstParamData%SIG_Slop = SrcParamData%SIG_Slop
    DstParamData%SIG_SySp = SrcParamData%SIG_SySp
    DstParamData%TEC_A0 = SrcParamData%TEC_A0
    DstParamData%TEC_C0 = SrcParamData%TEC_C0
    DstParamData%TEC_C1 = SrcParamData%TEC_C1
    DstParamData%TEC_C2 = SrcParamData%TEC_C2
    DstParamData%TEC_K2 = SrcParamData%TEC_K2
    DstParamData%TEC_MR = SrcParamData%TEC_MR
    DstParamData%TEC_Re1 = SrcParamData%TEC_Re1
    DstParamData%TEC_RLR = SrcParamData%TEC_RLR
    DstParamData%TEC_RRes = SrcParamData%TEC_RRes
    DstParamData%TEC_SRes = SrcParamData%TEC_SRes
    DstParamData%TEC_SySp = SrcParamData%TEC_SySp
    DstParamData%TEC_V1a = SrcParamData%TEC_V1a
    DstParamData%TEC_VLL = SrcParamData%TEC_VLL
    DstParamData%TEC_Xe1 = SrcParamData%TEC_Xe1
    DstParamData%GenEff = SrcParamData%GenEff
IF (ALLOCATED(SrcParamData%BlPitchInit)) THEN
  i1_l = LBOUND(SrcParamData%BlPitchInit,1)
  i1_u = UBOUND(SrcParamData%BlPitchInit,1)
  IF (.NOT. ALLOCATED(DstParamData%BlPitchInit)) THEN 
    ALLOCATE(DstParamData%BlPitchInit(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BlPitchInit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%BlPitchInit = SrcParamData%BlPitchInit
ENDIF
IF (ALLOCATED(SrcParamData%BlPitchF)) THEN
  i1_l = LBOUND(SrcParamData%BlPitchF,1)
  i1_u = UBOUND(SrcParamData%BlPitchF,1)
  IF (.NOT. ALLOCATED(DstParamData%BlPitchF)) THEN 
    ALLOCATE(DstParamData%BlPitchF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BlPitchF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%BlPitchF = SrcParamData%BlPitchF
ENDIF
IF (ALLOCATED(SrcParamData%PitManRat)) THEN
  i1_l = LBOUND(SrcParamData%PitManRat,1)
  i1_u = UBOUND(SrcParamData%PitManRat,1)
  IF (.NOT. ALLOCATED(DstParamData%PitManRat)) THEN 
    ALLOCATE(DstParamData%PitManRat(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PitManRat.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PitManRat = SrcParamData%PitManRat
ENDIF
    DstParamData%YawManRat = SrcParamData%YawManRat
    DstParamData%NacYawF = SrcParamData%NacYawF
    DstParamData%SpdGenOn = SrcParamData%SpdGenOn
    DstParamData%THSSBrDp = SrcParamData%THSSBrDp
    DstParamData%THSSBrFl = SrcParamData%THSSBrFl
    DstParamData%TimGenOf = SrcParamData%TimGenOf
    DstParamData%TimGenOn = SrcParamData%TimGenOn
    DstParamData%TPCOn = SrcParamData%TPCOn
IF (ALLOCATED(SrcParamData%TPitManS)) THEN
  i1_l = LBOUND(SrcParamData%TPitManS,1)
  i1_u = UBOUND(SrcParamData%TPitManS,1)
  IF (.NOT. ALLOCATED(DstParamData%TPitManS)) THEN 
    ALLOCATE(DstParamData%TPitManS(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TPitManS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%TPitManS = SrcParamData%TPitManS
ENDIF
    DstParamData%TYawManS = SrcParamData%TYawManS
    DstParamData%TYCOn = SrcParamData%TYCOn
    DstParamData%VS_RtGnSp = SrcParamData%VS_RtGnSp
    DstParamData%VS_RtTq = SrcParamData%VS_RtTq
    DstParamData%VS_Slope = SrcParamData%VS_Slope
    DstParamData%VS_SlPc = SrcParamData%VS_SlPc
    DstParamData%VS_SySp = SrcParamData%VS_SySp
    DstParamData%VS_TrGnSp = SrcParamData%VS_TrGnSp
    DstParamData%YawPosCom = SrcParamData%YawPosCom
    DstParamData%YawRateCom = SrcParamData%YawRateCom
    DstParamData%GenModel = SrcParamData%GenModel
    DstParamData%HSSBrMode = SrcParamData%HSSBrMode
    DstParamData%PCMode = SrcParamData%PCMode
    DstParamData%VSContrl = SrcParamData%VSContrl
    DstParamData%YCMode = SrcParamData%YCMode
    DstParamData%GenTiStp = SrcParamData%GenTiStp
    DstParamData%GenTiStr = SrcParamData%GenTiStr
    DstParamData%VS_Rgn2K = SrcParamData%VS_Rgn2K
    DstParamData%YawNeut = SrcParamData%YawNeut
    DstParamData%YawSpr = SrcParamData%YawSpr
    DstParamData%YawDamp = SrcParamData%YawDamp
    DstParamData%TpBrDT = SrcParamData%TpBrDT
IF (ALLOCATED(SrcParamData%TBDepISp)) THEN
  i1_l = LBOUND(SrcParamData%TBDepISp,1)
  i1_u = UBOUND(SrcParamData%TBDepISp,1)
  IF (.NOT. ALLOCATED(DstParamData%TBDepISp)) THEN 
    ALLOCATE(DstParamData%TBDepISp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TBDepISp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%TBDepISp = SrcParamData%TBDepISp
ENDIF
    DstParamData%TBDrConN = SrcParamData%TBDrConN
    DstParamData%TBDrConD = SrcParamData%TBDrConD
    DstParamData%NumBl = SrcParamData%NumBl
    DstParamData%NumBStC = SrcParamData%NumBStC
    DstParamData%NumNStC = SrcParamData%NumNStC
    DstParamData%NumTStC = SrcParamData%NumTStC
    DstParamData%NumSStC = SrcParamData%NumSStC
    DstParamData%AfCmode = SrcParamData%AfCmode
    DstParamData%AfC_Mean = SrcParamData%AfC_Mean
    DstParamData%AfC_Amp = SrcParamData%AfC_Amp
    DstParamData%AfC_Phase = SrcParamData%AfC_Phase
    DstParamData%CCmode = SrcParamData%CCmode
    DstParamData%StCCmode = SrcParamData%StCCmode
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%NumOuts_DLL = SrcParamData%NumOuts_DLL
    DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%Delim = SrcParamData%Delim
    DstParamData%UseBladedInterface = SrcParamData%UseBladedInterface
    DstParamData%UseLegacyInterface = SrcParamData%UseLegacyInterface
      DstParamData%DLL_Trgt = SrcParamData%DLL_Trgt
    DstParamData%DLL_Ramp = SrcParamData%DLL_Ramp
    DstParamData%BlAlpha = SrcParamData%BlAlpha
    DstParamData%DLL_n = SrcParamData%DLL_n
    DstParamData%avcOUTNAME_LEN = SrcParamData%avcOUTNAME_LEN
    DstParamData%NacYaw_North = SrcParamData%NacYaw_North
    DstParamData%AvgWindSpeed = SrcParamData%AvgWindSpeed
    DstParamData%AirDens = SrcParamData%AirDens
    DstParamData%TrimCase = SrcParamData%TrimCase
    DstParamData%TrimGain = SrcParamData%TrimGain
    DstParamData%RotSpeedRef = SrcParamData%RotSpeedRef
IF (ALLOCATED(SrcParamData%BStC)) THEN
  i1_l = LBOUND(SrcParamData%BStC,1)
  i1_u = UBOUND(SrcParamData%BStC,1)
  IF (.NOT. ALLOCATED(DstParamData%BStC)) THEN 
    ALLOCATE(DstParamData%BStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%BStC,1), UBOUND(SrcParamData%BStC,1)
      CALL StC_CopyParam( SrcParamData%BStC(i1), DstParamData%BStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%NStC)) THEN
  i1_l = LBOUND(SrcParamData%NStC,1)
  i1_u = UBOUND(SrcParamData%NStC,1)
  IF (.NOT. ALLOCATED(DstParamData%NStC)) THEN 
    ALLOCATE(DstParamData%NStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%NStC,1), UBOUND(SrcParamData%NStC,1)
      CALL StC_CopyParam( SrcParamData%NStC(i1), DstParamData%NStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%TStC)) THEN
  i1_l = LBOUND(SrcParamData%TStC,1)
  i1_u = UBOUND(SrcParamData%TStC,1)
  IF (.NOT. ALLOCATED(DstParamData%TStC)) THEN 
    ALLOCATE(DstParamData%TStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%TStC,1), UBOUND(SrcParamData%TStC,1)
      CALL StC_CopyParam( SrcParamData%TStC(i1), DstParamData%TStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%SStC)) THEN
  i1_l = LBOUND(SrcParamData%SStC,1)
  i1_u = UBOUND(SrcParamData%SStC,1)
  IF (.NOT. ALLOCATED(DstParamData%SStC)) THEN 
    ALLOCATE(DstParamData%SStC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%SStC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%SStC,1), UBOUND(SrcParamData%SStC,1)
      CALL StC_CopyParam( SrcParamData%SStC(i1), DstParamData%SStC(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%InterpOrder = SrcParamData%InterpOrder
    DstParamData%EXavrSWAP = SrcParamData%EXavrSWAP
    DstParamData%NumCableControl = SrcParamData%NumCableControl
    DstParamData%NumStC_Control = SrcParamData%NumStC_Control
IF (ALLOCATED(SrcParamData%StCMeasNumPerChan)) THEN
  i1_l = LBOUND(SrcParamData%StCMeasNumPerChan,1)
  i1_u = UBOUND(SrcParamData%StCMeasNumPerChan,1)
  IF (.NOT. ALLOCATED(DstParamData%StCMeasNumPerChan)) THEN 
    ALLOCATE(DstParamData%StCMeasNumPerChan(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%StCMeasNumPerChan.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%StCMeasNumPerChan = SrcParamData%StCMeasNumPerChan
ENDIF
    DstParamData%UseSC = SrcParamData%UseSC
IF (ALLOCATED(SrcParamData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcParamData%Jac_u_indx,1)
  i1_u = UBOUND(SrcParamData%Jac_u_indx,1)
  i2_l = LBOUND(SrcParamData%Jac_u_indx,2)
  i2_u = UBOUND(SrcParamData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_u_indx)) THEN 
    ALLOCATE(DstParamData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_u_indx = SrcParamData%Jac_u_indx
ENDIF
IF (ALLOCATED(SrcParamData%Jac_x_indx)) THEN
  i1_l = LBOUND(SrcParamData%Jac_x_indx,1)
  i1_u = UBOUND(SrcParamData%Jac_x_indx,1)
  i2_l = LBOUND(SrcParamData%Jac_x_indx,2)
  i2_u = UBOUND(SrcParamData%Jac_x_indx,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_x_indx)) THEN 
    ALLOCATE(DstParamData%Jac_x_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_x_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_x_indx = SrcParamData%Jac_x_indx
ENDIF
IF (ALLOCATED(SrcParamData%du)) THEN
  i1_l = LBOUND(SrcParamData%du,1)
  i1_u = UBOUND(SrcParamData%du,1)
  IF (.NOT. ALLOCATED(DstParamData%du)) THEN 
    ALLOCATE(DstParamData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%du.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%du = SrcParamData%du
ENDIF
IF (ALLOCATED(SrcParamData%dx)) THEN
  i1_l = LBOUND(SrcParamData%dx,1)
  i1_u = UBOUND(SrcParamData%dx,1)
  IF (.NOT. ALLOCATED(DstParamData%dx)) THEN 
    ALLOCATE(DstParamData%dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dx = SrcParamData%dx
ENDIF
    DstParamData%Jac_nu = SrcParamData%Jac_nu
    DstParamData%Jac_ny = SrcParamData%Jac_ny
    DstParamData%Jac_nx = SrcParamData%Jac_nx
IF (ALLOCATED(SrcParamData%Jac_Idx_BStC_u)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_BStC_u,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_BStC_u,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_BStC_u,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_BStC_u,2)
  i3_l = LBOUND(SrcParamData%Jac_Idx_BStC_u,3)
  i3_u = UBOUND(SrcParamData%Jac_Idx_BStC_u,3)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_BStC_u)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_BStC_u(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_BStC_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_BStC_u = SrcParamData%Jac_Idx_BStC_u
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_NStC_u)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_NStC_u,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_NStC_u,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_NStC_u,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_NStC_u,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_NStC_u)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_NStC_u(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_NStC_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_NStC_u = SrcParamData%Jac_Idx_NStC_u
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_TStC_u)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_TStC_u,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_TStC_u,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_TStC_u,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_TStC_u,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_TStC_u)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_TStC_u(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_TStC_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_TStC_u = SrcParamData%Jac_Idx_TStC_u
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_SStC_u)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_SStC_u,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_SStC_u,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_SStC_u,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_SStC_u,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_SStC_u)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_SStC_u(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_SStC_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_SStC_u = SrcParamData%Jac_Idx_SStC_u
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_BStC_x)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_BStC_x,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_BStC_x,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_BStC_x,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_BStC_x,2)
  i3_l = LBOUND(SrcParamData%Jac_Idx_BStC_x,3)
  i3_u = UBOUND(SrcParamData%Jac_Idx_BStC_x,3)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_BStC_x)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_BStC_x(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_BStC_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_BStC_x = SrcParamData%Jac_Idx_BStC_x
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_NStC_x)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_NStC_x,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_NStC_x,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_NStC_x,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_NStC_x,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_NStC_x)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_NStC_x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_NStC_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_NStC_x = SrcParamData%Jac_Idx_NStC_x
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_TStC_x)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_TStC_x,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_TStC_x,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_TStC_x,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_TStC_x,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_TStC_x)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_TStC_x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_TStC_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_TStC_x = SrcParamData%Jac_Idx_TStC_x
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_SStC_x)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_SStC_x,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_SStC_x,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_SStC_x,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_SStC_x,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_SStC_x)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_SStC_x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_SStC_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_SStC_x = SrcParamData%Jac_Idx_SStC_x
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_BStC_y)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_BStC_y,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_BStC_y,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_BStC_y,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_BStC_y,2)
  i3_l = LBOUND(SrcParamData%Jac_Idx_BStC_y,3)
  i3_u = UBOUND(SrcParamData%Jac_Idx_BStC_y,3)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_BStC_y)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_BStC_y(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_BStC_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_BStC_y = SrcParamData%Jac_Idx_BStC_y
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_NStC_y)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_NStC_y,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_NStC_y,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_NStC_y,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_NStC_y,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_NStC_y)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_NStC_y(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_NStC_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_NStC_y = SrcParamData%Jac_Idx_NStC_y
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_TStC_y)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_TStC_y,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_TStC_y,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_TStC_y,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_TStC_y,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_TStC_y)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_TStC_y(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_TStC_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_TStC_y = SrcParamData%Jac_Idx_TStC_y
ENDIF
IF (ALLOCATED(SrcParamData%Jac_Idx_SStC_y)) THEN
  i1_l = LBOUND(SrcParamData%Jac_Idx_SStC_y,1)
  i1_u = UBOUND(SrcParamData%Jac_Idx_SStC_y,1)
  i2_l = LBOUND(SrcParamData%Jac_Idx_SStC_y,2)
  i2_u = UBOUND(SrcParamData%Jac_Idx_SStC_y,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_Idx_SStC_y)) THEN 
    ALLOCATE(DstParamData%Jac_Idx_SStC_y(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_Idx_SStC_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_Idx_SStC_y = SrcParamData%Jac_Idx_SStC_y
ENDIF
    DstParamData%SensorType = SrcParamData%SensorType
    DstParamData%NumBeam = SrcParamData%NumBeam
    DstParamData%NumPulseGate = SrcParamData%NumPulseGate
    DstParamData%PulseSpacing = SrcParamData%PulseSpacing
    DstParamData%URefLid = SrcParamData%URefLid
 END SUBROUTINE SrvD_CopyParam

 SUBROUTINE SrvD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SrvD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%BlPitchInit)) THEN
  DEALLOCATE(ParamData%BlPitchInit)
ENDIF
IF (ALLOCATED(ParamData%BlPitchF)) THEN
  DEALLOCATE(ParamData%BlPitchF)
ENDIF
IF (ALLOCATED(ParamData%PitManRat)) THEN
  DEALLOCATE(ParamData%PitManRat)
ENDIF
IF (ALLOCATED(ParamData%TPitManS)) THEN
  DEALLOCATE(ParamData%TPitManS)
ENDIF
IF (ALLOCATED(ParamData%TBDepISp)) THEN
  DEALLOCATE(ParamData%TBDepISp)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( ParamData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
  CALL FreeDynamicLib( ParamData%DLL_Trgt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ParamData%BStC)) THEN
DO i1 = LBOUND(ParamData%BStC,1), UBOUND(ParamData%BStC,1)
  CALL StC_DestroyParam( ParamData%BStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%BStC)
ENDIF
IF (ALLOCATED(ParamData%NStC)) THEN
DO i1 = LBOUND(ParamData%NStC,1), UBOUND(ParamData%NStC,1)
  CALL StC_DestroyParam( ParamData%NStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%NStC)
ENDIF
IF (ALLOCATED(ParamData%TStC)) THEN
DO i1 = LBOUND(ParamData%TStC,1), UBOUND(ParamData%TStC,1)
  CALL StC_DestroyParam( ParamData%TStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%TStC)
ENDIF
IF (ALLOCATED(ParamData%SStC)) THEN
DO i1 = LBOUND(ParamData%SStC,1), UBOUND(ParamData%SStC,1)
  CALL StC_DestroyParam( ParamData%SStC(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%SStC)
ENDIF
IF (ALLOCATED(ParamData%StCMeasNumPerChan)) THEN
  DEALLOCATE(ParamData%StCMeasNumPerChan)
ENDIF
IF (ALLOCATED(ParamData%Jac_u_indx)) THEN
  DEALLOCATE(ParamData%Jac_u_indx)
ENDIF
IF (ALLOCATED(ParamData%Jac_x_indx)) THEN
  DEALLOCATE(ParamData%Jac_x_indx)
ENDIF
IF (ALLOCATED(ParamData%du)) THEN
  DEALLOCATE(ParamData%du)
ENDIF
IF (ALLOCATED(ParamData%dx)) THEN
  DEALLOCATE(ParamData%dx)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_BStC_u)) THEN
  DEALLOCATE(ParamData%Jac_Idx_BStC_u)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_NStC_u)) THEN
  DEALLOCATE(ParamData%Jac_Idx_NStC_u)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_TStC_u)) THEN
  DEALLOCATE(ParamData%Jac_Idx_TStC_u)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_SStC_u)) THEN
  DEALLOCATE(ParamData%Jac_Idx_SStC_u)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_BStC_x)) THEN
  DEALLOCATE(ParamData%Jac_Idx_BStC_x)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_NStC_x)) THEN
  DEALLOCATE(ParamData%Jac_Idx_NStC_x)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_TStC_x)) THEN
  DEALLOCATE(ParamData%Jac_Idx_TStC_x)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_SStC_x)) THEN
  DEALLOCATE(ParamData%Jac_Idx_SStC_x)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_BStC_y)) THEN
  DEALLOCATE(ParamData%Jac_Idx_BStC_y)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_NStC_y)) THEN
  DEALLOCATE(ParamData%Jac_Idx_NStC_y)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_TStC_y)) THEN
  DEALLOCATE(ParamData%Jac_Idx_TStC_y)
ENDIF
IF (ALLOCATED(ParamData%Jac_Idx_SStC_y)) THEN
  DEALLOCATE(ParamData%Jac_Idx_SStC_y)
ENDIF
 END SUBROUTINE SrvD_DestroyParam


subroutine SrvD_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackParam'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrDT
   call RegPack(Buf, InData%HSSBrDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTqF
   call RegPack(Buf, InData%HSSBrTqF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_POSl
   call RegPack(Buf, InData%SIG_POSl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_POTq
   call RegPack(Buf, InData%SIG_POTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SlPc
   call RegPack(Buf, InData%SIG_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_Slop
   call RegPack(Buf, InData%SIG_Slop)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SySp
   call RegPack(Buf, InData%SIG_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_A0
   call RegPack(Buf, InData%TEC_A0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_C0
   call RegPack(Buf, InData%TEC_C0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_C1
   call RegPack(Buf, InData%TEC_C1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_C2
   call RegPack(Buf, InData%TEC_C2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_K2
   call RegPack(Buf, InData%TEC_K2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_MR
   call RegPack(Buf, InData%TEC_MR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_Re1
   call RegPack(Buf, InData%TEC_Re1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RLR
   call RegPack(Buf, InData%TEC_RLR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RRes
   call RegPack(Buf, InData%TEC_RRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SRes
   call RegPack(Buf, InData%TEC_SRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SySp
   call RegPack(Buf, InData%TEC_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_V1a
   call RegPack(Buf, InData%TEC_V1a)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_VLL
   call RegPack(Buf, InData%TEC_VLL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_Xe1
   call RegPack(Buf, InData%TEC_Xe1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenEff
   call RegPack(Buf, InData%GenEff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchInit
   call RegPack(Buf, allocated(InData%BlPitchInit))
   if (allocated(InData%BlPitchInit)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitchInit), ubound(InData%BlPitchInit))
      call RegPack(Buf, InData%BlPitchInit)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchF
   call RegPack(Buf, allocated(InData%BlPitchF))
   if (allocated(InData%BlPitchF)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitchF), ubound(InData%BlPitchF))
      call RegPack(Buf, InData%BlPitchF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PitManRat
   call RegPack(Buf, allocated(InData%PitManRat))
   if (allocated(InData%PitManRat)) then
      call RegPackBounds(Buf, 1, lbound(InData%PitManRat), ubound(InData%PitManRat))
      call RegPack(Buf, InData%PitManRat)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawManRat
   call RegPack(Buf, InData%YawManRat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYawF
   call RegPack(Buf, InData%NacYawF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdGenOn
   call RegPack(Buf, InData%SpdGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! THSSBrDp
   call RegPack(Buf, InData%THSSBrDp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! THSSBrFl
   call RegPack(Buf, InData%THSSBrFl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOf
   call RegPack(Buf, InData%TimGenOf)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOn
   call RegPack(Buf, InData%TimGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPCOn
   call RegPack(Buf, InData%TPCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPitManS
   call RegPack(Buf, allocated(InData%TPitManS))
   if (allocated(InData%TPitManS)) then
      call RegPackBounds(Buf, 1, lbound(InData%TPitManS), ubound(InData%TPitManS))
      call RegPack(Buf, InData%TPitManS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYawManS
   call RegPack(Buf, InData%TYawManS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYCOn
   call RegPack(Buf, InData%TYCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtGnSp
   call RegPack(Buf, InData%VS_RtGnSp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtTq
   call RegPack(Buf, InData%VS_RtTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_Slope
   call RegPack(Buf, InData%VS_Slope)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_SlPc
   call RegPack(Buf, InData%VS_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_SySp
   call RegPack(Buf, InData%VS_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_TrGnSp
   call RegPack(Buf, InData%VS_TrGnSp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawPosCom
   call RegPack(Buf, InData%YawPosCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRateCom
   call RegPack(Buf, InData%YawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenModel
   call RegPack(Buf, InData%GenModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrMode
   call RegPack(Buf, InData%HSSBrMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCMode
   call RegPack(Buf, InData%PCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VSContrl
   call RegPack(Buf, InData%VSContrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YCMode
   call RegPack(Buf, InData%YCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStp
   call RegPack(Buf, InData%GenTiStp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStr
   call RegPack(Buf, InData%GenTiStr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_Rgn2K
   call RegPack(Buf, InData%VS_Rgn2K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawNeut
   call RegPack(Buf, InData%YawNeut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawSpr
   call RegPack(Buf, InData%YawSpr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawDamp
   call RegPack(Buf, InData%YawDamp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TpBrDT
   call RegPack(Buf, InData%TpBrDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDepISp
   call RegPack(Buf, allocated(InData%TBDepISp))
   if (allocated(InData%TBDepISp)) then
      call RegPackBounds(Buf, 1, lbound(InData%TBDepISp), ubound(InData%TBDepISp))
      call RegPack(Buf, InData%TBDepISp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDrConN
   call RegPack(Buf, InData%TBDrConN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDrConD
   call RegPack(Buf, InData%TBDrConD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegPack(Buf, InData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBStC
   call RegPack(Buf, InData%NumBStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumNStC
   call RegPack(Buf, InData%NumNStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTStC
   call RegPack(Buf, InData%NumTStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSStC
   call RegPack(Buf, InData%NumSStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfCmode
   call RegPack(Buf, InData%AfCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Mean
   call RegPack(Buf, InData%AfC_Mean)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Amp
   call RegPack(Buf, InData%AfC_Amp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Phase
   call RegPack(Buf, InData%AfC_Phase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CCmode
   call RegPack(Buf, InData%CCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCCmode
   call RegPack(Buf, InData%StCCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts_DLL
   call RegPack(Buf, InData%NumOuts_DLL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseBladedInterface
   call RegPack(Buf, InData%UseBladedInterface)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseLegacyInterface
   call RegPack(Buf, InData%UseLegacyInterface)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_Trgt
   call DLLTypePack(Buf, InData%DLL_Trgt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_Ramp
   call RegPack(Buf, InData%DLL_Ramp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAlpha
   call RegPack(Buf, InData%BlAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_n
   call RegPack(Buf, InData%DLL_n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! avcOUTNAME_LEN
   call RegPack(Buf, InData%avcOUTNAME_LEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYaw_North
   call RegPack(Buf, InData%NacYaw_North)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgWindSpeed
   call RegPack(Buf, InData%AvgWindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimCase
   call RegPack(Buf, InData%TrimCase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimGain
   call RegPack(Buf, InData%TrimGain)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeedRef
   call RegPack(Buf, InData%RotSpeedRef)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   call RegPack(Buf, allocated(InData%BStC))
   if (allocated(InData%BStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BStC), ubound(InData%BStC))
      LB(1:1) = lbound(InData%BStC)
      UB(1:1) = ubound(InData%BStC)
      do i1 = LB(1), UB(1)
         call StC_PackParam(Buf, InData%BStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC
   call RegPack(Buf, allocated(InData%NStC))
   if (allocated(InData%NStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC), ubound(InData%NStC))
      LB(1:1) = lbound(InData%NStC)
      UB(1:1) = ubound(InData%NStC)
      do i1 = LB(1), UB(1)
         call StC_PackParam(Buf, InData%NStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC
   call RegPack(Buf, allocated(InData%TStC))
   if (allocated(InData%TStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC), ubound(InData%TStC))
      LB(1:1) = lbound(InData%TStC)
      UB(1:1) = ubound(InData%TStC)
      do i1 = LB(1), UB(1)
         call StC_PackParam(Buf, InData%TStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC
   call RegPack(Buf, allocated(InData%SStC))
   if (allocated(InData%SStC)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC), ubound(InData%SStC))
      LB(1:1) = lbound(InData%SStC)
      UB(1:1) = ubound(InData%SStC)
      do i1 = LB(1), UB(1)
         call StC_PackParam(Buf, InData%SStC(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InterpOrder
   call RegPack(Buf, InData%InterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EXavrSWAP
   call RegPack(Buf, InData%EXavrSWAP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCableControl
   call RegPack(Buf, InData%NumCableControl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumStC_Control
   call RegPack(Buf, InData%NumStC_Control)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCMeasNumPerChan
   call RegPack(Buf, allocated(InData%StCMeasNumPerChan))
   if (allocated(InData%StCMeasNumPerChan)) then
      call RegPackBounds(Buf, 1, lbound(InData%StCMeasNumPerChan), ubound(InData%StCMeasNumPerChan))
      call RegPack(Buf, InData%StCMeasNumPerChan)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseSC
   call RegPack(Buf, InData%UseSC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_x_indx
   call RegPack(Buf, allocated(InData%Jac_x_indx))
   if (allocated(InData%Jac_x_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_x_indx), ubound(InData%Jac_x_indx))
      call RegPack(Buf, InData%Jac_x_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! du
   call RegPack(Buf, allocated(InData%du))
   if (allocated(InData%du)) then
      call RegPackBounds(Buf, 1, lbound(InData%du), ubound(InData%du))
      call RegPack(Buf, InData%du)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegPack(Buf, allocated(InData%dx))
   if (allocated(InData%dx)) then
      call RegPackBounds(Buf, 1, lbound(InData%dx), ubound(InData%dx))
      call RegPack(Buf, InData%dx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nu
   call RegPack(Buf, InData%Jac_nu)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegPack(Buf, InData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nx
   call RegPack(Buf, InData%Jac_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_BStC_u
   call RegPack(Buf, allocated(InData%Jac_Idx_BStC_u))
   if (allocated(InData%Jac_Idx_BStC_u)) then
      call RegPackBounds(Buf, 3, lbound(InData%Jac_Idx_BStC_u), ubound(InData%Jac_Idx_BStC_u))
      call RegPack(Buf, InData%Jac_Idx_BStC_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_NStC_u
   call RegPack(Buf, allocated(InData%Jac_Idx_NStC_u))
   if (allocated(InData%Jac_Idx_NStC_u)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_NStC_u), ubound(InData%Jac_Idx_NStC_u))
      call RegPack(Buf, InData%Jac_Idx_NStC_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_TStC_u
   call RegPack(Buf, allocated(InData%Jac_Idx_TStC_u))
   if (allocated(InData%Jac_Idx_TStC_u)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_TStC_u), ubound(InData%Jac_Idx_TStC_u))
      call RegPack(Buf, InData%Jac_Idx_TStC_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_SStC_u
   call RegPack(Buf, allocated(InData%Jac_Idx_SStC_u))
   if (allocated(InData%Jac_Idx_SStC_u)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_SStC_u), ubound(InData%Jac_Idx_SStC_u))
      call RegPack(Buf, InData%Jac_Idx_SStC_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_BStC_x
   call RegPack(Buf, allocated(InData%Jac_Idx_BStC_x))
   if (allocated(InData%Jac_Idx_BStC_x)) then
      call RegPackBounds(Buf, 3, lbound(InData%Jac_Idx_BStC_x), ubound(InData%Jac_Idx_BStC_x))
      call RegPack(Buf, InData%Jac_Idx_BStC_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_NStC_x
   call RegPack(Buf, allocated(InData%Jac_Idx_NStC_x))
   if (allocated(InData%Jac_Idx_NStC_x)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_NStC_x), ubound(InData%Jac_Idx_NStC_x))
      call RegPack(Buf, InData%Jac_Idx_NStC_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_TStC_x
   call RegPack(Buf, allocated(InData%Jac_Idx_TStC_x))
   if (allocated(InData%Jac_Idx_TStC_x)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_TStC_x), ubound(InData%Jac_Idx_TStC_x))
      call RegPack(Buf, InData%Jac_Idx_TStC_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_SStC_x
   call RegPack(Buf, allocated(InData%Jac_Idx_SStC_x))
   if (allocated(InData%Jac_Idx_SStC_x)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_SStC_x), ubound(InData%Jac_Idx_SStC_x))
      call RegPack(Buf, InData%Jac_Idx_SStC_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_BStC_y
   call RegPack(Buf, allocated(InData%Jac_Idx_BStC_y))
   if (allocated(InData%Jac_Idx_BStC_y)) then
      call RegPackBounds(Buf, 3, lbound(InData%Jac_Idx_BStC_y), ubound(InData%Jac_Idx_BStC_y))
      call RegPack(Buf, InData%Jac_Idx_BStC_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_NStC_y
   call RegPack(Buf, allocated(InData%Jac_Idx_NStC_y))
   if (allocated(InData%Jac_Idx_NStC_y)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_NStC_y), ubound(InData%Jac_Idx_NStC_y))
      call RegPack(Buf, InData%Jac_Idx_NStC_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_TStC_y
   call RegPack(Buf, allocated(InData%Jac_Idx_TStC_y))
   if (allocated(InData%Jac_Idx_TStC_y)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_TStC_y), ubound(InData%Jac_Idx_TStC_y))
      call RegPack(Buf, InData%Jac_Idx_TStC_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_SStC_y
   call RegPack(Buf, allocated(InData%Jac_Idx_SStC_y))
   if (allocated(InData%Jac_Idx_SStC_y)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_Idx_SStC_y), ubound(InData%Jac_Idx_SStC_y))
      call RegPack(Buf, InData%Jac_Idx_SStC_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegPack(Buf, InData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegPack(Buf, InData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegPack(Buf, InData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegPack(Buf, InData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegPack(Buf, InData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackParam'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrDT
   call RegUnpack(Buf, OutData%HSSBrDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTqF
   call RegUnpack(Buf, OutData%HSSBrTqF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_POSl
   call RegUnpack(Buf, OutData%SIG_POSl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_POTq
   call RegUnpack(Buf, OutData%SIG_POTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SlPc
   call RegUnpack(Buf, OutData%SIG_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_Slop
   call RegUnpack(Buf, OutData%SIG_Slop)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIG_SySp
   call RegUnpack(Buf, OutData%SIG_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_A0
   call RegUnpack(Buf, OutData%TEC_A0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_C0
   call RegUnpack(Buf, OutData%TEC_C0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_C1
   call RegUnpack(Buf, OutData%TEC_C1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_C2
   call RegUnpack(Buf, OutData%TEC_C2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_K2
   call RegUnpack(Buf, OutData%TEC_K2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_MR
   call RegUnpack(Buf, OutData%TEC_MR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_Re1
   call RegUnpack(Buf, OutData%TEC_Re1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RLR
   call RegUnpack(Buf, OutData%TEC_RLR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_RRes
   call RegUnpack(Buf, OutData%TEC_RRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SRes
   call RegUnpack(Buf, OutData%TEC_SRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_SySp
   call RegUnpack(Buf, OutData%TEC_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_V1a
   call RegUnpack(Buf, OutData%TEC_V1a)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_VLL
   call RegUnpack(Buf, OutData%TEC_VLL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TEC_Xe1
   call RegUnpack(Buf, OutData%TEC_Xe1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenEff
   call RegUnpack(Buf, OutData%GenEff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchInit
   if (allocated(OutData%BlPitchInit)) deallocate(OutData%BlPitchInit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitchInit(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitchInit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitchInit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlPitchF
   if (allocated(OutData%BlPitchF)) deallocate(OutData%BlPitchF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitchF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitchF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitchF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PitManRat
   if (allocated(OutData%PitManRat)) deallocate(OutData%PitManRat)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PitManRat(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PitManRat.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PitManRat)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! YawManRat
   call RegUnpack(Buf, OutData%YawManRat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYawF
   call RegUnpack(Buf, OutData%NacYawF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdGenOn
   call RegUnpack(Buf, OutData%SpdGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! THSSBrDp
   call RegUnpack(Buf, OutData%THSSBrDp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! THSSBrFl
   call RegUnpack(Buf, OutData%THSSBrFl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOf
   call RegUnpack(Buf, OutData%TimGenOf)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimGenOn
   call RegUnpack(Buf, OutData%TimGenOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPCOn
   call RegUnpack(Buf, OutData%TPCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TPitManS
   if (allocated(OutData%TPitManS)) deallocate(OutData%TPitManS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TPitManS(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TPitManS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TPitManS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TYawManS
   call RegUnpack(Buf, OutData%TYawManS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TYCOn
   call RegUnpack(Buf, OutData%TYCOn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtGnSp
   call RegUnpack(Buf, OutData%VS_RtGnSp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_RtTq
   call RegUnpack(Buf, OutData%VS_RtTq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_Slope
   call RegUnpack(Buf, OutData%VS_Slope)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_SlPc
   call RegUnpack(Buf, OutData%VS_SlPc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_SySp
   call RegUnpack(Buf, OutData%VS_SySp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_TrGnSp
   call RegUnpack(Buf, OutData%VS_TrGnSp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawPosCom
   call RegUnpack(Buf, OutData%YawPosCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRateCom
   call RegUnpack(Buf, OutData%YawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenModel
   call RegUnpack(Buf, OutData%GenModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrMode
   call RegUnpack(Buf, OutData%HSSBrMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCMode
   call RegUnpack(Buf, OutData%PCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VSContrl
   call RegUnpack(Buf, OutData%VSContrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YCMode
   call RegUnpack(Buf, OutData%YCMode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStp
   call RegUnpack(Buf, OutData%GenTiStp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTiStr
   call RegUnpack(Buf, OutData%GenTiStr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VS_Rgn2K
   call RegUnpack(Buf, OutData%VS_Rgn2K)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawNeut
   call RegUnpack(Buf, OutData%YawNeut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawSpr
   call RegUnpack(Buf, OutData%YawSpr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawDamp
   call RegUnpack(Buf, OutData%YawDamp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TpBrDT
   call RegUnpack(Buf, OutData%TpBrDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDepISp
   if (allocated(OutData%TBDepISp)) deallocate(OutData%TBDepISp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TBDepISp(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TBDepISp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TBDepISp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TBDrConN
   call RegUnpack(Buf, OutData%TBDrConN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDrConD
   call RegUnpack(Buf, OutData%TBDrConD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegUnpack(Buf, OutData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBStC
   call RegUnpack(Buf, OutData%NumBStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumNStC
   call RegUnpack(Buf, OutData%NumNStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTStC
   call RegUnpack(Buf, OutData%NumTStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSStC
   call RegUnpack(Buf, OutData%NumSStC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfCmode
   call RegUnpack(Buf, OutData%AfCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Mean
   call RegUnpack(Buf, OutData%AfC_Mean)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Amp
   call RegUnpack(Buf, OutData%AfC_Amp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AfC_Phase
   call RegUnpack(Buf, OutData%AfC_Phase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CCmode
   call RegUnpack(Buf, OutData%CCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCCmode
   call RegUnpack(Buf, OutData%StCCmode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts_DLL
   call RegUnpack(Buf, OutData%NumOuts_DLL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseBladedInterface
   call RegUnpack(Buf, OutData%UseBladedInterface)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseLegacyInterface
   call RegUnpack(Buf, OutData%UseLegacyInterface)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_Trgt
   call DLLTypeUnpack(Buf, OutData%DLL_Trgt) ! DLL_Trgt 
   ! DLL_Ramp
   call RegUnpack(Buf, OutData%DLL_Ramp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAlpha
   call RegUnpack(Buf, OutData%BlAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DLL_n
   call RegUnpack(Buf, OutData%DLL_n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! avcOUTNAME_LEN
   call RegUnpack(Buf, OutData%avcOUTNAME_LEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacYaw_North
   call RegUnpack(Buf, OutData%NacYaw_North)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgWindSpeed
   call RegUnpack(Buf, OutData%AvgWindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimCase
   call RegUnpack(Buf, OutData%TrimCase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimGain
   call RegUnpack(Buf, OutData%TrimGain)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeedRef
   call RegUnpack(Buf, OutData%RotSpeedRef)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC
   if (allocated(OutData%BStC)) deallocate(OutData%BStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackParam(Buf, OutData%BStC(i1)) ! BStC 
      end do
   end if
   ! NStC
   if (allocated(OutData%NStC)) deallocate(OutData%NStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackParam(Buf, OutData%NStC(i1)) ! NStC 
      end do
   end if
   ! TStC
   if (allocated(OutData%TStC)) deallocate(OutData%TStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackParam(Buf, OutData%TStC(i1)) ! TStC 
      end do
   end if
   ! SStC
   if (allocated(OutData%SStC)) deallocate(OutData%SStC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call StC_UnpackParam(Buf, OutData%SStC(i1)) ! SStC 
      end do
   end if
   ! InterpOrder
   call RegUnpack(Buf, OutData%InterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EXavrSWAP
   call RegUnpack(Buf, OutData%EXavrSWAP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCableControl
   call RegUnpack(Buf, OutData%NumCableControl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumStC_Control
   call RegUnpack(Buf, OutData%NumStC_Control)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StCMeasNumPerChan
   if (allocated(OutData%StCMeasNumPerChan)) deallocate(OutData%StCMeasNumPerChan)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StCMeasNumPerChan(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StCMeasNumPerChan.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StCMeasNumPerChan)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UseSC
   call RegUnpack(Buf, OutData%UseSC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_x_indx
   if (allocated(OutData%Jac_x_indx)) deallocate(OutData%Jac_x_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_x_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_x_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_x_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! du
   if (allocated(OutData%du)) deallocate(OutData%du)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%du(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%du)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dx
   if (allocated(OutData%dx)) deallocate(OutData%dx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_nu
   call RegUnpack(Buf, OutData%Jac_nu)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nx
   call RegUnpack(Buf, OutData%Jac_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_Idx_BStC_u
   if (allocated(OutData%Jac_Idx_BStC_u)) deallocate(OutData%Jac_Idx_BStC_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_BStC_u(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_BStC_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_BStC_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_NStC_u
   if (allocated(OutData%Jac_Idx_NStC_u)) deallocate(OutData%Jac_Idx_NStC_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_NStC_u(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_NStC_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_NStC_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_TStC_u
   if (allocated(OutData%Jac_Idx_TStC_u)) deallocate(OutData%Jac_Idx_TStC_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_TStC_u(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_TStC_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_TStC_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_SStC_u
   if (allocated(OutData%Jac_Idx_SStC_u)) deallocate(OutData%Jac_Idx_SStC_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_SStC_u(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_SStC_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_SStC_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_BStC_x
   if (allocated(OutData%Jac_Idx_BStC_x)) deallocate(OutData%Jac_Idx_BStC_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_BStC_x(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_BStC_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_BStC_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_NStC_x
   if (allocated(OutData%Jac_Idx_NStC_x)) deallocate(OutData%Jac_Idx_NStC_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_NStC_x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_NStC_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_NStC_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_TStC_x
   if (allocated(OutData%Jac_Idx_TStC_x)) deallocate(OutData%Jac_Idx_TStC_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_TStC_x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_TStC_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_TStC_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_SStC_x
   if (allocated(OutData%Jac_Idx_SStC_x)) deallocate(OutData%Jac_Idx_SStC_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_SStC_x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_SStC_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_SStC_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_BStC_y
   if (allocated(OutData%Jac_Idx_BStC_y)) deallocate(OutData%Jac_Idx_BStC_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_BStC_y(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_BStC_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_BStC_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_NStC_y
   if (allocated(OutData%Jac_Idx_NStC_y)) deallocate(OutData%Jac_Idx_NStC_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_NStC_y(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_NStC_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_NStC_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_TStC_y
   if (allocated(OutData%Jac_Idx_TStC_y)) deallocate(OutData%Jac_Idx_TStC_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_TStC_y(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_TStC_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_TStC_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_Idx_SStC_y
   if (allocated(OutData%Jac_Idx_SStC_y)) deallocate(OutData%Jac_Idx_SStC_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_Idx_SStC_y(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_Idx_SStC_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_Idx_SStC_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SensorType
   call RegUnpack(Buf, OutData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegUnpack(Buf, OutData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegUnpack(Buf, OutData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegUnpack(Buf, OutData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegUnpack(Buf, OutData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SrvD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(SrvD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%BlPitch)) THEN
  i1_l = LBOUND(SrcInputData%BlPitch,1)
  i1_u = UBOUND(SrcInputData%BlPitch,1)
  IF (.NOT. ALLOCATED(DstInputData%BlPitch)) THEN 
    ALLOCATE(DstInputData%BlPitch(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%BlPitch.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%BlPitch = SrcInputData%BlPitch
ENDIF
    DstInputData%Yaw = SrcInputData%Yaw
    DstInputData%YawRate = SrcInputData%YawRate
    DstInputData%LSS_Spd = SrcInputData%LSS_Spd
    DstInputData%HSS_Spd = SrcInputData%HSS_Spd
    DstInputData%RotSpeed = SrcInputData%RotSpeed
    DstInputData%ExternalYawPosCom = SrcInputData%ExternalYawPosCom
    DstInputData%ExternalYawRateCom = SrcInputData%ExternalYawRateCom
IF (ALLOCATED(SrcInputData%ExternalBlPitchCom)) THEN
  i1_l = LBOUND(SrcInputData%ExternalBlPitchCom,1)
  i1_u = UBOUND(SrcInputData%ExternalBlPitchCom,1)
  IF (.NOT. ALLOCATED(DstInputData%ExternalBlPitchCom)) THEN 
    ALLOCATE(DstInputData%ExternalBlPitchCom(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%ExternalBlPitchCom.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%ExternalBlPitchCom = SrcInputData%ExternalBlPitchCom
ENDIF
    DstInputData%ExternalGenTrq = SrcInputData%ExternalGenTrq
    DstInputData%ExternalElecPwr = SrcInputData%ExternalElecPwr
    DstInputData%ExternalHSSBrFrac = SrcInputData%ExternalHSSBrFrac
IF (ALLOCATED(SrcInputData%ExternalBlAirfoilCom)) THEN
  i1_l = LBOUND(SrcInputData%ExternalBlAirfoilCom,1)
  i1_u = UBOUND(SrcInputData%ExternalBlAirfoilCom,1)
  IF (.NOT. ALLOCATED(DstInputData%ExternalBlAirfoilCom)) THEN 
    ALLOCATE(DstInputData%ExternalBlAirfoilCom(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%ExternalBlAirfoilCom.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%ExternalBlAirfoilCom = SrcInputData%ExternalBlAirfoilCom
ENDIF
IF (ALLOCATED(SrcInputData%ExternalCableDeltaL)) THEN
  i1_l = LBOUND(SrcInputData%ExternalCableDeltaL,1)
  i1_u = UBOUND(SrcInputData%ExternalCableDeltaL,1)
  IF (.NOT. ALLOCATED(DstInputData%ExternalCableDeltaL)) THEN 
    ALLOCATE(DstInputData%ExternalCableDeltaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%ExternalCableDeltaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%ExternalCableDeltaL = SrcInputData%ExternalCableDeltaL
ENDIF
IF (ALLOCATED(SrcInputData%ExternalCableDeltaLdot)) THEN
  i1_l = LBOUND(SrcInputData%ExternalCableDeltaLdot,1)
  i1_u = UBOUND(SrcInputData%ExternalCableDeltaLdot,1)
  IF (.NOT. ALLOCATED(DstInputData%ExternalCableDeltaLdot)) THEN 
    ALLOCATE(DstInputData%ExternalCableDeltaLdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%ExternalCableDeltaLdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%ExternalCableDeltaLdot = SrcInputData%ExternalCableDeltaLdot
ENDIF
    DstInputData%TwrAccel = SrcInputData%TwrAccel
    DstInputData%YawErr = SrcInputData%YawErr
    DstInputData%WindDir = SrcInputData%WindDir
    DstInputData%RootMyc = SrcInputData%RootMyc
    DstInputData%YawBrTAxp = SrcInputData%YawBrTAxp
    DstInputData%YawBrTAyp = SrcInputData%YawBrTAyp
    DstInputData%LSSTipPxa = SrcInputData%LSSTipPxa
    DstInputData%RootMxc = SrcInputData%RootMxc
    DstInputData%LSSTipMxa = SrcInputData%LSSTipMxa
    DstInputData%LSSTipMya = SrcInputData%LSSTipMya
    DstInputData%LSSTipMza = SrcInputData%LSSTipMza
    DstInputData%LSSTipMys = SrcInputData%LSSTipMys
    DstInputData%LSSTipMzs = SrcInputData%LSSTipMzs
    DstInputData%YawBrMyn = SrcInputData%YawBrMyn
    DstInputData%YawBrMzn = SrcInputData%YawBrMzn
    DstInputData%NcIMURAxs = SrcInputData%NcIMURAxs
    DstInputData%NcIMURAys = SrcInputData%NcIMURAys
    DstInputData%NcIMURAzs = SrcInputData%NcIMURAzs
    DstInputData%RotPwr = SrcInputData%RotPwr
    DstInputData%HorWindV = SrcInputData%HorWindV
    DstInputData%YawAngle = SrcInputData%YawAngle
    DstInputData%LSShftFxa = SrcInputData%LSShftFxa
    DstInputData%LSShftFys = SrcInputData%LSShftFys
    DstInputData%LSShftFzs = SrcInputData%LSShftFzs
IF (ALLOCATED(SrcInputData%fromSC)) THEN
  i1_l = LBOUND(SrcInputData%fromSC,1)
  i1_u = UBOUND(SrcInputData%fromSC,1)
  IF (.NOT. ALLOCATED(DstInputData%fromSC)) THEN 
    ALLOCATE(DstInputData%fromSC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%fromSC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%fromSC = SrcInputData%fromSC
ENDIF
IF (ALLOCATED(SrcInputData%fromSCglob)) THEN
  i1_l = LBOUND(SrcInputData%fromSCglob,1)
  i1_u = UBOUND(SrcInputData%fromSCglob,1)
  IF (.NOT. ALLOCATED(DstInputData%fromSCglob)) THEN 
    ALLOCATE(DstInputData%fromSCglob(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%fromSCglob.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%fromSCglob = SrcInputData%fromSCglob
ENDIF
IF (ALLOCATED(SrcInputData%Lidar)) THEN
  i1_l = LBOUND(SrcInputData%Lidar,1)
  i1_u = UBOUND(SrcInputData%Lidar,1)
  IF (.NOT. ALLOCATED(DstInputData%Lidar)) THEN 
    ALLOCATE(DstInputData%Lidar(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Lidar.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Lidar = SrcInputData%Lidar
ENDIF
      CALL MeshCopy( SrcInputData%PtfmMotionMesh, DstInputData%PtfmMotionMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInputData%BStCMotionMesh)) THEN
  i1_l = LBOUND(SrcInputData%BStCMotionMesh,1)
  i1_u = UBOUND(SrcInputData%BStCMotionMesh,1)
  i2_l = LBOUND(SrcInputData%BStCMotionMesh,2)
  i2_u = UBOUND(SrcInputData%BStCMotionMesh,2)
  IF (.NOT. ALLOCATED(DstInputData%BStCMotionMesh)) THEN 
    ALLOCATE(DstInputData%BStCMotionMesh(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%BStCMotionMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcInputData%BStCMotionMesh,2), UBOUND(SrcInputData%BStCMotionMesh,2)
    DO i1 = LBOUND(SrcInputData%BStCMotionMesh,1), UBOUND(SrcInputData%BStCMotionMesh,1)
      CALL MeshCopy( SrcInputData%BStCMotionMesh(i1,i2), DstInputData%BStCMotionMesh(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%NStCMotionMesh)) THEN
  i1_l = LBOUND(SrcInputData%NStCMotionMesh,1)
  i1_u = UBOUND(SrcInputData%NStCMotionMesh,1)
  IF (.NOT. ALLOCATED(DstInputData%NStCMotionMesh)) THEN 
    ALLOCATE(DstInputData%NStCMotionMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%NStCMotionMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%NStCMotionMesh,1), UBOUND(SrcInputData%NStCMotionMesh,1)
      CALL MeshCopy( SrcInputData%NStCMotionMesh(i1), DstInputData%NStCMotionMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%TStCMotionMesh)) THEN
  i1_l = LBOUND(SrcInputData%TStCMotionMesh,1)
  i1_u = UBOUND(SrcInputData%TStCMotionMesh,1)
  IF (.NOT. ALLOCATED(DstInputData%TStCMotionMesh)) THEN 
    ALLOCATE(DstInputData%TStCMotionMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%TStCMotionMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%TStCMotionMesh,1), UBOUND(SrcInputData%TStCMotionMesh,1)
      CALL MeshCopy( SrcInputData%TStCMotionMesh(i1), DstInputData%TStCMotionMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%SStCMotionMesh)) THEN
  i1_l = LBOUND(SrcInputData%SStCMotionMesh,1)
  i1_u = UBOUND(SrcInputData%SStCMotionMesh,1)
  IF (.NOT. ALLOCATED(DstInputData%SStCMotionMesh)) THEN 
    ALLOCATE(DstInputData%SStCMotionMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%SStCMotionMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%SStCMotionMesh,1), UBOUND(SrcInputData%SStCMotionMesh,1)
      CALL MeshCopy( SrcInputData%SStCMotionMesh(i1), DstInputData%SStCMotionMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%LidSpeed)) THEN
  i1_l = LBOUND(SrcInputData%LidSpeed,1)
  i1_u = UBOUND(SrcInputData%LidSpeed,1)
  IF (.NOT. ALLOCATED(DstInputData%LidSpeed)) THEN 
    ALLOCATE(DstInputData%LidSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%LidSpeed.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%LidSpeed = SrcInputData%LidSpeed
ENDIF
IF (ALLOCATED(SrcInputData%MsrPositionsX)) THEN
  i1_l = LBOUND(SrcInputData%MsrPositionsX,1)
  i1_u = UBOUND(SrcInputData%MsrPositionsX,1)
  IF (.NOT. ALLOCATED(DstInputData%MsrPositionsX)) THEN 
    ALLOCATE(DstInputData%MsrPositionsX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MsrPositionsX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%MsrPositionsX = SrcInputData%MsrPositionsX
ENDIF
IF (ALLOCATED(SrcInputData%MsrPositionsY)) THEN
  i1_l = LBOUND(SrcInputData%MsrPositionsY,1)
  i1_u = UBOUND(SrcInputData%MsrPositionsY,1)
  IF (.NOT. ALLOCATED(DstInputData%MsrPositionsY)) THEN 
    ALLOCATE(DstInputData%MsrPositionsY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MsrPositionsY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%MsrPositionsY = SrcInputData%MsrPositionsY
ENDIF
IF (ALLOCATED(SrcInputData%MsrPositionsZ)) THEN
  i1_l = LBOUND(SrcInputData%MsrPositionsZ,1)
  i1_u = UBOUND(SrcInputData%MsrPositionsZ,1)
  IF (.NOT. ALLOCATED(DstInputData%MsrPositionsZ)) THEN 
    ALLOCATE(DstInputData%MsrPositionsZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MsrPositionsZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%MsrPositionsZ = SrcInputData%MsrPositionsZ
ENDIF
 END SUBROUTINE SrvD_CopyInput

 SUBROUTINE SrvD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SrvD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%BlPitch)) THEN
  DEALLOCATE(InputData%BlPitch)
ENDIF
IF (ALLOCATED(InputData%ExternalBlPitchCom)) THEN
  DEALLOCATE(InputData%ExternalBlPitchCom)
ENDIF
IF (ALLOCATED(InputData%ExternalBlAirfoilCom)) THEN
  DEALLOCATE(InputData%ExternalBlAirfoilCom)
ENDIF
IF (ALLOCATED(InputData%ExternalCableDeltaL)) THEN
  DEALLOCATE(InputData%ExternalCableDeltaL)
ENDIF
IF (ALLOCATED(InputData%ExternalCableDeltaLdot)) THEN
  DEALLOCATE(InputData%ExternalCableDeltaLdot)
ENDIF
IF (ALLOCATED(InputData%fromSC)) THEN
  DEALLOCATE(InputData%fromSC)
ENDIF
IF (ALLOCATED(InputData%fromSCglob)) THEN
  DEALLOCATE(InputData%fromSCglob)
ENDIF
IF (ALLOCATED(InputData%Lidar)) THEN
  DEALLOCATE(InputData%Lidar)
ENDIF
  CALL MeshDestroy( InputData%PtfmMotionMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InputData%BStCMotionMesh)) THEN
DO i2 = LBOUND(InputData%BStCMotionMesh,2), UBOUND(InputData%BStCMotionMesh,2)
DO i1 = LBOUND(InputData%BStCMotionMesh,1), UBOUND(InputData%BStCMotionMesh,1)
  CALL MeshDestroy( InputData%BStCMotionMesh(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(InputData%BStCMotionMesh)
ENDIF
IF (ALLOCATED(InputData%NStCMotionMesh)) THEN
DO i1 = LBOUND(InputData%NStCMotionMesh,1), UBOUND(InputData%NStCMotionMesh,1)
  CALL MeshDestroy( InputData%NStCMotionMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%NStCMotionMesh)
ENDIF
IF (ALLOCATED(InputData%TStCMotionMesh)) THEN
DO i1 = LBOUND(InputData%TStCMotionMesh,1), UBOUND(InputData%TStCMotionMesh,1)
  CALL MeshDestroy( InputData%TStCMotionMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%TStCMotionMesh)
ENDIF
IF (ALLOCATED(InputData%SStCMotionMesh)) THEN
DO i1 = LBOUND(InputData%SStCMotionMesh,1), UBOUND(InputData%SStCMotionMesh,1)
  CALL MeshDestroy( InputData%SStCMotionMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%SStCMotionMesh)
ENDIF
IF (ALLOCATED(InputData%LidSpeed)) THEN
  DEALLOCATE(InputData%LidSpeed)
ENDIF
IF (ALLOCATED(InputData%MsrPositionsX)) THEN
  DEALLOCATE(InputData%MsrPositionsX)
ENDIF
IF (ALLOCATED(InputData%MsrPositionsY)) THEN
  DEALLOCATE(InputData%MsrPositionsY)
ENDIF
IF (ALLOCATED(InputData%MsrPositionsZ)) THEN
  DEALLOCATE(InputData%MsrPositionsZ)
ENDIF
 END SUBROUTINE SrvD_DestroyInput


subroutine SrvD_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! BlPitch
   call RegPack(Buf, allocated(InData%BlPitch))
   if (allocated(InData%BlPitch)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitch), ubound(InData%BlPitch))
      call RegPack(Buf, InData%BlPitch)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Yaw
   call RegPack(Buf, InData%Yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRate
   call RegPack(Buf, InData%YawRate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSS_Spd
   call RegPack(Buf, InData%LSS_Spd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSS_Spd
   call RegPack(Buf, InData%HSS_Spd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeed
   call RegPack(Buf, InData%RotSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalYawPosCom
   call RegPack(Buf, InData%ExternalYawPosCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalYawRateCom
   call RegPack(Buf, InData%ExternalYawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalBlPitchCom
   call RegPack(Buf, allocated(InData%ExternalBlPitchCom))
   if (allocated(InData%ExternalBlPitchCom)) then
      call RegPackBounds(Buf, 1, lbound(InData%ExternalBlPitchCom), ubound(InData%ExternalBlPitchCom))
      call RegPack(Buf, InData%ExternalBlPitchCom)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalGenTrq
   call RegPack(Buf, InData%ExternalGenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalElecPwr
   call RegPack(Buf, InData%ExternalElecPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalHSSBrFrac
   call RegPack(Buf, InData%ExternalHSSBrFrac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalBlAirfoilCom
   call RegPack(Buf, allocated(InData%ExternalBlAirfoilCom))
   if (allocated(InData%ExternalBlAirfoilCom)) then
      call RegPackBounds(Buf, 1, lbound(InData%ExternalBlAirfoilCom), ubound(InData%ExternalBlAirfoilCom))
      call RegPack(Buf, InData%ExternalBlAirfoilCom)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalCableDeltaL
   call RegPack(Buf, allocated(InData%ExternalCableDeltaL))
   if (allocated(InData%ExternalCableDeltaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%ExternalCableDeltaL), ubound(InData%ExternalCableDeltaL))
      call RegPack(Buf, InData%ExternalCableDeltaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalCableDeltaLdot
   call RegPack(Buf, allocated(InData%ExternalCableDeltaLdot))
   if (allocated(InData%ExternalCableDeltaLdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%ExternalCableDeltaLdot), ubound(InData%ExternalCableDeltaLdot))
      call RegPack(Buf, InData%ExternalCableDeltaLdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrAccel
   call RegPack(Buf, InData%TwrAccel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr
   call RegPack(Buf, InData%YawErr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindDir
   call RegPack(Buf, InData%WindDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMyc
   call RegPack(Buf, InData%RootMyc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAxp
   call RegPack(Buf, InData%YawBrTAxp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAyp
   call RegPack(Buf, InData%YawBrTAyp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipPxa
   call RegPack(Buf, InData%LSSTipPxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMxc
   call RegPack(Buf, InData%RootMxc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMxa
   call RegPack(Buf, InData%LSSTipMxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMya
   call RegPack(Buf, InData%LSSTipMya)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMza
   call RegPack(Buf, InData%LSSTipMza)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMys
   call RegPack(Buf, InData%LSSTipMys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMzs
   call RegPack(Buf, InData%LSSTipMzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMyn
   call RegPack(Buf, InData%YawBrMyn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMzn
   call RegPack(Buf, InData%YawBrMzn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAxs
   call RegPack(Buf, InData%NcIMURAxs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAys
   call RegPack(Buf, InData%NcIMURAys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAzs
   call RegPack(Buf, InData%NcIMURAzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotPwr
   call RegPack(Buf, InData%RotPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HorWindV
   call RegPack(Buf, InData%HorWindV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawAngle
   call RegPack(Buf, InData%YawAngle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFxa
   call RegPack(Buf, InData%LSShftFxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFys
   call RegPack(Buf, InData%LSShftFys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFzs
   call RegPack(Buf, InData%LSShftFzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSC
   call RegPack(Buf, allocated(InData%fromSC))
   if (allocated(InData%fromSC)) then
      call RegPackBounds(Buf, 1, lbound(InData%fromSC), ubound(InData%fromSC))
      call RegPack(Buf, InData%fromSC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSCglob
   call RegPack(Buf, allocated(InData%fromSCglob))
   if (allocated(InData%fromSCglob)) then
      call RegPackBounds(Buf, 1, lbound(InData%fromSCglob), ubound(InData%fromSCglob))
      call RegPack(Buf, InData%fromSCglob)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lidar
   call RegPack(Buf, allocated(InData%Lidar))
   if (allocated(InData%Lidar)) then
      call RegPackBounds(Buf, 1, lbound(InData%Lidar), ubound(InData%Lidar))
      call RegPack(Buf, InData%Lidar)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmMotionMesh
   call MeshPack(Buf, InData%PtfmMotionMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStCMotionMesh
   call RegPack(Buf, allocated(InData%BStCMotionMesh))
   if (allocated(InData%BStCMotionMesh)) then
      call RegPackBounds(Buf, 2, lbound(InData%BStCMotionMesh), ubound(InData%BStCMotionMesh))
      LB(1:2) = lbound(InData%BStCMotionMesh)
      UB(1:2) = ubound(InData%BStCMotionMesh)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call MeshPack(Buf, InData%BStCMotionMesh(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStCMotionMesh
   call RegPack(Buf, allocated(InData%NStCMotionMesh))
   if (allocated(InData%NStCMotionMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStCMotionMesh), ubound(InData%NStCMotionMesh))
      LB(1:1) = lbound(InData%NStCMotionMesh)
      UB(1:1) = ubound(InData%NStCMotionMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%NStCMotionMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStCMotionMesh
   call RegPack(Buf, allocated(InData%TStCMotionMesh))
   if (allocated(InData%TStCMotionMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStCMotionMesh), ubound(InData%TStCMotionMesh))
      LB(1:1) = lbound(InData%TStCMotionMesh)
      UB(1:1) = ubound(InData%TStCMotionMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%TStCMotionMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStCMotionMesh
   call RegPack(Buf, allocated(InData%SStCMotionMesh))
   if (allocated(InData%SStCMotionMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStCMotionMesh), ubound(InData%SStCMotionMesh))
      LB(1:1) = lbound(InData%SStCMotionMesh)
      UB(1:1) = ubound(InData%SStCMotionMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%SStCMotionMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidSpeed
   call RegPack(Buf, allocated(InData%LidSpeed))
   if (allocated(InData%LidSpeed)) then
      call RegPackBounds(Buf, 1, lbound(InData%LidSpeed), ubound(InData%LidSpeed))
      call RegPack(Buf, InData%LidSpeed)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsX
   call RegPack(Buf, allocated(InData%MsrPositionsX))
   if (allocated(InData%MsrPositionsX)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsX), ubound(InData%MsrPositionsX))
      call RegPack(Buf, InData%MsrPositionsX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsY
   call RegPack(Buf, allocated(InData%MsrPositionsY))
   if (allocated(InData%MsrPositionsY)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsY), ubound(InData%MsrPositionsY))
      call RegPack(Buf, InData%MsrPositionsY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsZ
   call RegPack(Buf, allocated(InData%MsrPositionsZ))
   if (allocated(InData%MsrPositionsZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsZ), ubound(InData%MsrPositionsZ))
      call RegPack(Buf, InData%MsrPositionsZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! BlPitch
   if (allocated(OutData%BlPitch)) deallocate(OutData%BlPitch)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitch(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitch.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitch)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Yaw
   call RegUnpack(Buf, OutData%Yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRate
   call RegUnpack(Buf, OutData%YawRate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSS_Spd
   call RegUnpack(Buf, OutData%LSS_Spd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSS_Spd
   call RegUnpack(Buf, OutData%HSS_Spd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeed
   call RegUnpack(Buf, OutData%RotSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalYawPosCom
   call RegUnpack(Buf, OutData%ExternalYawPosCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalYawRateCom
   call RegUnpack(Buf, OutData%ExternalYawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalBlPitchCom
   if (allocated(OutData%ExternalBlPitchCom)) deallocate(OutData%ExternalBlPitchCom)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ExternalBlPitchCom(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ExternalBlPitchCom.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ExternalBlPitchCom)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ExternalGenTrq
   call RegUnpack(Buf, OutData%ExternalGenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalElecPwr
   call RegUnpack(Buf, OutData%ExternalElecPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalHSSBrFrac
   call RegUnpack(Buf, OutData%ExternalHSSBrFrac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternalBlAirfoilCom
   if (allocated(OutData%ExternalBlAirfoilCom)) deallocate(OutData%ExternalBlAirfoilCom)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ExternalBlAirfoilCom(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ExternalBlAirfoilCom.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ExternalBlAirfoilCom)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ExternalCableDeltaL
   if (allocated(OutData%ExternalCableDeltaL)) deallocate(OutData%ExternalCableDeltaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ExternalCableDeltaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ExternalCableDeltaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ExternalCableDeltaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ExternalCableDeltaLdot
   if (allocated(OutData%ExternalCableDeltaLdot)) deallocate(OutData%ExternalCableDeltaLdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ExternalCableDeltaLdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ExternalCableDeltaLdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ExternalCableDeltaLdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrAccel
   call RegUnpack(Buf, OutData%TwrAccel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr
   call RegUnpack(Buf, OutData%YawErr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindDir
   call RegUnpack(Buf, OutData%WindDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMyc
   call RegUnpack(Buf, OutData%RootMyc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAxp
   call RegUnpack(Buf, OutData%YawBrTAxp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrTAyp
   call RegUnpack(Buf, OutData%YawBrTAyp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipPxa
   call RegUnpack(Buf, OutData%LSSTipPxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootMxc
   call RegUnpack(Buf, OutData%RootMxc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMxa
   call RegUnpack(Buf, OutData%LSSTipMxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMya
   call RegUnpack(Buf, OutData%LSSTipMya)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMza
   call RegUnpack(Buf, OutData%LSSTipMza)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMys
   call RegUnpack(Buf, OutData%LSSTipMys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSSTipMzs
   call RegUnpack(Buf, OutData%LSSTipMzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMyn
   call RegUnpack(Buf, OutData%YawBrMyn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawBrMzn
   call RegUnpack(Buf, OutData%YawBrMzn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAxs
   call RegUnpack(Buf, OutData%NcIMURAxs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAys
   call RegUnpack(Buf, OutData%NcIMURAys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NcIMURAzs
   call RegUnpack(Buf, OutData%NcIMURAzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotPwr
   call RegUnpack(Buf, OutData%RotPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HorWindV
   call RegUnpack(Buf, OutData%HorWindV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawAngle
   call RegUnpack(Buf, OutData%YawAngle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFxa
   call RegUnpack(Buf, OutData%LSShftFxa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFys
   call RegUnpack(Buf, OutData%LSShftFys)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LSShftFzs
   call RegUnpack(Buf, OutData%LSShftFzs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSC
   if (allocated(OutData%fromSC)) deallocate(OutData%fromSC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%fromSC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%fromSC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%fromSC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! fromSCglob
   if (allocated(OutData%fromSCglob)) deallocate(OutData%fromSCglob)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%fromSCglob(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%fromSCglob.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%fromSCglob)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Lidar
   if (allocated(OutData%Lidar)) deallocate(OutData%Lidar)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Lidar(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Lidar.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Lidar)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmMotionMesh
   call MeshUnpack(Buf, OutData%PtfmMotionMesh) ! PtfmMotionMesh 
   ! BStCMotionMesh
   if (allocated(OutData%BStCMotionMesh)) deallocate(OutData%BStCMotionMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStCMotionMesh(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStCMotionMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call MeshUnpack(Buf, OutData%BStCMotionMesh(i1,i2)) ! BStCMotionMesh 
         end do
      end do
   end if
   ! NStCMotionMesh
   if (allocated(OutData%NStCMotionMesh)) deallocate(OutData%NStCMotionMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStCMotionMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStCMotionMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%NStCMotionMesh(i1)) ! NStCMotionMesh 
      end do
   end if
   ! TStCMotionMesh
   if (allocated(OutData%TStCMotionMesh)) deallocate(OutData%TStCMotionMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStCMotionMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStCMotionMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%TStCMotionMesh(i1)) ! TStCMotionMesh 
      end do
   end if
   ! SStCMotionMesh
   if (allocated(OutData%SStCMotionMesh)) deallocate(OutData%SStCMotionMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStCMotionMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStCMotionMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%SStCMotionMesh(i1)) ! SStCMotionMesh 
      end do
   end if
   ! LidSpeed
   if (allocated(OutData%LidSpeed)) deallocate(OutData%LidSpeed)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LidSpeed(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LidSpeed.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LidSpeed)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsX
   if (allocated(OutData%MsrPositionsX)) deallocate(OutData%MsrPositionsX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsY
   if (allocated(OutData%MsrPositionsY)) deallocate(OutData%MsrPositionsY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsZ
   if (allocated(OutData%MsrPositionsZ)) deallocate(OutData%MsrPositionsZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SrvD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SrvD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(SrvD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SrvD_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
IF (ALLOCATED(SrcOutputData%BlPitchCom)) THEN
  i1_l = LBOUND(SrcOutputData%BlPitchCom,1)
  i1_u = UBOUND(SrcOutputData%BlPitchCom,1)
  IF (.NOT. ALLOCATED(DstOutputData%BlPitchCom)) THEN 
    ALLOCATE(DstOutputData%BlPitchCom(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%BlPitchCom.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%BlPitchCom = SrcOutputData%BlPitchCom
ENDIF
IF (ALLOCATED(SrcOutputData%BlAirfoilCom)) THEN
  i1_l = LBOUND(SrcOutputData%BlAirfoilCom,1)
  i1_u = UBOUND(SrcOutputData%BlAirfoilCom,1)
  IF (.NOT. ALLOCATED(DstOutputData%BlAirfoilCom)) THEN 
    ALLOCATE(DstOutputData%BlAirfoilCom(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%BlAirfoilCom.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%BlAirfoilCom = SrcOutputData%BlAirfoilCom
ENDIF
    DstOutputData%YawMom = SrcOutputData%YawMom
    DstOutputData%GenTrq = SrcOutputData%GenTrq
    DstOutputData%HSSBrTrqC = SrcOutputData%HSSBrTrqC
    DstOutputData%ElecPwr = SrcOutputData%ElecPwr
IF (ALLOCATED(SrcOutputData%TBDrCon)) THEN
  i1_l = LBOUND(SrcOutputData%TBDrCon,1)
  i1_u = UBOUND(SrcOutputData%TBDrCon,1)
  IF (.NOT. ALLOCATED(DstOutputData%TBDrCon)) THEN 
    ALLOCATE(DstOutputData%TBDrCon(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%TBDrCon.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%TBDrCon = SrcOutputData%TBDrCon
ENDIF
IF (ALLOCATED(SrcOutputData%Lidar)) THEN
  i1_l = LBOUND(SrcOutputData%Lidar,1)
  i1_u = UBOUND(SrcOutputData%Lidar,1)
  IF (.NOT. ALLOCATED(DstOutputData%Lidar)) THEN 
    ALLOCATE(DstOutputData%Lidar(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Lidar.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Lidar = SrcOutputData%Lidar
ENDIF
IF (ALLOCATED(SrcOutputData%CableDeltaL)) THEN
  i1_l = LBOUND(SrcOutputData%CableDeltaL,1)
  i1_u = UBOUND(SrcOutputData%CableDeltaL,1)
  IF (.NOT. ALLOCATED(DstOutputData%CableDeltaL)) THEN 
    ALLOCATE(DstOutputData%CableDeltaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%CableDeltaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%CableDeltaL = SrcOutputData%CableDeltaL
ENDIF
IF (ALLOCATED(SrcOutputData%CableDeltaLdot)) THEN
  i1_l = LBOUND(SrcOutputData%CableDeltaLdot,1)
  i1_u = UBOUND(SrcOutputData%CableDeltaLdot,1)
  IF (.NOT. ALLOCATED(DstOutputData%CableDeltaLdot)) THEN 
    ALLOCATE(DstOutputData%CableDeltaLdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%CableDeltaLdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%CableDeltaLdot = SrcOutputData%CableDeltaLdot
ENDIF
IF (ALLOCATED(SrcOutputData%BStCLoadMesh)) THEN
  i1_l = LBOUND(SrcOutputData%BStCLoadMesh,1)
  i1_u = UBOUND(SrcOutputData%BStCLoadMesh,1)
  i2_l = LBOUND(SrcOutputData%BStCLoadMesh,2)
  i2_u = UBOUND(SrcOutputData%BStCLoadMesh,2)
  IF (.NOT. ALLOCATED(DstOutputData%BStCLoadMesh)) THEN 
    ALLOCATE(DstOutputData%BStCLoadMesh(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%BStCLoadMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcOutputData%BStCLoadMesh,2), UBOUND(SrcOutputData%BStCLoadMesh,2)
    DO i1 = LBOUND(SrcOutputData%BStCLoadMesh,1), UBOUND(SrcOutputData%BStCLoadMesh,1)
      CALL MeshCopy( SrcOutputData%BStCLoadMesh(i1,i2), DstOutputData%BStCLoadMesh(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%NStCLoadMesh)) THEN
  i1_l = LBOUND(SrcOutputData%NStCLoadMesh,1)
  i1_u = UBOUND(SrcOutputData%NStCLoadMesh,1)
  IF (.NOT. ALLOCATED(DstOutputData%NStCLoadMesh)) THEN 
    ALLOCATE(DstOutputData%NStCLoadMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%NStCLoadMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%NStCLoadMesh,1), UBOUND(SrcOutputData%NStCLoadMesh,1)
      CALL MeshCopy( SrcOutputData%NStCLoadMesh(i1), DstOutputData%NStCLoadMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%TStCLoadMesh)) THEN
  i1_l = LBOUND(SrcOutputData%TStCLoadMesh,1)
  i1_u = UBOUND(SrcOutputData%TStCLoadMesh,1)
  IF (.NOT. ALLOCATED(DstOutputData%TStCLoadMesh)) THEN 
    ALLOCATE(DstOutputData%TStCLoadMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%TStCLoadMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%TStCLoadMesh,1), UBOUND(SrcOutputData%TStCLoadMesh,1)
      CALL MeshCopy( SrcOutputData%TStCLoadMesh(i1), DstOutputData%TStCLoadMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%SStCLoadMesh)) THEN
  i1_l = LBOUND(SrcOutputData%SStCLoadMesh,1)
  i1_u = UBOUND(SrcOutputData%SStCLoadMesh,1)
  IF (.NOT. ALLOCATED(DstOutputData%SStCLoadMesh)) THEN 
    ALLOCATE(DstOutputData%SStCLoadMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%SStCLoadMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%SStCLoadMesh,1), UBOUND(SrcOutputData%SStCLoadMesh,1)
      CALL MeshCopy( SrcOutputData%SStCLoadMesh(i1), DstOutputData%SStCLoadMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%toSC)) THEN
  i1_l = LBOUND(SrcOutputData%toSC,1)
  i1_u = UBOUND(SrcOutputData%toSC,1)
  IF (.NOT. ALLOCATED(DstOutputData%toSC)) THEN 
    ALLOCATE(DstOutputData%toSC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%toSC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%toSC = SrcOutputData%toSC
ENDIF
 END SUBROUTINE SrvD_CopyOutput

 SUBROUTINE SrvD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SrvD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SrvD_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
IF (ALLOCATED(OutputData%BlPitchCom)) THEN
  DEALLOCATE(OutputData%BlPitchCom)
ENDIF
IF (ALLOCATED(OutputData%BlAirfoilCom)) THEN
  DEALLOCATE(OutputData%BlAirfoilCom)
ENDIF
IF (ALLOCATED(OutputData%TBDrCon)) THEN
  DEALLOCATE(OutputData%TBDrCon)
ENDIF
IF (ALLOCATED(OutputData%Lidar)) THEN
  DEALLOCATE(OutputData%Lidar)
ENDIF
IF (ALLOCATED(OutputData%CableDeltaL)) THEN
  DEALLOCATE(OutputData%CableDeltaL)
ENDIF
IF (ALLOCATED(OutputData%CableDeltaLdot)) THEN
  DEALLOCATE(OutputData%CableDeltaLdot)
ENDIF
IF (ALLOCATED(OutputData%BStCLoadMesh)) THEN
DO i2 = LBOUND(OutputData%BStCLoadMesh,2), UBOUND(OutputData%BStCLoadMesh,2)
DO i1 = LBOUND(OutputData%BStCLoadMesh,1), UBOUND(OutputData%BStCLoadMesh,1)
  CALL MeshDestroy( OutputData%BStCLoadMesh(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(OutputData%BStCLoadMesh)
ENDIF
IF (ALLOCATED(OutputData%NStCLoadMesh)) THEN
DO i1 = LBOUND(OutputData%NStCLoadMesh,1), UBOUND(OutputData%NStCLoadMesh,1)
  CALL MeshDestroy( OutputData%NStCLoadMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%NStCLoadMesh)
ENDIF
IF (ALLOCATED(OutputData%TStCLoadMesh)) THEN
DO i1 = LBOUND(OutputData%TStCLoadMesh,1), UBOUND(OutputData%TStCLoadMesh,1)
  CALL MeshDestroy( OutputData%TStCLoadMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%TStCLoadMesh)
ENDIF
IF (ALLOCATED(OutputData%SStCLoadMesh)) THEN
DO i1 = LBOUND(OutputData%SStCLoadMesh,1), UBOUND(OutputData%SStCLoadMesh,1)
  CALL MeshDestroy( OutputData%SStCLoadMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%SStCLoadMesh)
ENDIF
IF (ALLOCATED(OutputData%toSC)) THEN
  DEALLOCATE(OutputData%toSC)
ENDIF
 END SUBROUTINE SrvD_DestroyOutput


subroutine SrvD_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SrvD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SrvD_PackOutput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchCom
   call RegPack(Buf, allocated(InData%BlPitchCom))
   if (allocated(InData%BlPitchCom)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlPitchCom), ubound(InData%BlPitchCom))
      call RegPack(Buf, InData%BlPitchCom)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAirfoilCom
   call RegPack(Buf, allocated(InData%BlAirfoilCom))
   if (allocated(InData%BlAirfoilCom)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlAirfoilCom), ubound(InData%BlAirfoilCom))
      call RegPack(Buf, InData%BlAirfoilCom)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawMom
   call RegPack(Buf, InData%YawMom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq
   call RegPack(Buf, InData%GenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTrqC
   call RegPack(Buf, InData%HSSBrTrqC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElecPwr
   call RegPack(Buf, InData%ElecPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDrCon
   call RegPack(Buf, allocated(InData%TBDrCon))
   if (allocated(InData%TBDrCon)) then
      call RegPackBounds(Buf, 1, lbound(InData%TBDrCon), ubound(InData%TBDrCon))
      call RegPack(Buf, InData%TBDrCon)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lidar
   call RegPack(Buf, allocated(InData%Lidar))
   if (allocated(InData%Lidar)) then
      call RegPackBounds(Buf, 1, lbound(InData%Lidar), ubound(InData%Lidar))
      call RegPack(Buf, InData%Lidar)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaL
   call RegPack(Buf, allocated(InData%CableDeltaL))
   if (allocated(InData%CableDeltaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableDeltaL), ubound(InData%CableDeltaL))
      call RegPack(Buf, InData%CableDeltaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaLdot
   call RegPack(Buf, allocated(InData%CableDeltaLdot))
   if (allocated(InData%CableDeltaLdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableDeltaLdot), ubound(InData%CableDeltaLdot))
      call RegPack(Buf, InData%CableDeltaLdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStCLoadMesh
   call RegPack(Buf, allocated(InData%BStCLoadMesh))
   if (allocated(InData%BStCLoadMesh)) then
      call RegPackBounds(Buf, 2, lbound(InData%BStCLoadMesh), ubound(InData%BStCLoadMesh))
      LB(1:2) = lbound(InData%BStCLoadMesh)
      UB(1:2) = ubound(InData%BStCLoadMesh)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call MeshPack(Buf, InData%BStCLoadMesh(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStCLoadMesh
   call RegPack(Buf, allocated(InData%NStCLoadMesh))
   if (allocated(InData%NStCLoadMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStCLoadMesh), ubound(InData%NStCLoadMesh))
      LB(1:1) = lbound(InData%NStCLoadMesh)
      UB(1:1) = ubound(InData%NStCLoadMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%NStCLoadMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStCLoadMesh
   call RegPack(Buf, allocated(InData%TStCLoadMesh))
   if (allocated(InData%TStCLoadMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStCLoadMesh), ubound(InData%TStCLoadMesh))
      LB(1:1) = lbound(InData%TStCLoadMesh)
      UB(1:1) = ubound(InData%TStCLoadMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%TStCLoadMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStCLoadMesh
   call RegPack(Buf, allocated(InData%SStCLoadMesh))
   if (allocated(InData%SStCLoadMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStCLoadMesh), ubound(InData%SStCLoadMesh))
      LB(1:1) = lbound(InData%SStCLoadMesh)
      UB(1:1) = ubound(InData%SStCLoadMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%SStCLoadMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! toSC
   call RegPack(Buf, allocated(InData%toSC))
   if (allocated(InData%toSC)) then
      call RegPackBounds(Buf, 1, lbound(InData%toSC), ubound(InData%toSC))
      call RegPack(Buf, InData%toSC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SrvD_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SrvD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SrvD_UnPackOutput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlPitchCom
   if (allocated(OutData%BlPitchCom)) deallocate(OutData%BlPitchCom)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlPitchCom(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPitchCom.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlPitchCom)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlAirfoilCom
   if (allocated(OutData%BlAirfoilCom)) deallocate(OutData%BlAirfoilCom)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlAirfoilCom(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAirfoilCom.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlAirfoilCom)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! YawMom
   call RegUnpack(Buf, OutData%YawMom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GenTrq
   call RegUnpack(Buf, OutData%GenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrTrqC
   call RegUnpack(Buf, OutData%HSSBrTrqC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElecPwr
   call RegUnpack(Buf, OutData%ElecPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TBDrCon
   if (allocated(OutData%TBDrCon)) deallocate(OutData%TBDrCon)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TBDrCon(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TBDrCon.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TBDrCon)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Lidar
   if (allocated(OutData%Lidar)) deallocate(OutData%Lidar)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Lidar(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Lidar.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Lidar)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CableDeltaL
   if (allocated(OutData%CableDeltaL)) deallocate(OutData%CableDeltaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableDeltaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableDeltaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableDeltaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CableDeltaLdot
   if (allocated(OutData%CableDeltaLdot)) deallocate(OutData%CableDeltaLdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableDeltaLdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableDeltaLdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableDeltaLdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BStCLoadMesh
   if (allocated(OutData%BStCLoadMesh)) deallocate(OutData%BStCLoadMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStCLoadMesh(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStCLoadMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call MeshUnpack(Buf, OutData%BStCLoadMesh(i1,i2)) ! BStCLoadMesh 
         end do
      end do
   end if
   ! NStCLoadMesh
   if (allocated(OutData%NStCLoadMesh)) deallocate(OutData%NStCLoadMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStCLoadMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStCLoadMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%NStCLoadMesh(i1)) ! NStCLoadMesh 
      end do
   end if
   ! TStCLoadMesh
   if (allocated(OutData%TStCLoadMesh)) deallocate(OutData%TStCLoadMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStCLoadMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStCLoadMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%TStCLoadMesh(i1)) ! TStCLoadMesh 
      end do
   end if
   ! SStCLoadMesh
   if (allocated(OutData%SStCLoadMesh)) deallocate(OutData%SStCLoadMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStCLoadMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStCLoadMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%SStCLoadMesh(i1)) ! SStCLoadMesh 
      end do
   end if
   ! toSC
   if (allocated(OutData%toSC)) deallocate(OutData%toSC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%toSC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%toSC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%toSC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE SrvD_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SrvD_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(SrvD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'SrvD_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL SrvD_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL SrvD_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL SrvD_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE SrvD_Input_ExtrapInterp


 SUBROUTINE SrvD_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(SrvD_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(SrvD_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(SrvD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'SrvD_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%BlPitch) .AND. ALLOCATED(u1%BlPitch)) THEN
  DO i1 = LBOUND(u_out%BlPitch,1),UBOUND(u_out%BlPitch,1)
    CALL Angles_ExtrapInterp( u1%BlPitch(i1), u2%BlPitch(i1), tin, u_out%BlPitch(i1), tin_out )
  END DO
END IF ! check if allocated
  CALL Angles_ExtrapInterp( u1%Yaw, u2%Yaw, tin, u_out%Yaw, tin_out )
  b = -(u1%YawRate - u2%YawRate)
  u_out%YawRate = u1%YawRate + b * ScaleFactor
  b = -(u1%LSS_Spd - u2%LSS_Spd)
  u_out%LSS_Spd = u1%LSS_Spd + b * ScaleFactor
  b = -(u1%HSS_Spd - u2%HSS_Spd)
  u_out%HSS_Spd = u1%HSS_Spd + b * ScaleFactor
  b = -(u1%RotSpeed - u2%RotSpeed)
  u_out%RotSpeed = u1%RotSpeed + b * ScaleFactor
  CALL Angles_ExtrapInterp( u1%ExternalYawPosCom, u2%ExternalYawPosCom, tin, u_out%ExternalYawPosCom, tin_out )
  b = -(u1%ExternalYawRateCom - u2%ExternalYawRateCom)
  u_out%ExternalYawRateCom = u1%ExternalYawRateCom + b * ScaleFactor
IF (ALLOCATED(u_out%ExternalBlPitchCom) .AND. ALLOCATED(u1%ExternalBlPitchCom)) THEN
  DO i1 = LBOUND(u_out%ExternalBlPitchCom,1),UBOUND(u_out%ExternalBlPitchCom,1)
    CALL Angles_ExtrapInterp( u1%ExternalBlPitchCom(i1), u2%ExternalBlPitchCom(i1), tin, u_out%ExternalBlPitchCom(i1), tin_out )
  END DO
END IF ! check if allocated
  b = -(u1%ExternalGenTrq - u2%ExternalGenTrq)
  u_out%ExternalGenTrq = u1%ExternalGenTrq + b * ScaleFactor
  b = -(u1%ExternalElecPwr - u2%ExternalElecPwr)
  u_out%ExternalElecPwr = u1%ExternalElecPwr + b * ScaleFactor
  b = -(u1%ExternalHSSBrFrac - u2%ExternalHSSBrFrac)
  u_out%ExternalHSSBrFrac = u1%ExternalHSSBrFrac + b * ScaleFactor
IF (ALLOCATED(u_out%ExternalBlAirfoilCom) .AND. ALLOCATED(u1%ExternalBlAirfoilCom)) THEN
  DO i1 = LBOUND(u_out%ExternalBlAirfoilCom,1),UBOUND(u_out%ExternalBlAirfoilCom,1)
    b = -(u1%ExternalBlAirfoilCom(i1) - u2%ExternalBlAirfoilCom(i1))
    u_out%ExternalBlAirfoilCom(i1) = u1%ExternalBlAirfoilCom(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%ExternalCableDeltaL) .AND. ALLOCATED(u1%ExternalCableDeltaL)) THEN
  DO i1 = LBOUND(u_out%ExternalCableDeltaL,1),UBOUND(u_out%ExternalCableDeltaL,1)
    b = -(u1%ExternalCableDeltaL(i1) - u2%ExternalCableDeltaL(i1))
    u_out%ExternalCableDeltaL(i1) = u1%ExternalCableDeltaL(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%ExternalCableDeltaLdot) .AND. ALLOCATED(u1%ExternalCableDeltaLdot)) THEN
  DO i1 = LBOUND(u_out%ExternalCableDeltaLdot,1),UBOUND(u_out%ExternalCableDeltaLdot,1)
    b = -(u1%ExternalCableDeltaLdot(i1) - u2%ExternalCableDeltaLdot(i1))
    u_out%ExternalCableDeltaLdot(i1) = u1%ExternalCableDeltaLdot(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
  b = -(u1%TwrAccel - u2%TwrAccel)
  u_out%TwrAccel = u1%TwrAccel + b * ScaleFactor
  CALL Angles_ExtrapInterp( u1%YawErr, u2%YawErr, tin, u_out%YawErr, tin_out )
  CALL Angles_ExtrapInterp( u1%WindDir, u2%WindDir, tin, u_out%WindDir, tin_out )
  DO i1 = LBOUND(u_out%RootMyc,1),UBOUND(u_out%RootMyc,1)
    b = -(u1%RootMyc(i1) - u2%RootMyc(i1))
    u_out%RootMyc(i1) = u1%RootMyc(i1) + b * ScaleFactor
  END DO
  b = -(u1%YawBrTAxp - u2%YawBrTAxp)
  u_out%YawBrTAxp = u1%YawBrTAxp + b * ScaleFactor
  b = -(u1%YawBrTAyp - u2%YawBrTAyp)
  u_out%YawBrTAyp = u1%YawBrTAyp + b * ScaleFactor
  b = -(u1%LSSTipPxa - u2%LSSTipPxa)
  u_out%LSSTipPxa = u1%LSSTipPxa + b * ScaleFactor
  DO i1 = LBOUND(u_out%RootMxc,1),UBOUND(u_out%RootMxc,1)
    b = -(u1%RootMxc(i1) - u2%RootMxc(i1))
    u_out%RootMxc(i1) = u1%RootMxc(i1) + b * ScaleFactor
  END DO
  b = -(u1%LSSTipMxa - u2%LSSTipMxa)
  u_out%LSSTipMxa = u1%LSSTipMxa + b * ScaleFactor
  b = -(u1%LSSTipMya - u2%LSSTipMya)
  u_out%LSSTipMya = u1%LSSTipMya + b * ScaleFactor
  b = -(u1%LSSTipMza - u2%LSSTipMza)
  u_out%LSSTipMza = u1%LSSTipMza + b * ScaleFactor
  b = -(u1%LSSTipMys - u2%LSSTipMys)
  u_out%LSSTipMys = u1%LSSTipMys + b * ScaleFactor
  b = -(u1%LSSTipMzs - u2%LSSTipMzs)
  u_out%LSSTipMzs = u1%LSSTipMzs + b * ScaleFactor
  b = -(u1%YawBrMyn - u2%YawBrMyn)
  u_out%YawBrMyn = u1%YawBrMyn + b * ScaleFactor
  b = -(u1%YawBrMzn - u2%YawBrMzn)
  u_out%YawBrMzn = u1%YawBrMzn + b * ScaleFactor
  b = -(u1%NcIMURAxs - u2%NcIMURAxs)
  u_out%NcIMURAxs = u1%NcIMURAxs + b * ScaleFactor
  b = -(u1%NcIMURAys - u2%NcIMURAys)
  u_out%NcIMURAys = u1%NcIMURAys + b * ScaleFactor
  b = -(u1%NcIMURAzs - u2%NcIMURAzs)
  u_out%NcIMURAzs = u1%NcIMURAzs + b * ScaleFactor
  b = -(u1%RotPwr - u2%RotPwr)
  u_out%RotPwr = u1%RotPwr + b * ScaleFactor
  b = -(u1%HorWindV - u2%HorWindV)
  u_out%HorWindV = u1%HorWindV + b * ScaleFactor
  CALL Angles_ExtrapInterp( u1%YawAngle, u2%YawAngle, tin, u_out%YawAngle, tin_out )
  b = -(u1%LSShftFxa - u2%LSShftFxa)
  u_out%LSShftFxa = u1%LSShftFxa + b * ScaleFactor
  b = -(u1%LSShftFys - u2%LSShftFys)
  u_out%LSShftFys = u1%LSShftFys + b * ScaleFactor
  b = -(u1%LSShftFzs - u2%LSShftFzs)
  u_out%LSShftFzs = u1%LSShftFzs + b * ScaleFactor
IF (ALLOCATED(u_out%fromSC) .AND. ALLOCATED(u1%fromSC)) THEN
  DO i1 = LBOUND(u_out%fromSC,1),UBOUND(u_out%fromSC,1)
    b = -(u1%fromSC(i1) - u2%fromSC(i1))
    u_out%fromSC(i1) = u1%fromSC(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%fromSCglob) .AND. ALLOCATED(u1%fromSCglob)) THEN
  DO i1 = LBOUND(u_out%fromSCglob,1),UBOUND(u_out%fromSCglob,1)
    b = -(u1%fromSCglob(i1) - u2%fromSCglob(i1))
    u_out%fromSCglob(i1) = u1%fromSCglob(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%Lidar) .AND. ALLOCATED(u1%Lidar)) THEN
  DO i1 = LBOUND(u_out%Lidar,1),UBOUND(u_out%Lidar,1)
    b = -(u1%Lidar(i1) - u2%Lidar(i1))
    u_out%Lidar(i1) = u1%Lidar(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
      CALL MeshExtrapInterp1(u1%PtfmMotionMesh, u2%PtfmMotionMesh, tin, u_out%PtfmMotionMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%BStCMotionMesh) .AND. ALLOCATED(u1%BStCMotionMesh)) THEN
  DO i2 = LBOUND(u_out%BStCMotionMesh,2),UBOUND(u_out%BStCMotionMesh,2)
  DO i1 = LBOUND(u_out%BStCMotionMesh,1),UBOUND(u_out%BStCMotionMesh,1)
      CALL MeshExtrapInterp1(u1%BStCMotionMesh(i1,i2), u2%BStCMotionMesh(i1,i2), tin, u_out%BStCMotionMesh(i1,i2), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%NStCMotionMesh) .AND. ALLOCATED(u1%NStCMotionMesh)) THEN
  DO i1 = LBOUND(u_out%NStCMotionMesh,1),UBOUND(u_out%NStCMotionMesh,1)
      CALL MeshExtrapInterp1(u1%NStCMotionMesh(i1), u2%NStCMotionMesh(i1), tin, u_out%NStCMotionMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%TStCMotionMesh) .AND. ALLOCATED(u1%TStCMotionMesh)) THEN
  DO i1 = LBOUND(u_out%TStCMotionMesh,1),UBOUND(u_out%TStCMotionMesh,1)
      CALL MeshExtrapInterp1(u1%TStCMotionMesh(i1), u2%TStCMotionMesh(i1), tin, u_out%TStCMotionMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%SStCMotionMesh) .AND. ALLOCATED(u1%SStCMotionMesh)) THEN
  DO i1 = LBOUND(u_out%SStCMotionMesh,1),UBOUND(u_out%SStCMotionMesh,1)
      CALL MeshExtrapInterp1(u1%SStCMotionMesh(i1), u2%SStCMotionMesh(i1), tin, u_out%SStCMotionMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%LidSpeed) .AND. ALLOCATED(u1%LidSpeed)) THEN
  DO i1 = LBOUND(u_out%LidSpeed,1),UBOUND(u_out%LidSpeed,1)
    b = -(u1%LidSpeed(i1) - u2%LidSpeed(i1))
    u_out%LidSpeed(i1) = u1%LidSpeed(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%MsrPositionsX) .AND. ALLOCATED(u1%MsrPositionsX)) THEN
  DO i1 = LBOUND(u_out%MsrPositionsX,1),UBOUND(u_out%MsrPositionsX,1)
    b = -(u1%MsrPositionsX(i1) - u2%MsrPositionsX(i1))
    u_out%MsrPositionsX(i1) = u1%MsrPositionsX(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%MsrPositionsY) .AND. ALLOCATED(u1%MsrPositionsY)) THEN
  DO i1 = LBOUND(u_out%MsrPositionsY,1),UBOUND(u_out%MsrPositionsY,1)
    b = -(u1%MsrPositionsY(i1) - u2%MsrPositionsY(i1))
    u_out%MsrPositionsY(i1) = u1%MsrPositionsY(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%MsrPositionsZ) .AND. ALLOCATED(u1%MsrPositionsZ)) THEN
  DO i1 = LBOUND(u_out%MsrPositionsZ,1),UBOUND(u_out%MsrPositionsZ,1)
    b = -(u1%MsrPositionsZ(i1) - u2%MsrPositionsZ(i1))
    u_out%MsrPositionsZ(i1) = u1%MsrPositionsZ(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE SrvD_Input_ExtrapInterp1


 SUBROUTINE SrvD_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(SrvD_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(SrvD_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(SrvD_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(SrvD_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'SrvD_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%BlPitch) .AND. ALLOCATED(u1%BlPitch)) THEN
  DO i1 = LBOUND(u_out%BlPitch,1),UBOUND(u_out%BlPitch,1)
    CALL Angles_ExtrapInterp( u1%BlPitch(i1), u2%BlPitch(i1), u3%BlPitch(i1), tin, u_out%BlPitch(i1), tin_out )
  END DO
END IF ! check if allocated
  CALL Angles_ExtrapInterp( u1%Yaw, u2%Yaw, u3%Yaw, tin, u_out%Yaw, tin_out )
  b = (t(3)**2*(u1%YawRate - u2%YawRate) + t(2)**2*(-u1%YawRate + u3%YawRate))* scaleFactor
  c = ( (t(2)-t(3))*u1%YawRate + t(3)*u2%YawRate - t(2)*u3%YawRate ) * scaleFactor
  u_out%YawRate = u1%YawRate + b  + c * t_out
  b = (t(3)**2*(u1%LSS_Spd - u2%LSS_Spd) + t(2)**2*(-u1%LSS_Spd + u3%LSS_Spd))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSS_Spd + t(3)*u2%LSS_Spd - t(2)*u3%LSS_Spd ) * scaleFactor
  u_out%LSS_Spd = u1%LSS_Spd + b  + c * t_out
  b = (t(3)**2*(u1%HSS_Spd - u2%HSS_Spd) + t(2)**2*(-u1%HSS_Spd + u3%HSS_Spd))* scaleFactor
  c = ( (t(2)-t(3))*u1%HSS_Spd + t(3)*u2%HSS_Spd - t(2)*u3%HSS_Spd ) * scaleFactor
  u_out%HSS_Spd = u1%HSS_Spd + b  + c * t_out
  b = (t(3)**2*(u1%RotSpeed - u2%RotSpeed) + t(2)**2*(-u1%RotSpeed + u3%RotSpeed))* scaleFactor
  c = ( (t(2)-t(3))*u1%RotSpeed + t(3)*u2%RotSpeed - t(2)*u3%RotSpeed ) * scaleFactor
  u_out%RotSpeed = u1%RotSpeed + b  + c * t_out
  CALL Angles_ExtrapInterp( u1%ExternalYawPosCom, u2%ExternalYawPosCom, u3%ExternalYawPosCom, tin, u_out%ExternalYawPosCom, tin_out )
  b = (t(3)**2*(u1%ExternalYawRateCom - u2%ExternalYawRateCom) + t(2)**2*(-u1%ExternalYawRateCom + u3%ExternalYawRateCom))* scaleFactor
  c = ( (t(2)-t(3))*u1%ExternalYawRateCom + t(3)*u2%ExternalYawRateCom - t(2)*u3%ExternalYawRateCom ) * scaleFactor
  u_out%ExternalYawRateCom = u1%ExternalYawRateCom + b  + c * t_out
IF (ALLOCATED(u_out%ExternalBlPitchCom) .AND. ALLOCATED(u1%ExternalBlPitchCom)) THEN
  DO i1 = LBOUND(u_out%ExternalBlPitchCom,1),UBOUND(u_out%ExternalBlPitchCom,1)
    CALL Angles_ExtrapInterp( u1%ExternalBlPitchCom(i1), u2%ExternalBlPitchCom(i1), u3%ExternalBlPitchCom(i1), tin, u_out%ExternalBlPitchCom(i1), tin_out )
  END DO
END IF ! check if allocated
  b = (t(3)**2*(u1%ExternalGenTrq - u2%ExternalGenTrq) + t(2)**2*(-u1%ExternalGenTrq + u3%ExternalGenTrq))* scaleFactor
  c = ( (t(2)-t(3))*u1%ExternalGenTrq + t(3)*u2%ExternalGenTrq - t(2)*u3%ExternalGenTrq ) * scaleFactor
  u_out%ExternalGenTrq = u1%ExternalGenTrq + b  + c * t_out
  b = (t(3)**2*(u1%ExternalElecPwr - u2%ExternalElecPwr) + t(2)**2*(-u1%ExternalElecPwr + u3%ExternalElecPwr))* scaleFactor
  c = ( (t(2)-t(3))*u1%ExternalElecPwr + t(3)*u2%ExternalElecPwr - t(2)*u3%ExternalElecPwr ) * scaleFactor
  u_out%ExternalElecPwr = u1%ExternalElecPwr + b  + c * t_out
  b = (t(3)**2*(u1%ExternalHSSBrFrac - u2%ExternalHSSBrFrac) + t(2)**2*(-u1%ExternalHSSBrFrac + u3%ExternalHSSBrFrac))* scaleFactor
  c = ( (t(2)-t(3))*u1%ExternalHSSBrFrac + t(3)*u2%ExternalHSSBrFrac - t(2)*u3%ExternalHSSBrFrac ) * scaleFactor
  u_out%ExternalHSSBrFrac = u1%ExternalHSSBrFrac + b  + c * t_out
IF (ALLOCATED(u_out%ExternalBlAirfoilCom) .AND. ALLOCATED(u1%ExternalBlAirfoilCom)) THEN
  DO i1 = LBOUND(u_out%ExternalBlAirfoilCom,1),UBOUND(u_out%ExternalBlAirfoilCom,1)
    b = (t(3)**2*(u1%ExternalBlAirfoilCom(i1) - u2%ExternalBlAirfoilCom(i1)) + t(2)**2*(-u1%ExternalBlAirfoilCom(i1) + u3%ExternalBlAirfoilCom(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%ExternalBlAirfoilCom(i1) + t(3)*u2%ExternalBlAirfoilCom(i1) - t(2)*u3%ExternalBlAirfoilCom(i1) ) * scaleFactor
    u_out%ExternalBlAirfoilCom(i1) = u1%ExternalBlAirfoilCom(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%ExternalCableDeltaL) .AND. ALLOCATED(u1%ExternalCableDeltaL)) THEN
  DO i1 = LBOUND(u_out%ExternalCableDeltaL,1),UBOUND(u_out%ExternalCableDeltaL,1)
    b = (t(3)**2*(u1%ExternalCableDeltaL(i1) - u2%ExternalCableDeltaL(i1)) + t(2)**2*(-u1%ExternalCableDeltaL(i1) + u3%ExternalCableDeltaL(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%ExternalCableDeltaL(i1) + t(3)*u2%ExternalCableDeltaL(i1) - t(2)*u3%ExternalCableDeltaL(i1) ) * scaleFactor
    u_out%ExternalCableDeltaL(i1) = u1%ExternalCableDeltaL(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%ExternalCableDeltaLdot) .AND. ALLOCATED(u1%ExternalCableDeltaLdot)) THEN
  DO i1 = LBOUND(u_out%ExternalCableDeltaLdot,1),UBOUND(u_out%ExternalCableDeltaLdot,1)
    b = (t(3)**2*(u1%ExternalCableDeltaLdot(i1) - u2%ExternalCableDeltaLdot(i1)) + t(2)**2*(-u1%ExternalCableDeltaLdot(i1) + u3%ExternalCableDeltaLdot(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%ExternalCableDeltaLdot(i1) + t(3)*u2%ExternalCableDeltaLdot(i1) - t(2)*u3%ExternalCableDeltaLdot(i1) ) * scaleFactor
    u_out%ExternalCableDeltaLdot(i1) = u1%ExternalCableDeltaLdot(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
  b = (t(3)**2*(u1%TwrAccel - u2%TwrAccel) + t(2)**2*(-u1%TwrAccel + u3%TwrAccel))* scaleFactor
  c = ( (t(2)-t(3))*u1%TwrAccel + t(3)*u2%TwrAccel - t(2)*u3%TwrAccel ) * scaleFactor
  u_out%TwrAccel = u1%TwrAccel + b  + c * t_out
  CALL Angles_ExtrapInterp( u1%YawErr, u2%YawErr, u3%YawErr, tin, u_out%YawErr, tin_out )
  CALL Angles_ExtrapInterp( u1%WindDir, u2%WindDir, u3%WindDir, tin, u_out%WindDir, tin_out )
  DO i1 = LBOUND(u_out%RootMyc,1),UBOUND(u_out%RootMyc,1)
    b = (t(3)**2*(u1%RootMyc(i1) - u2%RootMyc(i1)) + t(2)**2*(-u1%RootMyc(i1) + u3%RootMyc(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%RootMyc(i1) + t(3)*u2%RootMyc(i1) - t(2)*u3%RootMyc(i1) ) * scaleFactor
    u_out%RootMyc(i1) = u1%RootMyc(i1) + b  + c * t_out
  END DO
  b = (t(3)**2*(u1%YawBrTAxp - u2%YawBrTAxp) + t(2)**2*(-u1%YawBrTAxp + u3%YawBrTAxp))* scaleFactor
  c = ( (t(2)-t(3))*u1%YawBrTAxp + t(3)*u2%YawBrTAxp - t(2)*u3%YawBrTAxp ) * scaleFactor
  u_out%YawBrTAxp = u1%YawBrTAxp + b  + c * t_out
  b = (t(3)**2*(u1%YawBrTAyp - u2%YawBrTAyp) + t(2)**2*(-u1%YawBrTAyp + u3%YawBrTAyp))* scaleFactor
  c = ( (t(2)-t(3))*u1%YawBrTAyp + t(3)*u2%YawBrTAyp - t(2)*u3%YawBrTAyp ) * scaleFactor
  u_out%YawBrTAyp = u1%YawBrTAyp + b  + c * t_out
  b = (t(3)**2*(u1%LSSTipPxa - u2%LSSTipPxa) + t(2)**2*(-u1%LSSTipPxa + u3%LSSTipPxa))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSSTipPxa + t(3)*u2%LSSTipPxa - t(2)*u3%LSSTipPxa ) * scaleFactor
  u_out%LSSTipPxa = u1%LSSTipPxa + b  + c * t_out
  DO i1 = LBOUND(u_out%RootMxc,1),UBOUND(u_out%RootMxc,1)
    b = (t(3)**2*(u1%RootMxc(i1) - u2%RootMxc(i1)) + t(2)**2*(-u1%RootMxc(i1) + u3%RootMxc(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%RootMxc(i1) + t(3)*u2%RootMxc(i1) - t(2)*u3%RootMxc(i1) ) * scaleFactor
    u_out%RootMxc(i1) = u1%RootMxc(i1) + b  + c * t_out
  END DO
  b = (t(3)**2*(u1%LSSTipMxa - u2%LSSTipMxa) + t(2)**2*(-u1%LSSTipMxa + u3%LSSTipMxa))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSSTipMxa + t(3)*u2%LSSTipMxa - t(2)*u3%LSSTipMxa ) * scaleFactor
  u_out%LSSTipMxa = u1%LSSTipMxa + b  + c * t_out
  b = (t(3)**2*(u1%LSSTipMya - u2%LSSTipMya) + t(2)**2*(-u1%LSSTipMya + u3%LSSTipMya))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSSTipMya + t(3)*u2%LSSTipMya - t(2)*u3%LSSTipMya ) * scaleFactor
  u_out%LSSTipMya = u1%LSSTipMya + b  + c * t_out
  b = (t(3)**2*(u1%LSSTipMza - u2%LSSTipMza) + t(2)**2*(-u1%LSSTipMza + u3%LSSTipMza))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSSTipMza + t(3)*u2%LSSTipMza - t(2)*u3%LSSTipMza ) * scaleFactor
  u_out%LSSTipMza = u1%LSSTipMza + b  + c * t_out
  b = (t(3)**2*(u1%LSSTipMys - u2%LSSTipMys) + t(2)**2*(-u1%LSSTipMys + u3%LSSTipMys))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSSTipMys + t(3)*u2%LSSTipMys - t(2)*u3%LSSTipMys ) * scaleFactor
  u_out%LSSTipMys = u1%LSSTipMys + b  + c * t_out
  b = (t(3)**2*(u1%LSSTipMzs - u2%LSSTipMzs) + t(2)**2*(-u1%LSSTipMzs + u3%LSSTipMzs))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSSTipMzs + t(3)*u2%LSSTipMzs - t(2)*u3%LSSTipMzs ) * scaleFactor
  u_out%LSSTipMzs = u1%LSSTipMzs + b  + c * t_out
  b = (t(3)**2*(u1%YawBrMyn - u2%YawBrMyn) + t(2)**2*(-u1%YawBrMyn + u3%YawBrMyn))* scaleFactor
  c = ( (t(2)-t(3))*u1%YawBrMyn + t(3)*u2%YawBrMyn - t(2)*u3%YawBrMyn ) * scaleFactor
  u_out%YawBrMyn = u1%YawBrMyn + b  + c * t_out
  b = (t(3)**2*(u1%YawBrMzn - u2%YawBrMzn) + t(2)**2*(-u1%YawBrMzn + u3%YawBrMzn))* scaleFactor
  c = ( (t(2)-t(3))*u1%YawBrMzn + t(3)*u2%YawBrMzn - t(2)*u3%YawBrMzn ) * scaleFactor
  u_out%YawBrMzn = u1%YawBrMzn + b  + c * t_out
  b = (t(3)**2*(u1%NcIMURAxs - u2%NcIMURAxs) + t(2)**2*(-u1%NcIMURAxs + u3%NcIMURAxs))* scaleFactor
  c = ( (t(2)-t(3))*u1%NcIMURAxs + t(3)*u2%NcIMURAxs - t(2)*u3%NcIMURAxs ) * scaleFactor
  u_out%NcIMURAxs = u1%NcIMURAxs + b  + c * t_out
  b = (t(3)**2*(u1%NcIMURAys - u2%NcIMURAys) + t(2)**2*(-u1%NcIMURAys + u3%NcIMURAys))* scaleFactor
  c = ( (t(2)-t(3))*u1%NcIMURAys + t(3)*u2%NcIMURAys - t(2)*u3%NcIMURAys ) * scaleFactor
  u_out%NcIMURAys = u1%NcIMURAys + b  + c * t_out
  b = (t(3)**2*(u1%NcIMURAzs - u2%NcIMURAzs) + t(2)**2*(-u1%NcIMURAzs + u3%NcIMURAzs))* scaleFactor
  c = ( (t(2)-t(3))*u1%NcIMURAzs + t(3)*u2%NcIMURAzs - t(2)*u3%NcIMURAzs ) * scaleFactor
  u_out%NcIMURAzs = u1%NcIMURAzs + b  + c * t_out
  b = (t(3)**2*(u1%RotPwr - u2%RotPwr) + t(2)**2*(-u1%RotPwr + u3%RotPwr))* scaleFactor
  c = ( (t(2)-t(3))*u1%RotPwr + t(3)*u2%RotPwr - t(2)*u3%RotPwr ) * scaleFactor
  u_out%RotPwr = u1%RotPwr + b  + c * t_out
  b = (t(3)**2*(u1%HorWindV - u2%HorWindV) + t(2)**2*(-u1%HorWindV + u3%HorWindV))* scaleFactor
  c = ( (t(2)-t(3))*u1%HorWindV + t(3)*u2%HorWindV - t(2)*u3%HorWindV ) * scaleFactor
  u_out%HorWindV = u1%HorWindV + b  + c * t_out
  CALL Angles_ExtrapInterp( u1%YawAngle, u2%YawAngle, u3%YawAngle, tin, u_out%YawAngle, tin_out )
  b = (t(3)**2*(u1%LSShftFxa - u2%LSShftFxa) + t(2)**2*(-u1%LSShftFxa + u3%LSShftFxa))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSShftFxa + t(3)*u2%LSShftFxa - t(2)*u3%LSShftFxa ) * scaleFactor
  u_out%LSShftFxa = u1%LSShftFxa + b  + c * t_out
  b = (t(3)**2*(u1%LSShftFys - u2%LSShftFys) + t(2)**2*(-u1%LSShftFys + u3%LSShftFys))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSShftFys + t(3)*u2%LSShftFys - t(2)*u3%LSShftFys ) * scaleFactor
  u_out%LSShftFys = u1%LSShftFys + b  + c * t_out
  b = (t(3)**2*(u1%LSShftFzs - u2%LSShftFzs) + t(2)**2*(-u1%LSShftFzs + u3%LSShftFzs))* scaleFactor
  c = ( (t(2)-t(3))*u1%LSShftFzs + t(3)*u2%LSShftFzs - t(2)*u3%LSShftFzs ) * scaleFactor
  u_out%LSShftFzs = u1%LSShftFzs + b  + c * t_out
IF (ALLOCATED(u_out%fromSC) .AND. ALLOCATED(u1%fromSC)) THEN
  DO i1 = LBOUND(u_out%fromSC,1),UBOUND(u_out%fromSC,1)
    b = (t(3)**2*(u1%fromSC(i1) - u2%fromSC(i1)) + t(2)**2*(-u1%fromSC(i1) + u3%fromSC(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%fromSC(i1) + t(3)*u2%fromSC(i1) - t(2)*u3%fromSC(i1) ) * scaleFactor
    u_out%fromSC(i1) = u1%fromSC(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%fromSCglob) .AND. ALLOCATED(u1%fromSCglob)) THEN
  DO i1 = LBOUND(u_out%fromSCglob,1),UBOUND(u_out%fromSCglob,1)
    b = (t(3)**2*(u1%fromSCglob(i1) - u2%fromSCglob(i1)) + t(2)**2*(-u1%fromSCglob(i1) + u3%fromSCglob(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%fromSCglob(i1) + t(3)*u2%fromSCglob(i1) - t(2)*u3%fromSCglob(i1) ) * scaleFactor
    u_out%fromSCglob(i1) = u1%fromSCglob(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%Lidar) .AND. ALLOCATED(u1%Lidar)) THEN
  DO i1 = LBOUND(u_out%Lidar,1),UBOUND(u_out%Lidar,1)
    b = (t(3)**2*(u1%Lidar(i1) - u2%Lidar(i1)) + t(2)**2*(-u1%Lidar(i1) + u3%Lidar(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%Lidar(i1) + t(3)*u2%Lidar(i1) - t(2)*u3%Lidar(i1) ) * scaleFactor
    u_out%Lidar(i1) = u1%Lidar(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
      CALL MeshExtrapInterp2(u1%PtfmMotionMesh, u2%PtfmMotionMesh, u3%PtfmMotionMesh, tin, u_out%PtfmMotionMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%BStCMotionMesh) .AND. ALLOCATED(u1%BStCMotionMesh)) THEN
  DO i2 = LBOUND(u_out%BStCMotionMesh,2),UBOUND(u_out%BStCMotionMesh,2)
  DO i1 = LBOUND(u_out%BStCMotionMesh,1),UBOUND(u_out%BStCMotionMesh,1)
      CALL MeshExtrapInterp2(u1%BStCMotionMesh(i1,i2), u2%BStCMotionMesh(i1,i2), u3%BStCMotionMesh(i1,i2), tin, u_out%BStCMotionMesh(i1,i2), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%NStCMotionMesh) .AND. ALLOCATED(u1%NStCMotionMesh)) THEN
  DO i1 = LBOUND(u_out%NStCMotionMesh,1),UBOUND(u_out%NStCMotionMesh,1)
      CALL MeshExtrapInterp2(u1%NStCMotionMesh(i1), u2%NStCMotionMesh(i1), u3%NStCMotionMesh(i1), tin, u_out%NStCMotionMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%TStCMotionMesh) .AND. ALLOCATED(u1%TStCMotionMesh)) THEN
  DO i1 = LBOUND(u_out%TStCMotionMesh,1),UBOUND(u_out%TStCMotionMesh,1)
      CALL MeshExtrapInterp2(u1%TStCMotionMesh(i1), u2%TStCMotionMesh(i1), u3%TStCMotionMesh(i1), tin, u_out%TStCMotionMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%SStCMotionMesh) .AND. ALLOCATED(u1%SStCMotionMesh)) THEN
  DO i1 = LBOUND(u_out%SStCMotionMesh,1),UBOUND(u_out%SStCMotionMesh,1)
      CALL MeshExtrapInterp2(u1%SStCMotionMesh(i1), u2%SStCMotionMesh(i1), u3%SStCMotionMesh(i1), tin, u_out%SStCMotionMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%LidSpeed) .AND. ALLOCATED(u1%LidSpeed)) THEN
  DO i1 = LBOUND(u_out%LidSpeed,1),UBOUND(u_out%LidSpeed,1)
    b = (t(3)**2*(u1%LidSpeed(i1) - u2%LidSpeed(i1)) + t(2)**2*(-u1%LidSpeed(i1) + u3%LidSpeed(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%LidSpeed(i1) + t(3)*u2%LidSpeed(i1) - t(2)*u3%LidSpeed(i1) ) * scaleFactor
    u_out%LidSpeed(i1) = u1%LidSpeed(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%MsrPositionsX) .AND. ALLOCATED(u1%MsrPositionsX)) THEN
  DO i1 = LBOUND(u_out%MsrPositionsX,1),UBOUND(u_out%MsrPositionsX,1)
    b = (t(3)**2*(u1%MsrPositionsX(i1) - u2%MsrPositionsX(i1)) + t(2)**2*(-u1%MsrPositionsX(i1) + u3%MsrPositionsX(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%MsrPositionsX(i1) + t(3)*u2%MsrPositionsX(i1) - t(2)*u3%MsrPositionsX(i1) ) * scaleFactor
    u_out%MsrPositionsX(i1) = u1%MsrPositionsX(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%MsrPositionsY) .AND. ALLOCATED(u1%MsrPositionsY)) THEN
  DO i1 = LBOUND(u_out%MsrPositionsY,1),UBOUND(u_out%MsrPositionsY,1)
    b = (t(3)**2*(u1%MsrPositionsY(i1) - u2%MsrPositionsY(i1)) + t(2)**2*(-u1%MsrPositionsY(i1) + u3%MsrPositionsY(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%MsrPositionsY(i1) + t(3)*u2%MsrPositionsY(i1) - t(2)*u3%MsrPositionsY(i1) ) * scaleFactor
    u_out%MsrPositionsY(i1) = u1%MsrPositionsY(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%MsrPositionsZ) .AND. ALLOCATED(u1%MsrPositionsZ)) THEN
  DO i1 = LBOUND(u_out%MsrPositionsZ,1),UBOUND(u_out%MsrPositionsZ,1)
    b = (t(3)**2*(u1%MsrPositionsZ(i1) - u2%MsrPositionsZ(i1)) + t(2)**2*(-u1%MsrPositionsZ(i1) + u3%MsrPositionsZ(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%MsrPositionsZ(i1) + t(3)*u2%MsrPositionsZ(i1) - t(2)*u3%MsrPositionsZ(i1) ) * scaleFactor
    u_out%MsrPositionsZ(i1) = u1%MsrPositionsZ(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE SrvD_Input_ExtrapInterp2


 SUBROUTINE SrvD_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'SrvD_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL SrvD_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL SrvD_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL SrvD_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE SrvD_Output_ExtrapInterp


 SUBROUTINE SrvD_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'SrvD_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%BlPitchCom) .AND. ALLOCATED(y1%BlPitchCom)) THEN
  DO i1 = LBOUND(y_out%BlPitchCom,1),UBOUND(y_out%BlPitchCom,1)
    CALL Angles_ExtrapInterp( y1%BlPitchCom(i1), y2%BlPitchCom(i1), tin, y_out%BlPitchCom(i1), tin_out )
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%BlAirfoilCom) .AND. ALLOCATED(y1%BlAirfoilCom)) THEN
  DO i1 = LBOUND(y_out%BlAirfoilCom,1),UBOUND(y_out%BlAirfoilCom,1)
    b = -(y1%BlAirfoilCom(i1) - y2%BlAirfoilCom(i1))
    y_out%BlAirfoilCom(i1) = y1%BlAirfoilCom(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
  b = -(y1%YawMom - y2%YawMom)
  y_out%YawMom = y1%YawMom + b * ScaleFactor
  b = -(y1%GenTrq - y2%GenTrq)
  y_out%GenTrq = y1%GenTrq + b * ScaleFactor
  b = -(y1%HSSBrTrqC - y2%HSSBrTrqC)
  y_out%HSSBrTrqC = y1%HSSBrTrqC + b * ScaleFactor
  b = -(y1%ElecPwr - y2%ElecPwr)
  y_out%ElecPwr = y1%ElecPwr + b * ScaleFactor
IF (ALLOCATED(y_out%TBDrCon) .AND. ALLOCATED(y1%TBDrCon)) THEN
  DO i1 = LBOUND(y_out%TBDrCon,1),UBOUND(y_out%TBDrCon,1)
    b = -(y1%TBDrCon(i1) - y2%TBDrCon(i1))
    y_out%TBDrCon(i1) = y1%TBDrCon(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Lidar) .AND. ALLOCATED(y1%Lidar)) THEN
  DO i1 = LBOUND(y_out%Lidar,1),UBOUND(y_out%Lidar,1)
    b = -(y1%Lidar(i1) - y2%Lidar(i1))
    y_out%Lidar(i1) = y1%Lidar(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%CableDeltaL) .AND. ALLOCATED(y1%CableDeltaL)) THEN
  DO i1 = LBOUND(y_out%CableDeltaL,1),UBOUND(y_out%CableDeltaL,1)
    b = -(y1%CableDeltaL(i1) - y2%CableDeltaL(i1))
    y_out%CableDeltaL(i1) = y1%CableDeltaL(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%CableDeltaLdot) .AND. ALLOCATED(y1%CableDeltaLdot)) THEN
  DO i1 = LBOUND(y_out%CableDeltaLdot,1),UBOUND(y_out%CableDeltaLdot,1)
    b = -(y1%CableDeltaLdot(i1) - y2%CableDeltaLdot(i1))
    y_out%CableDeltaLdot(i1) = y1%CableDeltaLdot(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%BStCLoadMesh) .AND. ALLOCATED(y1%BStCLoadMesh)) THEN
  DO i2 = LBOUND(y_out%BStCLoadMesh,2),UBOUND(y_out%BStCLoadMesh,2)
  DO i1 = LBOUND(y_out%BStCLoadMesh,1),UBOUND(y_out%BStCLoadMesh,1)
      CALL MeshExtrapInterp1(y1%BStCLoadMesh(i1,i2), y2%BStCLoadMesh(i1,i2), tin, y_out%BStCLoadMesh(i1,i2), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%NStCLoadMesh) .AND. ALLOCATED(y1%NStCLoadMesh)) THEN
  DO i1 = LBOUND(y_out%NStCLoadMesh,1),UBOUND(y_out%NStCLoadMesh,1)
      CALL MeshExtrapInterp1(y1%NStCLoadMesh(i1), y2%NStCLoadMesh(i1), tin, y_out%NStCLoadMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%TStCLoadMesh) .AND. ALLOCATED(y1%TStCLoadMesh)) THEN
  DO i1 = LBOUND(y_out%TStCLoadMesh,1),UBOUND(y_out%TStCLoadMesh,1)
      CALL MeshExtrapInterp1(y1%TStCLoadMesh(i1), y2%TStCLoadMesh(i1), tin, y_out%TStCLoadMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%SStCLoadMesh) .AND. ALLOCATED(y1%SStCLoadMesh)) THEN
  DO i1 = LBOUND(y_out%SStCLoadMesh,1),UBOUND(y_out%SStCLoadMesh,1)
      CALL MeshExtrapInterp1(y1%SStCLoadMesh(i1), y2%SStCLoadMesh(i1), tin, y_out%SStCLoadMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%toSC) .AND. ALLOCATED(y1%toSC)) THEN
  DO i1 = LBOUND(y_out%toSC,1),UBOUND(y_out%toSC,1)
    b = -(y1%toSC(i1) - y2%toSC(i1))
    y_out%toSC(i1) = y1%toSC(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE SrvD_Output_ExtrapInterp1


 SUBROUTINE SrvD_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(SrvD_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'SrvD_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%BlPitchCom) .AND. ALLOCATED(y1%BlPitchCom)) THEN
  DO i1 = LBOUND(y_out%BlPitchCom,1),UBOUND(y_out%BlPitchCom,1)
    CALL Angles_ExtrapInterp( y1%BlPitchCom(i1), y2%BlPitchCom(i1), y3%BlPitchCom(i1), tin, y_out%BlPitchCom(i1), tin_out )
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%BlAirfoilCom) .AND. ALLOCATED(y1%BlAirfoilCom)) THEN
  DO i1 = LBOUND(y_out%BlAirfoilCom,1),UBOUND(y_out%BlAirfoilCom,1)
    b = (t(3)**2*(y1%BlAirfoilCom(i1) - y2%BlAirfoilCom(i1)) + t(2)**2*(-y1%BlAirfoilCom(i1) + y3%BlAirfoilCom(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%BlAirfoilCom(i1) + t(3)*y2%BlAirfoilCom(i1) - t(2)*y3%BlAirfoilCom(i1) ) * scaleFactor
    y_out%BlAirfoilCom(i1) = y1%BlAirfoilCom(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
  b = (t(3)**2*(y1%YawMom - y2%YawMom) + t(2)**2*(-y1%YawMom + y3%YawMom))* scaleFactor
  c = ( (t(2)-t(3))*y1%YawMom + t(3)*y2%YawMom - t(2)*y3%YawMom ) * scaleFactor
  y_out%YawMom = y1%YawMom + b  + c * t_out
  b = (t(3)**2*(y1%GenTrq - y2%GenTrq) + t(2)**2*(-y1%GenTrq + y3%GenTrq))* scaleFactor
  c = ( (t(2)-t(3))*y1%GenTrq + t(3)*y2%GenTrq - t(2)*y3%GenTrq ) * scaleFactor
  y_out%GenTrq = y1%GenTrq + b  + c * t_out
  b = (t(3)**2*(y1%HSSBrTrqC - y2%HSSBrTrqC) + t(2)**2*(-y1%HSSBrTrqC + y3%HSSBrTrqC))* scaleFactor
  c = ( (t(2)-t(3))*y1%HSSBrTrqC + t(3)*y2%HSSBrTrqC - t(2)*y3%HSSBrTrqC ) * scaleFactor
  y_out%HSSBrTrqC = y1%HSSBrTrqC + b  + c * t_out
  b = (t(3)**2*(y1%ElecPwr - y2%ElecPwr) + t(2)**2*(-y1%ElecPwr + y3%ElecPwr))* scaleFactor
  c = ( (t(2)-t(3))*y1%ElecPwr + t(3)*y2%ElecPwr - t(2)*y3%ElecPwr ) * scaleFactor
  y_out%ElecPwr = y1%ElecPwr + b  + c * t_out
IF (ALLOCATED(y_out%TBDrCon) .AND. ALLOCATED(y1%TBDrCon)) THEN
  DO i1 = LBOUND(y_out%TBDrCon,1),UBOUND(y_out%TBDrCon,1)
    b = (t(3)**2*(y1%TBDrCon(i1) - y2%TBDrCon(i1)) + t(2)**2*(-y1%TBDrCon(i1) + y3%TBDrCon(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%TBDrCon(i1) + t(3)*y2%TBDrCon(i1) - t(2)*y3%TBDrCon(i1) ) * scaleFactor
    y_out%TBDrCon(i1) = y1%TBDrCon(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Lidar) .AND. ALLOCATED(y1%Lidar)) THEN
  DO i1 = LBOUND(y_out%Lidar,1),UBOUND(y_out%Lidar,1)
    b = (t(3)**2*(y1%Lidar(i1) - y2%Lidar(i1)) + t(2)**2*(-y1%Lidar(i1) + y3%Lidar(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%Lidar(i1) + t(3)*y2%Lidar(i1) - t(2)*y3%Lidar(i1) ) * scaleFactor
    y_out%Lidar(i1) = y1%Lidar(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%CableDeltaL) .AND. ALLOCATED(y1%CableDeltaL)) THEN
  DO i1 = LBOUND(y_out%CableDeltaL,1),UBOUND(y_out%CableDeltaL,1)
    b = (t(3)**2*(y1%CableDeltaL(i1) - y2%CableDeltaL(i1)) + t(2)**2*(-y1%CableDeltaL(i1) + y3%CableDeltaL(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%CableDeltaL(i1) + t(3)*y2%CableDeltaL(i1) - t(2)*y3%CableDeltaL(i1) ) * scaleFactor
    y_out%CableDeltaL(i1) = y1%CableDeltaL(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%CableDeltaLdot) .AND. ALLOCATED(y1%CableDeltaLdot)) THEN
  DO i1 = LBOUND(y_out%CableDeltaLdot,1),UBOUND(y_out%CableDeltaLdot,1)
    b = (t(3)**2*(y1%CableDeltaLdot(i1) - y2%CableDeltaLdot(i1)) + t(2)**2*(-y1%CableDeltaLdot(i1) + y3%CableDeltaLdot(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%CableDeltaLdot(i1) + t(3)*y2%CableDeltaLdot(i1) - t(2)*y3%CableDeltaLdot(i1) ) * scaleFactor
    y_out%CableDeltaLdot(i1) = y1%CableDeltaLdot(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%BStCLoadMesh) .AND. ALLOCATED(y1%BStCLoadMesh)) THEN
  DO i2 = LBOUND(y_out%BStCLoadMesh,2),UBOUND(y_out%BStCLoadMesh,2)
  DO i1 = LBOUND(y_out%BStCLoadMesh,1),UBOUND(y_out%BStCLoadMesh,1)
      CALL MeshExtrapInterp2(y1%BStCLoadMesh(i1,i2), y2%BStCLoadMesh(i1,i2), y3%BStCLoadMesh(i1,i2), tin, y_out%BStCLoadMesh(i1,i2), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%NStCLoadMesh) .AND. ALLOCATED(y1%NStCLoadMesh)) THEN
  DO i1 = LBOUND(y_out%NStCLoadMesh,1),UBOUND(y_out%NStCLoadMesh,1)
      CALL MeshExtrapInterp2(y1%NStCLoadMesh(i1), y2%NStCLoadMesh(i1), y3%NStCLoadMesh(i1), tin, y_out%NStCLoadMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%TStCLoadMesh) .AND. ALLOCATED(y1%TStCLoadMesh)) THEN
  DO i1 = LBOUND(y_out%TStCLoadMesh,1),UBOUND(y_out%TStCLoadMesh,1)
      CALL MeshExtrapInterp2(y1%TStCLoadMesh(i1), y2%TStCLoadMesh(i1), y3%TStCLoadMesh(i1), tin, y_out%TStCLoadMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%SStCLoadMesh) .AND. ALLOCATED(y1%SStCLoadMesh)) THEN
  DO i1 = LBOUND(y_out%SStCLoadMesh,1),UBOUND(y_out%SStCLoadMesh,1)
      CALL MeshExtrapInterp2(y1%SStCLoadMesh(i1), y2%SStCLoadMesh(i1), y3%SStCLoadMesh(i1), tin, y_out%SStCLoadMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%toSC) .AND. ALLOCATED(y1%toSC)) THEN
  DO i1 = LBOUND(y_out%toSC,1),UBOUND(y_out%toSC,1)
    b = (t(3)**2*(y1%toSC(i1) - y2%toSC(i1)) + t(2)**2*(-y1%toSC(i1) + y3%toSC(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%toSC(i1) + t(3)*y2%toSC(i1) - t(2)*y3%toSC(i1) ) * scaleFactor
    y_out%toSC(i1) = y1%toSC(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE SrvD_Output_ExtrapInterp2

END MODULE ServoDyn_Types
!ENDOFREGISTRYGENERATEDFILE
