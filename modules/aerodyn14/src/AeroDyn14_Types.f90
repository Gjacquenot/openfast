!STARTOFREGISTRYGENERATEDFILE 'AeroDyn14_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn14_Types
!.................................................................................................................................
! This file is part of AeroDyn14.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn14. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn14_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE DWM_Types
USE NWTC_Library
IMPLICIT NONE
! =========  Marker  =======
  TYPE, PUBLIC :: Marker
    REAL(ReKi) , DIMENSION(1:3)  :: Position 
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orientation 
    REAL(ReKi) , DIMENSION(1:3)  :: TranslationVel 
    REAL(ReKi) , DIMENSION(1:3)  :: RotationVel 
  END TYPE Marker
! =======================
! =========  AeroConfig  =======
  TYPE, PUBLIC :: AeroConfig
    TYPE(Marker) , DIMENSION(:), ALLOCATABLE  :: Blade 
    TYPE(Marker)  :: Hub 
    TYPE(Marker)  :: RotorFurl 
    TYPE(Marker)  :: Nacelle 
    TYPE(Marker)  :: TailFin 
    TYPE(Marker)  :: Tower 
    TYPE(Marker)  :: SubStructure 
    TYPE(Marker)  :: Foundation 
    REAL(ReKi)  :: BladeLength 
  END TYPE AeroConfig
! =======================
! =========  AirFoil  =======
  TYPE, PUBLIC :: AirFoil
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CD 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CL 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CM 
    REAL(ReKi)  :: PMC 
    REAL(ReKi)  :: MulTabLoc 
  END TYPE AirFoil
! =======================
! =========  AirFoilParms  =======
  TYPE, PUBLIC :: AirFoilParms
    INTEGER(IntKi)  :: MaxTable = 20 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTables 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NLift 
    INTEGER(IntKi)  :: NumCL 
    INTEGER(IntKi)  :: NumFoil 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NFoil 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabMet 
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: FoilNm 
  END TYPE AirFoilParms
! =======================
! =========  Beddoes  =======
  TYPE, PUBLIC :: Beddoes
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ADOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AFE1 
    REAL(ReKi)  :: AN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOL 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: BEDSEP 
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: OLDSEP 
    REAL(ReKi)  :: CC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CDO 
    REAL(ReKi)  :: CMI 
    REAL(ReKi)  :: CMQ 
    REAL(ReKi)  :: CN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNA 
    REAL(ReKi)  :: CNCP 
    REAL(ReKi)  :: CNIQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPD1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNPOT1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNSL 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CVN1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFAFE1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DQP1 
    REAL(ReKi)  :: DS 
    REAL(ReKi)  :: FK 
    REAL(ReKi)  :: FP 
    REAL(ReKi)  :: FPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSP1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FSPC1 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTB 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: FTBC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDCNV 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDF 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDFC 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDPP 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDDQ 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDTAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDXN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLDYN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: QX1 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TAU 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XN 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: YN 
    LOGICAL  :: SHIFT 
    LOGICAL  :: VOR 
  END TYPE Beddoes
! =======================
! =========  BeddoesParms  =======
  TYPE, PUBLIC :: BeddoesParms
    REAL(ReKi)  :: AS      !< Speed of sound for mach num calc [-]
    REAL(ReKi)  :: TF      !< Time constant applied to loc of separation pt [-]
    REAL(ReKi)  :: TP      !< Time constant for pressure lag [-]
    REAL(ReKi)  :: TV      !< Time constant for strength and shed of vortex [-]
    REAL(ReKi)  :: TVL      !< Nondim time of transit of vort moving across airfoil surf [-]
  END TYPE BeddoesParms
! =======================
! =========  BladeParms  =======
  TYPE, PUBLIC :: BladeParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: C      !< Chord of each blade element from input file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DR      !< Span-wise width of elem (len of elem ctred at RELM(i) [-]
    REAL(ReKi)  :: R      !< Rotor radius [-]
    REAL(ReKi)  :: BladeLength      !< Blade Length [-]
  END TYPE BladeParms
! =======================
! =========  DynInflow  =======
  TYPE, PUBLIC :: DynInflow
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: dAlph_dt 
    REAL(ReKi) , DIMENSION(3:6,1:4)  :: dBeta_dt 
    REAL(ReKi)  :: DTO 
    REAL(ReKi) , DIMENSION(1:6)  :: old_Alph 
    REAL(ReKi) , DIMENSION(3:6)  :: old_Beta 
    REAL(ReKi)  :: old_LmdM 
    REAL(ReKi)  :: oldKai 
    REAL(ReKi) , DIMENSION(1:6)  :: PhiLqC 
    REAL(ReKi) , DIMENSION(3:6)  :: PhiLqS 
    REAL(ReKi)  :: Pzero 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMC_SAVE 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RMS_SAVE 
    REAL(ReKi)  :: TipSpeed 
    REAL(ReKi)  :: totalInf 
    REAL(ReKi)  :: Vparam 
    REAL(ReKi)  :: Vtotal 
    REAL(ReKi) , DIMENSION(1:6)  :: xAlpha 
    REAL(ReKi) , DIMENSION(3:6)  :: xBeta 
    REAL(ReKi)  :: xKai 
    REAL(ReKi)  :: XLAMBDA_M 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: xLcos 
    REAL(ReKi) , DIMENSION(3:6,3:6)  :: xLsin 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminR 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MminusR 
    INTEGER(IntKi) , DIMENSION(1:6,1:6)  :: MplusR 
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: GAMMA 
  END TYPE DynInflow
! =======================
! =========  DynInflowParms  =======
  TYPE, PUBLIC :: DynInflowParms
    INTEGER(IntKi)  :: MAXINFLO = 2 
    REAL(ReKi) , DIMENSION(1:6)  :: xMinv 
  END TYPE DynInflowParms
! =======================
! =========  Element  =======
  TYPE, PUBLIC :: Element
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A      !< - [Axial induction factor]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AP      !< - [Tangential induction factor]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ALPHA      !< - [Angle of attack]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: W2      !< - [Relative velocity norm ]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_A_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: OLD_AP_NS 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PITNOW      !< - [Current pitch angle - Based on blade orientation (to verify)]
  END TYPE Element
! =======================
! =========  ElementParms  =======
  TYPE, PUBLIC :: ElementParms
    INTEGER(IntKi)  :: NELM      !< - [Number of elements (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TWIST      !< - [Airfoil twist angle (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RELM      !< - [Radius of element (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HLCNST      !< - [Hub loss constant B/2*(r-rh)/rh (constant)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TLCNST      !< - [Tip loss constant B/2*(R-r)/R (constant) ]
  END TYPE ElementParms
! =======================
! =========  ElOutParms  =======
  TYPE, PUBLIC :: ElOutParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAA 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AAP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ALF 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CDD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CLL 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CNN 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CTT 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFNSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DFTSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DynPres 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PMM 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PITSAV 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ReyNum 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Gamma      !< - [Circulation along the span, 1/2 c Vrel Cl]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVX 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVY 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SaveVZ 
    REAL(ReKi)  :: VXSAV 
    REAL(ReKi)  :: VYSAV 
    REAL(ReKi)  :: VZSAV 
    INTEGER(IntKi)  :: NumWndElOut      !< Number of Blade Elements [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: WndElPrNum 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrList 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    INTEGER(IntKi)  :: NumElOut      !< Number of Blade Elements [-]
  END TYPE ElOutParms
! =======================
! =========  InducedVel  =======
  TYPE, PUBLIC :: InducedVel
    REAL(ReKi)  :: SumInFl = 0 
  END TYPE InducedVel
! =======================
! =========  InducedVelParms  =======
  TYPE, PUBLIC :: InducedVelParms
    REAL(ReKi)  :: AToler      !< Convergence tolerance for induction factor [-]
    REAL(ReKi)  :: EqAIDmult      !< Multiplier for drag term in axial-induction equation. [-]
    LOGICAL  :: EquilDA      !< False unless DB or DA appended to EQUIL [-]
    LOGICAL  :: EquilDT      !< False unless DB or DT appended to EQUIL [-]
    LOGICAL  :: TLoss      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: GTech      !< Tip-loss model (EQUIL only) [PRANDtl, GTECH, or NONE] [-]
    LOGICAL  :: HLoss      !< Hub-loss model (EQUIL only) [PRANDtl or NONE] [-]
  END TYPE InducedVelParms
! =======================
! =========  Rotor  =======
  TYPE, PUBLIC :: Rotor
    REAL(ReKi)  :: AVGINFL      !< average induced velocity at the previous time [-]
    REAL(ReKi)  :: CTILT 
    REAL(ReKi)  :: CYaw 
    REAL(ReKi)  :: REVS 
    REAL(ReKi)  :: STILT 
    REAL(ReKi)  :: SYaw 
    REAL(ReKi)  :: TILT 
    REAL(ReKi)  :: YawAng 
    REAL(ReKi)  :: YawVEL 
  END TYPE Rotor
! =======================
! =========  RotorParms  =======
  TYPE, PUBLIC :: RotorParms
    REAL(ReKi)  :: HH 
  END TYPE RotorParms
! =======================
! =========  TwrPropsParms  =======
  TYPE, PUBLIC :: TwrPropsParms
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrHtFr 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrWid 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrCD 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrRe 
    REAL(ReKi) , DIMENSION(1:3)  :: VTwr 
    REAL(ReKi)  :: Tower_Wake_Constant 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NTwrCDCol      !< The tower CD column that represents a particular twr ht [-]
    INTEGER(IntKi)  :: NTwrHT      !< The number of tower height rows in the table [-]
    INTEGER(IntKi)  :: NTwrRe      !< The number of tower Re entry rows in the table [-]
    INTEGER(IntKi)  :: NTwrCD      !< The number of tower CD columns in the table [-]
    LOGICAL  :: TwrPotent      !< Tower influence model [-]
    LOGICAL  :: TwrShadow      !< Tower shadow model [-]
    REAL(ReKi)  :: ShadHWid      !< Tower-shadow half width [m]
    REAL(ReKi)  :: TShadC1      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TShadC2      !< Tower-shadow constant [-]
    REAL(ReKi)  :: TwrShad      !< Tower-shadow velocity deficit [-]
    LOGICAL  :: PJM_Version      !< Only true if new tower influence model, by PJM [-]
    CHARACTER(1024)  :: TwrFile      !< Tower data file name [-]
    REAL(ReKi)  :: T_Shad_Refpt      !< Tower-shadow reference point [m]
    LOGICAL  :: CalcTwrAero      !< Flag to tell AeroDyn to calculate drag on the tower [m]
    INTEGER(IntKi)  :: NumTwrNodes      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrNodeWidth      !< The width (diameter) of the tower at the ElastoDyn node locations. [-]
  END TYPE TwrPropsParms
! =======================
! =========  Wind  =======
  TYPE, PUBLIC :: Wind
    REAL(ReKi)  :: ANGFLW 
    REAL(ReKi)  :: CDEL 
    REAL(ReKi)  :: VROTORX 
    REAL(ReKi)  :: VROTORY 
    REAL(ReKi)  :: VROTORZ 
    REAL(ReKi)  :: SDEL 
  END TYPE Wind
! =======================
! =========  WindParms  =======
  TYPE, PUBLIC :: WindParms
    REAL(ReKi)  :: Rho      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [(m^2/sec)]
  END TYPE WindParms
! =======================
! =========  PositionType  =======
  TYPE, PUBLIC :: PositionType
    REAL(ReKi) , DIMENSION(1:3)  :: Pos      !< X,Y,Z coordinate of a point [-]
  END TYPE PositionType
! =======================
! =========  OrientationType  =======
  TYPE, PUBLIC :: OrientationType
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: Orient      !< Direction Cosine Matrix [-]
  END TYPE OrientationType
! =======================
! =========  AD14_InitInputType  =======
  TYPE, PUBLIC :: AD14_InitInputType
    CHARACTER(1024)  :: Title      !< Title [-]
    CHARACTER(1024)  :: OutRootName 
    CHARACTER(1024)  :: ADFileName      !< AeroDyn file name [-]
    LOGICAL  :: WrSumFile      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: NumBl      !< Number of Blades [-]
    REAL(ReKi)  :: BladeLength      !< Blade Length [-]
    LOGICAL  :: LinearizeFlag 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    TYPE(AeroConfig)  :: TurbineComponents 
    INTEGER(IntKi)  :: NumTwrNodes      !< Number of ElastoDyn tower nodes.  Tower drag will be computed at those points. [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrNodeLocs      !< Location of ElastoDyn tower nodes with respect to the inertial origin. [-]
    REAL(ReKi)  :: HubHt      !< hub height wrt inertial origin [m]
    TYPE(DWM_InitInputType)  :: DWM 
  END TYPE AD14_InitInputType
! =======================
! =========  AD14_InitOutputType  =======
  TYPE, PUBLIC :: AD14_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< version information [-]
    TYPE(DWM_InitOutputType)  :: DWM 
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
  END TYPE AD14_InitOutputType
! =======================
! =========  AD14_ContinuousStateType  =======
  TYPE, PUBLIC :: AD14_ContinuousStateType
    TYPE(DWM_ContinuousStateType)  :: DWM 
  END TYPE AD14_ContinuousStateType
! =======================
! =========  AD14_DiscreteStateType  =======
  TYPE, PUBLIC :: AD14_DiscreteStateType
    TYPE(DWM_DiscreteStateType)  :: DWM 
  END TYPE AD14_DiscreteStateType
! =======================
! =========  AD14_ConstraintStateType  =======
  TYPE, PUBLIC :: AD14_ConstraintStateType
    TYPE(DWM_ConstraintStateType)  :: DWM 
  END TYPE AD14_ConstraintStateType
! =======================
! =========  AD14_OtherStateType  =======
  TYPE, PUBLIC :: AD14_OtherStateType
    TYPE(DWM_OtherStateType)  :: DWM      !< variables for DWM module [-]
  END TYPE AD14_OtherStateType
! =======================
! =========  AD14_MiscVarType  =======
  TYPE, PUBLIC :: AD14_MiscVarType
    TYPE(DWM_MiscVarType)  :: DWM      !< variables for DWM module [-]
    TYPE(DWM_InputType)  :: DWM_Inputs 
    TYPE(DWM_OutputType)  :: DWM_Outputs 
    REAL(DbKi)  :: DT      !< actual Time step [seconds]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ElPrNum 
    REAL(DbKi)  :: OldTime 
    REAL(ReKi)  :: HubLoss = 1 
    REAL(ReKi)  :: Loss = 1 
    REAL(ReKi)  :: TipLoss = 1 
    REAL(ReKi)  :: TLpt7 
    LOGICAL  :: FirstPassGTL = .TRUE. 
    LOGICAL  :: SuperSonic = .FALSE. 
    LOGICAL  :: AFLAGVinderr = .FALSE. 
    LOGICAL  :: AFLAGTwrInflu = .FALSE. 
    LOGICAL  :: OnePassDynDbg = .TRUE. 
    LOGICAL  :: NoLoadsCalculated = .TRUE. 
    INTEGER(IntKi)  :: NERRORS = 0 
    TYPE(AirFoil)  :: AirFoil 
    TYPE(Beddoes)  :: Beddoes 
    TYPE(DynInflow)  :: DynInflow 
    TYPE(Element)  :: Element 
    TYPE(Rotor)  :: Rotor 
    TYPE(Wind)  :: Wind 
    TYPE(InducedVel)  :: InducedVel 
    TYPE(ElOutParms)  :: ElOut 
    LOGICAL  :: Skew 
    LOGICAL  :: DynInit      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: FirstWarn      !< If it's the first warning about AeroDyn not recalculating loads [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredForces 
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: StoredMoments 
  END TYPE AD14_MiscVarType
! =======================
! =========  AD14_ParameterType  =======
  TYPE, PUBLIC :: AD14_ParameterType
    CHARACTER(1024)  :: Title      !< Title [-]
    LOGICAL  :: SIUnit 
    LOGICAL  :: Echo = .FALSE. 
    LOGICAL  :: MultiTab 
    LOGICAL  :: LinearizeFlag 
    LOGICAL  :: OutputPlottingInfo = .FALSE. 
    LOGICAL  :: UseDWM = .FALSE.      !< flag to determine if DWM module should be used [-]
    REAL(ReKi)  :: TwoPiNB      !< 2*pi/num of blades [-]
    INTEGER(IntKi)  :: NumBl      !< Number of Blades [-]
    INTEGER(IntKi)  :: NBlInpSt      !< Number of Blade Input Stations [-]
    LOGICAL  :: ElemPrn 
    LOGICAL  :: DStall      !< FALSE=Steady, TRUE=BEDDOES [-]
    LOGICAL  :: PMoment      !< FALSE=NO_CM, TRUE=USE_CM [-]
    LOGICAL  :: Reynolds 
    LOGICAL  :: DynInfl      !< FALSE=EQUIL, TRUE=DYNIN [-]
    LOGICAL  :: Wake      !< False unless WAKE or SWIRL [-]
    LOGICAL  :: Swirl      !< False unless WAKE or SWIRL [-]
    REAL(DbKi)  :: DtAero      !< Time interval for aerodynamic calculations [-]
    REAL(ReKi)  :: HubRad      !< Hub radius [m]
    INTEGER(IntKi)  :: UnEc = -1 
    INTEGER(IntKi)  :: UnElem = -1 
    INTEGER(IntKi)  :: UnWndOut = -1 
    INTEGER(IntKi)  :: MAXICOUNT = 1000 
    LOGICAL  :: WrOptFile = .TRUE.      !< T/F: Write an AeroDyn summary [-]
    INTEGER(IntKi)  :: DEFAULT_Wind = -1 
    TYPE(AirFoilParms)  :: AirFoil 
    TYPE(BladeParms)  :: Blade 
    TYPE(BeddoesParms)  :: Beddoes 
    TYPE(DynInflowParms)  :: DynInflow 
    TYPE(ElementParms)  :: Element 
    TYPE(TwrPropsParms)  :: TwrProps 
    TYPE(InducedVelParms)  :: InducedVel 
    TYPE(WindParms)  :: Wind 
    TYPE(RotorParms)  :: Rotor 
    TYPE(DWM_ParameterType)  :: DWM 
  END TYPE AD14_ParameterType
! =======================
! =========  AD14_InputType  =======
  TYPE, PUBLIC :: AD14_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: InputMarkers      !< Input Forces and positions for the blades (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_InputMarkers      !< Input Forces and positions for the tower (mesh) [-]
    TYPE(AeroConfig)  :: TurbineComponents      !< Current locations of components [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MulTabLoc 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowVelocity      !< U,V,W wind inflow speeds at all locations on the Inputmarker and Twr_InputMarker meshes [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgInfVel      !< an average disk velocity (depends on wind type and should be removed) [m/s]
  END TYPE AD14_InputType
! =======================
! =========  AD14_OutputType  =======
  TYPE, PUBLIC :: AD14_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: OutputLoads      !< Output Loads (mesh) for each blade [-]
    TYPE(MeshType)  :: Twr_OutputLoads      !< Tower Output Loads (mesh) [-]
  END TYPE AD14_OutputType
! =======================
CONTAINS
 SUBROUTINE AD14_CopyMarker( SrcMarkerData, DstMarkerData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Marker), INTENT(IN) :: SrcMarkerData
   TYPE(Marker), INTENT(INOUT) :: DstMarkerData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyMarker'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMarkerData%Position = SrcMarkerData%Position
    DstMarkerData%Orientation = SrcMarkerData%Orientation
    DstMarkerData%TranslationVel = SrcMarkerData%TranslationVel
    DstMarkerData%RotationVel = SrcMarkerData%RotationVel
 END SUBROUTINE AD14_CopyMarker

 SUBROUTINE AD14_DestroyMarker( MarkerData, ErrStat, ErrMsg )
  TYPE(Marker), INTENT(INOUT) :: MarkerData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyMarker'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyMarker


subroutine AD14_PackMarker(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Marker), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackMarker'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Position
   call RegPack(Buf, InData%Position)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Orientation
   call RegPack(Buf, InData%Orientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TranslationVel
   call RegPack(Buf, InData%TranslationVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotationVel
   call RegPack(Buf, InData%RotationVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackMarker(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Marker), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackMarker'
   if (Buf%ErrStat /= ErrID_None) return
   ! Position
   call RegUnpack(Buf, OutData%Position)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Orientation
   call RegUnpack(Buf, OutData%Orientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TranslationVel
   call RegUnpack(Buf, OutData%TranslationVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotationVel
   call RegUnpack(Buf, OutData%RotationVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyAeroConfig( SrcAeroConfigData, DstAeroConfigData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AeroConfig), INTENT(IN) :: SrcAeroConfigData
   TYPE(AeroConfig), INTENT(INOUT) :: DstAeroConfigData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyAeroConfig'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcAeroConfigData%Blade)) THEN
  i1_l = LBOUND(SrcAeroConfigData%Blade,1)
  i1_u = UBOUND(SrcAeroConfigData%Blade,1)
  IF (.NOT. ALLOCATED(DstAeroConfigData%Blade)) THEN 
    ALLOCATE(DstAeroConfigData%Blade(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroConfigData%Blade.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcAeroConfigData%Blade,1), UBOUND(SrcAeroConfigData%Blade,1)
      CALL AD14_Copymarker( SrcAeroConfigData%Blade(i1), DstAeroConfigData%Blade(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL AD14_Copymarker( SrcAeroConfigData%Hub, DstAeroConfigData%Hub, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%RotorFurl, DstAeroConfigData%RotorFurl, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%Nacelle, DstAeroConfigData%Nacelle, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%TailFin, DstAeroConfigData%TailFin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%Tower, DstAeroConfigData%Tower, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%SubStructure, DstAeroConfigData%SubStructure, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copymarker( SrcAeroConfigData%Foundation, DstAeroConfigData%Foundation, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstAeroConfigData%BladeLength = SrcAeroConfigData%BladeLength
 END SUBROUTINE AD14_CopyAeroConfig

 SUBROUTINE AD14_DestroyAeroConfig( AeroConfigData, ErrStat, ErrMsg )
  TYPE(AeroConfig), INTENT(INOUT) :: AeroConfigData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyAeroConfig'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(AeroConfigData%Blade)) THEN
DO i1 = LBOUND(AeroConfigData%Blade,1), UBOUND(AeroConfigData%Blade,1)
  CALL AD14_DestroyMarker( AeroConfigData%Blade(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(AeroConfigData%Blade)
ENDIF
  CALL AD14_DestroyMarker( AeroConfigData%Hub, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMarker( AeroConfigData%RotorFurl, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMarker( AeroConfigData%Nacelle, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMarker( AeroConfigData%TailFin, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMarker( AeroConfigData%Tower, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMarker( AeroConfigData%SubStructure, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMarker( AeroConfigData%Foundation, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyAeroConfig


subroutine AD14_PackAeroConfig(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AeroConfig), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAeroConfig'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Blade
   call RegPack(Buf, allocated(InData%Blade))
   if (allocated(InData%Blade)) then
      call RegPackBounds(Buf, 1, lbound(InData%Blade), ubound(InData%Blade))
      LB(1:1) = lbound(InData%Blade)
      UB(1:1) = ubound(InData%Blade)
      do i1 = LB(1), UB(1)
         call AD14_PackMarker(Buf, InData%Blade(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Hub
   call AD14_PackMarker(Buf, InData%Hub) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotorFurl
   call AD14_PackMarker(Buf, InData%RotorFurl) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nacelle
   call AD14_PackMarker(Buf, InData%Nacelle) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TailFin
   call AD14_PackMarker(Buf, InData%TailFin) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tower
   call AD14_PackMarker(Buf, InData%Tower) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubStructure
   call AD14_PackMarker(Buf, InData%SubStructure) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Foundation
   call AD14_PackMarker(Buf, InData%Foundation) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeLength
   call RegPack(Buf, InData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackAeroConfig(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AeroConfig), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAeroConfig'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Blade
   if (allocated(OutData%Blade)) deallocate(OutData%Blade)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Blade(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Blade.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD14_UnpackMarker(Buf, OutData%Blade(i1)) ! Blade 
      end do
   end if
   ! Hub
   call AD14_UnpackMarker(Buf, OutData%Hub) ! Hub 
   ! RotorFurl
   call AD14_UnpackMarker(Buf, OutData%RotorFurl) ! RotorFurl 
   ! Nacelle
   call AD14_UnpackMarker(Buf, OutData%Nacelle) ! Nacelle 
   ! TailFin
   call AD14_UnpackMarker(Buf, OutData%TailFin) ! TailFin 
   ! Tower
   call AD14_UnpackMarker(Buf, OutData%Tower) ! Tower 
   ! SubStructure
   call AD14_UnpackMarker(Buf, OutData%SubStructure) ! SubStructure 
   ! Foundation
   call AD14_UnpackMarker(Buf, OutData%Foundation) ! Foundation 
   ! BladeLength
   call RegUnpack(Buf, OutData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyAirFoil( SrcAirFoilData, DstAirFoilData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AirFoil), INTENT(IN) :: SrcAirFoilData
   TYPE(AirFoil), INTENT(INOUT) :: DstAirFoilData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyAirFoil'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcAirFoilData%AL)) THEN
  i1_l = LBOUND(SrcAirFoilData%AL,1)
  i1_u = UBOUND(SrcAirFoilData%AL,1)
  i2_l = LBOUND(SrcAirFoilData%AL,2)
  i2_u = UBOUND(SrcAirFoilData%AL,2)
  IF (.NOT. ALLOCATED(DstAirFoilData%AL)) THEN 
    ALLOCATE(DstAirFoilData%AL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%AL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%AL = SrcAirFoilData%AL
ENDIF
IF (ALLOCATED(SrcAirFoilData%CD)) THEN
  i1_l = LBOUND(SrcAirFoilData%CD,1)
  i1_u = UBOUND(SrcAirFoilData%CD,1)
  i2_l = LBOUND(SrcAirFoilData%CD,2)
  i2_u = UBOUND(SrcAirFoilData%CD,2)
  i3_l = LBOUND(SrcAirFoilData%CD,3)
  i3_u = UBOUND(SrcAirFoilData%CD,3)
  IF (.NOT. ALLOCATED(DstAirFoilData%CD)) THEN 
    ALLOCATE(DstAirFoilData%CD(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%CD = SrcAirFoilData%CD
ENDIF
IF (ALLOCATED(SrcAirFoilData%CL)) THEN
  i1_l = LBOUND(SrcAirFoilData%CL,1)
  i1_u = UBOUND(SrcAirFoilData%CL,1)
  i2_l = LBOUND(SrcAirFoilData%CL,2)
  i2_u = UBOUND(SrcAirFoilData%CL,2)
  i3_l = LBOUND(SrcAirFoilData%CL,3)
  i3_u = UBOUND(SrcAirFoilData%CL,3)
  IF (.NOT. ALLOCATED(DstAirFoilData%CL)) THEN 
    ALLOCATE(DstAirFoilData%CL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%CL = SrcAirFoilData%CL
ENDIF
IF (ALLOCATED(SrcAirFoilData%CM)) THEN
  i1_l = LBOUND(SrcAirFoilData%CM,1)
  i1_u = UBOUND(SrcAirFoilData%CM,1)
  i2_l = LBOUND(SrcAirFoilData%CM,2)
  i2_u = UBOUND(SrcAirFoilData%CM,2)
  i3_l = LBOUND(SrcAirFoilData%CM,3)
  i3_u = UBOUND(SrcAirFoilData%CM,3)
  IF (.NOT. ALLOCATED(DstAirFoilData%CM)) THEN 
    ALLOCATE(DstAirFoilData%CM(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilData%CM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilData%CM = SrcAirFoilData%CM
ENDIF
    DstAirFoilData%PMC = SrcAirFoilData%PMC
    DstAirFoilData%MulTabLoc = SrcAirFoilData%MulTabLoc
 END SUBROUTINE AD14_CopyAirFoil

 SUBROUTINE AD14_DestroyAirFoil( AirFoilData, ErrStat, ErrMsg )
  TYPE(AirFoil), INTENT(INOUT) :: AirFoilData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyAirFoil'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(AirFoilData%AL)) THEN
  DEALLOCATE(AirFoilData%AL)
ENDIF
IF (ALLOCATED(AirFoilData%CD)) THEN
  DEALLOCATE(AirFoilData%CD)
ENDIF
IF (ALLOCATED(AirFoilData%CL)) THEN
  DEALLOCATE(AirFoilData%CL)
ENDIF
IF (ALLOCATED(AirFoilData%CM)) THEN
  DEALLOCATE(AirFoilData%CM)
ENDIF
 END SUBROUTINE AD14_DestroyAirFoil


subroutine AD14_PackAirFoil(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AirFoil), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAirFoil'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AL
   call RegPack(Buf, allocated(InData%AL))
   if (allocated(InData%AL)) then
      call RegPackBounds(Buf, 2, lbound(InData%AL), ubound(InData%AL))
      call RegPack(Buf, InData%AL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CD
   call RegPack(Buf, allocated(InData%CD))
   if (allocated(InData%CD)) then
      call RegPackBounds(Buf, 3, lbound(InData%CD), ubound(InData%CD))
      call RegPack(Buf, InData%CD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CL
   call RegPack(Buf, allocated(InData%CL))
   if (allocated(InData%CL)) then
      call RegPackBounds(Buf, 3, lbound(InData%CL), ubound(InData%CL))
      call RegPack(Buf, InData%CL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CM
   call RegPack(Buf, allocated(InData%CM))
   if (allocated(InData%CM)) then
      call RegPackBounds(Buf, 3, lbound(InData%CM), ubound(InData%CM))
      call RegPack(Buf, InData%CM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PMC
   call RegPack(Buf, InData%PMC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MulTabLoc
   call RegPack(Buf, InData%MulTabLoc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackAirFoil(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AirFoil), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAirFoil'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AL
   if (allocated(OutData%AL)) deallocate(OutData%AL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CD
   if (allocated(OutData%CD)) deallocate(OutData%CD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CD(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CL
   if (allocated(OutData%CL)) deallocate(OutData%CL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CM
   if (allocated(OutData%CM)) deallocate(OutData%CM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CM(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PMC
   call RegUnpack(Buf, OutData%PMC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MulTabLoc
   call RegUnpack(Buf, OutData%MulTabLoc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyAirFoilParms( SrcAirFoilParmsData, DstAirFoilParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AirFoilParms), INTENT(IN) :: SrcAirFoilParmsData
   TYPE(AirFoilParms), INTENT(INOUT) :: DstAirFoilParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyAirFoilParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstAirFoilParmsData%MaxTable = SrcAirFoilParmsData%MaxTable
IF (ALLOCATED(SrcAirFoilParmsData%NTables)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%NTables,1)
  i1_u = UBOUND(SrcAirFoilParmsData%NTables,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%NTables)) THEN 
    ALLOCATE(DstAirFoilParmsData%NTables(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NTables.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%NTables = SrcAirFoilParmsData%NTables
ENDIF
IF (ALLOCATED(SrcAirFoilParmsData%NLift)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%NLift,1)
  i1_u = UBOUND(SrcAirFoilParmsData%NLift,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%NLift)) THEN 
    ALLOCATE(DstAirFoilParmsData%NLift(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NLift.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%NLift = SrcAirFoilParmsData%NLift
ENDIF
    DstAirFoilParmsData%NumCL = SrcAirFoilParmsData%NumCL
    DstAirFoilParmsData%NumFoil = SrcAirFoilParmsData%NumFoil
IF (ALLOCATED(SrcAirFoilParmsData%NFoil)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%NFoil,1)
  i1_u = UBOUND(SrcAirFoilParmsData%NFoil,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%NFoil)) THEN 
    ALLOCATE(DstAirFoilParmsData%NFoil(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%NFoil.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%NFoil = SrcAirFoilParmsData%NFoil
ENDIF
IF (ALLOCATED(SrcAirFoilParmsData%MulTabMet)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%MulTabMet,1)
  i1_u = UBOUND(SrcAirFoilParmsData%MulTabMet,1)
  i2_l = LBOUND(SrcAirFoilParmsData%MulTabMet,2)
  i2_u = UBOUND(SrcAirFoilParmsData%MulTabMet,2)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%MulTabMet)) THEN 
    ALLOCATE(DstAirFoilParmsData%MulTabMet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%MulTabMet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%MulTabMet = SrcAirFoilParmsData%MulTabMet
ENDIF
IF (ALLOCATED(SrcAirFoilParmsData%FoilNm)) THEN
  i1_l = LBOUND(SrcAirFoilParmsData%FoilNm,1)
  i1_u = UBOUND(SrcAirFoilParmsData%FoilNm,1)
  IF (.NOT. ALLOCATED(DstAirFoilParmsData%FoilNm)) THEN 
    ALLOCATE(DstAirFoilParmsData%FoilNm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAirFoilParmsData%FoilNm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAirFoilParmsData%FoilNm = SrcAirFoilParmsData%FoilNm
ENDIF
 END SUBROUTINE AD14_CopyAirFoilParms

 SUBROUTINE AD14_DestroyAirFoilParms( AirFoilParmsData, ErrStat, ErrMsg )
  TYPE(AirFoilParms), INTENT(INOUT) :: AirFoilParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyAirFoilParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(AirFoilParmsData%NTables)) THEN
  DEALLOCATE(AirFoilParmsData%NTables)
ENDIF
IF (ALLOCATED(AirFoilParmsData%NLift)) THEN
  DEALLOCATE(AirFoilParmsData%NLift)
ENDIF
IF (ALLOCATED(AirFoilParmsData%NFoil)) THEN
  DEALLOCATE(AirFoilParmsData%NFoil)
ENDIF
IF (ALLOCATED(AirFoilParmsData%MulTabMet)) THEN
  DEALLOCATE(AirFoilParmsData%MulTabMet)
ENDIF
IF (ALLOCATED(AirFoilParmsData%FoilNm)) THEN
  DEALLOCATE(AirFoilParmsData%FoilNm)
ENDIF
 END SUBROUTINE AD14_DestroyAirFoilParms


subroutine AD14_PackAirFoilParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AirFoilParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackAirFoilParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! MaxTable
   call RegPack(Buf, InData%MaxTable)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTables
   call RegPack(Buf, allocated(InData%NTables))
   if (allocated(InData%NTables)) then
      call RegPackBounds(Buf, 1, lbound(InData%NTables), ubound(InData%NTables))
      call RegPack(Buf, InData%NTables)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NLift
   call RegPack(Buf, allocated(InData%NLift))
   if (allocated(InData%NLift)) then
      call RegPackBounds(Buf, 1, lbound(InData%NLift), ubound(InData%NLift))
      call RegPack(Buf, InData%NLift)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCL
   call RegPack(Buf, InData%NumCL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumFoil
   call RegPack(Buf, InData%NumFoil)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NFoil
   call RegPack(Buf, allocated(InData%NFoil))
   if (allocated(InData%NFoil)) then
      call RegPackBounds(Buf, 1, lbound(InData%NFoil), ubound(InData%NFoil))
      call RegPack(Buf, InData%NFoil)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MulTabMet
   call RegPack(Buf, allocated(InData%MulTabMet))
   if (allocated(InData%MulTabMet)) then
      call RegPackBounds(Buf, 2, lbound(InData%MulTabMet), ubound(InData%MulTabMet))
      call RegPack(Buf, InData%MulTabMet)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FoilNm
   call RegPack(Buf, allocated(InData%FoilNm))
   if (allocated(InData%FoilNm)) then
      call RegPackBounds(Buf, 1, lbound(InData%FoilNm), ubound(InData%FoilNm))
      call RegPack(Buf, InData%FoilNm)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackAirFoilParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AirFoilParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackAirFoilParms'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! MaxTable
   call RegUnpack(Buf, OutData%MaxTable)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTables
   if (allocated(OutData%NTables)) deallocate(OutData%NTables)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NTables(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NTables.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NTables)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NLift
   if (allocated(OutData%NLift)) deallocate(OutData%NLift)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NLift(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NLift.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NLift)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumCL
   call RegUnpack(Buf, OutData%NumCL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumFoil
   call RegUnpack(Buf, OutData%NumFoil)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NFoil
   if (allocated(OutData%NFoil)) deallocate(OutData%NFoil)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NFoil(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NFoil.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NFoil)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MulTabMet
   if (allocated(OutData%MulTabMet)) deallocate(OutData%MulTabMet)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MulTabMet(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MulTabMet.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MulTabMet)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FoilNm
   if (allocated(OutData%FoilNm)) deallocate(OutData%FoilNm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FoilNm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FoilNm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FoilNm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD14_CopyBeddoes( SrcBeddoesData, DstBeddoesData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Beddoes), INTENT(IN) :: SrcBeddoesData
   TYPE(Beddoes), INTENT(INOUT) :: DstBeddoesData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyBeddoes'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBeddoesData%ADOT)) THEN
  i1_l = LBOUND(SrcBeddoesData%ADOT,1)
  i1_u = UBOUND(SrcBeddoesData%ADOT,1)
  i2_l = LBOUND(SrcBeddoesData%ADOT,2)
  i2_u = UBOUND(SrcBeddoesData%ADOT,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ADOT)) THEN 
    ALLOCATE(DstBeddoesData%ADOT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ADOT = SrcBeddoesData%ADOT
ENDIF
IF (ALLOCATED(SrcBeddoesData%ADOT1)) THEN
  i1_l = LBOUND(SrcBeddoesData%ADOT1,1)
  i1_u = UBOUND(SrcBeddoesData%ADOT1,1)
  i2_l = LBOUND(SrcBeddoesData%ADOT1,2)
  i2_u = UBOUND(SrcBeddoesData%ADOT1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ADOT1)) THEN 
    ALLOCATE(DstBeddoesData%ADOT1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ADOT1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ADOT1 = SrcBeddoesData%ADOT1
ENDIF
IF (ALLOCATED(SrcBeddoesData%AFE)) THEN
  i1_l = LBOUND(SrcBeddoesData%AFE,1)
  i1_u = UBOUND(SrcBeddoesData%AFE,1)
  i2_l = LBOUND(SrcBeddoesData%AFE,2)
  i2_u = UBOUND(SrcBeddoesData%AFE,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AFE)) THEN 
    ALLOCATE(DstBeddoesData%AFE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AFE = SrcBeddoesData%AFE
ENDIF
IF (ALLOCATED(SrcBeddoesData%AFE1)) THEN
  i1_l = LBOUND(SrcBeddoesData%AFE1,1)
  i1_u = UBOUND(SrcBeddoesData%AFE1,1)
  i2_l = LBOUND(SrcBeddoesData%AFE1,2)
  i2_u = UBOUND(SrcBeddoesData%AFE1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AFE1)) THEN 
    ALLOCATE(DstBeddoesData%AFE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AFE1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AFE1 = SrcBeddoesData%AFE1
ENDIF
    DstBeddoesData%AN = SrcBeddoesData%AN
IF (ALLOCATED(SrcBeddoesData%ANE)) THEN
  i1_l = LBOUND(SrcBeddoesData%ANE,1)
  i1_u = UBOUND(SrcBeddoesData%ANE,1)
  i2_l = LBOUND(SrcBeddoesData%ANE,2)
  i2_u = UBOUND(SrcBeddoesData%ANE,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ANE)) THEN 
    ALLOCATE(DstBeddoesData%ANE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ANE = SrcBeddoesData%ANE
ENDIF
IF (ALLOCATED(SrcBeddoesData%ANE1)) THEN
  i1_l = LBOUND(SrcBeddoesData%ANE1,1)
  i1_u = UBOUND(SrcBeddoesData%ANE1,1)
  i2_l = LBOUND(SrcBeddoesData%ANE1,2)
  i2_u = UBOUND(SrcBeddoesData%ANE1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%ANE1)) THEN 
    ALLOCATE(DstBeddoesData%ANE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%ANE1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%ANE1 = SrcBeddoesData%ANE1
ENDIF
IF (ALLOCATED(SrcBeddoesData%AOD)) THEN
  i1_l = LBOUND(SrcBeddoesData%AOD,1)
  i1_u = UBOUND(SrcBeddoesData%AOD,1)
  i2_l = LBOUND(SrcBeddoesData%AOD,2)
  i2_u = UBOUND(SrcBeddoesData%AOD,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AOD)) THEN 
    ALLOCATE(DstBeddoesData%AOD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AOD = SrcBeddoesData%AOD
ENDIF
IF (ALLOCATED(SrcBeddoesData%AOL)) THEN
  i1_l = LBOUND(SrcBeddoesData%AOL,1)
  i1_u = UBOUND(SrcBeddoesData%AOL,1)
  i2_l = LBOUND(SrcBeddoesData%AOL,2)
  i2_u = UBOUND(SrcBeddoesData%AOL,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%AOL)) THEN 
    ALLOCATE(DstBeddoesData%AOL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%AOL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%AOL = SrcBeddoesData%AOL
ENDIF
IF (ALLOCATED(SrcBeddoesData%BEDSEP)) THEN
  i1_l = LBOUND(SrcBeddoesData%BEDSEP,1)
  i1_u = UBOUND(SrcBeddoesData%BEDSEP,1)
  i2_l = LBOUND(SrcBeddoesData%BEDSEP,2)
  i2_u = UBOUND(SrcBeddoesData%BEDSEP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%BEDSEP)) THEN 
    ALLOCATE(DstBeddoesData%BEDSEP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%BEDSEP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%BEDSEP = SrcBeddoesData%BEDSEP
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDSEP)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDSEP,1)
  i1_u = UBOUND(SrcBeddoesData%OLDSEP,1)
  i2_l = LBOUND(SrcBeddoesData%OLDSEP,2)
  i2_u = UBOUND(SrcBeddoesData%OLDSEP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDSEP)) THEN 
    ALLOCATE(DstBeddoesData%OLDSEP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDSEP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDSEP = SrcBeddoesData%OLDSEP
ENDIF
    DstBeddoesData%CC = SrcBeddoesData%CC
IF (ALLOCATED(SrcBeddoesData%CDO)) THEN
  i1_l = LBOUND(SrcBeddoesData%CDO,1)
  i1_u = UBOUND(SrcBeddoesData%CDO,1)
  i2_l = LBOUND(SrcBeddoesData%CDO,2)
  i2_u = UBOUND(SrcBeddoesData%CDO,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CDO)) THEN 
    ALLOCATE(DstBeddoesData%CDO(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CDO.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CDO = SrcBeddoesData%CDO
ENDIF
    DstBeddoesData%CMI = SrcBeddoesData%CMI
    DstBeddoesData%CMQ = SrcBeddoesData%CMQ
    DstBeddoesData%CN = SrcBeddoesData%CN
IF (ALLOCATED(SrcBeddoesData%CNA)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNA,1)
  i1_u = UBOUND(SrcBeddoesData%CNA,1)
  i2_l = LBOUND(SrcBeddoesData%CNA,2)
  i2_u = UBOUND(SrcBeddoesData%CNA,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNA)) THEN 
    ALLOCATE(DstBeddoesData%CNA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNA = SrcBeddoesData%CNA
ENDIF
    DstBeddoesData%CNCP = SrcBeddoesData%CNCP
    DstBeddoesData%CNIQ = SrcBeddoesData%CNIQ
IF (ALLOCATED(SrcBeddoesData%CNP)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNP,1)
  i1_u = UBOUND(SrcBeddoesData%CNP,1)
  i2_l = LBOUND(SrcBeddoesData%CNP,2)
  i2_u = UBOUND(SrcBeddoesData%CNP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNP)) THEN 
    ALLOCATE(DstBeddoesData%CNP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNP = SrcBeddoesData%CNP
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNP1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNP1,1)
  i1_u = UBOUND(SrcBeddoesData%CNP1,1)
  i2_l = LBOUND(SrcBeddoesData%CNP1,2)
  i2_u = UBOUND(SrcBeddoesData%CNP1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNP1)) THEN 
    ALLOCATE(DstBeddoesData%CNP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNP1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNP1 = SrcBeddoesData%CNP1
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPD)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPD,1)
  i1_u = UBOUND(SrcBeddoesData%CNPD,1)
  i2_l = LBOUND(SrcBeddoesData%CNPD,2)
  i2_u = UBOUND(SrcBeddoesData%CNPD,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPD)) THEN 
    ALLOCATE(DstBeddoesData%CNPD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPD = SrcBeddoesData%CNPD
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPD1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPD1,1)
  i1_u = UBOUND(SrcBeddoesData%CNPD1,1)
  i2_l = LBOUND(SrcBeddoesData%CNPD1,2)
  i2_u = UBOUND(SrcBeddoesData%CNPD1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPD1)) THEN 
    ALLOCATE(DstBeddoesData%CNPD1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPD1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPD1 = SrcBeddoesData%CNPD1
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPOT)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPOT,1)
  i1_u = UBOUND(SrcBeddoesData%CNPOT,1)
  i2_l = LBOUND(SrcBeddoesData%CNPOT,2)
  i2_u = UBOUND(SrcBeddoesData%CNPOT,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPOT)) THEN 
    ALLOCATE(DstBeddoesData%CNPOT(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPOT = SrcBeddoesData%CNPOT
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNPOT1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNPOT1,1)
  i1_u = UBOUND(SrcBeddoesData%CNPOT1,1)
  i2_l = LBOUND(SrcBeddoesData%CNPOT1,2)
  i2_u = UBOUND(SrcBeddoesData%CNPOT1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNPOT1)) THEN 
    ALLOCATE(DstBeddoesData%CNPOT1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNPOT1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNPOT1 = SrcBeddoesData%CNPOT1
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNS)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNS,1)
  i1_u = UBOUND(SrcBeddoesData%CNS,1)
  i2_l = LBOUND(SrcBeddoesData%CNS,2)
  i2_u = UBOUND(SrcBeddoesData%CNS,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNS)) THEN 
    ALLOCATE(DstBeddoesData%CNS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNS = SrcBeddoesData%CNS
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNSL)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNSL,1)
  i1_u = UBOUND(SrcBeddoesData%CNSL,1)
  i2_l = LBOUND(SrcBeddoesData%CNSL,2)
  i2_u = UBOUND(SrcBeddoesData%CNSL,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNSL)) THEN 
    ALLOCATE(DstBeddoesData%CNSL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNSL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNSL = SrcBeddoesData%CNSL
ENDIF
IF (ALLOCATED(SrcBeddoesData%CNV)) THEN
  i1_l = LBOUND(SrcBeddoesData%CNV,1)
  i1_u = UBOUND(SrcBeddoesData%CNV,1)
  i2_l = LBOUND(SrcBeddoesData%CNV,2)
  i2_u = UBOUND(SrcBeddoesData%CNV,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CNV)) THEN 
    ALLOCATE(DstBeddoesData%CNV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CNV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CNV = SrcBeddoesData%CNV
ENDIF
IF (ALLOCATED(SrcBeddoesData%CVN)) THEN
  i1_l = LBOUND(SrcBeddoesData%CVN,1)
  i1_u = UBOUND(SrcBeddoesData%CVN,1)
  i2_l = LBOUND(SrcBeddoesData%CVN,2)
  i2_u = UBOUND(SrcBeddoesData%CVN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CVN)) THEN 
    ALLOCATE(DstBeddoesData%CVN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CVN = SrcBeddoesData%CVN
ENDIF
IF (ALLOCATED(SrcBeddoesData%CVN1)) THEN
  i1_l = LBOUND(SrcBeddoesData%CVN1,1)
  i1_u = UBOUND(SrcBeddoesData%CVN1,1)
  i2_l = LBOUND(SrcBeddoesData%CVN1,2)
  i2_u = UBOUND(SrcBeddoesData%CVN1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%CVN1)) THEN 
    ALLOCATE(DstBeddoesData%CVN1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%CVN1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%CVN1 = SrcBeddoesData%CVN1
ENDIF
IF (ALLOCATED(SrcBeddoesData%DF)) THEN
  i1_l = LBOUND(SrcBeddoesData%DF,1)
  i1_u = UBOUND(SrcBeddoesData%DF,1)
  i2_l = LBOUND(SrcBeddoesData%DF,2)
  i2_u = UBOUND(SrcBeddoesData%DF,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DF)) THEN 
    ALLOCATE(DstBeddoesData%DF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DF = SrcBeddoesData%DF
ENDIF
IF (ALLOCATED(SrcBeddoesData%DFAFE)) THEN
  i1_l = LBOUND(SrcBeddoesData%DFAFE,1)
  i1_u = UBOUND(SrcBeddoesData%DFAFE,1)
  i2_l = LBOUND(SrcBeddoesData%DFAFE,2)
  i2_u = UBOUND(SrcBeddoesData%DFAFE,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DFAFE)) THEN 
    ALLOCATE(DstBeddoesData%DFAFE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DFAFE = SrcBeddoesData%DFAFE
ENDIF
IF (ALLOCATED(SrcBeddoesData%DFAFE1)) THEN
  i1_l = LBOUND(SrcBeddoesData%DFAFE1,1)
  i1_u = UBOUND(SrcBeddoesData%DFAFE1,1)
  i2_l = LBOUND(SrcBeddoesData%DFAFE1,2)
  i2_u = UBOUND(SrcBeddoesData%DFAFE1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DFAFE1)) THEN 
    ALLOCATE(DstBeddoesData%DFAFE1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFAFE1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DFAFE1 = SrcBeddoesData%DFAFE1
ENDIF
IF (ALLOCATED(SrcBeddoesData%DFC)) THEN
  i1_l = LBOUND(SrcBeddoesData%DFC,1)
  i1_u = UBOUND(SrcBeddoesData%DFC,1)
  i2_l = LBOUND(SrcBeddoesData%DFC,2)
  i2_u = UBOUND(SrcBeddoesData%DFC,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DFC)) THEN 
    ALLOCATE(DstBeddoesData%DFC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DFC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DFC = SrcBeddoesData%DFC
ENDIF
IF (ALLOCATED(SrcBeddoesData%DN)) THEN
  i1_l = LBOUND(SrcBeddoesData%DN,1)
  i1_u = UBOUND(SrcBeddoesData%DN,1)
  i2_l = LBOUND(SrcBeddoesData%DN,2)
  i2_u = UBOUND(SrcBeddoesData%DN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DN)) THEN 
    ALLOCATE(DstBeddoesData%DN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DN = SrcBeddoesData%DN
ENDIF
IF (ALLOCATED(SrcBeddoesData%DPP)) THEN
  i1_l = LBOUND(SrcBeddoesData%DPP,1)
  i1_u = UBOUND(SrcBeddoesData%DPP,1)
  i2_l = LBOUND(SrcBeddoesData%DPP,2)
  i2_u = UBOUND(SrcBeddoesData%DPP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DPP)) THEN 
    ALLOCATE(DstBeddoesData%DPP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DPP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DPP = SrcBeddoesData%DPP
ENDIF
IF (ALLOCATED(SrcBeddoesData%DQ)) THEN
  i1_l = LBOUND(SrcBeddoesData%DQ,1)
  i1_u = UBOUND(SrcBeddoesData%DQ,1)
  i2_l = LBOUND(SrcBeddoesData%DQ,2)
  i2_u = UBOUND(SrcBeddoesData%DQ,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DQ)) THEN 
    ALLOCATE(DstBeddoesData%DQ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DQ = SrcBeddoesData%DQ
ENDIF
IF (ALLOCATED(SrcBeddoesData%DQP)) THEN
  i1_l = LBOUND(SrcBeddoesData%DQP,1)
  i1_u = UBOUND(SrcBeddoesData%DQP,1)
  i2_l = LBOUND(SrcBeddoesData%DQP,2)
  i2_u = UBOUND(SrcBeddoesData%DQP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DQP)) THEN 
    ALLOCATE(DstBeddoesData%DQP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DQP = SrcBeddoesData%DQP
ENDIF
IF (ALLOCATED(SrcBeddoesData%DQP1)) THEN
  i1_l = LBOUND(SrcBeddoesData%DQP1,1)
  i1_u = UBOUND(SrcBeddoesData%DQP1,1)
  i2_l = LBOUND(SrcBeddoesData%DQP1,2)
  i2_u = UBOUND(SrcBeddoesData%DQP1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%DQP1)) THEN 
    ALLOCATE(DstBeddoesData%DQP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%DQP1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%DQP1 = SrcBeddoesData%DQP1
ENDIF
    DstBeddoesData%DS = SrcBeddoesData%DS
    DstBeddoesData%FK = SrcBeddoesData%FK
    DstBeddoesData%FP = SrcBeddoesData%FP
    DstBeddoesData%FPC = SrcBeddoesData%FPC
IF (ALLOCATED(SrcBeddoesData%FSP)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSP,1)
  i1_u = UBOUND(SrcBeddoesData%FSP,1)
  i2_l = LBOUND(SrcBeddoesData%FSP,2)
  i2_u = UBOUND(SrcBeddoesData%FSP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSP)) THEN 
    ALLOCATE(DstBeddoesData%FSP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSP = SrcBeddoesData%FSP
ENDIF
IF (ALLOCATED(SrcBeddoesData%FSP1)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSP1,1)
  i1_u = UBOUND(SrcBeddoesData%FSP1,1)
  i2_l = LBOUND(SrcBeddoesData%FSP1,2)
  i2_u = UBOUND(SrcBeddoesData%FSP1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSP1)) THEN 
    ALLOCATE(DstBeddoesData%FSP1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSP1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSP1 = SrcBeddoesData%FSP1
ENDIF
IF (ALLOCATED(SrcBeddoesData%FSPC)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSPC,1)
  i1_u = UBOUND(SrcBeddoesData%FSPC,1)
  i2_l = LBOUND(SrcBeddoesData%FSPC,2)
  i2_u = UBOUND(SrcBeddoesData%FSPC,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSPC)) THEN 
    ALLOCATE(DstBeddoesData%FSPC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSPC = SrcBeddoesData%FSPC
ENDIF
IF (ALLOCATED(SrcBeddoesData%FSPC1)) THEN
  i1_l = LBOUND(SrcBeddoesData%FSPC1,1)
  i1_u = UBOUND(SrcBeddoesData%FSPC1,1)
  i2_l = LBOUND(SrcBeddoesData%FSPC1,2)
  i2_u = UBOUND(SrcBeddoesData%FSPC1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%FSPC1)) THEN 
    ALLOCATE(DstBeddoesData%FSPC1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FSPC1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FSPC1 = SrcBeddoesData%FSPC1
ENDIF
IF (ALLOCATED(SrcBeddoesData%FTB)) THEN
  i1_l = LBOUND(SrcBeddoesData%FTB,1)
  i1_u = UBOUND(SrcBeddoesData%FTB,1)
  i2_l = LBOUND(SrcBeddoesData%FTB,2)
  i2_u = UBOUND(SrcBeddoesData%FTB,2)
  i3_l = LBOUND(SrcBeddoesData%FTB,3)
  i3_u = UBOUND(SrcBeddoesData%FTB,3)
  IF (.NOT. ALLOCATED(DstBeddoesData%FTB)) THEN 
    ALLOCATE(DstBeddoesData%FTB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FTB = SrcBeddoesData%FTB
ENDIF
IF (ALLOCATED(SrcBeddoesData%FTBC)) THEN
  i1_l = LBOUND(SrcBeddoesData%FTBC,1)
  i1_u = UBOUND(SrcBeddoesData%FTBC,1)
  i2_l = LBOUND(SrcBeddoesData%FTBC,2)
  i2_u = UBOUND(SrcBeddoesData%FTBC,2)
  i3_l = LBOUND(SrcBeddoesData%FTBC,3)
  i3_u = UBOUND(SrcBeddoesData%FTBC,3)
  IF (.NOT. ALLOCATED(DstBeddoesData%FTBC)) THEN 
    ALLOCATE(DstBeddoesData%FTBC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%FTBC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%FTBC = SrcBeddoesData%FTBC
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDCNV)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDCNV,1)
  i1_u = UBOUND(SrcBeddoesData%OLDCNV,1)
  i2_l = LBOUND(SrcBeddoesData%OLDCNV,2)
  i2_u = UBOUND(SrcBeddoesData%OLDCNV,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDCNV)) THEN 
    ALLOCATE(DstBeddoesData%OLDCNV(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDCNV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDCNV = SrcBeddoesData%OLDCNV
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDF)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDF,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDF,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDF,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDF,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDF)) THEN 
    ALLOCATE(DstBeddoesData%OLDDF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDF = SrcBeddoesData%OLDDF
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDFC)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDFC,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDFC,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDFC,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDFC,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDFC)) THEN 
    ALLOCATE(DstBeddoesData%OLDDFC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDFC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDFC = SrcBeddoesData%OLDDFC
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDN)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDN,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDN,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDN,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDN)) THEN 
    ALLOCATE(DstBeddoesData%OLDDN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDN = SrcBeddoesData%OLDDN
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDPP)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDPP,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDPP,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDPP,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDPP,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDPP)) THEN 
    ALLOCATE(DstBeddoesData%OLDDPP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDPP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDPP = SrcBeddoesData%OLDDPP
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDDQ)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDDQ,1)
  i1_u = UBOUND(SrcBeddoesData%OLDDQ,1)
  i2_l = LBOUND(SrcBeddoesData%OLDDQ,2)
  i2_u = UBOUND(SrcBeddoesData%OLDDQ,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDDQ)) THEN 
    ALLOCATE(DstBeddoesData%OLDDQ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDDQ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDDQ = SrcBeddoesData%OLDDQ
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDTAU)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDTAU,1)
  i1_u = UBOUND(SrcBeddoesData%OLDTAU,1)
  i2_l = LBOUND(SrcBeddoesData%OLDTAU,2)
  i2_u = UBOUND(SrcBeddoesData%OLDTAU,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDTAU)) THEN 
    ALLOCATE(DstBeddoesData%OLDTAU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDTAU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDTAU = SrcBeddoesData%OLDTAU
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDXN)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDXN,1)
  i1_u = UBOUND(SrcBeddoesData%OLDXN,1)
  i2_l = LBOUND(SrcBeddoesData%OLDXN,2)
  i2_u = UBOUND(SrcBeddoesData%OLDXN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDXN)) THEN 
    ALLOCATE(DstBeddoesData%OLDXN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDXN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDXN = SrcBeddoesData%OLDXN
ENDIF
IF (ALLOCATED(SrcBeddoesData%OLDYN)) THEN
  i1_l = LBOUND(SrcBeddoesData%OLDYN,1)
  i1_u = UBOUND(SrcBeddoesData%OLDYN,1)
  i2_l = LBOUND(SrcBeddoesData%OLDYN,2)
  i2_u = UBOUND(SrcBeddoesData%OLDYN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%OLDYN)) THEN 
    ALLOCATE(DstBeddoesData%OLDYN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%OLDYN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%OLDYN = SrcBeddoesData%OLDYN
ENDIF
IF (ALLOCATED(SrcBeddoesData%QX)) THEN
  i1_l = LBOUND(SrcBeddoesData%QX,1)
  i1_u = UBOUND(SrcBeddoesData%QX,1)
  i2_l = LBOUND(SrcBeddoesData%QX,2)
  i2_u = UBOUND(SrcBeddoesData%QX,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%QX)) THEN 
    ALLOCATE(DstBeddoesData%QX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%QX = SrcBeddoesData%QX
ENDIF
IF (ALLOCATED(SrcBeddoesData%QX1)) THEN
  i1_l = LBOUND(SrcBeddoesData%QX1,1)
  i1_u = UBOUND(SrcBeddoesData%QX1,1)
  i2_l = LBOUND(SrcBeddoesData%QX1,2)
  i2_u = UBOUND(SrcBeddoesData%QX1,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%QX1)) THEN 
    ALLOCATE(DstBeddoesData%QX1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%QX1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%QX1 = SrcBeddoesData%QX1
ENDIF
IF (ALLOCATED(SrcBeddoesData%TAU)) THEN
  i1_l = LBOUND(SrcBeddoesData%TAU,1)
  i1_u = UBOUND(SrcBeddoesData%TAU,1)
  i2_l = LBOUND(SrcBeddoesData%TAU,2)
  i2_u = UBOUND(SrcBeddoesData%TAU,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%TAU)) THEN 
    ALLOCATE(DstBeddoesData%TAU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%TAU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%TAU = SrcBeddoesData%TAU
ENDIF
IF (ALLOCATED(SrcBeddoesData%XN)) THEN
  i1_l = LBOUND(SrcBeddoesData%XN,1)
  i1_u = UBOUND(SrcBeddoesData%XN,1)
  i2_l = LBOUND(SrcBeddoesData%XN,2)
  i2_u = UBOUND(SrcBeddoesData%XN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%XN)) THEN 
    ALLOCATE(DstBeddoesData%XN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%XN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%XN = SrcBeddoesData%XN
ENDIF
IF (ALLOCATED(SrcBeddoesData%YN)) THEN
  i1_l = LBOUND(SrcBeddoesData%YN,1)
  i1_u = UBOUND(SrcBeddoesData%YN,1)
  i2_l = LBOUND(SrcBeddoesData%YN,2)
  i2_u = UBOUND(SrcBeddoesData%YN,2)
  IF (.NOT. ALLOCATED(DstBeddoesData%YN)) THEN 
    ALLOCATE(DstBeddoesData%YN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeddoesData%YN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeddoesData%YN = SrcBeddoesData%YN
ENDIF
    DstBeddoesData%SHIFT = SrcBeddoesData%SHIFT
    DstBeddoesData%VOR = SrcBeddoesData%VOR
 END SUBROUTINE AD14_CopyBeddoes

 SUBROUTINE AD14_DestroyBeddoes( BeddoesData, ErrStat, ErrMsg )
  TYPE(Beddoes), INTENT(INOUT) :: BeddoesData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyBeddoes'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(BeddoesData%ADOT)) THEN
  DEALLOCATE(BeddoesData%ADOT)
ENDIF
IF (ALLOCATED(BeddoesData%ADOT1)) THEN
  DEALLOCATE(BeddoesData%ADOT1)
ENDIF
IF (ALLOCATED(BeddoesData%AFE)) THEN
  DEALLOCATE(BeddoesData%AFE)
ENDIF
IF (ALLOCATED(BeddoesData%AFE1)) THEN
  DEALLOCATE(BeddoesData%AFE1)
ENDIF
IF (ALLOCATED(BeddoesData%ANE)) THEN
  DEALLOCATE(BeddoesData%ANE)
ENDIF
IF (ALLOCATED(BeddoesData%ANE1)) THEN
  DEALLOCATE(BeddoesData%ANE1)
ENDIF
IF (ALLOCATED(BeddoesData%AOD)) THEN
  DEALLOCATE(BeddoesData%AOD)
ENDIF
IF (ALLOCATED(BeddoesData%AOL)) THEN
  DEALLOCATE(BeddoesData%AOL)
ENDIF
IF (ALLOCATED(BeddoesData%BEDSEP)) THEN
  DEALLOCATE(BeddoesData%BEDSEP)
ENDIF
IF (ALLOCATED(BeddoesData%OLDSEP)) THEN
  DEALLOCATE(BeddoesData%OLDSEP)
ENDIF
IF (ALLOCATED(BeddoesData%CDO)) THEN
  DEALLOCATE(BeddoesData%CDO)
ENDIF
IF (ALLOCATED(BeddoesData%CNA)) THEN
  DEALLOCATE(BeddoesData%CNA)
ENDIF
IF (ALLOCATED(BeddoesData%CNP)) THEN
  DEALLOCATE(BeddoesData%CNP)
ENDIF
IF (ALLOCATED(BeddoesData%CNP1)) THEN
  DEALLOCATE(BeddoesData%CNP1)
ENDIF
IF (ALLOCATED(BeddoesData%CNPD)) THEN
  DEALLOCATE(BeddoesData%CNPD)
ENDIF
IF (ALLOCATED(BeddoesData%CNPD1)) THEN
  DEALLOCATE(BeddoesData%CNPD1)
ENDIF
IF (ALLOCATED(BeddoesData%CNPOT)) THEN
  DEALLOCATE(BeddoesData%CNPOT)
ENDIF
IF (ALLOCATED(BeddoesData%CNPOT1)) THEN
  DEALLOCATE(BeddoesData%CNPOT1)
ENDIF
IF (ALLOCATED(BeddoesData%CNS)) THEN
  DEALLOCATE(BeddoesData%CNS)
ENDIF
IF (ALLOCATED(BeddoesData%CNSL)) THEN
  DEALLOCATE(BeddoesData%CNSL)
ENDIF
IF (ALLOCATED(BeddoesData%CNV)) THEN
  DEALLOCATE(BeddoesData%CNV)
ENDIF
IF (ALLOCATED(BeddoesData%CVN)) THEN
  DEALLOCATE(BeddoesData%CVN)
ENDIF
IF (ALLOCATED(BeddoesData%CVN1)) THEN
  DEALLOCATE(BeddoesData%CVN1)
ENDIF
IF (ALLOCATED(BeddoesData%DF)) THEN
  DEALLOCATE(BeddoesData%DF)
ENDIF
IF (ALLOCATED(BeddoesData%DFAFE)) THEN
  DEALLOCATE(BeddoesData%DFAFE)
ENDIF
IF (ALLOCATED(BeddoesData%DFAFE1)) THEN
  DEALLOCATE(BeddoesData%DFAFE1)
ENDIF
IF (ALLOCATED(BeddoesData%DFC)) THEN
  DEALLOCATE(BeddoesData%DFC)
ENDIF
IF (ALLOCATED(BeddoesData%DN)) THEN
  DEALLOCATE(BeddoesData%DN)
ENDIF
IF (ALLOCATED(BeddoesData%DPP)) THEN
  DEALLOCATE(BeddoesData%DPP)
ENDIF
IF (ALLOCATED(BeddoesData%DQ)) THEN
  DEALLOCATE(BeddoesData%DQ)
ENDIF
IF (ALLOCATED(BeddoesData%DQP)) THEN
  DEALLOCATE(BeddoesData%DQP)
ENDIF
IF (ALLOCATED(BeddoesData%DQP1)) THEN
  DEALLOCATE(BeddoesData%DQP1)
ENDIF
IF (ALLOCATED(BeddoesData%FSP)) THEN
  DEALLOCATE(BeddoesData%FSP)
ENDIF
IF (ALLOCATED(BeddoesData%FSP1)) THEN
  DEALLOCATE(BeddoesData%FSP1)
ENDIF
IF (ALLOCATED(BeddoesData%FSPC)) THEN
  DEALLOCATE(BeddoesData%FSPC)
ENDIF
IF (ALLOCATED(BeddoesData%FSPC1)) THEN
  DEALLOCATE(BeddoesData%FSPC1)
ENDIF
IF (ALLOCATED(BeddoesData%FTB)) THEN
  DEALLOCATE(BeddoesData%FTB)
ENDIF
IF (ALLOCATED(BeddoesData%FTBC)) THEN
  DEALLOCATE(BeddoesData%FTBC)
ENDIF
IF (ALLOCATED(BeddoesData%OLDCNV)) THEN
  DEALLOCATE(BeddoesData%OLDCNV)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDF)) THEN
  DEALLOCATE(BeddoesData%OLDDF)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDFC)) THEN
  DEALLOCATE(BeddoesData%OLDDFC)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDN)) THEN
  DEALLOCATE(BeddoesData%OLDDN)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDPP)) THEN
  DEALLOCATE(BeddoesData%OLDDPP)
ENDIF
IF (ALLOCATED(BeddoesData%OLDDQ)) THEN
  DEALLOCATE(BeddoesData%OLDDQ)
ENDIF
IF (ALLOCATED(BeddoesData%OLDTAU)) THEN
  DEALLOCATE(BeddoesData%OLDTAU)
ENDIF
IF (ALLOCATED(BeddoesData%OLDXN)) THEN
  DEALLOCATE(BeddoesData%OLDXN)
ENDIF
IF (ALLOCATED(BeddoesData%OLDYN)) THEN
  DEALLOCATE(BeddoesData%OLDYN)
ENDIF
IF (ALLOCATED(BeddoesData%QX)) THEN
  DEALLOCATE(BeddoesData%QX)
ENDIF
IF (ALLOCATED(BeddoesData%QX1)) THEN
  DEALLOCATE(BeddoesData%QX1)
ENDIF
IF (ALLOCATED(BeddoesData%TAU)) THEN
  DEALLOCATE(BeddoesData%TAU)
ENDIF
IF (ALLOCATED(BeddoesData%XN)) THEN
  DEALLOCATE(BeddoesData%XN)
ENDIF
IF (ALLOCATED(BeddoesData%YN)) THEN
  DEALLOCATE(BeddoesData%YN)
ENDIF
 END SUBROUTINE AD14_DestroyBeddoes


subroutine AD14_PackBeddoes(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Beddoes), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBeddoes'
   if (Buf%ErrStat >= AbortErrLev) return
   ! ADOT
   call RegPack(Buf, allocated(InData%ADOT))
   if (allocated(InData%ADOT)) then
      call RegPackBounds(Buf, 2, lbound(InData%ADOT), ubound(InData%ADOT))
      call RegPack(Buf, InData%ADOT)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ADOT1
   call RegPack(Buf, allocated(InData%ADOT1))
   if (allocated(InData%ADOT1)) then
      call RegPackBounds(Buf, 2, lbound(InData%ADOT1), ubound(InData%ADOT1))
      call RegPack(Buf, InData%ADOT1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFE
   call RegPack(Buf, allocated(InData%AFE))
   if (allocated(InData%AFE)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFE), ubound(InData%AFE))
      call RegPack(Buf, InData%AFE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFE1
   call RegPack(Buf, allocated(InData%AFE1))
   if (allocated(InData%AFE1)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFE1), ubound(InData%AFE1))
      call RegPack(Buf, InData%AFE1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AN
   call RegPack(Buf, InData%AN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ANE
   call RegPack(Buf, allocated(InData%ANE))
   if (allocated(InData%ANE)) then
      call RegPackBounds(Buf, 2, lbound(InData%ANE), ubound(InData%ANE))
      call RegPack(Buf, InData%ANE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ANE1
   call RegPack(Buf, allocated(InData%ANE1))
   if (allocated(InData%ANE1)) then
      call RegPackBounds(Buf, 2, lbound(InData%ANE1), ubound(InData%ANE1))
      call RegPack(Buf, InData%ANE1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AOD
   call RegPack(Buf, allocated(InData%AOD))
   if (allocated(InData%AOD)) then
      call RegPackBounds(Buf, 2, lbound(InData%AOD), ubound(InData%AOD))
      call RegPack(Buf, InData%AOD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AOL
   call RegPack(Buf, allocated(InData%AOL))
   if (allocated(InData%AOL)) then
      call RegPackBounds(Buf, 2, lbound(InData%AOL), ubound(InData%AOL))
      call RegPack(Buf, InData%AOL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BEDSEP
   call RegPack(Buf, allocated(InData%BEDSEP))
   if (allocated(InData%BEDSEP)) then
      call RegPackBounds(Buf, 2, lbound(InData%BEDSEP), ubound(InData%BEDSEP))
      call RegPack(Buf, InData%BEDSEP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDSEP
   call RegPack(Buf, allocated(InData%OLDSEP))
   if (allocated(InData%OLDSEP)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDSEP), ubound(InData%OLDSEP))
      call RegPack(Buf, InData%OLDSEP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CC
   call RegPack(Buf, InData%CC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CDO
   call RegPack(Buf, allocated(InData%CDO))
   if (allocated(InData%CDO)) then
      call RegPackBounds(Buf, 2, lbound(InData%CDO), ubound(InData%CDO))
      call RegPack(Buf, InData%CDO)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMI
   call RegPack(Buf, InData%CMI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMQ
   call RegPack(Buf, InData%CMQ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CN
   call RegPack(Buf, InData%CN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNA
   call RegPack(Buf, allocated(InData%CNA))
   if (allocated(InData%CNA)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNA), ubound(InData%CNA))
      call RegPack(Buf, InData%CNA)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNCP
   call RegPack(Buf, InData%CNCP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNIQ
   call RegPack(Buf, InData%CNIQ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNP
   call RegPack(Buf, allocated(InData%CNP))
   if (allocated(InData%CNP)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNP), ubound(InData%CNP))
      call RegPack(Buf, InData%CNP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNP1
   call RegPack(Buf, allocated(InData%CNP1))
   if (allocated(InData%CNP1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNP1), ubound(InData%CNP1))
      call RegPack(Buf, InData%CNP1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNPD
   call RegPack(Buf, allocated(InData%CNPD))
   if (allocated(InData%CNPD)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPD), ubound(InData%CNPD))
      call RegPack(Buf, InData%CNPD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNPD1
   call RegPack(Buf, allocated(InData%CNPD1))
   if (allocated(InData%CNPD1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPD1), ubound(InData%CNPD1))
      call RegPack(Buf, InData%CNPD1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNPOT
   call RegPack(Buf, allocated(InData%CNPOT))
   if (allocated(InData%CNPOT)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPOT), ubound(InData%CNPOT))
      call RegPack(Buf, InData%CNPOT)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNPOT1
   call RegPack(Buf, allocated(InData%CNPOT1))
   if (allocated(InData%CNPOT1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNPOT1), ubound(InData%CNPOT1))
      call RegPack(Buf, InData%CNPOT1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNS
   call RegPack(Buf, allocated(InData%CNS))
   if (allocated(InData%CNS)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNS), ubound(InData%CNS))
      call RegPack(Buf, InData%CNS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNSL
   call RegPack(Buf, allocated(InData%CNSL))
   if (allocated(InData%CNSL)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNSL), ubound(InData%CNSL))
      call RegPack(Buf, InData%CNSL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNV
   call RegPack(Buf, allocated(InData%CNV))
   if (allocated(InData%CNV)) then
      call RegPackBounds(Buf, 2, lbound(InData%CNV), ubound(InData%CNV))
      call RegPack(Buf, InData%CNV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CVN
   call RegPack(Buf, allocated(InData%CVN))
   if (allocated(InData%CVN)) then
      call RegPackBounds(Buf, 2, lbound(InData%CVN), ubound(InData%CVN))
      call RegPack(Buf, InData%CVN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CVN1
   call RegPack(Buf, allocated(InData%CVN1))
   if (allocated(InData%CVN1)) then
      call RegPackBounds(Buf, 2, lbound(InData%CVN1), ubound(InData%CVN1))
      call RegPack(Buf, InData%CVN1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DF
   call RegPack(Buf, allocated(InData%DF))
   if (allocated(InData%DF)) then
      call RegPackBounds(Buf, 2, lbound(InData%DF), ubound(InData%DF))
      call RegPack(Buf, InData%DF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DFAFE
   call RegPack(Buf, allocated(InData%DFAFE))
   if (allocated(InData%DFAFE)) then
      call RegPackBounds(Buf, 2, lbound(InData%DFAFE), ubound(InData%DFAFE))
      call RegPack(Buf, InData%DFAFE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DFAFE1
   call RegPack(Buf, allocated(InData%DFAFE1))
   if (allocated(InData%DFAFE1)) then
      call RegPackBounds(Buf, 2, lbound(InData%DFAFE1), ubound(InData%DFAFE1))
      call RegPack(Buf, InData%DFAFE1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DFC
   call RegPack(Buf, allocated(InData%DFC))
   if (allocated(InData%DFC)) then
      call RegPackBounds(Buf, 2, lbound(InData%DFC), ubound(InData%DFC))
      call RegPack(Buf, InData%DFC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DN
   call RegPack(Buf, allocated(InData%DN))
   if (allocated(InData%DN)) then
      call RegPackBounds(Buf, 2, lbound(InData%DN), ubound(InData%DN))
      call RegPack(Buf, InData%DN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DPP
   call RegPack(Buf, allocated(InData%DPP))
   if (allocated(InData%DPP)) then
      call RegPackBounds(Buf, 2, lbound(InData%DPP), ubound(InData%DPP))
      call RegPack(Buf, InData%DPP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DQ
   call RegPack(Buf, allocated(InData%DQ))
   if (allocated(InData%DQ)) then
      call RegPackBounds(Buf, 2, lbound(InData%DQ), ubound(InData%DQ))
      call RegPack(Buf, InData%DQ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DQP
   call RegPack(Buf, allocated(InData%DQP))
   if (allocated(InData%DQP)) then
      call RegPackBounds(Buf, 2, lbound(InData%DQP), ubound(InData%DQP))
      call RegPack(Buf, InData%DQP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DQP1
   call RegPack(Buf, allocated(InData%DQP1))
   if (allocated(InData%DQP1)) then
      call RegPackBounds(Buf, 2, lbound(InData%DQP1), ubound(InData%DQP1))
      call RegPack(Buf, InData%DQP1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DS
   call RegPack(Buf, InData%DS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FK
   call RegPack(Buf, InData%FK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FP
   call RegPack(Buf, InData%FP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FPC
   call RegPack(Buf, InData%FPC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FSP
   call RegPack(Buf, allocated(InData%FSP))
   if (allocated(InData%FSP)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSP), ubound(InData%FSP))
      call RegPack(Buf, InData%FSP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FSP1
   call RegPack(Buf, allocated(InData%FSP1))
   if (allocated(InData%FSP1)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSP1), ubound(InData%FSP1))
      call RegPack(Buf, InData%FSP1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FSPC
   call RegPack(Buf, allocated(InData%FSPC))
   if (allocated(InData%FSPC)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSPC), ubound(InData%FSPC))
      call RegPack(Buf, InData%FSPC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FSPC1
   call RegPack(Buf, allocated(InData%FSPC1))
   if (allocated(InData%FSPC1)) then
      call RegPackBounds(Buf, 2, lbound(InData%FSPC1), ubound(InData%FSPC1))
      call RegPack(Buf, InData%FSPC1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FTB
   call RegPack(Buf, allocated(InData%FTB))
   if (allocated(InData%FTB)) then
      call RegPackBounds(Buf, 3, lbound(InData%FTB), ubound(InData%FTB))
      call RegPack(Buf, InData%FTB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FTBC
   call RegPack(Buf, allocated(InData%FTBC))
   if (allocated(InData%FTBC)) then
      call RegPackBounds(Buf, 3, lbound(InData%FTBC), ubound(InData%FTBC))
      call RegPack(Buf, InData%FTBC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDCNV
   call RegPack(Buf, allocated(InData%OLDCNV))
   if (allocated(InData%OLDCNV)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDCNV), ubound(InData%OLDCNV))
      call RegPack(Buf, InData%OLDCNV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDDF
   call RegPack(Buf, allocated(InData%OLDDF))
   if (allocated(InData%OLDDF)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDF), ubound(InData%OLDDF))
      call RegPack(Buf, InData%OLDDF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDDFC
   call RegPack(Buf, allocated(InData%OLDDFC))
   if (allocated(InData%OLDDFC)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDFC), ubound(InData%OLDDFC))
      call RegPack(Buf, InData%OLDDFC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDDN
   call RegPack(Buf, allocated(InData%OLDDN))
   if (allocated(InData%OLDDN)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDN), ubound(InData%OLDDN))
      call RegPack(Buf, InData%OLDDN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDDPP
   call RegPack(Buf, allocated(InData%OLDDPP))
   if (allocated(InData%OLDDPP)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDPP), ubound(InData%OLDDPP))
      call RegPack(Buf, InData%OLDDPP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDDQ
   call RegPack(Buf, allocated(InData%OLDDQ))
   if (allocated(InData%OLDDQ)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDDQ), ubound(InData%OLDDQ))
      call RegPack(Buf, InData%OLDDQ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDTAU
   call RegPack(Buf, allocated(InData%OLDTAU))
   if (allocated(InData%OLDTAU)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDTAU), ubound(InData%OLDTAU))
      call RegPack(Buf, InData%OLDTAU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDXN
   call RegPack(Buf, allocated(InData%OLDXN))
   if (allocated(InData%OLDXN)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDXN), ubound(InData%OLDXN))
      call RegPack(Buf, InData%OLDXN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLDYN
   call RegPack(Buf, allocated(InData%OLDYN))
   if (allocated(InData%OLDYN)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLDYN), ubound(InData%OLDYN))
      call RegPack(Buf, InData%OLDYN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! QX
   call RegPack(Buf, allocated(InData%QX))
   if (allocated(InData%QX)) then
      call RegPackBounds(Buf, 2, lbound(InData%QX), ubound(InData%QX))
      call RegPack(Buf, InData%QX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! QX1
   call RegPack(Buf, allocated(InData%QX1))
   if (allocated(InData%QX1)) then
      call RegPackBounds(Buf, 2, lbound(InData%QX1), ubound(InData%QX1))
      call RegPack(Buf, InData%QX1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TAU
   call RegPack(Buf, allocated(InData%TAU))
   if (allocated(InData%TAU)) then
      call RegPackBounds(Buf, 2, lbound(InData%TAU), ubound(InData%TAU))
      call RegPack(Buf, InData%TAU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! XN
   call RegPack(Buf, allocated(InData%XN))
   if (allocated(InData%XN)) then
      call RegPackBounds(Buf, 2, lbound(InData%XN), ubound(InData%XN))
      call RegPack(Buf, InData%XN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! YN
   call RegPack(Buf, allocated(InData%YN))
   if (allocated(InData%YN)) then
      call RegPackBounds(Buf, 2, lbound(InData%YN), ubound(InData%YN))
      call RegPack(Buf, InData%YN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHIFT
   call RegPack(Buf, InData%SHIFT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VOR
   call RegPack(Buf, InData%VOR)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackBeddoes(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Beddoes), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBeddoes'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! ADOT
   if (allocated(OutData%ADOT)) deallocate(OutData%ADOT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ADOT(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADOT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ADOT)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ADOT1
   if (allocated(OutData%ADOT1)) deallocate(OutData%ADOT1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ADOT1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADOT1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ADOT1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AFE
   if (allocated(OutData%AFE)) deallocate(OutData%AFE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AFE1
   if (allocated(OutData%AFE1)) deallocate(OutData%AFE1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFE1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFE1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFE1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AN
   call RegUnpack(Buf, OutData%AN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ANE
   if (allocated(OutData%ANE)) deallocate(OutData%ANE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ANE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ANE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ANE1
   if (allocated(OutData%ANE1)) deallocate(OutData%ANE1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ANE1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANE1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ANE1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AOD
   if (allocated(OutData%AOD)) deallocate(OutData%AOD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AOD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AOD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AOL
   if (allocated(OutData%AOL)) deallocate(OutData%AOL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AOL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AOL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BEDSEP
   if (allocated(OutData%BEDSEP)) deallocate(OutData%BEDSEP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BEDSEP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BEDSEP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BEDSEP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDSEP
   if (allocated(OutData%OLDSEP)) deallocate(OutData%OLDSEP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDSEP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDSEP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDSEP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CC
   call RegUnpack(Buf, OutData%CC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CDO
   if (allocated(OutData%CDO)) deallocate(OutData%CDO)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CDO(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CDO.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CDO)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CMI
   call RegUnpack(Buf, OutData%CMI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMQ
   call RegUnpack(Buf, OutData%CMQ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CN
   call RegUnpack(Buf, OutData%CN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNA
   if (allocated(OutData%CNA)) deallocate(OutData%CNA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNCP
   call RegUnpack(Buf, OutData%CNCP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNIQ
   call RegUnpack(Buf, OutData%CNIQ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNP
   if (allocated(OutData%CNP)) deallocate(OutData%CNP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNP1
   if (allocated(OutData%CNP1)) deallocate(OutData%CNP1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNP1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNP1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNP1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNPD
   if (allocated(OutData%CNPD)) deallocate(OutData%CNPD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNPD1
   if (allocated(OutData%CNPD1)) deallocate(OutData%CNPD1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPD1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPD1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPD1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNPOT
   if (allocated(OutData%CNPOT)) deallocate(OutData%CNPOT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPOT(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPOT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPOT)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNPOT1
   if (allocated(OutData%CNPOT1)) deallocate(OutData%CNPOT1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNPOT1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNPOT1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNPOT1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNS
   if (allocated(OutData%CNS)) deallocate(OutData%CNS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNS(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNSL
   if (allocated(OutData%CNSL)) deallocate(OutData%CNSL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNSL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNSL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNSL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNV
   if (allocated(OutData%CNV)) deallocate(OutData%CNV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNV(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CVN
   if (allocated(OutData%CVN)) deallocate(OutData%CVN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CVN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CVN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CVN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CVN1
   if (allocated(OutData%CVN1)) deallocate(OutData%CVN1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CVN1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CVN1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CVN1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DF
   if (allocated(OutData%DF)) deallocate(OutData%DF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DF(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DFAFE
   if (allocated(OutData%DFAFE)) deallocate(OutData%DFAFE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFAFE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFAFE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFAFE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DFAFE1
   if (allocated(OutData%DFAFE1)) deallocate(OutData%DFAFE1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFAFE1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFAFE1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFAFE1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DFC
   if (allocated(OutData%DFC)) deallocate(OutData%DFC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DN
   if (allocated(OutData%DN)) deallocate(OutData%DN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DPP
   if (allocated(OutData%DPP)) deallocate(OutData%DPP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DPP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DPP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DPP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DQ
   if (allocated(OutData%DQ)) deallocate(OutData%DQ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DQ(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DQ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DQP
   if (allocated(OutData%DQP)) deallocate(OutData%DQP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DQP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DQP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DQP1
   if (allocated(OutData%DQP1)) deallocate(OutData%DQP1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DQP1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DQP1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DQP1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DS
   call RegUnpack(Buf, OutData%DS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FK
   call RegUnpack(Buf, OutData%FK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FP
   call RegUnpack(Buf, OutData%FP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FPC
   call RegUnpack(Buf, OutData%FPC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FSP
   if (allocated(OutData%FSP)) deallocate(OutData%FSP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FSP1
   if (allocated(OutData%FSP1)) deallocate(OutData%FSP1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSP1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSP1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSP1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FSPC
   if (allocated(OutData%FSPC)) deallocate(OutData%FSPC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSPC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSPC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSPC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FSPC1
   if (allocated(OutData%FSPC1)) deallocate(OutData%FSPC1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FSPC1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FSPC1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FSPC1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FTB
   if (allocated(OutData%FTB)) deallocate(OutData%FTB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FTB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FTB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FTB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FTBC
   if (allocated(OutData%FTBC)) deallocate(OutData%FTBC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FTBC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FTBC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FTBC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDCNV
   if (allocated(OutData%OLDCNV)) deallocate(OutData%OLDCNV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDCNV(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDCNV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDCNV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDDF
   if (allocated(OutData%OLDDF)) deallocate(OutData%OLDDF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDF(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDDFC
   if (allocated(OutData%OLDDFC)) deallocate(OutData%OLDDFC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDFC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDFC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDFC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDDN
   if (allocated(OutData%OLDDN)) deallocate(OutData%OLDDN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDDPP
   if (allocated(OutData%OLDDPP)) deallocate(OutData%OLDDPP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDPP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDPP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDPP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDDQ
   if (allocated(OutData%OLDDQ)) deallocate(OutData%OLDDQ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDDQ(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDDQ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDDQ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDTAU
   if (allocated(OutData%OLDTAU)) deallocate(OutData%OLDTAU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDTAU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDTAU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDTAU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDXN
   if (allocated(OutData%OLDXN)) deallocate(OutData%OLDXN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDXN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDXN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDXN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLDYN
   if (allocated(OutData%OLDYN)) deallocate(OutData%OLDYN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLDYN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLDYN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLDYN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! QX
   if (allocated(OutData%QX)) deallocate(OutData%QX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%QX(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%QX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%QX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! QX1
   if (allocated(OutData%QX1)) deallocate(OutData%QX1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%QX1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%QX1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%QX1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TAU
   if (allocated(OutData%TAU)) deallocate(OutData%TAU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TAU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TAU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TAU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! XN
   if (allocated(OutData%XN)) deallocate(OutData%XN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%XN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%XN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%XN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! YN
   if (allocated(OutData%YN)) deallocate(OutData%YN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%YN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%YN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%YN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SHIFT
   call RegUnpack(Buf, OutData%SHIFT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VOR
   call RegUnpack(Buf, OutData%VOR)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyBeddoesParms( SrcBeddoesParmsData, DstBeddoesParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BeddoesParms), INTENT(IN) :: SrcBeddoesParmsData
   TYPE(BeddoesParms), INTENT(INOUT) :: DstBeddoesParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyBeddoesParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBeddoesParmsData%AS = SrcBeddoesParmsData%AS
    DstBeddoesParmsData%TF = SrcBeddoesParmsData%TF
    DstBeddoesParmsData%TP = SrcBeddoesParmsData%TP
    DstBeddoesParmsData%TV = SrcBeddoesParmsData%TV
    DstBeddoesParmsData%TVL = SrcBeddoesParmsData%TVL
 END SUBROUTINE AD14_CopyBeddoesParms

 SUBROUTINE AD14_DestroyBeddoesParms( BeddoesParmsData, ErrStat, ErrMsg )
  TYPE(BeddoesParms), INTENT(INOUT) :: BeddoesParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyBeddoesParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyBeddoesParms


subroutine AD14_PackBeddoesParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BeddoesParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBeddoesParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AS
   call RegPack(Buf, InData%AS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TF
   call RegPack(Buf, InData%TF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TP
   call RegPack(Buf, InData%TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TV
   call RegPack(Buf, InData%TV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TVL
   call RegPack(Buf, InData%TVL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackBeddoesParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BeddoesParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBeddoesParms'
   if (Buf%ErrStat /= ErrID_None) return
   ! AS
   call RegUnpack(Buf, OutData%AS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TF
   call RegUnpack(Buf, OutData%TF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TP
   call RegUnpack(Buf, OutData%TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TV
   call RegUnpack(Buf, OutData%TV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TVL
   call RegUnpack(Buf, OutData%TVL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyBladeParms( SrcBladeParmsData, DstBladeParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BladeParms), INTENT(IN) :: SrcBladeParmsData
   TYPE(BladeParms), INTENT(INOUT) :: DstBladeParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyBladeParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBladeParmsData%C)) THEN
  i1_l = LBOUND(SrcBladeParmsData%C,1)
  i1_u = UBOUND(SrcBladeParmsData%C,1)
  IF (.NOT. ALLOCATED(DstBladeParmsData%C)) THEN 
    ALLOCATE(DstBladeParmsData%C(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%C.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladeParmsData%C = SrcBladeParmsData%C
ENDIF
IF (ALLOCATED(SrcBladeParmsData%DR)) THEN
  i1_l = LBOUND(SrcBladeParmsData%DR,1)
  i1_u = UBOUND(SrcBladeParmsData%DR,1)
  IF (.NOT. ALLOCATED(DstBladeParmsData%DR)) THEN 
    ALLOCATE(DstBladeParmsData%DR(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladeParmsData%DR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladeParmsData%DR = SrcBladeParmsData%DR
ENDIF
    DstBladeParmsData%R = SrcBladeParmsData%R
    DstBladeParmsData%BladeLength = SrcBladeParmsData%BladeLength
 END SUBROUTINE AD14_CopyBladeParms

 SUBROUTINE AD14_DestroyBladeParms( BladeParmsData, ErrStat, ErrMsg )
  TYPE(BladeParms), INTENT(INOUT) :: BladeParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyBladeParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(BladeParmsData%C)) THEN
  DEALLOCATE(BladeParmsData%C)
ENDIF
IF (ALLOCATED(BladeParmsData%DR)) THEN
  DEALLOCATE(BladeParmsData%DR)
ENDIF
 END SUBROUTINE AD14_DestroyBladeParms


subroutine AD14_PackBladeParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BladeParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackBladeParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! C
   call RegPack(Buf, allocated(InData%C))
   if (allocated(InData%C)) then
      call RegPackBounds(Buf, 1, lbound(InData%C), ubound(InData%C))
      call RegPack(Buf, InData%C)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DR
   call RegPack(Buf, allocated(InData%DR))
   if (allocated(InData%DR)) then
      call RegPackBounds(Buf, 1, lbound(InData%DR), ubound(InData%DR))
      call RegPack(Buf, InData%DR)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! R
   call RegPack(Buf, InData%R)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeLength
   call RegPack(Buf, InData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackBladeParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BladeParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackBladeParms'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! C
   if (allocated(OutData%C)) deallocate(OutData%C)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DR
   if (allocated(OutData%DR)) deallocate(OutData%DR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DR(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! R
   call RegUnpack(Buf, OutData%R)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeLength
   call RegUnpack(Buf, OutData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyDynInflow( SrcDynInflowData, DstDynInflowData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DynInflow), INTENT(IN) :: SrcDynInflowData
   TYPE(DynInflow), INTENT(INOUT) :: DstDynInflowData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyDynInflow'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDynInflowData%dAlph_dt = SrcDynInflowData%dAlph_dt
    DstDynInflowData%dBeta_dt = SrcDynInflowData%dBeta_dt
    DstDynInflowData%DTO = SrcDynInflowData%DTO
    DstDynInflowData%old_Alph = SrcDynInflowData%old_Alph
    DstDynInflowData%old_Beta = SrcDynInflowData%old_Beta
    DstDynInflowData%old_LmdM = SrcDynInflowData%old_LmdM
    DstDynInflowData%oldKai = SrcDynInflowData%oldKai
    DstDynInflowData%PhiLqC = SrcDynInflowData%PhiLqC
    DstDynInflowData%PhiLqS = SrcDynInflowData%PhiLqS
    DstDynInflowData%Pzero = SrcDynInflowData%Pzero
IF (ALLOCATED(SrcDynInflowData%RMC_SAVE)) THEN
  i1_l = LBOUND(SrcDynInflowData%RMC_SAVE,1)
  i1_u = UBOUND(SrcDynInflowData%RMC_SAVE,1)
  i2_l = LBOUND(SrcDynInflowData%RMC_SAVE,2)
  i2_u = UBOUND(SrcDynInflowData%RMC_SAVE,2)
  i3_l = LBOUND(SrcDynInflowData%RMC_SAVE,3)
  i3_u = UBOUND(SrcDynInflowData%RMC_SAVE,3)
  IF (.NOT. ALLOCATED(DstDynInflowData%RMC_SAVE)) THEN 
    ALLOCATE(DstDynInflowData%RMC_SAVE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMC_SAVE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDynInflowData%RMC_SAVE = SrcDynInflowData%RMC_SAVE
ENDIF
IF (ALLOCATED(SrcDynInflowData%RMS_SAVE)) THEN
  i1_l = LBOUND(SrcDynInflowData%RMS_SAVE,1)
  i1_u = UBOUND(SrcDynInflowData%RMS_SAVE,1)
  i2_l = LBOUND(SrcDynInflowData%RMS_SAVE,2)
  i2_u = UBOUND(SrcDynInflowData%RMS_SAVE,2)
  i3_l = LBOUND(SrcDynInflowData%RMS_SAVE,3)
  i3_u = UBOUND(SrcDynInflowData%RMS_SAVE,3)
  IF (.NOT. ALLOCATED(DstDynInflowData%RMS_SAVE)) THEN 
    ALLOCATE(DstDynInflowData%RMS_SAVE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDynInflowData%RMS_SAVE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDynInflowData%RMS_SAVE = SrcDynInflowData%RMS_SAVE
ENDIF
    DstDynInflowData%TipSpeed = SrcDynInflowData%TipSpeed
    DstDynInflowData%totalInf = SrcDynInflowData%totalInf
    DstDynInflowData%Vparam = SrcDynInflowData%Vparam
    DstDynInflowData%Vtotal = SrcDynInflowData%Vtotal
    DstDynInflowData%xAlpha = SrcDynInflowData%xAlpha
    DstDynInflowData%xBeta = SrcDynInflowData%xBeta
    DstDynInflowData%xKai = SrcDynInflowData%xKai
    DstDynInflowData%XLAMBDA_M = SrcDynInflowData%XLAMBDA_M
    DstDynInflowData%xLcos = SrcDynInflowData%xLcos
    DstDynInflowData%xLsin = SrcDynInflowData%xLsin
    DstDynInflowData%MminR = SrcDynInflowData%MminR
    DstDynInflowData%MminusR = SrcDynInflowData%MminusR
    DstDynInflowData%MplusR = SrcDynInflowData%MplusR
    DstDynInflowData%GAMMA = SrcDynInflowData%GAMMA
 END SUBROUTINE AD14_CopyDynInflow

 SUBROUTINE AD14_DestroyDynInflow( DynInflowData, ErrStat, ErrMsg )
  TYPE(DynInflow), INTENT(INOUT) :: DynInflowData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyDynInflow'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DynInflowData%RMC_SAVE)) THEN
  DEALLOCATE(DynInflowData%RMC_SAVE)
ENDIF
IF (ALLOCATED(DynInflowData%RMS_SAVE)) THEN
  DEALLOCATE(DynInflowData%RMS_SAVE)
ENDIF
 END SUBROUTINE AD14_DestroyDynInflow


subroutine AD14_PackDynInflow(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(DynInflow), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDynInflow'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dAlph_dt
   call RegPack(Buf, InData%dAlph_dt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dBeta_dt
   call RegPack(Buf, InData%dBeta_dt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTO
   call RegPack(Buf, InData%DTO)
   if (RegCheckErr(Buf, RoutineName)) return
   ! old_Alph
   call RegPack(Buf, InData%old_Alph)
   if (RegCheckErr(Buf, RoutineName)) return
   ! old_Beta
   call RegPack(Buf, InData%old_Beta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! old_LmdM
   call RegPack(Buf, InData%old_LmdM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! oldKai
   call RegPack(Buf, InData%oldKai)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiLqC
   call RegPack(Buf, InData%PhiLqC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiLqS
   call RegPack(Buf, InData%PhiLqS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pzero
   call RegPack(Buf, InData%Pzero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RMC_SAVE
   call RegPack(Buf, allocated(InData%RMC_SAVE))
   if (allocated(InData%RMC_SAVE)) then
      call RegPackBounds(Buf, 3, lbound(InData%RMC_SAVE), ubound(InData%RMC_SAVE))
      call RegPack(Buf, InData%RMC_SAVE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RMS_SAVE
   call RegPack(Buf, allocated(InData%RMS_SAVE))
   if (allocated(InData%RMS_SAVE)) then
      call RegPackBounds(Buf, 3, lbound(InData%RMS_SAVE), ubound(InData%RMS_SAVE))
      call RegPack(Buf, InData%RMS_SAVE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TipSpeed
   call RegPack(Buf, InData%TipSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalInf
   call RegPack(Buf, InData%totalInf)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vparam
   call RegPack(Buf, InData%Vparam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vtotal
   call RegPack(Buf, InData%Vtotal)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xAlpha
   call RegPack(Buf, InData%xAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xBeta
   call RegPack(Buf, InData%xBeta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xKai
   call RegPack(Buf, InData%xKai)
   if (RegCheckErr(Buf, RoutineName)) return
   ! XLAMBDA_M
   call RegPack(Buf, InData%XLAMBDA_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xLcos
   call RegPack(Buf, InData%xLcos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xLsin
   call RegPack(Buf, InData%xLsin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MminR
   call RegPack(Buf, InData%MminR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MminusR
   call RegPack(Buf, InData%MminusR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MplusR
   call RegPack(Buf, InData%MplusR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GAMMA
   call RegPack(Buf, InData%GAMMA)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackDynInflow(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(DynInflow), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDynInflow'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! dAlph_dt
   call RegUnpack(Buf, OutData%dAlph_dt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dBeta_dt
   call RegUnpack(Buf, OutData%dBeta_dt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTO
   call RegUnpack(Buf, OutData%DTO)
   if (RegCheckErr(Buf, RoutineName)) return
   ! old_Alph
   call RegUnpack(Buf, OutData%old_Alph)
   if (RegCheckErr(Buf, RoutineName)) return
   ! old_Beta
   call RegUnpack(Buf, OutData%old_Beta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! old_LmdM
   call RegUnpack(Buf, OutData%old_LmdM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! oldKai
   call RegUnpack(Buf, OutData%oldKai)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiLqC
   call RegUnpack(Buf, OutData%PhiLqC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiLqS
   call RegUnpack(Buf, OutData%PhiLqS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pzero
   call RegUnpack(Buf, OutData%Pzero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RMC_SAVE
   if (allocated(OutData%RMC_SAVE)) deallocate(OutData%RMC_SAVE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RMC_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RMC_SAVE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RMC_SAVE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RMS_SAVE
   if (allocated(OutData%RMS_SAVE)) deallocate(OutData%RMS_SAVE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RMS_SAVE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RMS_SAVE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RMS_SAVE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TipSpeed
   call RegUnpack(Buf, OutData%TipSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalInf
   call RegUnpack(Buf, OutData%totalInf)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vparam
   call RegUnpack(Buf, OutData%Vparam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vtotal
   call RegUnpack(Buf, OutData%Vtotal)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xAlpha
   call RegUnpack(Buf, OutData%xAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xBeta
   call RegUnpack(Buf, OutData%xBeta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xKai
   call RegUnpack(Buf, OutData%xKai)
   if (RegCheckErr(Buf, RoutineName)) return
   ! XLAMBDA_M
   call RegUnpack(Buf, OutData%XLAMBDA_M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xLcos
   call RegUnpack(Buf, OutData%xLcos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xLsin
   call RegUnpack(Buf, OutData%xLsin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MminR
   call RegUnpack(Buf, OutData%MminR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MminusR
   call RegUnpack(Buf, OutData%MminusR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MplusR
   call RegUnpack(Buf, OutData%MplusR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GAMMA
   call RegUnpack(Buf, OutData%GAMMA)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyDynInflowParms( SrcDynInflowParmsData, DstDynInflowParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(DynInflowParms), INTENT(IN) :: SrcDynInflowParmsData
   TYPE(DynInflowParms), INTENT(INOUT) :: DstDynInflowParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyDynInflowParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDynInflowParmsData%MAXINFLO = SrcDynInflowParmsData%MAXINFLO
    DstDynInflowParmsData%xMinv = SrcDynInflowParmsData%xMinv
 END SUBROUTINE AD14_CopyDynInflowParms

 SUBROUTINE AD14_DestroyDynInflowParms( DynInflowParmsData, ErrStat, ErrMsg )
  TYPE(DynInflowParms), INTENT(INOUT) :: DynInflowParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyDynInflowParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyDynInflowParms


subroutine AD14_PackDynInflowParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(DynInflowParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDynInflowParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! MAXINFLO
   call RegPack(Buf, InData%MAXINFLO)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xMinv
   call RegPack(Buf, InData%xMinv)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackDynInflowParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(DynInflowParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDynInflowParms'
   if (Buf%ErrStat /= ErrID_None) return
   ! MAXINFLO
   call RegUnpack(Buf, OutData%MAXINFLO)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xMinv
   call RegUnpack(Buf, OutData%xMinv)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyElement( SrcElementData, DstElementData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Element), INTENT(IN) :: SrcElementData
   TYPE(Element), INTENT(INOUT) :: DstElementData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyElement'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcElementData%A)) THEN
  i1_l = LBOUND(SrcElementData%A,1)
  i1_u = UBOUND(SrcElementData%A,1)
  i2_l = LBOUND(SrcElementData%A,2)
  i2_u = UBOUND(SrcElementData%A,2)
  IF (.NOT. ALLOCATED(DstElementData%A)) THEN 
    ALLOCATE(DstElementData%A(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%A.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%A = SrcElementData%A
ENDIF
IF (ALLOCATED(SrcElementData%AP)) THEN
  i1_l = LBOUND(SrcElementData%AP,1)
  i1_u = UBOUND(SrcElementData%AP,1)
  i2_l = LBOUND(SrcElementData%AP,2)
  i2_u = UBOUND(SrcElementData%AP,2)
  IF (.NOT. ALLOCATED(DstElementData%AP)) THEN 
    ALLOCATE(DstElementData%AP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%AP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%AP = SrcElementData%AP
ENDIF
IF (ALLOCATED(SrcElementData%ALPHA)) THEN
  i1_l = LBOUND(SrcElementData%ALPHA,1)
  i1_u = UBOUND(SrcElementData%ALPHA,1)
  i2_l = LBOUND(SrcElementData%ALPHA,2)
  i2_u = UBOUND(SrcElementData%ALPHA,2)
  IF (.NOT. ALLOCATED(DstElementData%ALPHA)) THEN 
    ALLOCATE(DstElementData%ALPHA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%ALPHA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%ALPHA = SrcElementData%ALPHA
ENDIF
IF (ALLOCATED(SrcElementData%W2)) THEN
  i1_l = LBOUND(SrcElementData%W2,1)
  i1_u = UBOUND(SrcElementData%W2,1)
  i2_l = LBOUND(SrcElementData%W2,2)
  i2_u = UBOUND(SrcElementData%W2,2)
  IF (.NOT. ALLOCATED(DstElementData%W2)) THEN 
    ALLOCATE(DstElementData%W2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%W2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%W2 = SrcElementData%W2
ENDIF
IF (ALLOCATED(SrcElementData%OLD_A_NS)) THEN
  i1_l = LBOUND(SrcElementData%OLD_A_NS,1)
  i1_u = UBOUND(SrcElementData%OLD_A_NS,1)
  i2_l = LBOUND(SrcElementData%OLD_A_NS,2)
  i2_u = UBOUND(SrcElementData%OLD_A_NS,2)
  IF (.NOT. ALLOCATED(DstElementData%OLD_A_NS)) THEN 
    ALLOCATE(DstElementData%OLD_A_NS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_A_NS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%OLD_A_NS = SrcElementData%OLD_A_NS
ENDIF
IF (ALLOCATED(SrcElementData%OLD_AP_NS)) THEN
  i1_l = LBOUND(SrcElementData%OLD_AP_NS,1)
  i1_u = UBOUND(SrcElementData%OLD_AP_NS,1)
  i2_l = LBOUND(SrcElementData%OLD_AP_NS,2)
  i2_u = UBOUND(SrcElementData%OLD_AP_NS,2)
  IF (.NOT. ALLOCATED(DstElementData%OLD_AP_NS)) THEN 
    ALLOCATE(DstElementData%OLD_AP_NS(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%OLD_AP_NS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%OLD_AP_NS = SrcElementData%OLD_AP_NS
ENDIF
IF (ALLOCATED(SrcElementData%PITNOW)) THEN
  i1_l = LBOUND(SrcElementData%PITNOW,1)
  i1_u = UBOUND(SrcElementData%PITNOW,1)
  i2_l = LBOUND(SrcElementData%PITNOW,2)
  i2_u = UBOUND(SrcElementData%PITNOW,2)
  IF (.NOT. ALLOCATED(DstElementData%PITNOW)) THEN 
    ALLOCATE(DstElementData%PITNOW(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementData%PITNOW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementData%PITNOW = SrcElementData%PITNOW
ENDIF
 END SUBROUTINE AD14_CopyElement

 SUBROUTINE AD14_DestroyElement( ElementData, ErrStat, ErrMsg )
  TYPE(Element), INTENT(INOUT) :: ElementData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyElement'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ElementData%A)) THEN
  DEALLOCATE(ElementData%A)
ENDIF
IF (ALLOCATED(ElementData%AP)) THEN
  DEALLOCATE(ElementData%AP)
ENDIF
IF (ALLOCATED(ElementData%ALPHA)) THEN
  DEALLOCATE(ElementData%ALPHA)
ENDIF
IF (ALLOCATED(ElementData%W2)) THEN
  DEALLOCATE(ElementData%W2)
ENDIF
IF (ALLOCATED(ElementData%OLD_A_NS)) THEN
  DEALLOCATE(ElementData%OLD_A_NS)
ENDIF
IF (ALLOCATED(ElementData%OLD_AP_NS)) THEN
  DEALLOCATE(ElementData%OLD_AP_NS)
ENDIF
IF (ALLOCATED(ElementData%PITNOW)) THEN
  DEALLOCATE(ElementData%PITNOW)
ENDIF
 END SUBROUTINE AD14_DestroyElement


subroutine AD14_PackElement(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Element), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElement'
   if (Buf%ErrStat >= AbortErrLev) return
   ! A
   call RegPack(Buf, allocated(InData%A))
   if (allocated(InData%A)) then
      call RegPackBounds(Buf, 2, lbound(InData%A), ubound(InData%A))
      call RegPack(Buf, InData%A)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AP
   call RegPack(Buf, allocated(InData%AP))
   if (allocated(InData%AP)) then
      call RegPackBounds(Buf, 2, lbound(InData%AP), ubound(InData%AP))
      call RegPack(Buf, InData%AP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ALPHA
   call RegPack(Buf, allocated(InData%ALPHA))
   if (allocated(InData%ALPHA)) then
      call RegPackBounds(Buf, 2, lbound(InData%ALPHA), ubound(InData%ALPHA))
      call RegPack(Buf, InData%ALPHA)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! W2
   call RegPack(Buf, allocated(InData%W2))
   if (allocated(InData%W2)) then
      call RegPackBounds(Buf, 2, lbound(InData%W2), ubound(InData%W2))
      call RegPack(Buf, InData%W2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLD_A_NS
   call RegPack(Buf, allocated(InData%OLD_A_NS))
   if (allocated(InData%OLD_A_NS)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLD_A_NS), ubound(InData%OLD_A_NS))
      call RegPack(Buf, InData%OLD_A_NS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OLD_AP_NS
   call RegPack(Buf, allocated(InData%OLD_AP_NS))
   if (allocated(InData%OLD_AP_NS)) then
      call RegPackBounds(Buf, 2, lbound(InData%OLD_AP_NS), ubound(InData%OLD_AP_NS))
      call RegPack(Buf, InData%OLD_AP_NS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PITNOW
   call RegPack(Buf, allocated(InData%PITNOW))
   if (allocated(InData%PITNOW)) then
      call RegPackBounds(Buf, 2, lbound(InData%PITNOW), ubound(InData%PITNOW))
      call RegPack(Buf, InData%PITNOW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackElement(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Element), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElement'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! A
   if (allocated(OutData%A)) deallocate(OutData%A)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%A(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%A.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%A)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AP
   if (allocated(OutData%AP)) deallocate(OutData%AP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ALPHA
   if (allocated(OutData%ALPHA)) deallocate(OutData%ALPHA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ALPHA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ALPHA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ALPHA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! W2
   if (allocated(OutData%W2)) deallocate(OutData%W2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W2(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%W2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLD_A_NS
   if (allocated(OutData%OLD_A_NS)) deallocate(OutData%OLD_A_NS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLD_A_NS(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLD_A_NS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLD_A_NS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OLD_AP_NS
   if (allocated(OutData%OLD_AP_NS)) deallocate(OutData%OLD_AP_NS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OLD_AP_NS(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OLD_AP_NS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OLD_AP_NS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PITNOW
   if (allocated(OutData%PITNOW)) deallocate(OutData%PITNOW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PITNOW(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PITNOW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PITNOW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD14_CopyElementParms( SrcElementParmsData, DstElementParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElementParms), INTENT(IN) :: SrcElementParmsData
   TYPE(ElementParms), INTENT(INOUT) :: DstElementParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyElementParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstElementParmsData%NELM = SrcElementParmsData%NELM
IF (ALLOCATED(SrcElementParmsData%TWIST)) THEN
  i1_l = LBOUND(SrcElementParmsData%TWIST,1)
  i1_u = UBOUND(SrcElementParmsData%TWIST,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%TWIST)) THEN 
    ALLOCATE(DstElementParmsData%TWIST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TWIST.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%TWIST = SrcElementParmsData%TWIST
ENDIF
IF (ALLOCATED(SrcElementParmsData%RELM)) THEN
  i1_l = LBOUND(SrcElementParmsData%RELM,1)
  i1_u = UBOUND(SrcElementParmsData%RELM,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%RELM)) THEN 
    ALLOCATE(DstElementParmsData%RELM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%RELM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%RELM = SrcElementParmsData%RELM
ENDIF
IF (ALLOCATED(SrcElementParmsData%HLCNST)) THEN
  i1_l = LBOUND(SrcElementParmsData%HLCNST,1)
  i1_u = UBOUND(SrcElementParmsData%HLCNST,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%HLCNST)) THEN 
    ALLOCATE(DstElementParmsData%HLCNST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%HLCNST.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%HLCNST = SrcElementParmsData%HLCNST
ENDIF
IF (ALLOCATED(SrcElementParmsData%TLCNST)) THEN
  i1_l = LBOUND(SrcElementParmsData%TLCNST,1)
  i1_u = UBOUND(SrcElementParmsData%TLCNST,1)
  IF (.NOT. ALLOCATED(DstElementParmsData%TLCNST)) THEN 
    ALLOCATE(DstElementParmsData%TLCNST(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElementParmsData%TLCNST.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElementParmsData%TLCNST = SrcElementParmsData%TLCNST
ENDIF
 END SUBROUTINE AD14_CopyElementParms

 SUBROUTINE AD14_DestroyElementParms( ElementParmsData, ErrStat, ErrMsg )
  TYPE(ElementParms), INTENT(INOUT) :: ElementParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyElementParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ElementParmsData%TWIST)) THEN
  DEALLOCATE(ElementParmsData%TWIST)
ENDIF
IF (ALLOCATED(ElementParmsData%RELM)) THEN
  DEALLOCATE(ElementParmsData%RELM)
ENDIF
IF (ALLOCATED(ElementParmsData%HLCNST)) THEN
  DEALLOCATE(ElementParmsData%HLCNST)
ENDIF
IF (ALLOCATED(ElementParmsData%TLCNST)) THEN
  DEALLOCATE(ElementParmsData%TLCNST)
ENDIF
 END SUBROUTINE AD14_DestroyElementParms


subroutine AD14_PackElementParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ElementParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElementParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NELM
   call RegPack(Buf, InData%NELM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TWIST
   call RegPack(Buf, allocated(InData%TWIST))
   if (allocated(InData%TWIST)) then
      call RegPackBounds(Buf, 1, lbound(InData%TWIST), ubound(InData%TWIST))
      call RegPack(Buf, InData%TWIST)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RELM
   call RegPack(Buf, allocated(InData%RELM))
   if (allocated(InData%RELM)) then
      call RegPackBounds(Buf, 1, lbound(InData%RELM), ubound(InData%RELM))
      call RegPack(Buf, InData%RELM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLCNST
   call RegPack(Buf, allocated(InData%HLCNST))
   if (allocated(InData%HLCNST)) then
      call RegPackBounds(Buf, 1, lbound(InData%HLCNST), ubound(InData%HLCNST))
      call RegPack(Buf, InData%HLCNST)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TLCNST
   call RegPack(Buf, allocated(InData%TLCNST))
   if (allocated(InData%TLCNST)) then
      call RegPackBounds(Buf, 1, lbound(InData%TLCNST), ubound(InData%TLCNST))
      call RegPack(Buf, InData%TLCNST)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackElementParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ElementParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElementParms'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NELM
   call RegUnpack(Buf, OutData%NELM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TWIST
   if (allocated(OutData%TWIST)) deallocate(OutData%TWIST)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TWIST(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TWIST.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TWIST)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RELM
   if (allocated(OutData%RELM)) deallocate(OutData%RELM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RELM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RELM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RELM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HLCNST
   if (allocated(OutData%HLCNST)) deallocate(OutData%HLCNST)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HLCNST(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HLCNST.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HLCNST)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TLCNST
   if (allocated(OutData%TLCNST)) deallocate(OutData%TLCNST)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TLCNST(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TLCNST.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TLCNST)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD14_CopyElOutParms( SrcElOutParmsData, DstElOutParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElOutParms), INTENT(IN) :: SrcElOutParmsData
   TYPE(ElOutParms), INTENT(INOUT) :: DstElOutParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyElOutParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcElOutParmsData%AAA)) THEN
  i1_l = LBOUND(SrcElOutParmsData%AAA,1)
  i1_u = UBOUND(SrcElOutParmsData%AAA,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%AAA)) THEN 
    ALLOCATE(DstElOutParmsData%AAA(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%AAA = SrcElOutParmsData%AAA
ENDIF
IF (ALLOCATED(SrcElOutParmsData%AAP)) THEN
  i1_l = LBOUND(SrcElOutParmsData%AAP,1)
  i1_u = UBOUND(SrcElOutParmsData%AAP,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%AAP)) THEN 
    ALLOCATE(DstElOutParmsData%AAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%AAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%AAP = SrcElOutParmsData%AAP
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ALF)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ALF,1)
  i1_u = UBOUND(SrcElOutParmsData%ALF,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ALF)) THEN 
    ALLOCATE(DstElOutParmsData%ALF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ALF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ALF = SrcElOutParmsData%ALF
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CDD)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CDD,1)
  i1_u = UBOUND(SrcElOutParmsData%CDD,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CDD)) THEN 
    ALLOCATE(DstElOutParmsData%CDD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CDD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CDD = SrcElOutParmsData%CDD
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CLL)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CLL,1)
  i1_u = UBOUND(SrcElOutParmsData%CLL,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CLL)) THEN 
    ALLOCATE(DstElOutParmsData%CLL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CLL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CLL = SrcElOutParmsData%CLL
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CMM)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CMM,1)
  i1_u = UBOUND(SrcElOutParmsData%CMM,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CMM)) THEN 
    ALLOCATE(DstElOutParmsData%CMM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CMM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CMM = SrcElOutParmsData%CMM
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CNN)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CNN,1)
  i1_u = UBOUND(SrcElOutParmsData%CNN,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CNN)) THEN 
    ALLOCATE(DstElOutParmsData%CNN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CNN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CNN = SrcElOutParmsData%CNN
ENDIF
IF (ALLOCATED(SrcElOutParmsData%CTT)) THEN
  i1_l = LBOUND(SrcElOutParmsData%CTT,1)
  i1_u = UBOUND(SrcElOutParmsData%CTT,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%CTT)) THEN 
    ALLOCATE(DstElOutParmsData%CTT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%CTT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%CTT = SrcElOutParmsData%CTT
ENDIF
IF (ALLOCATED(SrcElOutParmsData%DFNSAV)) THEN
  i1_l = LBOUND(SrcElOutParmsData%DFNSAV,1)
  i1_u = UBOUND(SrcElOutParmsData%DFNSAV,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%DFNSAV)) THEN 
    ALLOCATE(DstElOutParmsData%DFNSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFNSAV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%DFNSAV = SrcElOutParmsData%DFNSAV
ENDIF
IF (ALLOCATED(SrcElOutParmsData%DFTSAV)) THEN
  i1_l = LBOUND(SrcElOutParmsData%DFTSAV,1)
  i1_u = UBOUND(SrcElOutParmsData%DFTSAV,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%DFTSAV)) THEN 
    ALLOCATE(DstElOutParmsData%DFTSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DFTSAV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%DFTSAV = SrcElOutParmsData%DFTSAV
ENDIF
IF (ALLOCATED(SrcElOutParmsData%DynPres)) THEN
  i1_l = LBOUND(SrcElOutParmsData%DynPres,1)
  i1_u = UBOUND(SrcElOutParmsData%DynPres,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%DynPres)) THEN 
    ALLOCATE(DstElOutParmsData%DynPres(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%DynPres.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%DynPres = SrcElOutParmsData%DynPres
ENDIF
IF (ALLOCATED(SrcElOutParmsData%PMM)) THEN
  i1_l = LBOUND(SrcElOutParmsData%PMM,1)
  i1_u = UBOUND(SrcElOutParmsData%PMM,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%PMM)) THEN 
    ALLOCATE(DstElOutParmsData%PMM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PMM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%PMM = SrcElOutParmsData%PMM
ENDIF
IF (ALLOCATED(SrcElOutParmsData%PITSAV)) THEN
  i1_l = LBOUND(SrcElOutParmsData%PITSAV,1)
  i1_u = UBOUND(SrcElOutParmsData%PITSAV,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%PITSAV)) THEN 
    ALLOCATE(DstElOutParmsData%PITSAV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%PITSAV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%PITSAV = SrcElOutParmsData%PITSAV
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ReyNum)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ReyNum,1)
  i1_u = UBOUND(SrcElOutParmsData%ReyNum,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ReyNum)) THEN 
    ALLOCATE(DstElOutParmsData%ReyNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ReyNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ReyNum = SrcElOutParmsData%ReyNum
ENDIF
IF (ALLOCATED(SrcElOutParmsData%Gamma)) THEN
  i1_l = LBOUND(SrcElOutParmsData%Gamma,1)
  i1_u = UBOUND(SrcElOutParmsData%Gamma,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%Gamma)) THEN 
    ALLOCATE(DstElOutParmsData%Gamma(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%Gamma.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%Gamma = SrcElOutParmsData%Gamma
ENDIF
IF (ALLOCATED(SrcElOutParmsData%SaveVX)) THEN
  i1_l = LBOUND(SrcElOutParmsData%SaveVX,1)
  i1_u = UBOUND(SrcElOutParmsData%SaveVX,1)
  i2_l = LBOUND(SrcElOutParmsData%SaveVX,2)
  i2_u = UBOUND(SrcElOutParmsData%SaveVX,2)
  IF (.NOT. ALLOCATED(DstElOutParmsData%SaveVX)) THEN 
    ALLOCATE(DstElOutParmsData%SaveVX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%SaveVX = SrcElOutParmsData%SaveVX
ENDIF
IF (ALLOCATED(SrcElOutParmsData%SaveVY)) THEN
  i1_l = LBOUND(SrcElOutParmsData%SaveVY,1)
  i1_u = UBOUND(SrcElOutParmsData%SaveVY,1)
  i2_l = LBOUND(SrcElOutParmsData%SaveVY,2)
  i2_u = UBOUND(SrcElOutParmsData%SaveVY,2)
  IF (.NOT. ALLOCATED(DstElOutParmsData%SaveVY)) THEN 
    ALLOCATE(DstElOutParmsData%SaveVY(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%SaveVY = SrcElOutParmsData%SaveVY
ENDIF
IF (ALLOCATED(SrcElOutParmsData%SaveVZ)) THEN
  i1_l = LBOUND(SrcElOutParmsData%SaveVZ,1)
  i1_u = UBOUND(SrcElOutParmsData%SaveVZ,1)
  i2_l = LBOUND(SrcElOutParmsData%SaveVZ,2)
  i2_u = UBOUND(SrcElOutParmsData%SaveVZ,2)
  IF (.NOT. ALLOCATED(DstElOutParmsData%SaveVZ)) THEN 
    ALLOCATE(DstElOutParmsData%SaveVZ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%SaveVZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%SaveVZ = SrcElOutParmsData%SaveVZ
ENDIF
    DstElOutParmsData%VXSAV = SrcElOutParmsData%VXSAV
    DstElOutParmsData%VYSAV = SrcElOutParmsData%VYSAV
    DstElOutParmsData%VZSAV = SrcElOutParmsData%VZSAV
    DstElOutParmsData%NumWndElOut = SrcElOutParmsData%NumWndElOut
IF (ALLOCATED(SrcElOutParmsData%WndElPrList)) THEN
  i1_l = LBOUND(SrcElOutParmsData%WndElPrList,1)
  i1_u = UBOUND(SrcElOutParmsData%WndElPrList,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%WndElPrList)) THEN 
    ALLOCATE(DstElOutParmsData%WndElPrList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%WndElPrList = SrcElOutParmsData%WndElPrList
ENDIF
IF (ALLOCATED(SrcElOutParmsData%WndElPrNum)) THEN
  i1_l = LBOUND(SrcElOutParmsData%WndElPrNum,1)
  i1_u = UBOUND(SrcElOutParmsData%WndElPrNum,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%WndElPrNum)) THEN 
    ALLOCATE(DstElOutParmsData%WndElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%WndElPrNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%WndElPrNum = SrcElOutParmsData%WndElPrNum
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ElPrList)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ElPrList,1)
  i1_u = UBOUND(SrcElOutParmsData%ElPrList,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ElPrList)) THEN 
    ALLOCATE(DstElOutParmsData%ElPrList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ElPrList = SrcElOutParmsData%ElPrList
ENDIF
IF (ALLOCATED(SrcElOutParmsData%ElPrNum)) THEN
  i1_l = LBOUND(SrcElOutParmsData%ElPrNum,1)
  i1_u = UBOUND(SrcElOutParmsData%ElPrNum,1)
  IF (.NOT. ALLOCATED(DstElOutParmsData%ElPrNum)) THEN 
    ALLOCATE(DstElOutParmsData%ElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElOutParmsData%ElPrNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElOutParmsData%ElPrNum = SrcElOutParmsData%ElPrNum
ENDIF
    DstElOutParmsData%NumElOut = SrcElOutParmsData%NumElOut
 END SUBROUTINE AD14_CopyElOutParms

 SUBROUTINE AD14_DestroyElOutParms( ElOutParmsData, ErrStat, ErrMsg )
  TYPE(ElOutParms), INTENT(INOUT) :: ElOutParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyElOutParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ElOutParmsData%AAA)) THEN
  DEALLOCATE(ElOutParmsData%AAA)
ENDIF
IF (ALLOCATED(ElOutParmsData%AAP)) THEN
  DEALLOCATE(ElOutParmsData%AAP)
ENDIF
IF (ALLOCATED(ElOutParmsData%ALF)) THEN
  DEALLOCATE(ElOutParmsData%ALF)
ENDIF
IF (ALLOCATED(ElOutParmsData%CDD)) THEN
  DEALLOCATE(ElOutParmsData%CDD)
ENDIF
IF (ALLOCATED(ElOutParmsData%CLL)) THEN
  DEALLOCATE(ElOutParmsData%CLL)
ENDIF
IF (ALLOCATED(ElOutParmsData%CMM)) THEN
  DEALLOCATE(ElOutParmsData%CMM)
ENDIF
IF (ALLOCATED(ElOutParmsData%CNN)) THEN
  DEALLOCATE(ElOutParmsData%CNN)
ENDIF
IF (ALLOCATED(ElOutParmsData%CTT)) THEN
  DEALLOCATE(ElOutParmsData%CTT)
ENDIF
IF (ALLOCATED(ElOutParmsData%DFNSAV)) THEN
  DEALLOCATE(ElOutParmsData%DFNSAV)
ENDIF
IF (ALLOCATED(ElOutParmsData%DFTSAV)) THEN
  DEALLOCATE(ElOutParmsData%DFTSAV)
ENDIF
IF (ALLOCATED(ElOutParmsData%DynPres)) THEN
  DEALLOCATE(ElOutParmsData%DynPres)
ENDIF
IF (ALLOCATED(ElOutParmsData%PMM)) THEN
  DEALLOCATE(ElOutParmsData%PMM)
ENDIF
IF (ALLOCATED(ElOutParmsData%PITSAV)) THEN
  DEALLOCATE(ElOutParmsData%PITSAV)
ENDIF
IF (ALLOCATED(ElOutParmsData%ReyNum)) THEN
  DEALLOCATE(ElOutParmsData%ReyNum)
ENDIF
IF (ALLOCATED(ElOutParmsData%Gamma)) THEN
  DEALLOCATE(ElOutParmsData%Gamma)
ENDIF
IF (ALLOCATED(ElOutParmsData%SaveVX)) THEN
  DEALLOCATE(ElOutParmsData%SaveVX)
ENDIF
IF (ALLOCATED(ElOutParmsData%SaveVY)) THEN
  DEALLOCATE(ElOutParmsData%SaveVY)
ENDIF
IF (ALLOCATED(ElOutParmsData%SaveVZ)) THEN
  DEALLOCATE(ElOutParmsData%SaveVZ)
ENDIF
IF (ALLOCATED(ElOutParmsData%WndElPrList)) THEN
  DEALLOCATE(ElOutParmsData%WndElPrList)
ENDIF
IF (ALLOCATED(ElOutParmsData%WndElPrNum)) THEN
  DEALLOCATE(ElOutParmsData%WndElPrNum)
ENDIF
IF (ALLOCATED(ElOutParmsData%ElPrList)) THEN
  DEALLOCATE(ElOutParmsData%ElPrList)
ENDIF
IF (ALLOCATED(ElOutParmsData%ElPrNum)) THEN
  DEALLOCATE(ElOutParmsData%ElPrNum)
ENDIF
 END SUBROUTINE AD14_DestroyElOutParms


subroutine AD14_PackElOutParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ElOutParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackElOutParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AAA
   call RegPack(Buf, allocated(InData%AAA))
   if (allocated(InData%AAA)) then
      call RegPackBounds(Buf, 1, lbound(InData%AAA), ubound(InData%AAA))
      call RegPack(Buf, InData%AAA)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AAP
   call RegPack(Buf, allocated(InData%AAP))
   if (allocated(InData%AAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%AAP), ubound(InData%AAP))
      call RegPack(Buf, InData%AAP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ALF
   call RegPack(Buf, allocated(InData%ALF))
   if (allocated(InData%ALF)) then
      call RegPackBounds(Buf, 1, lbound(InData%ALF), ubound(InData%ALF))
      call RegPack(Buf, InData%ALF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CDD
   call RegPack(Buf, allocated(InData%CDD))
   if (allocated(InData%CDD)) then
      call RegPackBounds(Buf, 1, lbound(InData%CDD), ubound(InData%CDD))
      call RegPack(Buf, InData%CDD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CLL
   call RegPack(Buf, allocated(InData%CLL))
   if (allocated(InData%CLL)) then
      call RegPackBounds(Buf, 1, lbound(InData%CLL), ubound(InData%CLL))
      call RegPack(Buf, InData%CLL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMM
   call RegPack(Buf, allocated(InData%CMM))
   if (allocated(InData%CMM)) then
      call RegPackBounds(Buf, 1, lbound(InData%CMM), ubound(InData%CMM))
      call RegPack(Buf, InData%CMM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CNN
   call RegPack(Buf, allocated(InData%CNN))
   if (allocated(InData%CNN)) then
      call RegPackBounds(Buf, 1, lbound(InData%CNN), ubound(InData%CNN))
      call RegPack(Buf, InData%CNN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CTT
   call RegPack(Buf, allocated(InData%CTT))
   if (allocated(InData%CTT)) then
      call RegPackBounds(Buf, 1, lbound(InData%CTT), ubound(InData%CTT))
      call RegPack(Buf, InData%CTT)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DFNSAV
   call RegPack(Buf, allocated(InData%DFNSAV))
   if (allocated(InData%DFNSAV)) then
      call RegPackBounds(Buf, 1, lbound(InData%DFNSAV), ubound(InData%DFNSAV))
      call RegPack(Buf, InData%DFNSAV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DFTSAV
   call RegPack(Buf, allocated(InData%DFTSAV))
   if (allocated(InData%DFTSAV)) then
      call RegPackBounds(Buf, 1, lbound(InData%DFTSAV), ubound(InData%DFTSAV))
      call RegPack(Buf, InData%DFTSAV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynPres
   call RegPack(Buf, allocated(InData%DynPres))
   if (allocated(InData%DynPres)) then
      call RegPackBounds(Buf, 1, lbound(InData%DynPres), ubound(InData%DynPres))
      call RegPack(Buf, InData%DynPres)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PMM
   call RegPack(Buf, allocated(InData%PMM))
   if (allocated(InData%PMM)) then
      call RegPackBounds(Buf, 1, lbound(InData%PMM), ubound(InData%PMM))
      call RegPack(Buf, InData%PMM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PITSAV
   call RegPack(Buf, allocated(InData%PITSAV))
   if (allocated(InData%PITSAV)) then
      call RegPackBounds(Buf, 1, lbound(InData%PITSAV), ubound(InData%PITSAV))
      call RegPack(Buf, InData%PITSAV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ReyNum
   call RegPack(Buf, allocated(InData%ReyNum))
   if (allocated(InData%ReyNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%ReyNum), ubound(InData%ReyNum))
      call RegPack(Buf, InData%ReyNum)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gamma
   call RegPack(Buf, allocated(InData%Gamma))
   if (allocated(InData%Gamma)) then
      call RegPackBounds(Buf, 1, lbound(InData%Gamma), ubound(InData%Gamma))
      call RegPack(Buf, InData%Gamma)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SaveVX
   call RegPack(Buf, allocated(InData%SaveVX))
   if (allocated(InData%SaveVX)) then
      call RegPackBounds(Buf, 2, lbound(InData%SaveVX), ubound(InData%SaveVX))
      call RegPack(Buf, InData%SaveVX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SaveVY
   call RegPack(Buf, allocated(InData%SaveVY))
   if (allocated(InData%SaveVY)) then
      call RegPackBounds(Buf, 2, lbound(InData%SaveVY), ubound(InData%SaveVY))
      call RegPack(Buf, InData%SaveVY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SaveVZ
   call RegPack(Buf, allocated(InData%SaveVZ))
   if (allocated(InData%SaveVZ)) then
      call RegPackBounds(Buf, 2, lbound(InData%SaveVZ), ubound(InData%SaveVZ))
      call RegPack(Buf, InData%SaveVZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VXSAV
   call RegPack(Buf, InData%VXSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VYSAV
   call RegPack(Buf, InData%VYSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VZSAV
   call RegPack(Buf, InData%VZSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumWndElOut
   call RegPack(Buf, InData%NumWndElOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WndElPrList
   call RegPack(Buf, allocated(InData%WndElPrList))
   if (allocated(InData%WndElPrList)) then
      call RegPackBounds(Buf, 1, lbound(InData%WndElPrList), ubound(InData%WndElPrList))
      call RegPack(Buf, InData%WndElPrList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WndElPrNum
   call RegPack(Buf, allocated(InData%WndElPrNum))
   if (allocated(InData%WndElPrNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%WndElPrNum), ubound(InData%WndElPrNum))
      call RegPack(Buf, InData%WndElPrNum)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElPrList
   call RegPack(Buf, allocated(InData%ElPrList))
   if (allocated(InData%ElPrList)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElPrList), ubound(InData%ElPrList))
      call RegPack(Buf, InData%ElPrList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElPrNum
   call RegPack(Buf, allocated(InData%ElPrNum))
   if (allocated(InData%ElPrNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElPrNum), ubound(InData%ElPrNum))
      call RegPack(Buf, InData%ElPrNum)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumElOut
   call RegPack(Buf, InData%NumElOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackElOutParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ElOutParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackElOutParms'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AAA
   if (allocated(OutData%AAA)) deallocate(OutData%AAA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AAA(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AAA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AAA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AAP
   if (allocated(OutData%AAP)) deallocate(OutData%AAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AAP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ALF
   if (allocated(OutData%ALF)) deallocate(OutData%ALF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ALF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ALF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ALF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CDD
   if (allocated(OutData%CDD)) deallocate(OutData%CDD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CDD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CDD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CDD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CLL
   if (allocated(OutData%CLL)) deallocate(OutData%CLL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CLL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CLL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CLL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CMM
   if (allocated(OutData%CMM)) deallocate(OutData%CMM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CMM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CMM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CMM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CNN
   if (allocated(OutData%CNN)) deallocate(OutData%CNN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CNN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CNN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CNN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CTT
   if (allocated(OutData%CTT)) deallocate(OutData%CTT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CTT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CTT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CTT)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DFNSAV
   if (allocated(OutData%DFNSAV)) deallocate(OutData%DFNSAV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFNSAV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFNSAV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFNSAV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DFTSAV
   if (allocated(OutData%DFTSAV)) deallocate(OutData%DFTSAV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DFTSAV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DFTSAV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DFTSAV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DynPres
   if (allocated(OutData%DynPres)) deallocate(OutData%DynPres)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DynPres(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DynPres.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DynPres)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PMM
   if (allocated(OutData%PMM)) deallocate(OutData%PMM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PMM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PMM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PMM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PITSAV
   if (allocated(OutData%PITSAV)) deallocate(OutData%PITSAV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PITSAV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PITSAV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PITSAV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ReyNum
   if (allocated(OutData%ReyNum)) deallocate(OutData%ReyNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ReyNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ReyNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ReyNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Gamma
   if (allocated(OutData%Gamma)) deallocate(OutData%Gamma)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Gamma(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Gamma)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SaveVX
   if (allocated(OutData%SaveVX)) deallocate(OutData%SaveVX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SaveVX(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SaveVX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SaveVY
   if (allocated(OutData%SaveVY)) deallocate(OutData%SaveVY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SaveVY(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SaveVY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SaveVZ
   if (allocated(OutData%SaveVZ)) deallocate(OutData%SaveVZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SaveVZ(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SaveVZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SaveVZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VXSAV
   call RegUnpack(Buf, OutData%VXSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VYSAV
   call RegUnpack(Buf, OutData%VYSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VZSAV
   call RegUnpack(Buf, OutData%VZSAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumWndElOut
   call RegUnpack(Buf, OutData%NumWndElOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WndElPrList
   if (allocated(OutData%WndElPrList)) deallocate(OutData%WndElPrList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WndElPrList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndElPrList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WndElPrList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WndElPrNum
   if (allocated(OutData%WndElPrNum)) deallocate(OutData%WndElPrNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WndElPrNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndElPrNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WndElPrNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ElPrList
   if (allocated(OutData%ElPrList)) deallocate(OutData%ElPrList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElPrList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElPrList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ElPrNum
   if (allocated(OutData%ElPrNum)) deallocate(OutData%ElPrNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElPrNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElPrNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumElOut
   call RegUnpack(Buf, OutData%NumElOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyInducedVel( SrcInducedVelData, DstInducedVelData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InducedVel), INTENT(IN) :: SrcInducedVelData
   TYPE(InducedVel), INTENT(INOUT) :: DstInducedVelData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInducedVel'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInducedVelData%SumInFl = SrcInducedVelData%SumInFl
 END SUBROUTINE AD14_CopyInducedVel

 SUBROUTINE AD14_DestroyInducedVel( InducedVelData, ErrStat, ErrMsg )
  TYPE(InducedVel), INTENT(INOUT) :: InducedVelData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInducedVel'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyInducedVel


subroutine AD14_PackInducedVel(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(InducedVel), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInducedVel'
   if (Buf%ErrStat >= AbortErrLev) return
   ! SumInFl
   call RegPack(Buf, InData%SumInFl)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInducedVel(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(InducedVel), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInducedVel'
   if (Buf%ErrStat /= ErrID_None) return
   ! SumInFl
   call RegUnpack(Buf, OutData%SumInFl)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyInducedVelParms( SrcInducedVelParmsData, DstInducedVelParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InducedVelParms), INTENT(IN) :: SrcInducedVelParmsData
   TYPE(InducedVelParms), INTENT(INOUT) :: DstInducedVelParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInducedVelParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInducedVelParmsData%AToler = SrcInducedVelParmsData%AToler
    DstInducedVelParmsData%EqAIDmult = SrcInducedVelParmsData%EqAIDmult
    DstInducedVelParmsData%EquilDA = SrcInducedVelParmsData%EquilDA
    DstInducedVelParmsData%EquilDT = SrcInducedVelParmsData%EquilDT
    DstInducedVelParmsData%TLoss = SrcInducedVelParmsData%TLoss
    DstInducedVelParmsData%GTech = SrcInducedVelParmsData%GTech
    DstInducedVelParmsData%HLoss = SrcInducedVelParmsData%HLoss
 END SUBROUTINE AD14_CopyInducedVelParms

 SUBROUTINE AD14_DestroyInducedVelParms( InducedVelParmsData, ErrStat, ErrMsg )
  TYPE(InducedVelParms), INTENT(INOUT) :: InducedVelParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInducedVelParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyInducedVelParms


subroutine AD14_PackInducedVelParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(InducedVelParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInducedVelParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AToler
   call RegPack(Buf, InData%AToler)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EqAIDmult
   call RegPack(Buf, InData%EqAIDmult)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EquilDA
   call RegPack(Buf, InData%EquilDA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EquilDT
   call RegPack(Buf, InData%EquilDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TLoss
   call RegPack(Buf, InData%TLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GTech
   call RegPack(Buf, InData%GTech)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLoss
   call RegPack(Buf, InData%HLoss)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInducedVelParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(InducedVelParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInducedVelParms'
   if (Buf%ErrStat /= ErrID_None) return
   ! AToler
   call RegUnpack(Buf, OutData%AToler)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EqAIDmult
   call RegUnpack(Buf, OutData%EqAIDmult)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EquilDA
   call RegUnpack(Buf, OutData%EquilDA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EquilDT
   call RegUnpack(Buf, OutData%EquilDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TLoss
   call RegUnpack(Buf, OutData%TLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GTech
   call RegUnpack(Buf, OutData%GTech)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLoss
   call RegUnpack(Buf, OutData%HLoss)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyRotor( SrcRotorData, DstRotorData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Rotor), INTENT(IN) :: SrcRotorData
   TYPE(Rotor), INTENT(INOUT) :: DstRotorData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyRotor'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotorData%AVGINFL = SrcRotorData%AVGINFL
    DstRotorData%CTILT = SrcRotorData%CTILT
    DstRotorData%CYaw = SrcRotorData%CYaw
    DstRotorData%REVS = SrcRotorData%REVS
    DstRotorData%STILT = SrcRotorData%STILT
    DstRotorData%SYaw = SrcRotorData%SYaw
    DstRotorData%TILT = SrcRotorData%TILT
    DstRotorData%YawAng = SrcRotorData%YawAng
    DstRotorData%YawVEL = SrcRotorData%YawVEL
 END SUBROUTINE AD14_CopyRotor

 SUBROUTINE AD14_DestroyRotor( RotorData, ErrStat, ErrMsg )
  TYPE(Rotor), INTENT(INOUT) :: RotorData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyRotor'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyRotor


subroutine AD14_PackRotor(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Rotor), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackRotor'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AVGINFL
   call RegPack(Buf, InData%AVGINFL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CTILT
   call RegPack(Buf, InData%CTILT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CYaw
   call RegPack(Buf, InData%CYaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! REVS
   call RegPack(Buf, InData%REVS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! STILT
   call RegPack(Buf, InData%STILT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SYaw
   call RegPack(Buf, InData%SYaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TILT
   call RegPack(Buf, InData%TILT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawAng
   call RegPack(Buf, InData%YawAng)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawVEL
   call RegPack(Buf, InData%YawVEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackRotor(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Rotor), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackRotor'
   if (Buf%ErrStat /= ErrID_None) return
   ! AVGINFL
   call RegUnpack(Buf, OutData%AVGINFL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CTILT
   call RegUnpack(Buf, OutData%CTILT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CYaw
   call RegUnpack(Buf, OutData%CYaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! REVS
   call RegUnpack(Buf, OutData%REVS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! STILT
   call RegUnpack(Buf, OutData%STILT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SYaw
   call RegUnpack(Buf, OutData%SYaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TILT
   call RegUnpack(Buf, OutData%TILT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawAng
   call RegUnpack(Buf, OutData%YawAng)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawVEL
   call RegUnpack(Buf, OutData%YawVEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyRotorParms( SrcRotorParmsData, DstRotorParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotorParms), INTENT(IN) :: SrcRotorParmsData
   TYPE(RotorParms), INTENT(INOUT) :: DstRotorParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyRotorParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotorParmsData%HH = SrcRotorParmsData%HH
 END SUBROUTINE AD14_CopyRotorParms

 SUBROUTINE AD14_DestroyRotorParms( RotorParmsData, ErrStat, ErrMsg )
  TYPE(RotorParms), INTENT(INOUT) :: RotorParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyRotorParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyRotorParms


subroutine AD14_PackRotorParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotorParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackRotorParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! HH
   call RegPack(Buf, InData%HH)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackRotorParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotorParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackRotorParms'
   if (Buf%ErrStat /= ErrID_None) return
   ! HH
   call RegUnpack(Buf, OutData%HH)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyTwrPropsParms( SrcTwrPropsParmsData, DstTwrPropsParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(TwrPropsParms), INTENT(IN) :: SrcTwrPropsParmsData
   TYPE(TwrPropsParms), INTENT(INOUT) :: DstTwrPropsParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyTwrPropsParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcTwrPropsParmsData%TwrHtFr)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrHtFr,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrHtFr,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrHtFr)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrHtFr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrHtFr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrHtFr = SrcTwrPropsParmsData%TwrHtFr
ENDIF
IF (ALLOCATED(SrcTwrPropsParmsData%TwrWid)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrWid,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrWid,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrWid)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrWid(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrWid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrWid = SrcTwrPropsParmsData%TwrWid
ENDIF
IF (ALLOCATED(SrcTwrPropsParmsData%TwrCD)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrCD,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrCD,1)
  i2_l = LBOUND(SrcTwrPropsParmsData%TwrCD,2)
  i2_u = UBOUND(SrcTwrPropsParmsData%TwrCD,2)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrCD)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrCD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrCD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrCD = SrcTwrPropsParmsData%TwrCD
ENDIF
IF (ALLOCATED(SrcTwrPropsParmsData%TwrRe)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrRe,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrRe,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrRe)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrRe(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrRe.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrRe = SrcTwrPropsParmsData%TwrRe
ENDIF
    DstTwrPropsParmsData%VTwr = SrcTwrPropsParmsData%VTwr
    DstTwrPropsParmsData%Tower_Wake_Constant = SrcTwrPropsParmsData%Tower_Wake_Constant
IF (ALLOCATED(SrcTwrPropsParmsData%NTwrCDCol)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%NTwrCDCol,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%NTwrCDCol,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%NTwrCDCol)) THEN 
    ALLOCATE(DstTwrPropsParmsData%NTwrCDCol(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%NTwrCDCol.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%NTwrCDCol = SrcTwrPropsParmsData%NTwrCDCol
ENDIF
    DstTwrPropsParmsData%NTwrHT = SrcTwrPropsParmsData%NTwrHT
    DstTwrPropsParmsData%NTwrRe = SrcTwrPropsParmsData%NTwrRe
    DstTwrPropsParmsData%NTwrCD = SrcTwrPropsParmsData%NTwrCD
    DstTwrPropsParmsData%TwrPotent = SrcTwrPropsParmsData%TwrPotent
    DstTwrPropsParmsData%TwrShadow = SrcTwrPropsParmsData%TwrShadow
    DstTwrPropsParmsData%ShadHWid = SrcTwrPropsParmsData%ShadHWid
    DstTwrPropsParmsData%TShadC1 = SrcTwrPropsParmsData%TShadC1
    DstTwrPropsParmsData%TShadC2 = SrcTwrPropsParmsData%TShadC2
    DstTwrPropsParmsData%TwrShad = SrcTwrPropsParmsData%TwrShad
    DstTwrPropsParmsData%PJM_Version = SrcTwrPropsParmsData%PJM_Version
    DstTwrPropsParmsData%TwrFile = SrcTwrPropsParmsData%TwrFile
    DstTwrPropsParmsData%T_Shad_Refpt = SrcTwrPropsParmsData%T_Shad_Refpt
    DstTwrPropsParmsData%CalcTwrAero = SrcTwrPropsParmsData%CalcTwrAero
    DstTwrPropsParmsData%NumTwrNodes = SrcTwrPropsParmsData%NumTwrNodes
IF (ALLOCATED(SrcTwrPropsParmsData%TwrNodeWidth)) THEN
  i1_l = LBOUND(SrcTwrPropsParmsData%TwrNodeWidth,1)
  i1_u = UBOUND(SrcTwrPropsParmsData%TwrNodeWidth,1)
  IF (.NOT. ALLOCATED(DstTwrPropsParmsData%TwrNodeWidth)) THEN 
    ALLOCATE(DstTwrPropsParmsData%TwrNodeWidth(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstTwrPropsParmsData%TwrNodeWidth.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstTwrPropsParmsData%TwrNodeWidth = SrcTwrPropsParmsData%TwrNodeWidth
ENDIF
 END SUBROUTINE AD14_CopyTwrPropsParms

 SUBROUTINE AD14_DestroyTwrPropsParms( TwrPropsParmsData, ErrStat, ErrMsg )
  TYPE(TwrPropsParms), INTENT(INOUT) :: TwrPropsParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyTwrPropsParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(TwrPropsParmsData%TwrHtFr)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrHtFr)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrWid)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrWid)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrCD)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrCD)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrRe)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrRe)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%NTwrCDCol)) THEN
  DEALLOCATE(TwrPropsParmsData%NTwrCDCol)
ENDIF
IF (ALLOCATED(TwrPropsParmsData%TwrNodeWidth)) THEN
  DEALLOCATE(TwrPropsParmsData%TwrNodeWidth)
ENDIF
 END SUBROUTINE AD14_DestroyTwrPropsParms


subroutine AD14_PackTwrPropsParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TwrPropsParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackTwrPropsParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TwrHtFr
   call RegPack(Buf, allocated(InData%TwrHtFr))
   if (allocated(InData%TwrHtFr)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrHtFr), ubound(InData%TwrHtFr))
      call RegPack(Buf, InData%TwrHtFr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrWid
   call RegPack(Buf, allocated(InData%TwrWid))
   if (allocated(InData%TwrWid)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrWid), ubound(InData%TwrWid))
      call RegPack(Buf, InData%TwrWid)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrCD
   call RegPack(Buf, allocated(InData%TwrCD))
   if (allocated(InData%TwrCD)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrCD), ubound(InData%TwrCD))
      call RegPack(Buf, InData%TwrCD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrRe
   call RegPack(Buf, allocated(InData%TwrRe))
   if (allocated(InData%TwrRe)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrRe), ubound(InData%TwrRe))
      call RegPack(Buf, InData%TwrRe)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTwr
   call RegPack(Buf, InData%VTwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tower_Wake_Constant
   call RegPack(Buf, InData%Tower_Wake_Constant)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrCDCol
   call RegPack(Buf, allocated(InData%NTwrCDCol))
   if (allocated(InData%NTwrCDCol)) then
      call RegPackBounds(Buf, 1, lbound(InData%NTwrCDCol), ubound(InData%NTwrCDCol))
      call RegPack(Buf, InData%NTwrCDCol)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrHT
   call RegPack(Buf, InData%NTwrHT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrRe
   call RegPack(Buf, InData%NTwrRe)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrCD
   call RegPack(Buf, InData%NTwrCD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrPotent
   call RegPack(Buf, InData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadow
   call RegPack(Buf, InData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShadHWid
   call RegPack(Buf, InData%ShadHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TShadC1
   call RegPack(Buf, InData%TShadC1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TShadC2
   call RegPack(Buf, InData%TShadC2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShad
   call RegPack(Buf, InData%TwrShad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PJM_Version
   call RegPack(Buf, InData%PJM_Version)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrFile
   call RegPack(Buf, InData%TwrFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! T_Shad_Refpt
   call RegPack(Buf, InData%T_Shad_Refpt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CalcTwrAero
   call RegPack(Buf, InData%CalcTwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTwrNodes
   call RegPack(Buf, InData%NumTwrNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrNodeWidth
   call RegPack(Buf, allocated(InData%TwrNodeWidth))
   if (allocated(InData%TwrNodeWidth)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrNodeWidth), ubound(InData%TwrNodeWidth))
      call RegPack(Buf, InData%TwrNodeWidth)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackTwrPropsParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TwrPropsParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackTwrPropsParms'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! TwrHtFr
   if (allocated(OutData%TwrHtFr)) deallocate(OutData%TwrHtFr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrHtFr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrHtFr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrHtFr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrWid
   if (allocated(OutData%TwrWid)) deallocate(OutData%TwrWid)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrWid(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrWid.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrWid)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrCD
   if (allocated(OutData%TwrCD)) deallocate(OutData%TwrCD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrRe
   if (allocated(OutData%TwrRe)) deallocate(OutData%TwrRe)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrRe(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrRe.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrRe)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VTwr
   call RegUnpack(Buf, OutData%VTwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tower_Wake_Constant
   call RegUnpack(Buf, OutData%Tower_Wake_Constant)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrCDCol
   if (allocated(OutData%NTwrCDCol)) deallocate(OutData%NTwrCDCol)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NTwrCDCol(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NTwrCDCol.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NTwrCDCol)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NTwrHT
   call RegUnpack(Buf, OutData%NTwrHT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrRe
   call RegUnpack(Buf, OutData%NTwrRe)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwrCD
   call RegUnpack(Buf, OutData%NTwrCD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrPotent
   call RegUnpack(Buf, OutData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadow
   call RegUnpack(Buf, OutData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShadHWid
   call RegUnpack(Buf, OutData%ShadHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TShadC1
   call RegUnpack(Buf, OutData%TShadC1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TShadC2
   call RegUnpack(Buf, OutData%TShadC2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShad
   call RegUnpack(Buf, OutData%TwrShad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PJM_Version
   call RegUnpack(Buf, OutData%PJM_Version)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrFile
   call RegUnpack(Buf, OutData%TwrFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! T_Shad_Refpt
   call RegUnpack(Buf, OutData%T_Shad_Refpt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CalcTwrAero
   call RegUnpack(Buf, OutData%CalcTwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTwrNodes
   call RegUnpack(Buf, OutData%NumTwrNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrNodeWidth
   if (allocated(OutData%TwrNodeWidth)) deallocate(OutData%TwrNodeWidth)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrNodeWidth(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrNodeWidth.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrNodeWidth)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD14_CopyWind( SrcWindData, DstWindData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wind), INTENT(IN) :: SrcWindData
   TYPE(Wind), INTENT(INOUT) :: DstWindData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyWind'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstWindData%ANGFLW = SrcWindData%ANGFLW
    DstWindData%CDEL = SrcWindData%CDEL
    DstWindData%VROTORX = SrcWindData%VROTORX
    DstWindData%VROTORY = SrcWindData%VROTORY
    DstWindData%VROTORZ = SrcWindData%VROTORZ
    DstWindData%SDEL = SrcWindData%SDEL
 END SUBROUTINE AD14_CopyWind

 SUBROUTINE AD14_DestroyWind( WindData, ErrStat, ErrMsg )
  TYPE(Wind), INTENT(INOUT) :: WindData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyWind'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyWind


subroutine AD14_PackWind(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wind), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackWind'
   if (Buf%ErrStat >= AbortErrLev) return
   ! ANGFLW
   call RegPack(Buf, InData%ANGFLW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CDEL
   call RegPack(Buf, InData%CDEL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VROTORX
   call RegPack(Buf, InData%VROTORX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VROTORY
   call RegPack(Buf, InData%VROTORY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VROTORZ
   call RegPack(Buf, InData%VROTORZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SDEL
   call RegPack(Buf, InData%SDEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackWind(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wind), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackWind'
   if (Buf%ErrStat /= ErrID_None) return
   ! ANGFLW
   call RegUnpack(Buf, OutData%ANGFLW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CDEL
   call RegUnpack(Buf, OutData%CDEL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VROTORX
   call RegUnpack(Buf, OutData%VROTORX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VROTORY
   call RegUnpack(Buf, OutData%VROTORY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VROTORZ
   call RegUnpack(Buf, OutData%VROTORZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SDEL
   call RegUnpack(Buf, OutData%SDEL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyWindParms( SrcWindParmsData, DstWindParmsData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WindParms), INTENT(IN) :: SrcWindParmsData
   TYPE(WindParms), INTENT(INOUT) :: DstWindParmsData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyWindParms'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstWindParmsData%Rho = SrcWindParmsData%Rho
    DstWindParmsData%KinVisc = SrcWindParmsData%KinVisc
 END SUBROUTINE AD14_CopyWindParms

 SUBROUTINE AD14_DestroyWindParms( WindParmsData, ErrStat, ErrMsg )
  TYPE(WindParms), INTENT(INOUT) :: WindParmsData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyWindParms'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyWindParms


subroutine AD14_PackWindParms(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WindParms), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackWindParms'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Rho
   call RegPack(Buf, InData%Rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackWindParms(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WindParms), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackWindParms'
   if (Buf%ErrStat /= ErrID_None) return
   ! Rho
   call RegUnpack(Buf, OutData%Rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyPositionType( SrcPositionTypeData, DstPositionTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(PositionType), INTENT(IN) :: SrcPositionTypeData
   TYPE(PositionType), INTENT(INOUT) :: DstPositionTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyPositionType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstPositionTypeData%Pos = SrcPositionTypeData%Pos
 END SUBROUTINE AD14_CopyPositionType

 SUBROUTINE AD14_DestroyPositionType( PositionTypeData, ErrStat, ErrMsg )
  TYPE(PositionType), INTENT(INOUT) :: PositionTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyPositionType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyPositionType


subroutine AD14_PackPositionType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(PositionType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackPositionType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Pos
   call RegPack(Buf, InData%Pos)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackPositionType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(PositionType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackPositionType'
   if (Buf%ErrStat /= ErrID_None) return
   ! Pos
   call RegUnpack(Buf, OutData%Pos)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyOrientationType( SrcOrientationTypeData, DstOrientationTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(OrientationType), INTENT(IN) :: SrcOrientationTypeData
   TYPE(OrientationType), INTENT(INOUT) :: DstOrientationTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyOrientationType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOrientationTypeData%Orient = SrcOrientationTypeData%Orient
 END SUBROUTINE AD14_CopyOrientationType

 SUBROUTINE AD14_DestroyOrientationType( OrientationTypeData, ErrStat, ErrMsg )
  TYPE(OrientationType), INTENT(INOUT) :: OrientationTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyOrientationType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD14_DestroyOrientationType


subroutine AD14_PackOrientationType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OrientationType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOrientationType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Orient
   call RegPack(Buf, InData%Orient)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackOrientationType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OrientationType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOrientationType'
   if (Buf%ErrStat /= ErrID_None) return
   ! Orient
   call RegUnpack(Buf, OutData%Orient)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(AD14_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%Title = SrcInitInputData%Title
    DstInitInputData%OutRootName = SrcInitInputData%OutRootName
    DstInitInputData%ADFileName = SrcInitInputData%ADFileName
    DstInitInputData%WrSumFile = SrcInitInputData%WrSumFile
    DstInitInputData%NumBl = SrcInitInputData%NumBl
    DstInitInputData%BladeLength = SrcInitInputData%BladeLength
    DstInitInputData%LinearizeFlag = SrcInitInputData%LinearizeFlag
    DstInitInputData%UseDWM = SrcInitInputData%UseDWM
      CALL AD14_Copyaeroconfig( SrcInitInputData%TurbineComponents, DstInitInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%NumTwrNodes = SrcInitInputData%NumTwrNodes
IF (ALLOCATED(SrcInitInputData%TwrNodeLocs)) THEN
  i1_l = LBOUND(SrcInitInputData%TwrNodeLocs,1)
  i1_u = UBOUND(SrcInitInputData%TwrNodeLocs,1)
  i2_l = LBOUND(SrcInitInputData%TwrNodeLocs,2)
  i2_u = UBOUND(SrcInitInputData%TwrNodeLocs,2)
  IF (.NOT. ALLOCATED(DstInitInputData%TwrNodeLocs)) THEN 
    ALLOCATE(DstInitInputData%TwrNodeLocs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%TwrNodeLocs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%TwrNodeLocs = SrcInitInputData%TwrNodeLocs
ENDIF
    DstInitInputData%HubHt = SrcInitInputData%HubHt
      CALL DWM_CopyInitInput( SrcInitInputData%DWM, DstInitInputData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyInitInput

 SUBROUTINE AD14_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(AD14_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL AD14_DestroyAeroConfig( InitInputData%TurbineComponents, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitInputData%TwrNodeLocs)) THEN
  DEALLOCATE(InitInputData%TwrNodeLocs)
ENDIF
  CALL DWM_DestroyInitInput( InitInputData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyInitInput


subroutine AD14_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Title
   call RegPack(Buf, InData%Title)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutRootName
   call RegPack(Buf, InData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ADFileName
   call RegPack(Buf, InData%ADFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrSumFile
   call RegPack(Buf, InData%WrSumFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegPack(Buf, InData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeLength
   call RegPack(Buf, InData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinearizeFlag
   call RegPack(Buf, InData%LinearizeFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseDWM
   call RegPack(Buf, InData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineComponents
   call AD14_PackAeroConfig(Buf, InData%TurbineComponents) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTwrNodes
   call RegPack(Buf, InData%NumTwrNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrNodeLocs
   call RegPack(Buf, allocated(InData%TwrNodeLocs))
   if (allocated(InData%TwrNodeLocs)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrNodeLocs), ubound(InData%TwrNodeLocs))
      call RegPack(Buf, InData%TwrNodeLocs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubHt
   call RegPack(Buf, InData%HubHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DWM
   call DWM_PackInitInput(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInitInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Title
   call RegUnpack(Buf, OutData%Title)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutRootName
   call RegUnpack(Buf, OutData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ADFileName
   call RegUnpack(Buf, OutData%ADFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrSumFile
   call RegUnpack(Buf, OutData%WrSumFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegUnpack(Buf, OutData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeLength
   call RegUnpack(Buf, OutData%BladeLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinearizeFlag
   call RegUnpack(Buf, OutData%LinearizeFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseDWM
   call RegUnpack(Buf, OutData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineComponents
   call AD14_UnpackAeroConfig(Buf, OutData%TurbineComponents) ! TurbineComponents 
   ! NumTwrNodes
   call RegUnpack(Buf, OutData%NumTwrNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrNodeLocs
   if (allocated(OutData%TwrNodeLocs)) deallocate(OutData%TwrNodeLocs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrNodeLocs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrNodeLocs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrNodeLocs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HubHt
   call RegUnpack(Buf, OutData%HubHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DWM
   call DWM_UnpackInitInput(Buf, OutData%DWM) ! DWM 
end subroutine
 SUBROUTINE AD14_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(AD14_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyInitOutput( SrcInitOutputData%DWM, DstInitOutputData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitOutputData%AirDens = SrcInitOutputData%AirDens
 END SUBROUTINE AD14_CopyInitOutput

 SUBROUTINE AD14_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(AD14_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL DWM_DestroyInitOutput( InitOutputData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyInitOutput


subroutine AD14_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DWM
   call DWM_PackInitOutput(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! DWM
   call DWM_UnpackInitOutput(Buf, OutData%DWM) ! DWM 
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(AD14_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyContState( SrcContStateData%DWM, DstContStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyContState

 SUBROUTINE AD14_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(AD14_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL DWM_DestroyContState( ContStateData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyContState


subroutine AD14_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DWM
   call DWM_PackContState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DWM
   call DWM_UnpackContState(Buf, OutData%DWM) ! DWM 
end subroutine
 SUBROUTINE AD14_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(AD14_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyDiscState( SrcDiscStateData%DWM, DstDiscStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyDiscState

 SUBROUTINE AD14_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(AD14_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL DWM_DestroyDiscState( DiscStateData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyDiscState


subroutine AD14_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DWM
   call DWM_PackDiscState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DWM
   call DWM_UnpackDiscState(Buf, OutData%DWM) ! DWM 
end subroutine
 SUBROUTINE AD14_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(AD14_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyConstrState( SrcConstrStateData%DWM, DstConstrStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyConstrState

 SUBROUTINE AD14_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(AD14_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL DWM_DestroyConstrState( ConstrStateData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyConstrState


subroutine AD14_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DWM
   call DWM_PackConstrState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DWM
   call DWM_UnpackConstrState(Buf, OutData%DWM) ! DWM 
end subroutine
 SUBROUTINE AD14_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(AD14_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyOtherState( SrcOtherStateData%DWM, DstOtherStateData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyOtherState

 SUBROUTINE AD14_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(AD14_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL DWM_DestroyOtherState( OtherStateData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyOtherState


subroutine AD14_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DWM
   call DWM_PackOtherState(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DWM
   call DWM_UnpackOtherState(Buf, OutData%DWM) ! DWM 
end subroutine
 SUBROUTINE AD14_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(AD14_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL DWM_CopyMisc( SrcMiscData%DWM, DstMiscData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyInput( SrcMiscData%DWM_Inputs, DstMiscData%DWM_Inputs, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyOutput( SrcMiscData%DWM_Outputs, DstMiscData%DWM_Outputs, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%DT = SrcMiscData%DT
IF (ALLOCATED(SrcMiscData%ElPrNum)) THEN
  i1_l = LBOUND(SrcMiscData%ElPrNum,1)
  i1_u = UBOUND(SrcMiscData%ElPrNum,1)
  IF (.NOT. ALLOCATED(DstMiscData%ElPrNum)) THEN 
    ALLOCATE(DstMiscData%ElPrNum(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ElPrNum.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%ElPrNum = SrcMiscData%ElPrNum
ENDIF
    DstMiscData%OldTime = SrcMiscData%OldTime
    DstMiscData%HubLoss = SrcMiscData%HubLoss
    DstMiscData%Loss = SrcMiscData%Loss
    DstMiscData%TipLoss = SrcMiscData%TipLoss
    DstMiscData%TLpt7 = SrcMiscData%TLpt7
    DstMiscData%FirstPassGTL = SrcMiscData%FirstPassGTL
    DstMiscData%SuperSonic = SrcMiscData%SuperSonic
    DstMiscData%AFLAGVinderr = SrcMiscData%AFLAGVinderr
    DstMiscData%AFLAGTwrInflu = SrcMiscData%AFLAGTwrInflu
    DstMiscData%OnePassDynDbg = SrcMiscData%OnePassDynDbg
    DstMiscData%NoLoadsCalculated = SrcMiscData%NoLoadsCalculated
    DstMiscData%NERRORS = SrcMiscData%NERRORS
      CALL AD14_Copyairfoil( SrcMiscData%AirFoil, DstMiscData%AirFoil, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copybeddoes( SrcMiscData%Beddoes, DstMiscData%Beddoes, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copydyninflow( SrcMiscData%DynInflow, DstMiscData%DynInflow, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyelement( SrcMiscData%Element, DstMiscData%Element, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyrotor( SrcMiscData%Rotor, DstMiscData%Rotor, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copywind( SrcMiscData%Wind, DstMiscData%Wind, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyinducedvel( SrcMiscData%InducedVel, DstMiscData%InducedVel, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyeloutparms( SrcMiscData%ElOut, DstMiscData%ElOut, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%Skew = SrcMiscData%Skew
    DstMiscData%DynInit = SrcMiscData%DynInit
    DstMiscData%FirstWarn = SrcMiscData%FirstWarn
IF (ALLOCATED(SrcMiscData%StoredForces)) THEN
  i1_l = LBOUND(SrcMiscData%StoredForces,1)
  i1_u = UBOUND(SrcMiscData%StoredForces,1)
  i2_l = LBOUND(SrcMiscData%StoredForces,2)
  i2_u = UBOUND(SrcMiscData%StoredForces,2)
  i3_l = LBOUND(SrcMiscData%StoredForces,3)
  i3_u = UBOUND(SrcMiscData%StoredForces,3)
  IF (.NOT. ALLOCATED(DstMiscData%StoredForces)) THEN 
    ALLOCATE(DstMiscData%StoredForces(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredForces.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%StoredForces = SrcMiscData%StoredForces
ENDIF
IF (ALLOCATED(SrcMiscData%StoredMoments)) THEN
  i1_l = LBOUND(SrcMiscData%StoredMoments,1)
  i1_u = UBOUND(SrcMiscData%StoredMoments,1)
  i2_l = LBOUND(SrcMiscData%StoredMoments,2)
  i2_u = UBOUND(SrcMiscData%StoredMoments,2)
  i3_l = LBOUND(SrcMiscData%StoredMoments,3)
  i3_u = UBOUND(SrcMiscData%StoredMoments,3)
  IF (.NOT. ALLOCATED(DstMiscData%StoredMoments)) THEN 
    ALLOCATE(DstMiscData%StoredMoments(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%StoredMoments.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%StoredMoments = SrcMiscData%StoredMoments
ENDIF
 END SUBROUTINE AD14_CopyMisc

 SUBROUTINE AD14_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(AD14_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL DWM_DestroyMisc( MiscData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL DWM_DestroyInput( MiscData%DWM_Inputs, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL DWM_DestroyOutput( MiscData%DWM_Outputs, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%ElPrNum)) THEN
  DEALLOCATE(MiscData%ElPrNum)
ENDIF
  CALL AD14_DestroyAirFoil( MiscData%AirFoil, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyBeddoes( MiscData%Beddoes, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyDynInflow( MiscData%DynInflow, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyElement( MiscData%Element, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyRotor( MiscData%Rotor, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyWind( MiscData%Wind, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyInducedVel( MiscData%InducedVel, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyElOutParms( MiscData%ElOut, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%StoredForces)) THEN
  DEALLOCATE(MiscData%StoredForces)
ENDIF
IF (ALLOCATED(MiscData%StoredMoments)) THEN
  DEALLOCATE(MiscData%StoredMoments)
ENDIF
 END SUBROUTINE AD14_DestroyMisc


subroutine AD14_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DWM
   call DWM_PackMisc(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DWM_Inputs
   call DWM_PackInput(Buf, InData%DWM_Inputs) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DWM_Outputs
   call DWM_PackOutput(Buf, InData%DWM_Outputs) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElPrNum
   call RegPack(Buf, allocated(InData%ElPrNum))
   if (allocated(InData%ElPrNum)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElPrNum), ubound(InData%ElPrNum))
      call RegPack(Buf, InData%ElPrNum)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OldTime
   call RegPack(Buf, InData%OldTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoss
   call RegPack(Buf, InData%HubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Loss
   call RegPack(Buf, InData%Loss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TipLoss
   call RegPack(Buf, InData%TipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TLpt7
   call RegPack(Buf, InData%TLpt7)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstPassGTL
   call RegPack(Buf, InData%FirstPassGTL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SuperSonic
   call RegPack(Buf, InData%SuperSonic)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFLAGVinderr
   call RegPack(Buf, InData%AFLAGVinderr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFLAGTwrInflu
   call RegPack(Buf, InData%AFLAGTwrInflu)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OnePassDynDbg
   call RegPack(Buf, InData%OnePassDynDbg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NoLoadsCalculated
   call RegPack(Buf, InData%NoLoadsCalculated)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NERRORS
   call RegPack(Buf, InData%NERRORS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirFoil
   call AD14_PackAirFoil(Buf, InData%AirFoil) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Beddoes
   call AD14_PackBeddoes(Buf, InData%Beddoes) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynInflow
   call AD14_PackDynInflow(Buf, InData%DynInflow) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Element
   call AD14_PackElement(Buf, InData%Element) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rotor
   call AD14_PackRotor(Buf, InData%Rotor) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Wind
   call AD14_PackWind(Buf, InData%Wind) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InducedVel
   call AD14_PackInducedVel(Buf, InData%InducedVel) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElOut
   call AD14_PackElOutParms(Buf, InData%ElOut) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Skew
   call RegPack(Buf, InData%Skew)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynInit
   call RegPack(Buf, InData%DynInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstWarn
   call RegPack(Buf, InData%FirstWarn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StoredForces
   call RegPack(Buf, allocated(InData%StoredForces))
   if (allocated(InData%StoredForces)) then
      call RegPackBounds(Buf, 3, lbound(InData%StoredForces), ubound(InData%StoredForces))
      call RegPack(Buf, InData%StoredForces)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StoredMoments
   call RegPack(Buf, allocated(InData%StoredMoments))
   if (allocated(InData%StoredMoments)) then
      call RegPackBounds(Buf, 3, lbound(InData%StoredMoments), ubound(InData%StoredMoments))
      call RegPack(Buf, InData%StoredMoments)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackMisc'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DWM
   call DWM_UnpackMisc(Buf, OutData%DWM) ! DWM 
   ! DWM_Inputs
   call DWM_UnpackInput(Buf, OutData%DWM_Inputs) ! DWM_Inputs 
   ! DWM_Outputs
   call DWM_UnpackOutput(Buf, OutData%DWM_Outputs) ! DWM_Outputs 
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElPrNum
   if (allocated(OutData%ElPrNum)) deallocate(OutData%ElPrNum)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElPrNum(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElPrNum.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElPrNum)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OldTime
   call RegUnpack(Buf, OutData%OldTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoss
   call RegUnpack(Buf, OutData%HubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Loss
   call RegUnpack(Buf, OutData%Loss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TipLoss
   call RegUnpack(Buf, OutData%TipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TLpt7
   call RegUnpack(Buf, OutData%TLpt7)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstPassGTL
   call RegUnpack(Buf, OutData%FirstPassGTL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SuperSonic
   call RegUnpack(Buf, OutData%SuperSonic)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFLAGVinderr
   call RegUnpack(Buf, OutData%AFLAGVinderr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFLAGTwrInflu
   call RegUnpack(Buf, OutData%AFLAGTwrInflu)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OnePassDynDbg
   call RegUnpack(Buf, OutData%OnePassDynDbg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NoLoadsCalculated
   call RegUnpack(Buf, OutData%NoLoadsCalculated)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NERRORS
   call RegUnpack(Buf, OutData%NERRORS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirFoil
   call AD14_UnpackAirFoil(Buf, OutData%AirFoil) ! AirFoil 
   ! Beddoes
   call AD14_UnpackBeddoes(Buf, OutData%Beddoes) ! Beddoes 
   ! DynInflow
   call AD14_UnpackDynInflow(Buf, OutData%DynInflow) ! DynInflow 
   ! Element
   call AD14_UnpackElement(Buf, OutData%Element) ! Element 
   ! Rotor
   call AD14_UnpackRotor(Buf, OutData%Rotor) ! Rotor 
   ! Wind
   call AD14_UnpackWind(Buf, OutData%Wind) ! Wind 
   ! InducedVel
   call AD14_UnpackInducedVel(Buf, OutData%InducedVel) ! InducedVel 
   ! ElOut
   call AD14_UnpackElOutParms(Buf, OutData%ElOut) ! ElOut 
   ! Skew
   call RegUnpack(Buf, OutData%Skew)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynInit
   call RegUnpack(Buf, OutData%DynInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstWarn
   call RegUnpack(Buf, OutData%FirstWarn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StoredForces
   if (allocated(OutData%StoredForces)) deallocate(OutData%StoredForces)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StoredForces(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StoredForces.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StoredForces)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StoredMoments
   if (allocated(OutData%StoredMoments)) deallocate(OutData%StoredMoments)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StoredMoments(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StoredMoments.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StoredMoments)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD14_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AD14_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%Title = SrcParamData%Title
    DstParamData%SIUnit = SrcParamData%SIUnit
    DstParamData%Echo = SrcParamData%Echo
    DstParamData%MultiTab = SrcParamData%MultiTab
    DstParamData%LinearizeFlag = SrcParamData%LinearizeFlag
    DstParamData%OutputPlottingInfo = SrcParamData%OutputPlottingInfo
    DstParamData%UseDWM = SrcParamData%UseDWM
    DstParamData%TwoPiNB = SrcParamData%TwoPiNB
    DstParamData%NumBl = SrcParamData%NumBl
    DstParamData%NBlInpSt = SrcParamData%NBlInpSt
    DstParamData%ElemPrn = SrcParamData%ElemPrn
    DstParamData%DStall = SrcParamData%DStall
    DstParamData%PMoment = SrcParamData%PMoment
    DstParamData%Reynolds = SrcParamData%Reynolds
    DstParamData%DynInfl = SrcParamData%DynInfl
    DstParamData%Wake = SrcParamData%Wake
    DstParamData%Swirl = SrcParamData%Swirl
    DstParamData%DtAero = SrcParamData%DtAero
    DstParamData%HubRad = SrcParamData%HubRad
    DstParamData%UnEc = SrcParamData%UnEc
    DstParamData%UnElem = SrcParamData%UnElem
    DstParamData%UnWndOut = SrcParamData%UnWndOut
    DstParamData%MAXICOUNT = SrcParamData%MAXICOUNT
    DstParamData%WrOptFile = SrcParamData%WrOptFile
    DstParamData%DEFAULT_Wind = SrcParamData%DEFAULT_Wind
      CALL AD14_Copyairfoilparms( SrcParamData%AirFoil, DstParamData%AirFoil, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copybladeparms( SrcParamData%Blade, DstParamData%Blade, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copybeddoesparms( SrcParamData%Beddoes, DstParamData%Beddoes, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copydyninflowparms( SrcParamData%DynInflow, DstParamData%DynInflow, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyelementparms( SrcParamData%Element, DstParamData%Element, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copytwrpropsparms( SrcParamData%TwrProps, DstParamData%TwrProps, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyinducedvelparms( SrcParamData%InducedVel, DstParamData%InducedVel, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copywindparms( SrcParamData%Wind, DstParamData%Wind, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyrotorparms( SrcParamData%Rotor, DstParamData%Rotor, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL DWM_CopyParam( SrcParamData%DWM, DstParamData%DWM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyParam

 SUBROUTINE AD14_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(AD14_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL AD14_DestroyAirFoilParms( ParamData%AirFoil, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyBladeParms( ParamData%Blade, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyBeddoesParms( ParamData%Beddoes, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyDynInflowParms( ParamData%DynInflow, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyElementParms( ParamData%Element, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyTwrPropsParms( ParamData%TwrProps, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyInducedVelParms( ParamData%InducedVel, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyWindParms( ParamData%Wind, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyRotorParms( ParamData%Rotor, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL DWM_DestroyParam( ParamData%DWM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyParam


subroutine AD14_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Title
   call RegPack(Buf, InData%Title)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIUnit
   call RegPack(Buf, InData%SIUnit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MultiTab
   call RegPack(Buf, InData%MultiTab)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinearizeFlag
   call RegPack(Buf, InData%LinearizeFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutputPlottingInfo
   call RegPack(Buf, InData%OutputPlottingInfo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseDWM
   call RegPack(Buf, InData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwoPiNB
   call RegPack(Buf, InData%TwoPiNB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegPack(Buf, InData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBlInpSt
   call RegPack(Buf, InData%NBlInpSt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElemPrn
   call RegPack(Buf, InData%ElemPrn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DStall
   call RegPack(Buf, InData%DStall)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PMoment
   call RegPack(Buf, InData%PMoment)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Reynolds
   call RegPack(Buf, InData%Reynolds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynInfl
   call RegPack(Buf, InData%DynInfl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Wake
   call RegPack(Buf, InData%Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Swirl
   call RegPack(Buf, InData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DtAero
   call RegPack(Buf, InData%DtAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubRad
   call RegPack(Buf, InData%HubRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnEc
   call RegPack(Buf, InData%UnEc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnElem
   call RegPack(Buf, InData%UnElem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnWndOut
   call RegPack(Buf, InData%UnWndOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MAXICOUNT
   call RegPack(Buf, InData%MAXICOUNT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrOptFile
   call RegPack(Buf, InData%WrOptFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DEFAULT_Wind
   call RegPack(Buf, InData%DEFAULT_Wind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirFoil
   call AD14_PackAirFoilParms(Buf, InData%AirFoil) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Blade
   call AD14_PackBladeParms(Buf, InData%Blade) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Beddoes
   call AD14_PackBeddoesParms(Buf, InData%Beddoes) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynInflow
   call AD14_PackDynInflowParms(Buf, InData%DynInflow) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Element
   call AD14_PackElementParms(Buf, InData%Element) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrProps
   call AD14_PackTwrPropsParms(Buf, InData%TwrProps) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InducedVel
   call AD14_PackInducedVelParms(Buf, InData%InducedVel) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Wind
   call AD14_PackWindParms(Buf, InData%Wind) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rotor
   call AD14_PackRotorParms(Buf, InData%Rotor) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DWM
   call DWM_PackParam(Buf, InData%DWM) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackParam'
   if (Buf%ErrStat /= ErrID_None) return
   ! Title
   call RegUnpack(Buf, OutData%Title)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SIUnit
   call RegUnpack(Buf, OutData%SIUnit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MultiTab
   call RegUnpack(Buf, OutData%MultiTab)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinearizeFlag
   call RegUnpack(Buf, OutData%LinearizeFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutputPlottingInfo
   call RegUnpack(Buf, OutData%OutputPlottingInfo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseDWM
   call RegUnpack(Buf, OutData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwoPiNB
   call RegUnpack(Buf, OutData%TwoPiNB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl
   call RegUnpack(Buf, OutData%NumBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBlInpSt
   call RegUnpack(Buf, OutData%NBlInpSt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElemPrn
   call RegUnpack(Buf, OutData%ElemPrn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DStall
   call RegUnpack(Buf, OutData%DStall)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PMoment
   call RegUnpack(Buf, OutData%PMoment)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Reynolds
   call RegUnpack(Buf, OutData%Reynolds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DynInfl
   call RegUnpack(Buf, OutData%DynInfl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Wake
   call RegUnpack(Buf, OutData%Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Swirl
   call RegUnpack(Buf, OutData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DtAero
   call RegUnpack(Buf, OutData%DtAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubRad
   call RegUnpack(Buf, OutData%HubRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnEc
   call RegUnpack(Buf, OutData%UnEc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnElem
   call RegUnpack(Buf, OutData%UnElem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnWndOut
   call RegUnpack(Buf, OutData%UnWndOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MAXICOUNT
   call RegUnpack(Buf, OutData%MAXICOUNT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrOptFile
   call RegUnpack(Buf, OutData%WrOptFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DEFAULT_Wind
   call RegUnpack(Buf, OutData%DEFAULT_Wind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirFoil
   call AD14_UnpackAirFoilParms(Buf, OutData%AirFoil) ! AirFoil 
   ! Blade
   call AD14_UnpackBladeParms(Buf, OutData%Blade) ! Blade 
   ! Beddoes
   call AD14_UnpackBeddoesParms(Buf, OutData%Beddoes) ! Beddoes 
   ! DynInflow
   call AD14_UnpackDynInflowParms(Buf, OutData%DynInflow) ! DynInflow 
   ! Element
   call AD14_UnpackElementParms(Buf, OutData%Element) ! Element 
   ! TwrProps
   call AD14_UnpackTwrPropsParms(Buf, OutData%TwrProps) ! TwrProps 
   ! InducedVel
   call AD14_UnpackInducedVelParms(Buf, OutData%InducedVel) ! InducedVel 
   ! Wind
   call AD14_UnpackWindParms(Buf, OutData%Wind) ! Wind 
   ! Rotor
   call AD14_UnpackRotorParms(Buf, OutData%Rotor) ! Rotor 
   ! DWM
   call DWM_UnpackParam(Buf, OutData%DWM) ! DWM 
end subroutine
 SUBROUTINE AD14_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(AD14_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%InputMarkers)) THEN
  i1_l = LBOUND(SrcInputData%InputMarkers,1)
  i1_u = UBOUND(SrcInputData%InputMarkers,1)
  IF (.NOT. ALLOCATED(DstInputData%InputMarkers)) THEN 
    ALLOCATE(DstInputData%InputMarkers(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InputMarkers.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%InputMarkers,1), UBOUND(SrcInputData%InputMarkers,1)
      CALL MeshCopy( SrcInputData%InputMarkers(i1), DstInputData%InputMarkers(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcInputData%Twr_InputMarkers, DstInputData%Twr_InputMarkers, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_Copyaeroconfig( SrcInputData%TurbineComponents, DstInputData%TurbineComponents, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInputData%MulTabLoc)) THEN
  i1_l = LBOUND(SrcInputData%MulTabLoc,1)
  i1_u = UBOUND(SrcInputData%MulTabLoc,1)
  i2_l = LBOUND(SrcInputData%MulTabLoc,2)
  i2_u = UBOUND(SrcInputData%MulTabLoc,2)
  IF (.NOT. ALLOCATED(DstInputData%MulTabLoc)) THEN 
    ALLOCATE(DstInputData%MulTabLoc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%MulTabLoc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%MulTabLoc = SrcInputData%MulTabLoc
ENDIF
IF (ALLOCATED(SrcInputData%InflowVelocity)) THEN
  i1_l = LBOUND(SrcInputData%InflowVelocity,1)
  i1_u = UBOUND(SrcInputData%InflowVelocity,1)
  i2_l = LBOUND(SrcInputData%InflowVelocity,2)
  i2_u = UBOUND(SrcInputData%InflowVelocity,2)
  IF (.NOT. ALLOCATED(DstInputData%InflowVelocity)) THEN 
    ALLOCATE(DstInputData%InflowVelocity(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InflowVelocity.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%InflowVelocity = SrcInputData%InflowVelocity
ENDIF
    DstInputData%AvgInfVel = SrcInputData%AvgInfVel
 END SUBROUTINE AD14_CopyInput

 SUBROUTINE AD14_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(AD14_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%InputMarkers)) THEN
DO i1 = LBOUND(InputData%InputMarkers,1), UBOUND(InputData%InputMarkers,1)
  CALL MeshDestroy( InputData%InputMarkers(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%InputMarkers)
ENDIF
  CALL MeshDestroy( InputData%Twr_InputMarkers, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyAeroConfig( InputData%TurbineComponents, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InputData%MulTabLoc)) THEN
  DEALLOCATE(InputData%MulTabLoc)
ENDIF
IF (ALLOCATED(InputData%InflowVelocity)) THEN
  DEALLOCATE(InputData%InflowVelocity)
ENDIF
 END SUBROUTINE AD14_DestroyInput


subroutine AD14_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputMarkers
   call RegPack(Buf, allocated(InData%InputMarkers))
   if (allocated(InData%InputMarkers)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputMarkers), ubound(InData%InputMarkers))
      LB(1:1) = lbound(InData%InputMarkers)
      UB(1:1) = ubound(InData%InputMarkers)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%InputMarkers(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Twr_InputMarkers
   call MeshPack(Buf, InData%Twr_InputMarkers) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineComponents
   call AD14_PackAeroConfig(Buf, InData%TurbineComponents) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! MulTabLoc
   call RegPack(Buf, allocated(InData%MulTabLoc))
   if (allocated(InData%MulTabLoc)) then
      call RegPackBounds(Buf, 2, lbound(InData%MulTabLoc), ubound(InData%MulTabLoc))
      call RegPack(Buf, InData%MulTabLoc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowVelocity
   call RegPack(Buf, allocated(InData%InflowVelocity))
   if (allocated(InData%InflowVelocity)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowVelocity), ubound(InData%InflowVelocity))
      call RegPack(Buf, InData%InflowVelocity)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgInfVel
   call RegPack(Buf, InData%AvgInfVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InputMarkers
   if (allocated(OutData%InputMarkers)) deallocate(OutData%InputMarkers)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputMarkers(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputMarkers.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%InputMarkers(i1)) ! InputMarkers 
      end do
   end if
   ! Twr_InputMarkers
   call MeshUnpack(Buf, OutData%Twr_InputMarkers) ! Twr_InputMarkers 
   ! TurbineComponents
   call AD14_UnpackAeroConfig(Buf, OutData%TurbineComponents) ! TurbineComponents 
   ! MulTabLoc
   if (allocated(OutData%MulTabLoc)) deallocate(OutData%MulTabLoc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MulTabLoc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MulTabLoc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MulTabLoc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InflowVelocity
   if (allocated(OutData%InflowVelocity)) deallocate(OutData%InflowVelocity)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowVelocity(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowVelocity.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowVelocity)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AvgInfVel
   call RegUnpack(Buf, OutData%AvgInfVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD14_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD14_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(AD14_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD14_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%OutputLoads)) THEN
  i1_l = LBOUND(SrcOutputData%OutputLoads,1)
  i1_u = UBOUND(SrcOutputData%OutputLoads,1)
  IF (.NOT. ALLOCATED(DstOutputData%OutputLoads)) THEN 
    ALLOCATE(DstOutputData%OutputLoads(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%OutputLoads.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%OutputLoads,1), UBOUND(SrcOutputData%OutputLoads,1)
      CALL MeshCopy( SrcOutputData%OutputLoads(i1), DstOutputData%OutputLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcOutputData%Twr_OutputLoads, DstOutputData%Twr_OutputLoads, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD14_CopyOutput

 SUBROUTINE AD14_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(AD14_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD14_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%OutputLoads)) THEN
DO i1 = LBOUND(OutputData%OutputLoads,1), UBOUND(OutputData%OutputLoads,1)
  CALL MeshDestroy( OutputData%OutputLoads(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%OutputLoads)
ENDIF
  CALL MeshDestroy( OutputData%Twr_OutputLoads, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD14_DestroyOutput


subroutine AD14_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD14_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD14_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! OutputLoads
   call RegPack(Buf, allocated(InData%OutputLoads))
   if (allocated(InData%OutputLoads)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutputLoads), ubound(InData%OutputLoads))
      LB(1:1) = lbound(InData%OutputLoads)
      UB(1:1) = ubound(InData%OutputLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%OutputLoads(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Twr_OutputLoads
   call MeshPack(Buf, InData%Twr_OutputLoads) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD14_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD14_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD14_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! OutputLoads
   if (allocated(OutData%OutputLoads)) deallocate(OutData%OutputLoads)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutputLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutputLoads.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%OutputLoads(i1)) ! OutputLoads 
      end do
   end if
   ! Twr_OutputLoads
   call MeshUnpack(Buf, OutData%Twr_OutputLoads) ! Twr_OutputLoads 
end subroutine

 SUBROUTINE AD14_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD14_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD14_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD14_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD14_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD14_Input_ExtrapInterp


 SUBROUTINE AD14_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(AD14_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
  DO i1 = LBOUND(u_out%InputMarkers,1),UBOUND(u_out%InputMarkers,1)
      CALL MeshExtrapInterp1(u1%InputMarkers(i1), u2%InputMarkers(i1), tin, u_out%InputMarkers(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp1(u1%Twr_InputMarkers, u2%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Position,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Position,1)
    b = -(u1%TurbineComponents%Blade(i11)%Position(i1) - u2%TurbineComponents%Blade(i11)%Position(i1))
    u_out%TurbineComponents%Blade(i11)%Position(i1) = u1%TurbineComponents%Blade(i11)%Position(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i2 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1)
      b = -(u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) - u2%TurbineComponents%Blade(i11)%Orientation(i1,i2))
      u_out%TurbineComponents%Blade(i11)%Orientation(i1,i2) = u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)
    b = -(u1%TurbineComponents%Blade(i11)%TranslationVel(i1) - u2%TurbineComponents%Blade(i11)%TranslationVel(i1))
    u_out%TurbineComponents%Blade(i11)%TranslationVel(i1) = u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1)
    b = -(u1%TurbineComponents%Blade(i11)%RotationVel(i1) - u2%TurbineComponents%Blade(i11)%RotationVel(i1))
    u_out%TurbineComponents%Blade(i11)%RotationVel(i1) = u1%TurbineComponents%Blade(i11)%RotationVel(i1) + b * ScaleFactor
  END DO
  ENDDO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%Position,1),UBOUND(u_out%TurbineComponents%Hub%Position,1)
    b = -(u1%TurbineComponents%Hub%Position(i1) - u2%TurbineComponents%Hub%Position(i1))
    u_out%TurbineComponents%Hub%Position(i1) = u1%TurbineComponents%Hub%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Hub%Orientation,2),UBOUND(u_out%TurbineComponents%Hub%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Hub%Orientation,1),UBOUND(u_out%TurbineComponents%Hub%Orientation,1)
      b = -(u1%TurbineComponents%Hub%Orientation(i1,i2) - u2%TurbineComponents%Hub%Orientation(i1,i2))
      u_out%TurbineComponents%Hub%Orientation(i1,i2) = u1%TurbineComponents%Hub%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%TranslationVel,1),UBOUND(u_out%TurbineComponents%Hub%TranslationVel,1)
    b = -(u1%TurbineComponents%Hub%TranslationVel(i1) - u2%TurbineComponents%Hub%TranslationVel(i1))
    u_out%TurbineComponents%Hub%TranslationVel(i1) = u1%TurbineComponents%Hub%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%RotationVel,1),UBOUND(u_out%TurbineComponents%Hub%RotationVel,1)
    b = -(u1%TurbineComponents%Hub%RotationVel(i1) - u2%TurbineComponents%Hub%RotationVel(i1))
    u_out%TurbineComponents%Hub%RotationVel(i1) = u1%TurbineComponents%Hub%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Position,1),UBOUND(u_out%TurbineComponents%RotorFurl%Position,1)
    b = -(u1%TurbineComponents%RotorFurl%Position(i1) - u2%TurbineComponents%RotorFurl%Position(i1))
    u_out%TurbineComponents%RotorFurl%Position(i1) = u1%TurbineComponents%RotorFurl%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1)
      b = -(u1%TurbineComponents%RotorFurl%Orientation(i1,i2) - u2%TurbineComponents%RotorFurl%Orientation(i1,i2))
      u_out%TurbineComponents%RotorFurl%Orientation(i1,i2) = u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1)
    b = -(u1%TurbineComponents%RotorFurl%TranslationVel(i1) - u2%TurbineComponents%RotorFurl%TranslationVel(i1))
    u_out%TurbineComponents%RotorFurl%TranslationVel(i1) = u1%TurbineComponents%RotorFurl%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1)
    b = -(u1%TurbineComponents%RotorFurl%RotationVel(i1) - u2%TurbineComponents%RotorFurl%RotationVel(i1))
    u_out%TurbineComponents%RotorFurl%RotationVel(i1) = u1%TurbineComponents%RotorFurl%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Position,1),UBOUND(u_out%TurbineComponents%Nacelle%Position,1)
    b = -(u1%TurbineComponents%Nacelle%Position(i1) - u2%TurbineComponents%Nacelle%Position(i1))
    u_out%TurbineComponents%Nacelle%Position(i1) = u1%TurbineComponents%Nacelle%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,2),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,1),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,1)
      b = -(u1%TurbineComponents%Nacelle%Orientation(i1,i2) - u2%TurbineComponents%Nacelle%Orientation(i1,i2))
      u_out%TurbineComponents%Nacelle%Orientation(i1,i2) = u1%TurbineComponents%Nacelle%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1)
    b = -(u1%TurbineComponents%Nacelle%TranslationVel(i1) - u2%TurbineComponents%Nacelle%TranslationVel(i1))
    u_out%TurbineComponents%Nacelle%TranslationVel(i1) = u1%TurbineComponents%Nacelle%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1)
    b = -(u1%TurbineComponents%Nacelle%RotationVel(i1) - u2%TurbineComponents%Nacelle%RotationVel(i1))
    u_out%TurbineComponents%Nacelle%RotationVel(i1) = u1%TurbineComponents%Nacelle%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Position,1),UBOUND(u_out%TurbineComponents%TailFin%Position,1)
    b = -(u1%TurbineComponents%TailFin%Position(i1) - u2%TurbineComponents%TailFin%Position(i1))
    u_out%TurbineComponents%TailFin%Position(i1) = u1%TurbineComponents%TailFin%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,2),UBOUND(u_out%TurbineComponents%TailFin%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,1),UBOUND(u_out%TurbineComponents%TailFin%Orientation,1)
      b = -(u1%TurbineComponents%TailFin%Orientation(i1,i2) - u2%TurbineComponents%TailFin%Orientation(i1,i2))
      u_out%TurbineComponents%TailFin%Orientation(i1,i2) = u1%TurbineComponents%TailFin%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1),UBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1)
    b = -(u1%TurbineComponents%TailFin%TranslationVel(i1) - u2%TurbineComponents%TailFin%TranslationVel(i1))
    u_out%TurbineComponents%TailFin%TranslationVel(i1) = u1%TurbineComponents%TailFin%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%RotationVel,1),UBOUND(u_out%TurbineComponents%TailFin%RotationVel,1)
    b = -(u1%TurbineComponents%TailFin%RotationVel(i1) - u2%TurbineComponents%TailFin%RotationVel(i1))
    u_out%TurbineComponents%TailFin%RotationVel(i1) = u1%TurbineComponents%TailFin%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%Position,1),UBOUND(u_out%TurbineComponents%Tower%Position,1)
    b = -(u1%TurbineComponents%Tower%Position(i1) - u2%TurbineComponents%Tower%Position(i1))
    u_out%TurbineComponents%Tower%Position(i1) = u1%TurbineComponents%Tower%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Tower%Orientation,2),UBOUND(u_out%TurbineComponents%Tower%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Tower%Orientation,1),UBOUND(u_out%TurbineComponents%Tower%Orientation,1)
      b = -(u1%TurbineComponents%Tower%Orientation(i1,i2) - u2%TurbineComponents%Tower%Orientation(i1,i2))
      u_out%TurbineComponents%Tower%Orientation(i1,i2) = u1%TurbineComponents%Tower%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%TranslationVel,1),UBOUND(u_out%TurbineComponents%Tower%TranslationVel,1)
    b = -(u1%TurbineComponents%Tower%TranslationVel(i1) - u2%TurbineComponents%Tower%TranslationVel(i1))
    u_out%TurbineComponents%Tower%TranslationVel(i1) = u1%TurbineComponents%Tower%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%RotationVel,1),UBOUND(u_out%TurbineComponents%Tower%RotationVel,1)
    b = -(u1%TurbineComponents%Tower%RotationVel(i1) - u2%TurbineComponents%Tower%RotationVel(i1))
    u_out%TurbineComponents%Tower%RotationVel(i1) = u1%TurbineComponents%Tower%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Position,1),UBOUND(u_out%TurbineComponents%SubStructure%Position,1)
    b = -(u1%TurbineComponents%SubStructure%Position(i1) - u2%TurbineComponents%SubStructure%Position(i1))
    u_out%TurbineComponents%SubStructure%Position(i1) = u1%TurbineComponents%SubStructure%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,2),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,1),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,1)
      b = -(u1%TurbineComponents%SubStructure%Orientation(i1,i2) - u2%TurbineComponents%SubStructure%Orientation(i1,i2))
      u_out%TurbineComponents%SubStructure%Orientation(i1,i2) = u1%TurbineComponents%SubStructure%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1)
    b = -(u1%TurbineComponents%SubStructure%TranslationVel(i1) - u2%TurbineComponents%SubStructure%TranslationVel(i1))
    u_out%TurbineComponents%SubStructure%TranslationVel(i1) = u1%TurbineComponents%SubStructure%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1)
    b = -(u1%TurbineComponents%SubStructure%RotationVel(i1) - u2%TurbineComponents%SubStructure%RotationVel(i1))
    u_out%TurbineComponents%SubStructure%RotationVel(i1) = u1%TurbineComponents%SubStructure%RotationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Position,1),UBOUND(u_out%TurbineComponents%Foundation%Position,1)
    b = -(u1%TurbineComponents%Foundation%Position(i1) - u2%TurbineComponents%Foundation%Position(i1))
    u_out%TurbineComponents%Foundation%Position(i1) = u1%TurbineComponents%Foundation%Position(i1) + b * ScaleFactor
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,2),UBOUND(u_out%TurbineComponents%Foundation%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,1),UBOUND(u_out%TurbineComponents%Foundation%Orientation,1)
      b = -(u1%TurbineComponents%Foundation%Orientation(i1,i2) - u2%TurbineComponents%Foundation%Orientation(i1,i2))
      u_out%TurbineComponents%Foundation%Orientation(i1,i2) = u1%TurbineComponents%Foundation%Orientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1),UBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1)
    b = -(u1%TurbineComponents%Foundation%TranslationVel(i1) - u2%TurbineComponents%Foundation%TranslationVel(i1))
    u_out%TurbineComponents%Foundation%TranslationVel(i1) = u1%TurbineComponents%Foundation%TranslationVel(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%RotationVel,1),UBOUND(u_out%TurbineComponents%Foundation%RotationVel,1)
    b = -(u1%TurbineComponents%Foundation%RotationVel(i1) - u2%TurbineComponents%Foundation%RotationVel(i1))
    u_out%TurbineComponents%Foundation%RotationVel(i1) = u1%TurbineComponents%Foundation%RotationVel(i1) + b * ScaleFactor
  END DO
  b = -(u1%TurbineComponents%BladeLength - u2%TurbineComponents%BladeLength)
  u_out%TurbineComponents%BladeLength = u1%TurbineComponents%BladeLength + b * ScaleFactor
IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
  DO i2 = LBOUND(u_out%MulTabLoc,2),UBOUND(u_out%MulTabLoc,2)
    DO i1 = LBOUND(u_out%MulTabLoc,1),UBOUND(u_out%MulTabLoc,1)
      b = -(u1%MulTabLoc(i1,i2) - u2%MulTabLoc(i1,i2))
      u_out%MulTabLoc(i1,i2) = u1%MulTabLoc(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
  DO i2 = LBOUND(u_out%InflowVelocity,2),UBOUND(u_out%InflowVelocity,2)
    DO i1 = LBOUND(u_out%InflowVelocity,1),UBOUND(u_out%InflowVelocity,1)
      b = -(u1%InflowVelocity(i1,i2) - u2%InflowVelocity(i1,i2))
      u_out%InflowVelocity(i1,i2) = u1%InflowVelocity(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%AvgInfVel,1),UBOUND(u_out%AvgInfVel,1)
    b = -(u1%AvgInfVel(i1) - u2%AvgInfVel(i1))
    u_out%AvgInfVel(i1) = u1%AvgInfVel(i1) + b * ScaleFactor
  END DO
 END SUBROUTINE AD14_Input_ExtrapInterp1


 SUBROUTINE AD14_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(AD14_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(AD14_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(AD14_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(AD14_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%InputMarkers) .AND. ALLOCATED(u1%InputMarkers)) THEN
  DO i1 = LBOUND(u_out%InputMarkers,1),UBOUND(u_out%InputMarkers,1)
      CALL MeshExtrapInterp2(u1%InputMarkers(i1), u2%InputMarkers(i1), u3%InputMarkers(i1), tin, u_out%InputMarkers(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp2(u1%Twr_InputMarkers, u2%Twr_InputMarkers, u3%Twr_InputMarkers, tin, u_out%Twr_InputMarkers, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%TurbineComponents%Blade) .AND. ALLOCATED(u1%TurbineComponents%Blade)) THEN
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Position,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%Position(i1) - u2%TurbineComponents%Blade(i11)%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%Position(i1) + u3%TurbineComponents%Blade(i11)%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%Position(i1) + t(3)*u2%TurbineComponents%Blade(i11)%Position(i1) - t(2)*u3%TurbineComponents%Blade(i11)%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Blade(i11)%Position(i1) = u1%TurbineComponents%Blade(i11)%Position(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i2 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1),UBOUND(u_out%TurbineComponents%Blade(i11)%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) - u2%TurbineComponents%Blade(i11)%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + u3%TurbineComponents%Blade(i11)%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Blade(i11)%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Blade(i11)%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Blade(i11)%Orientation(i1,i2) = u1%TurbineComponents%Blade(i11)%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%TranslationVel(i1) - u2%TurbineComponents%Blade(i11)%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + u3%TurbineComponents%Blade(i11)%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + t(3)*u2%TurbineComponents%Blade(i11)%TranslationVel(i1) - t(2)*u3%TurbineComponents%Blade(i11)%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Blade(i11)%TranslationVel(i1) = u1%TurbineComponents%Blade(i11)%TranslationVel(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i11 = LBOUND(u_out%TurbineComponents%Blade,1),UBOUND(u_out%TurbineComponents%Blade,1)
  DO i1 = LBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1),UBOUND(u_out%TurbineComponents%Blade(i11)%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Blade(i11)%RotationVel(i1) - u2%TurbineComponents%Blade(i11)%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Blade(i11)%RotationVel(i1) + u3%TurbineComponents%Blade(i11)%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Blade(i11)%RotationVel(i1) + t(3)*u2%TurbineComponents%Blade(i11)%RotationVel(i1) - t(2)*u3%TurbineComponents%Blade(i11)%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Blade(i11)%RotationVel(i1) = u1%TurbineComponents%Blade(i11)%RotationVel(i1) + b  + c * t_out
  END DO
  ENDDO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%Position,1),UBOUND(u_out%TurbineComponents%Hub%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Hub%Position(i1) - u2%TurbineComponents%Hub%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Hub%Position(i1) + u3%TurbineComponents%Hub%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%Position(i1) + t(3)*u2%TurbineComponents%Hub%Position(i1) - t(2)*u3%TurbineComponents%Hub%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Hub%Position(i1) = u1%TurbineComponents%Hub%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Hub%Orientation,2),UBOUND(u_out%TurbineComponents%Hub%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Hub%Orientation,1),UBOUND(u_out%TurbineComponents%Hub%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Hub%Orientation(i1,i2) - u2%TurbineComponents%Hub%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Hub%Orientation(i1,i2) + u3%TurbineComponents%Hub%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Hub%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Hub%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Hub%Orientation(i1,i2) = u1%TurbineComponents%Hub%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%TranslationVel,1),UBOUND(u_out%TurbineComponents%Hub%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Hub%TranslationVel(i1) - u2%TurbineComponents%Hub%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Hub%TranslationVel(i1) + u3%TurbineComponents%Hub%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%TranslationVel(i1) + t(3)*u2%TurbineComponents%Hub%TranslationVel(i1) - t(2)*u3%TurbineComponents%Hub%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Hub%TranslationVel(i1) = u1%TurbineComponents%Hub%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Hub%RotationVel,1),UBOUND(u_out%TurbineComponents%Hub%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Hub%RotationVel(i1) - u2%TurbineComponents%Hub%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Hub%RotationVel(i1) + u3%TurbineComponents%Hub%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Hub%RotationVel(i1) + t(3)*u2%TurbineComponents%Hub%RotationVel(i1) - t(2)*u3%TurbineComponents%Hub%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Hub%RotationVel(i1) = u1%TurbineComponents%Hub%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Position,1),UBOUND(u_out%TurbineComponents%RotorFurl%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%RotorFurl%Position(i1) - u2%TurbineComponents%RotorFurl%Position(i1)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%Position(i1) + u3%TurbineComponents%RotorFurl%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%Position(i1) + t(3)*u2%TurbineComponents%RotorFurl%Position(i1) - t(2)*u3%TurbineComponents%RotorFurl%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%RotorFurl%Position(i1) = u1%TurbineComponents%RotorFurl%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1),UBOUND(u_out%TurbineComponents%RotorFurl%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%RotorFurl%Orientation(i1,i2) - u2%TurbineComponents%RotorFurl%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + u3%TurbineComponents%RotorFurl%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + t(3)*u2%TurbineComponents%RotorFurl%Orientation(i1,i2) - t(2)*u3%TurbineComponents%RotorFurl%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%RotorFurl%Orientation(i1,i2) = u1%TurbineComponents%RotorFurl%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%RotorFurl%TranslationVel(i1) - u2%TurbineComponents%RotorFurl%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%TranslationVel(i1) + u3%TurbineComponents%RotorFurl%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%TranslationVel(i1) + t(3)*u2%TurbineComponents%RotorFurl%TranslationVel(i1) - t(2)*u3%TurbineComponents%RotorFurl%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%RotorFurl%TranslationVel(i1) = u1%TurbineComponents%RotorFurl%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1),UBOUND(u_out%TurbineComponents%RotorFurl%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%RotorFurl%RotationVel(i1) - u2%TurbineComponents%RotorFurl%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%RotorFurl%RotationVel(i1) + u3%TurbineComponents%RotorFurl%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%RotorFurl%RotationVel(i1) + t(3)*u2%TurbineComponents%RotorFurl%RotationVel(i1) - t(2)*u3%TurbineComponents%RotorFurl%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%RotorFurl%RotationVel(i1) = u1%TurbineComponents%RotorFurl%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Position,1),UBOUND(u_out%TurbineComponents%Nacelle%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Nacelle%Position(i1) - u2%TurbineComponents%Nacelle%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Nacelle%Position(i1) + u3%TurbineComponents%Nacelle%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%Position(i1) + t(3)*u2%TurbineComponents%Nacelle%Position(i1) - t(2)*u3%TurbineComponents%Nacelle%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Nacelle%Position(i1) = u1%TurbineComponents%Nacelle%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,2),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%Orientation,1),UBOUND(u_out%TurbineComponents%Nacelle%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Nacelle%Orientation(i1,i2) - u2%TurbineComponents%Nacelle%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Nacelle%Orientation(i1,i2) + u3%TurbineComponents%Nacelle%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Nacelle%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Nacelle%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Nacelle%Orientation(i1,i2) = u1%TurbineComponents%Nacelle%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Nacelle%TranslationVel(i1) - u2%TurbineComponents%Nacelle%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Nacelle%TranslationVel(i1) + u3%TurbineComponents%Nacelle%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%TranslationVel(i1) + t(3)*u2%TurbineComponents%Nacelle%TranslationVel(i1) - t(2)*u3%TurbineComponents%Nacelle%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Nacelle%TranslationVel(i1) = u1%TurbineComponents%Nacelle%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1),UBOUND(u_out%TurbineComponents%Nacelle%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Nacelle%RotationVel(i1) - u2%TurbineComponents%Nacelle%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Nacelle%RotationVel(i1) + u3%TurbineComponents%Nacelle%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Nacelle%RotationVel(i1) + t(3)*u2%TurbineComponents%Nacelle%RotationVel(i1) - t(2)*u3%TurbineComponents%Nacelle%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Nacelle%RotationVel(i1) = u1%TurbineComponents%Nacelle%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Position,1),UBOUND(u_out%TurbineComponents%TailFin%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%TailFin%Position(i1) - u2%TurbineComponents%TailFin%Position(i1)) + t(2)**2*(-u1%TurbineComponents%TailFin%Position(i1) + u3%TurbineComponents%TailFin%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%Position(i1) + t(3)*u2%TurbineComponents%TailFin%Position(i1) - t(2)*u3%TurbineComponents%TailFin%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%TailFin%Position(i1) = u1%TurbineComponents%TailFin%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,2),UBOUND(u_out%TurbineComponents%TailFin%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%TailFin%Orientation,1),UBOUND(u_out%TurbineComponents%TailFin%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%TailFin%Orientation(i1,i2) - u2%TurbineComponents%TailFin%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%TailFin%Orientation(i1,i2) + u3%TurbineComponents%TailFin%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%Orientation(i1,i2) + t(3)*u2%TurbineComponents%TailFin%Orientation(i1,i2) - t(2)*u3%TurbineComponents%TailFin%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%TailFin%Orientation(i1,i2) = u1%TurbineComponents%TailFin%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1),UBOUND(u_out%TurbineComponents%TailFin%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%TailFin%TranslationVel(i1) - u2%TurbineComponents%TailFin%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%TailFin%TranslationVel(i1) + u3%TurbineComponents%TailFin%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%TranslationVel(i1) + t(3)*u2%TurbineComponents%TailFin%TranslationVel(i1) - t(2)*u3%TurbineComponents%TailFin%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%TailFin%TranslationVel(i1) = u1%TurbineComponents%TailFin%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%TailFin%RotationVel,1),UBOUND(u_out%TurbineComponents%TailFin%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%TailFin%RotationVel(i1) - u2%TurbineComponents%TailFin%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%TailFin%RotationVel(i1) + u3%TurbineComponents%TailFin%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%TailFin%RotationVel(i1) + t(3)*u2%TurbineComponents%TailFin%RotationVel(i1) - t(2)*u3%TurbineComponents%TailFin%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%TailFin%RotationVel(i1) = u1%TurbineComponents%TailFin%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%Position,1),UBOUND(u_out%TurbineComponents%Tower%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Tower%Position(i1) - u2%TurbineComponents%Tower%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Tower%Position(i1) + u3%TurbineComponents%Tower%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%Position(i1) + t(3)*u2%TurbineComponents%Tower%Position(i1) - t(2)*u3%TurbineComponents%Tower%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Tower%Position(i1) = u1%TurbineComponents%Tower%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Tower%Orientation,2),UBOUND(u_out%TurbineComponents%Tower%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Tower%Orientation,1),UBOUND(u_out%TurbineComponents%Tower%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Tower%Orientation(i1,i2) - u2%TurbineComponents%Tower%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Tower%Orientation(i1,i2) + u3%TurbineComponents%Tower%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Tower%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Tower%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Tower%Orientation(i1,i2) = u1%TurbineComponents%Tower%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%TranslationVel,1),UBOUND(u_out%TurbineComponents%Tower%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Tower%TranslationVel(i1) - u2%TurbineComponents%Tower%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Tower%TranslationVel(i1) + u3%TurbineComponents%Tower%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%TranslationVel(i1) + t(3)*u2%TurbineComponents%Tower%TranslationVel(i1) - t(2)*u3%TurbineComponents%Tower%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Tower%TranslationVel(i1) = u1%TurbineComponents%Tower%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Tower%RotationVel,1),UBOUND(u_out%TurbineComponents%Tower%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Tower%RotationVel(i1) - u2%TurbineComponents%Tower%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Tower%RotationVel(i1) + u3%TurbineComponents%Tower%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Tower%RotationVel(i1) + t(3)*u2%TurbineComponents%Tower%RotationVel(i1) - t(2)*u3%TurbineComponents%Tower%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Tower%RotationVel(i1) = u1%TurbineComponents%Tower%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Position,1),UBOUND(u_out%TurbineComponents%SubStructure%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%SubStructure%Position(i1) - u2%TurbineComponents%SubStructure%Position(i1)) + t(2)**2*(-u1%TurbineComponents%SubStructure%Position(i1) + u3%TurbineComponents%SubStructure%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%Position(i1) + t(3)*u2%TurbineComponents%SubStructure%Position(i1) - t(2)*u3%TurbineComponents%SubStructure%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%SubStructure%Position(i1) = u1%TurbineComponents%SubStructure%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,2),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%Orientation,1),UBOUND(u_out%TurbineComponents%SubStructure%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%SubStructure%Orientation(i1,i2) - u2%TurbineComponents%SubStructure%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%SubStructure%Orientation(i1,i2) + u3%TurbineComponents%SubStructure%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%Orientation(i1,i2) + t(3)*u2%TurbineComponents%SubStructure%Orientation(i1,i2) - t(2)*u3%TurbineComponents%SubStructure%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%SubStructure%Orientation(i1,i2) = u1%TurbineComponents%SubStructure%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%SubStructure%TranslationVel(i1) - u2%TurbineComponents%SubStructure%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%SubStructure%TranslationVel(i1) + u3%TurbineComponents%SubStructure%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%TranslationVel(i1) + t(3)*u2%TurbineComponents%SubStructure%TranslationVel(i1) - t(2)*u3%TurbineComponents%SubStructure%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%SubStructure%TranslationVel(i1) = u1%TurbineComponents%SubStructure%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1),UBOUND(u_out%TurbineComponents%SubStructure%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%SubStructure%RotationVel(i1) - u2%TurbineComponents%SubStructure%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%SubStructure%RotationVel(i1) + u3%TurbineComponents%SubStructure%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%SubStructure%RotationVel(i1) + t(3)*u2%TurbineComponents%SubStructure%RotationVel(i1) - t(2)*u3%TurbineComponents%SubStructure%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%SubStructure%RotationVel(i1) = u1%TurbineComponents%SubStructure%RotationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Position,1),UBOUND(u_out%TurbineComponents%Foundation%Position,1)
    b = (t(3)**2*(u1%TurbineComponents%Foundation%Position(i1) - u2%TurbineComponents%Foundation%Position(i1)) + t(2)**2*(-u1%TurbineComponents%Foundation%Position(i1) + u3%TurbineComponents%Foundation%Position(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%Position(i1) + t(3)*u2%TurbineComponents%Foundation%Position(i1) - t(2)*u3%TurbineComponents%Foundation%Position(i1) ) * scaleFactor
    u_out%TurbineComponents%Foundation%Position(i1) = u1%TurbineComponents%Foundation%Position(i1) + b  + c * t_out
  END DO
  DO i2 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,2),UBOUND(u_out%TurbineComponents%Foundation%Orientation,2)
    DO i1 = LBOUND(u_out%TurbineComponents%Foundation%Orientation,1),UBOUND(u_out%TurbineComponents%Foundation%Orientation,1)
      b = (t(3)**2*(u1%TurbineComponents%Foundation%Orientation(i1,i2) - u2%TurbineComponents%Foundation%Orientation(i1,i2)) + t(2)**2*(-u1%TurbineComponents%Foundation%Orientation(i1,i2) + u3%TurbineComponents%Foundation%Orientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%Orientation(i1,i2) + t(3)*u2%TurbineComponents%Foundation%Orientation(i1,i2) - t(2)*u3%TurbineComponents%Foundation%Orientation(i1,i2) ) * scaleFactor
      u_out%TurbineComponents%Foundation%Orientation(i1,i2) = u1%TurbineComponents%Foundation%Orientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1),UBOUND(u_out%TurbineComponents%Foundation%TranslationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Foundation%TranslationVel(i1) - u2%TurbineComponents%Foundation%TranslationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Foundation%TranslationVel(i1) + u3%TurbineComponents%Foundation%TranslationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%TranslationVel(i1) + t(3)*u2%TurbineComponents%Foundation%TranslationVel(i1) - t(2)*u3%TurbineComponents%Foundation%TranslationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Foundation%TranslationVel(i1) = u1%TurbineComponents%Foundation%TranslationVel(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%TurbineComponents%Foundation%RotationVel,1),UBOUND(u_out%TurbineComponents%Foundation%RotationVel,1)
    b = (t(3)**2*(u1%TurbineComponents%Foundation%RotationVel(i1) - u2%TurbineComponents%Foundation%RotationVel(i1)) + t(2)**2*(-u1%TurbineComponents%Foundation%RotationVel(i1) + u3%TurbineComponents%Foundation%RotationVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%TurbineComponents%Foundation%RotationVel(i1) + t(3)*u2%TurbineComponents%Foundation%RotationVel(i1) - t(2)*u3%TurbineComponents%Foundation%RotationVel(i1) ) * scaleFactor
    u_out%TurbineComponents%Foundation%RotationVel(i1) = u1%TurbineComponents%Foundation%RotationVel(i1) + b  + c * t_out
  END DO
  b = (t(3)**2*(u1%TurbineComponents%BladeLength - u2%TurbineComponents%BladeLength) + t(2)**2*(-u1%TurbineComponents%BladeLength + u3%TurbineComponents%BladeLength))* scaleFactor
  c = ( (t(2)-t(3))*u1%TurbineComponents%BladeLength + t(3)*u2%TurbineComponents%BladeLength - t(2)*u3%TurbineComponents%BladeLength ) * scaleFactor
  u_out%TurbineComponents%BladeLength = u1%TurbineComponents%BladeLength + b  + c * t_out
IF (ALLOCATED(u_out%MulTabLoc) .AND. ALLOCATED(u1%MulTabLoc)) THEN
  DO i2 = LBOUND(u_out%MulTabLoc,2),UBOUND(u_out%MulTabLoc,2)
    DO i1 = LBOUND(u_out%MulTabLoc,1),UBOUND(u_out%MulTabLoc,1)
      b = (t(3)**2*(u1%MulTabLoc(i1,i2) - u2%MulTabLoc(i1,i2)) + t(2)**2*(-u1%MulTabLoc(i1,i2) + u3%MulTabLoc(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%MulTabLoc(i1,i2) + t(3)*u2%MulTabLoc(i1,i2) - t(2)*u3%MulTabLoc(i1,i2) ) * scaleFactor
      u_out%MulTabLoc(i1,i2) = u1%MulTabLoc(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowVelocity) .AND. ALLOCATED(u1%InflowVelocity)) THEN
  DO i2 = LBOUND(u_out%InflowVelocity,2),UBOUND(u_out%InflowVelocity,2)
    DO i1 = LBOUND(u_out%InflowVelocity,1),UBOUND(u_out%InflowVelocity,1)
      b = (t(3)**2*(u1%InflowVelocity(i1,i2) - u2%InflowVelocity(i1,i2)) + t(2)**2*(-u1%InflowVelocity(i1,i2) + u3%InflowVelocity(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%InflowVelocity(i1,i2) + t(3)*u2%InflowVelocity(i1,i2) - t(2)*u3%InflowVelocity(i1,i2) ) * scaleFactor
      u_out%InflowVelocity(i1,i2) = u1%InflowVelocity(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  DO i1 = LBOUND(u_out%AvgInfVel,1),UBOUND(u_out%AvgInfVel,1)
    b = (t(3)**2*(u1%AvgInfVel(i1) - u2%AvgInfVel(i1)) + t(2)**2*(-u1%AvgInfVel(i1) + u3%AvgInfVel(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%AvgInfVel(i1) + t(3)*u2%AvgInfVel(i1) - t(2)*u3%AvgInfVel(i1) ) * scaleFactor
    u_out%AvgInfVel(i1) = u1%AvgInfVel(i1) + b  + c * t_out
  END DO
 END SUBROUTINE AD14_Input_ExtrapInterp2


 SUBROUTINE AD14_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD14_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD14_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD14_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD14_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD14_Output_ExtrapInterp


 SUBROUTINE AD14_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD14_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
  DO i1 = LBOUND(y_out%OutputLoads,1),UBOUND(y_out%OutputLoads,1)
      CALL MeshExtrapInterp1(y1%OutputLoads(i1), y2%OutputLoads(i1), tin, y_out%OutputLoads(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp1(y1%Twr_OutputLoads, y2%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE AD14_Output_ExtrapInterp1


 SUBROUTINE AD14_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(AD14_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(AD14_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD14_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%OutputLoads) .AND. ALLOCATED(y1%OutputLoads)) THEN
  DO i1 = LBOUND(y_out%OutputLoads,1),UBOUND(y_out%OutputLoads,1)
      CALL MeshExtrapInterp2(y1%OutputLoads(i1), y2%OutputLoads(i1), y3%OutputLoads(i1), tin, y_out%OutputLoads(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL MeshExtrapInterp2(y1%Twr_OutputLoads, y2%Twr_OutputLoads, y3%Twr_OutputLoads, tin, y_out%Twr_OutputLoads, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE AD14_Output_ExtrapInterp2

END MODULE AeroDyn14_Types
!ENDOFREGISTRYGENERATEDFILE
