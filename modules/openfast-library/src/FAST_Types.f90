!STARTOFREGISTRYGENERATEDFILE 'FAST_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FAST_Types
!.................................................................................................................................
! This file is part of FAST.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FAST. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FAST_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE ElastoDyn_Types
USE BeamDyn_Types
USE ServoDyn_Types
USE AeroDyn14_Types
USE AeroDyn_Types
USE SubDyn_Types
USE SeaState_Types
USE HydroDyn_Types
USE IceFloe_Types
USE OpenFOAM_Types
USE SCDataEx_Types
USE IceDyn_Types
USE FEAMooring_Types
USE MAP_Types
USE MoorDyn_Types
USE OrcaFlexInterface_Types
USE ExtPtfm_MCKF_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_Unknown = -1      ! Unknown [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_None = 0      ! No module selected [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_Glue = 1      ! Glue code [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_IfW = 2      ! InflowWind [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_OpFM = 3      ! OpenFOAM [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ED = 4      ! ElastoDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_BD = 5      ! BeamDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_AD14 = 6      ! AeroDyn14 [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_AD = 7      ! AeroDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SrvD = 8      ! ServoDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SeaSt = 9      ! SeaState [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_HD = 10      ! HydroDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_SD = 11      ! SubDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_ExtPtfm = 12      ! External Platform Loading MCKF [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_MAP = 13      ! MAP (Mooring Analysis Program) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_FEAM = 14      ! FEAMooring [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_MD = 15      ! MoorDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_Orca = 16      ! OrcaFlex integration (HD/Mooring) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_IceF = 17      ! IceFloe [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Module_IceD = 18      ! IceDyn [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: NumModules = 18      ! The number of modules available in FAST [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxNBlades = 3      ! Maximum number of blades allowed on a turbine [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: IceD_MaxLegs = 4      ! because I don't know how many legs there are before calling IceD_Init and I don't want to copy the data because of sibling mesh issues, I'm going to allocate IceD based on this number [-]
! =========  FAST_VTK_BLSurfaceType  =======
  TYPE, PUBLIC :: FAST_VTK_BLSurfaceType
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AirfoilCoords      !< x,y coordinates for airfoil around each blade node on a blade (relative to reference) [-]
  END TYPE FAST_VTK_BLSurfaceType
! =======================
! =========  FAST_VTK_SurfaceType  =======
  TYPE, PUBLIC :: FAST_VTK_SurfaceType
    INTEGER(IntKi)  :: NumSectors      !< number of sectors in which to split circles (higher number gives smoother surface) [-]
    REAL(SiKi)  :: HubRad      !< Preconed hub radius (distance from the rotor apex to the blade root) [m]
    REAL(SiKi)  :: GroundRad      !< radius for plotting circle on ground [m]
    REAL(SiKi) , DIMENSION(1:3,1:8)  :: NacelleBox      !< X-Y-Z locations of 8 points that define the nacelle box, relative to the nacelle position [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: TowerRad      !< radius of each ED tower node [m]
    INTEGER(IntKi) , DIMENSION(1:2)  :: NWaveElevPts      !< number of points for wave elevation visualization [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElevXY      !< X-Y locations for WaveElev output (for visualization).  First dimension is the X (1) and Y (2) coordinate.  Second dimension is the point number. [m,-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElev      !< wave elevation at WaveElevXY; first dimension is time step; second dimension is point number [m,-]
    TYPE(FAST_VTK_BLSurfaceType) , DIMENSION(:), ALLOCATABLE  :: BladeShape      !< AirfoilCoords for each blade [m]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: MorisonRad      !< radius of each Morison node [m]
  END TYPE FAST_VTK_SurfaceType
! =======================
! =========  FAST_VTK_ModeShapeType  =======
  TYPE, PUBLIC :: FAST_VTK_ModeShapeType
    CHARACTER(1024)  :: CheckpointRoot      !< name of the checkpoint file written by FAST when linearization data was produced [-]
    CHARACTER(1024)  :: MatlabFileName      !< name of the file with eigenvectors written by Matlab [-]
    INTEGER(IntKi)  :: VTKLinModes      !< Number of modes to visualize [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: VTKModes      !< Which modes to visualize [-]
    INTEGER(IntKi)  :: VTKLinTim      !< Switch to make one animation for all LinTimes together (1) or separate animations for each LinTimes(2) [-]
    INTEGER(IntKi)  :: VTKNLinTimes      !< number of linearization times to use when VTKLinTim==2 [-]
    REAL(ReKi)  :: VTKLinScale      !< Mode shape visualization scaling factor [-]
    REAL(ReKi)  :: VTKLinPhase      !< Phase when making one animation for all LinTimes together (used only when VTKLinTim=1) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: DampingRatio      !< damping ratios from mbc3 analysis [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: NaturalFreq_Hz      !< natural frequency from mbc3 analysis [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: DampedFreq_Hz      !< damped frequency from mbc3 analysis [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: x_eig_magnitude      !< magnitude of eigenvector (dimension 1=state, dim 2= azimuth, dim 3 = mode) [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: x_eig_phase      !< phase of eigenvector (dimension 1=state, dim 2= azimuth, dim 3 = mode) [-]
  END TYPE FAST_VTK_ModeShapeType
! =======================
! =========  FAST_ParameterType  =======
  TYPE, PUBLIC :: FAST_ParameterType
    REAL(DbKi)  :: DT      !< Integration time step [global time] [s]
    REAL(DbKi) , DIMENSION(1:NumModules)  :: DT_module      !< Integration time step [global time] [s]
    INTEGER(IntKi) , DIMENSION(1:NumModules)  :: n_substeps      !< The number of module substeps for advancing states from t_global to t_global_next [-]
    INTEGER(IntKi)  :: n_TMax_m1      !< The time step of TMax - dt (the end time of the simulation) [(-)]
    REAL(DbKi)  :: TMax      !< Total run time [s]
    INTEGER(IntKi)  :: InterpOrder      !< Interpolation order {0,1,2} [-]
    INTEGER(IntKi)  :: NumCrctn      !< Number of correction iterations [-]
    INTEGER(IntKi)  :: KMax      !< Maximum number of input-output-solve iterations (KMax >= 1) [-]
    INTEGER(IntKi)  :: numIceLegs      !< number of suport-structure legs in contact with ice (IceDyn coupling) [-]
    INTEGER(IntKi)  :: nBeams      !< number of BeamDyn instances [-]
    LOGICAL  :: BD_OutputSibling      !< flag to determine if BD input is sibling of output mesh [-]
    LOGICAL , DIMENSION(1:NumModules)  :: ModuleInitialized      !< An array determining if the module has been initialized [-]
    REAL(DbKi)  :: DT_Ujac      !< Time between when we need to re-calculate these Jacobians [s]
    REAL(ReKi)  :: UJacSclFact      !< Scaling factor used to get similar magnitudes between accelerations, forces, and moments in Jacobians [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: SizeJac_Opt1      !< (1)=size of matrix; (2)=size of ED portion; (3)=size of SD portion [2 meshes]; (4)=size of HD portion; (5)=size of BD portion blade 1; (6)=size of BD portion blade 2; (7)=size of BD portion blade 3; (8)=size of Orca portion; (9)=size of ExtPtfm portion; [-]
    INTEGER(IntKi)  :: SolveOption      !< Switch to determine which solve option we are going to use (see Solve_FullOpt1, etc) [-]
    INTEGER(IntKi)  :: CompElast      !< Compute blade loads (switch) {Module_ED; Module_BD} [-]
    INTEGER(IntKi)  :: CompInflow      !< Compute inflow wind conditions (switch) {Module_None; Module_IfW; Module_OpFM} [-]
    INTEGER(IntKi)  :: CompAero      !< Compute aerodynamic loads (switch) {Module_None; Module_AD14; Module_AD} [-]
    INTEGER(IntKi)  :: CompServo      !< Compute control and electrical-drive dynamics (switch) {Module_None; Module_SrvD} [-]
    INTEGER(IntKi)  :: CompSeaSt      !< Compute sea states; wave kinematics (switch) {Module_None; Module_SeaSt} [-]
    INTEGER(IntKi)  :: CompHydro      !< Compute hydrodynamic loads (switch) {Module_None; Module_HD} [-]
    INTEGER(IntKi)  :: CompSub      !< Compute sub-structural dynamics (switch) {Module_None; Module_HD} [-]
    INTEGER(IntKi)  :: CompMooring      !< Compute mooring system (switch) {Module_None; Module_MAP; Module_FEAM; Module_MD; Module_Orca} [-]
    INTEGER(IntKi)  :: CompIce      !< Compute ice loading (switch) {Module_None; Module_IceF, Module_IceD} [-]
    INTEGER(IntKi)  :: MHK      !< MHK turbine type (switch) {0=Not an MHK turbine; 1=Fixed MHK turbine; 2=Floating MHK turbine} [-]
    LOGICAL  :: UseDWM      !< Use the DWM module in AeroDyn [-]
    LOGICAL  :: Linearize      !< Linearization analysis (flag) [-]
    INTEGER(IntKi)  :: WaveFieldMod      !< Wave field handling (-) (switch) 0: use individual HydroDyn inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    LOGICAL  :: FarmIntegration = .false.      !< whether this is called from FAST.Farm (or another program that doesn't want FAST to call all of the init stuff first) [-]
    REAL(SiKi) , DIMENSION(1:3)  :: TurbinePos      !< Initial position of turbine base (origin used for graphics) [m]
    REAL(ReKi)  :: Gravity      !< Gravitational acceleration [m/s^2]
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: WtrDens      !< Water density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic viscosity of working fluid [m^2/s]
    REAL(ReKi)  :: SpdSound      !< Speed of sound in working fluid [m/s]
    REAL(ReKi)  :: Patm      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap      !< Vapour pressure of working fluid [Pa]
    REAL(ReKi)  :: WtrDpth      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL      !< Offset between still-water level and mean sea level [m]
    CHARACTER(1024)  :: EDFile      !< The name of the ElastoDyn input file [-]
    CHARACTER(1024) , DIMENSION(1:MaxNBlades)  :: BDBldFile      !< Name of files containing BeamDyn inputs for each blade [-]
    CHARACTER(1024)  :: InflowFile      !< Name of file containing inflow wind input parameters [-]
    CHARACTER(1024)  :: AeroFile      !< Name of file containing aerodynamic input parameters [-]
    CHARACTER(1024)  :: ServoFile      !< Name of file containing control and electrical-drive input parameters [-]
    CHARACTER(1024)  :: SeaStFile      !< Name of file containing sea state input parameters [-]
    CHARACTER(1024)  :: HydroFile      !< Name of file containing hydrodynamic input parameters [-]
    CHARACTER(1024)  :: SubFile      !< Name of file containing sub-structural input parameters [-]
    CHARACTER(1024)  :: MooringFile      !< Name of file containing mooring system input parameters [-]
    CHARACTER(1024)  :: IceFile      !< Name of file containing ice loading input parameters [-]
    REAL(DbKi)  :: TStart      !< Time to begin tabular output [s]
    REAL(DbKi)  :: DT_Out      !< Time step for tabular output [s]
    LOGICAL  :: WrSttsTime      !< Whether we should write the status times to the screen [-]
    INTEGER(IntKi)  :: n_SttsTime      !< Number of time steps between screen status messages [-]
    INTEGER(IntKi)  :: n_ChkptTime      !< Number of time steps between writing checkpoint files [-]
    INTEGER(IntKi)  :: n_DT_Out      !< Number of time steps between writing a line in the time-marching output files [-]
    INTEGER(IntKi)  :: n_VTKTime      !< Number of time steps between writing VTK files [-]
    INTEGER(IntKi)  :: TurbineType      !< Type_LandBased, Type_Offshore_Fixed, Type_Offshore_Floating, Type_MHK_Fixed, or Type_MHK_Floating [-]
    LOGICAL  :: WrBinOutFile      !< Write a binary output file? (.outb) [-]
    LOGICAL  :: WrTxtOutFile      !< Write a text (formatted) output file? (.out) [-]
    INTEGER(IntKi)  :: WrBinMod      !< If writing binary, which file format is to be written [1, 2, or 3] [-]
    LOGICAL  :: SumPrint      !< Print summary data to file? (.sum) [-]
    INTEGER(IntKi)  :: WrVTK = 0      !< VTK Visualization data output: (switch) {0=none; 1=initialization data only; 2=animation} [-]
    INTEGER(IntKi)  :: VTK_Type      !< Type of  VTK visualization data: (switch) {1=surfaces; 2=basic meshes (lines/points); 3=all meshes (debug)} [-]
    LOGICAL  :: VTK_fields      !< Write mesh fields to VTK data files? (flag) {true/false} [-]
    CHARACTER(1)  :: Delim      !< Delimiter between columns of text output file (.out): space or tab [-]
    CHARACTER(20)  :: OutFmt      !< Format used for text tabular output (except time); resulting field should be 10 characters [-]
    CHARACTER(20)  :: OutFmt_t      !< Format used for time channel in text tabular output; resulting field should be 10 characters [-]
    INTEGER(IntKi)  :: FmtWidth      !< width of the time OutFmt specifier [-]
    INTEGER(IntKi)  :: TChanLen      !< width of the time channel [-]
    CHARACTER(1024)  :: OutFileRoot      !< The rootname of the output files [-]
    CHARACTER(1024)  :: FTitle      !< The description line from the FAST (glue-code) input file [-]
    CHARACTER(1024)  :: VTK_OutFileRoot = ''      !< The rootname of the VTK output files [-]
    INTEGER(IntKi)  :: VTK_tWidth      !< Width of number of files for leading zeros in file name format [-]
    REAL(DbKi)  :: VTK_fps      !< number of frames per second to output VTK data [-]
    TYPE(FAST_VTK_SurfaceType)  :: VTK_surface      !< Data for VTK surface visualization [-]
    CHARACTER(4)  :: Tdesc      !< description of turbine ID (for FAST.Farm) screen printing [-]
    LOGICAL  :: CalcSteady      !< Calculate a steady-state periodic operating point before linearization [unused if Linearize=False] [-]
    INTEGER(IntKi)  :: TrimCase      !< Controller parameter to be trimmed {1:yaw; 2:torque; 3:pitch} [unused if Linearize=False; used only if CalcSteady=True] [-]
    REAL(ReKi)  :: TrimTol      !< Tolerance for the rotational speed convergence (>0) [unused if Linearize=False; used only if CalcSteady=True] [-]
    REAL(ReKi)  :: TrimGain      !< Proportional gain for the rotational speed error (>0) [unused if Linearize=False; used only if CalcSteady=True] [rad/(rad/s) for yaw or pitch; Nm/(rad/s) for torque]
    REAL(ReKi)  :: Twr_Kdmp      !< Damping factor for the tower [unused if Linearize=False; used only if CalcSteady=True] [N/(m/s)]
    REAL(ReKi)  :: Bld_Kdmp      !< Damping factor for the blades [unused if Linearize=False; used only if CalcSteady=True] [N/(m/s)]
    INTEGER(IntKi)  :: NLinTimes      !< Number of LinTimes, or equally-spaced azimuth steps in periodic linearized model (>0)[unused if Linearize=False] [-]
    REAL(DbKi)  :: AzimDelta      !< difference between two consecutive azimuth positions in CalcSteady algorithm [rad]
    INTEGER(IntKi)  :: LinInputs      !< Inputs included in linearization (switch) {0=none; 1=standard; 2=all module inputs (debug)} [unused if Linearize=False] [-]
    INTEGER(IntKi)  :: LinOutputs      !< Outputs included in linearization (switch) {0=none; 1=from OutList(s); 2=all module outputs (debug)} [unused if Linearize=False] [-]
    LOGICAL  :: LinOutJac      !< Include full Jacabians in linearization output (for debug) (flag) [unused if Linearize=False; used only if LinInputs=LinOutputs=2] [-]
    LOGICAL  :: LinOutMod      !< Write module-level linearization output files in addition to output for full system? (flag) [unused if Linearize=False] [-]
    TYPE(FAST_VTK_ModeShapeType)  :: VTK_modes      !< Data for VTK mode-shape visualization [-]
    LOGICAL  :: UseSC      !< Use Supercontroller [-]
    INTEGER(IntKi)  :: Lin_NumMods      !< number of modules in the linearization [-]
    INTEGER(IntKi) , DIMENSION(1:NumModules)  :: Lin_ModOrder      !< indices that determine which order the modules are in the glue-code linearization matrix [-]
    INTEGER(IntKi)  :: LinInterpOrder      !< Interpolation order for CalcSteady solution [-]
  END TYPE FAST_ParameterType
! =======================
! =========  FAST_LinStateSave  =======
  TYPE, PUBLIC :: FAST_LinStateSave
    TYPE(IceD_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x_IceD      !< Continuous states [-]
    TYPE(IceD_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd_IceD      !< Discrete states [-]
    TYPE(IceD_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z_IceD      !< Constraint states [-]
    TYPE(IceD_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt_IceD      !< Other states [-]
    TYPE(IceD_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_IceD      !< System inputs [-]
    TYPE(BD_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x_BD      !< Continuous states [-]
    TYPE(BD_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd_BD      !< Discrete states [-]
    TYPE(BD_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z_BD      !< Constraint states [-]
    TYPE(BD_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt_BD      !< Other states [-]
    TYPE(BD_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_BD      !< System inputs [-]
    TYPE(ED_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_ED      !< Continuous states [-]
    TYPE(ED_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_ED      !< Discrete states [-]
    TYPE(ED_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_ED      !< Constraint states [-]
    TYPE(ED_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_ED      !< Other states [-]
    TYPE(ED_InputType) , DIMENSION(:), ALLOCATABLE  :: u_ED      !< System inputs [-]
    TYPE(SrvD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_SrvD      !< Continuous states [-]
    TYPE(SrvD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_SrvD      !< Discrete states [-]
    TYPE(SrvD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_SrvD      !< Constraint states [-]
    TYPE(SrvD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_SrvD      !< Other states [-]
    TYPE(SrvD_InputType) , DIMENSION(:), ALLOCATABLE  :: u_SrvD      !< System inputs [-]
    TYPE(AD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_AD      !< Continuous states [-]
    TYPE(AD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_AD      !< Discrete states [-]
    TYPE(AD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_AD      !< Constraint states [-]
    TYPE(AD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_AD      !< Other states [-]
    TYPE(AD_InputType) , DIMENSION(:), ALLOCATABLE  :: u_AD      !< System inputs [-]
    TYPE(InflowWind_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_IfW      !< Continuous states [-]
    TYPE(InflowWind_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_IfW      !< Discrete states [-]
    TYPE(InflowWind_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_IfW      !< Constraint states [-]
    TYPE(InflowWind_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_IfW      !< Other states [-]
    TYPE(InflowWind_InputType) , DIMENSION(:), ALLOCATABLE  :: u_IfW      !< System inputs [-]
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_SD      !< Continuous states [-]
    TYPE(SD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_SD      !< Discrete states [-]
    TYPE(SD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_SD      !< Constraint states [-]
    TYPE(SD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_SD      !< Other states [-]
    TYPE(SD_InputType) , DIMENSION(:), ALLOCATABLE  :: u_SD      !< System inputs [-]
    TYPE(ExtPtfm_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_ExtPtfm      !< Continuous states [-]
    TYPE(ExtPtfm_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_ExtPtfm      !< Discrete states [-]
    TYPE(ExtPtfm_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_ExtPtfm      !< Constraint states [-]
    TYPE(ExtPtfm_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_ExtPtfm      !< Other states [-]
    TYPE(ExtPtfm_InputType) , DIMENSION(:), ALLOCATABLE  :: u_ExtPtfm      !< System inputs [-]
    TYPE(HydroDyn_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_HD      !< Continuous states [-]
    TYPE(HydroDyn_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_HD      !< Discrete states [-]
    TYPE(HydroDyn_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_HD      !< Constraint states [-]
    TYPE(HydroDyn_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_HD      !< Other states [-]
    TYPE(HydroDyn_InputType) , DIMENSION(:), ALLOCATABLE  :: u_HD      !< System inputs [-]
    TYPE(IceFloe_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_IceF      !< Continuous states [-]
    TYPE(IceFloe_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_IceF      !< Discrete states [-]
    TYPE(IceFloe_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_IceF      !< Constraint states [-]
    TYPE(IceFloe_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_IceF      !< Other states [-]
    TYPE(IceFloe_InputType) , DIMENSION(:), ALLOCATABLE  :: u_IceF      !< System inputs [-]
    TYPE(MAP_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_MAP      !< Continuous states [-]
    TYPE(MAP_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_MAP      !< Discrete states [-]
    TYPE(MAP_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_MAP      !< Constraint states [-]
    TYPE(MAP_InputType) , DIMENSION(:), ALLOCATABLE  :: u_MAP      !< System inputs [-]
    TYPE(FEAM_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_FEAM      !< Continuous states [-]
    TYPE(FEAM_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_FEAM      !< Discrete states [-]
    TYPE(FEAM_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_FEAM      !< Constraint states [-]
    TYPE(FEAM_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_FEAM      !< Other states [-]
    TYPE(FEAM_InputType) , DIMENSION(:), ALLOCATABLE  :: u_FEAM      !< System inputs [-]
    TYPE(MD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: x_MD      !< Continuous states [-]
    TYPE(MD_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: xd_MD      !< Discrete states [-]
    TYPE(MD_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: z_MD      !< Constraint states [-]
    TYPE(MD_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: OtherSt_MD      !< Other states [-]
    TYPE(MD_InputType) , DIMENSION(:), ALLOCATABLE  :: u_MD      !< System inputs [-]
  END TYPE FAST_LinStateSave
! =======================
! =========  FAST_LinType  =======
  TYPE, PUBLIC :: FAST_LinType
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: Names_u      !< Names of the linearized inputs [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: Names_y      !< Names of the linearized outputs [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: Names_x      !< Names of the linearized continuous states [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: Names_xd      !< Names of the linearized discrete states [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: Names_z      !< Names of the linearized constraint states [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: op_u      !< input operating point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: op_y      !< output operating point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: op_x      !< continuous state operating point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: op_dx      !< 1st time derivative of continuous state operating point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: op_xd      !< discrete state operating point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: op_z      !< constraint state operating point [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: op_x_eig_mag      !< continuous state eigenvector magnitude [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: op_x_eig_phase      !< continuous state eigenvector phase [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: Use_u      !< array same size as names_u, which indicates if this input is used in linearization output file [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: Use_y      !< array same size as names_y, which indicates if this output is used in linearization output file [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: A      !< A matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: B      !< B matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: C      !< C matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: D      !< D matrix [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRotation      !< Matrix that rotates the continuous states [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRel_x      !< Matrix that defines the continuous states relative to root motion [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: StateRel_xdot      !< Matrix that defines the continuous states relative to root motion [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Whether the input is a load (used for scaling for potentially ill-conditioned G matrix) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Whether corresponding input is in rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Whether corresponding output is in rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Whether corresponding continuous state is in rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_z      !< Whether corresponding constraint state is in rotating frame [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Derivative order for continuous states [-]
    INTEGER(IntKi) , DIMENSION(1:3)  :: SizeLin      !< sizes of (1) the module's inputs,  (2) the module's linearized outputs, and (3) the module's continuous states [-]
    INTEGER(IntKi) , DIMENSION(1:3)  :: LinStartIndx      !< the starting index in combined matrices of (1) the module's inputs, (2) the module's linearized outputs, and (3) the module's continuous states [-]
    INTEGER(IntKi)  :: NumOutputs      !< number of WriteOutputs in each linearized module [-]
  END TYPE FAST_LinType
! =======================
! =========  FAST_ModLinType  =======
  TYPE, PUBLIC :: FAST_ModLinType
    TYPE(FAST_LinType) , DIMENSION(:), ALLOCATABLE  :: Instance      !< Linearization data for each module instance (e.g., 3 blades for BD) [-]
  END TYPE FAST_ModLinType
! =======================
! =========  FAST_LinFileType  =======
  TYPE, PUBLIC :: FAST_LinFileType
    TYPE(FAST_ModLinType) , DIMENSION(1:NumModules)  :: Modules      !< Linearization data for each module [-]
    TYPE(FAST_LinType)  :: Glue      !< Linearization data for the glue code (coupled system) [-]
    REAL(ReKi)  :: RotSpeed      !< Rotor azimuth angular speed [rad/s]
    REAL(ReKi)  :: Azimuth      !< Rotor azimuth position [rad]
    REAL(ReKi)  :: WindSpeed      !< Wind speed at reference height [m/s]
  END TYPE FAST_LinFileType
! =======================
! =========  FAST_MiscLinType  =======
  TYPE, PUBLIC :: FAST_MiscLinType
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: LinTimes      !< List of times at which to linearize [s]
    INTEGER(IntKi)  :: CopyOP_CtrlCode      !< mesh control code for copy type (new on first call; update otherwise) [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: AzimTarget      !< target azimuth positions in CalcSteady algorithm [rad]
    LOGICAL  :: IsConverged      !< whether the error calculation in the CalcSteady algorithm is converged [-]
    LOGICAL  :: FoundSteady      !< whether the CalcSteady algorithm found a steady-state solution [-]
    LOGICAL  :: ForceLin      !< whether the CalcSteady algorithm found a steady-state solution [-]
    INTEGER(IntKi)  :: n_rot      !< number of rotations completed in CalcSteady algorithm [-]
    INTEGER(IntKi)  :: AzimIndx      !< index into target azimuth array in CalcSteady algorithm [-]
    INTEGER(IntKi)  :: NextLinTimeIndx      !< index for next time in LinTimes where linearization should occur [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Psi      !< Azimuth angle at the current and previous time steps (uses LinInterpOrder); DbKi so that we can use registry-generated extrap/interp routines [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y_interp      !< Interpolated outputs packed into an array [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y_ref      !< Reference output range for CalcSteady error calculation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Y_prevRot      !< Linearization outputs from previous rotor revolution at each target azimuth  [-]
  END TYPE FAST_MiscLinType
! =======================
! =========  FAST_OutputFileType  =======
  TYPE, PUBLIC :: FAST_OutputFileType
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: TimeData      !< Array to contain the time output data for the binary file (first output time and a time [fixed] increment) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AllOutData      !< Array to contain all the output data (time history of all outputs); Index 1 is NumOuts, Index 2 is Time step [-]
    INTEGER(IntKi)  :: n_Out      !< Time index into the AllOutData array [-]
    INTEGER(IntKi)  :: NOutSteps      !< Maximum number of output steps [-]
    INTEGER(IntKi) , DIMENSION(1:NumModules)  :: numOuts      !< number of outputs to print from each module [-]
    INTEGER(IntKi)  :: UnOu = -1      !< I/O unit number for the tabular output file [-]
    INTEGER(IntKi)  :: UnSum = -1      !< I/O unit number for the summary file [-]
    INTEGER(IntKi)  :: UnGra = -1      !< I/O unit number for mesh graphics [-]
    CHARACTER(1024) , DIMENSION(1:3)  :: FileDescLines      !< Description lines to include in output files (header, time run, plus module names/versions) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChannelNames      !< Names of the output channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChannelUnits      !< Units for the output channels [-]
    TYPE(ProgDesc) , DIMENSION(1:NumModules)  :: Module_Ver      !< version information from all modules [-]
    CHARACTER(ChanLen) , DIMENSION(1:NumModules)  :: Module_Abrev      !< abbreviation for module (used in file output naming conventions) [-]
    LOGICAL  :: WriteThisStep      !< Whether this step will be written in the FAST output files [-]
    INTEGER(IntKi)  :: VTK_count      !< Number of VTK files written (for naming output files) [-]
    INTEGER(IntKi)  :: VTK_LastWaveIndx      !< last index into wave array [-]
    TYPE(FAST_LinFileType)  :: Lin      !< linearization data for output [-]
    INTEGER(IntKi)  :: ActualChanLen      !< width of the column headers output in the text and/or binary file [-]
    TYPE(FAST_LinStateSave)  :: op      !< operating points of states and inputs for VTK output of mode shapes [-]
    REAL(ReKi) , DIMENSION(1:5)  :: DriverWriteOutput      !< pitch and tsr for current aero map case, plus error, number of iterations, wind speed [-]
  END TYPE FAST_OutputFileType
! =======================
! =========  IceDyn_Data  =======
  TYPE, PUBLIC :: IceDyn_Data
    TYPE(IceD_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(IceD_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(IceD_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(IceD_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(IceD_ParameterType) , DIMENSION(:), ALLOCATABLE  :: p      !< Parameters [-]
    TYPE(IceD_InputType) , DIMENSION(:), ALLOCATABLE  :: u      !< System inputs [-]
    TYPE(IceD_OutputType) , DIMENSION(:), ALLOCATABLE  :: y      !< System outputs [-]
    TYPE(IceD_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: m      !< Misc/optimization variables [-]
    TYPE(IceD_InputType) , DIMENSION(:,:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE IceDyn_Data
! =======================
! =========  BeamDyn_Data  =======
  TYPE, PUBLIC :: BeamDyn_Data
    TYPE(BD_ContinuousStateType) , DIMENSION(:,:), ALLOCATABLE  :: x      !< Continuous states [-]
    TYPE(BD_DiscreteStateType) , DIMENSION(:,:), ALLOCATABLE  :: xd      !< Discrete states [-]
    TYPE(BD_ConstraintStateType) , DIMENSION(:,:), ALLOCATABLE  :: z      !< Constraint states [-]
    TYPE(BD_OtherStateType) , DIMENSION(:,:), ALLOCATABLE  :: OtherSt      !< Other states [-]
    TYPE(BD_ParameterType) , DIMENSION(:), ALLOCATABLE  :: p      !< Parameters [-]
    TYPE(BD_InputType) , DIMENSION(:), ALLOCATABLE  :: u      !< System inputs [-]
    TYPE(BD_OutputType) , DIMENSION(:), ALLOCATABLE  :: y      !< System outputs [-]
    TYPE(BD_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: m      !< Misc/optimization variables [-]
    TYPE(BD_OutputType) , DIMENSION(:,:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(BD_OutputType) , DIMENSION(:), ALLOCATABLE  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(BD_InputType) , DIMENSION(:,:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE BeamDyn_Data
! =======================
! =========  ElastoDyn_Data  =======
  TYPE, PUBLIC :: ElastoDyn_Data
    TYPE(ED_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(ED_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(ED_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(ED_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(ED_ParameterType)  :: p      !< Parameters [-]
    TYPE(ED_InputType)  :: u      !< System inputs [-]
    TYPE(ED_OutputType)  :: y      !< System outputs [-]
    TYPE(ED_MiscVarType)  :: m      !< Misc (optimization) variables not associated with time [-]
    TYPE(ED_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(ED_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(ED_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ElastoDyn_Data
! =======================
! =========  ServoDyn_Data  =======
  TYPE, PUBLIC :: ServoDyn_Data
    TYPE(SrvD_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(SrvD_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(SrvD_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(SrvD_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(SrvD_ParameterType)  :: p      !< Parameters [-]
    TYPE(SrvD_InputType)  :: u      !< System inputs [-]
    TYPE(SrvD_OutputType)  :: y      !< System outputs [-]
    TYPE(SrvD_MiscVarType)  :: m      !< Misc (optimization) variables not associated with time [-]
    TYPE(SrvD_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(SrvD_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(SrvD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ServoDyn_Data
! =======================
! =========  AeroDyn14_Data  =======
  TYPE, PUBLIC :: AeroDyn14_Data
    TYPE(AD14_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(AD14_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(AD14_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(AD14_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(AD14_ParameterType)  :: p      !< Parameters [-]
    TYPE(AD14_InputType)  :: u      !< System inputs [-]
    TYPE(AD14_OutputType)  :: y      !< System outputs [-]
    TYPE(AD14_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(AD14_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE AeroDyn14_Data
! =======================
! =========  AeroDyn_Data  =======
  TYPE, PUBLIC :: AeroDyn_Data
    TYPE(AD_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(AD_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(AD_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(AD_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(AD_ParameterType)  :: p      !< Parameters [-]
    TYPE(AD_InputType)  :: u      !< System inputs [-]
    TYPE(AD_OutputType)  :: y      !< System outputs [-]
    TYPE(AD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(AD_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(AD_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(AD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE AeroDyn_Data
! =======================
! =========  InflowWind_Data  =======
  TYPE, PUBLIC :: InflowWind_Data
    TYPE(InflowWind_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(InflowWind_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(InflowWind_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(InflowWind_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(InflowWind_ParameterType)  :: p      !< Parameters [-]
    TYPE(InflowWind_InputType)  :: u      !< System inputs [-]
    TYPE(InflowWind_OutputType)  :: y      !< System outputs [-]
    TYPE(InflowWind_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(InflowWind_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(InflowWind_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(InflowWind_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE InflowWind_Data
! =======================
! =========  OpenFOAM_Data  =======
  TYPE, PUBLIC :: OpenFOAM_Data
    TYPE(OpFM_InputType)  :: u      !< System inputs [-]
    TYPE(OpFM_OutputType)  :: y      !< System outputs [-]
    TYPE(OpFM_ParameterType)  :: p      !< Parameters [-]
    TYPE(OpFM_MiscVarType)  :: m      !< Parameters [-]
  END TYPE OpenFOAM_Data
! =======================
! =========  SCDataEx_Data  =======
  TYPE, PUBLIC :: SCDataEx_Data
    TYPE(SC_DX_InputType)  :: u      !< System inputs [-]
    TYPE(SC_DX_OutputType)  :: y      !< System outputs [-]
    TYPE(SC_DX_ParameterType)  :: p      !< System parameters [-]
  END TYPE SCDataEx_Data
! =======================
! =========  SubDyn_Data  =======
  TYPE, PUBLIC :: SubDyn_Data
    TYPE(SD_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(SD_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(SD_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(SD_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(SD_ParameterType)  :: p      !< Parameters [-]
    TYPE(SD_InputType)  :: u      !< System inputs [-]
    TYPE(SD_OutputType)  :: y      !< System outputs [-]
    TYPE(SD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(SD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    TYPE(SD_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(SD_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE SubDyn_Data
! =======================
! =========  ExtPtfm_Data  =======
  TYPE, PUBLIC :: ExtPtfm_Data
    TYPE(ExtPtfm_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(ExtPtfm_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(ExtPtfm_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(ExtPtfm_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(ExtPtfm_ParameterType)  :: p      !< Parameters [-]
    TYPE(ExtPtfm_InputType)  :: u      !< System inputs [-]
    TYPE(ExtPtfm_OutputType)  :: y      !< System outputs [-]
    TYPE(ExtPtfm_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(ExtPtfm_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE ExtPtfm_Data
! =======================
! =========  SeaState_Data  =======
  TYPE, PUBLIC :: SeaState_Data
    TYPE(SeaSt_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(SeaSt_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(SeaSt_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(SeaSt_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(SeaSt_ParameterType)  :: p      !< Parameters [-]
    TYPE(SeaSt_InputType)  :: u      !< System inputs [-]
    TYPE(SeaSt_OutputType)  :: y      !< System outputs [-]
    TYPE(SeaSt_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(SeaSt_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    TYPE(SeaSt_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(SeaSt_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE SeaState_Data
! =======================
! =========  HydroDyn_Data  =======
  TYPE, PUBLIC :: HydroDyn_Data
    TYPE(HydroDyn_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(HydroDyn_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(HydroDyn_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(HydroDyn_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(HydroDyn_ParameterType)  :: p      !< Parameters [-]
    TYPE(HydroDyn_InputType)  :: u      !< System inputs [-]
    TYPE(HydroDyn_OutputType)  :: y      !< System outputs [-]
    TYPE(HydroDyn_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(HydroDyn_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(HydroDyn_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(HydroDyn_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE HydroDyn_Data
! =======================
! =========  IceFloe_Data  =======
  TYPE, PUBLIC :: IceFloe_Data
    TYPE(IceFloe_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(IceFloe_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(IceFloe_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(IceFloe_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(IceFloe_ParameterType)  :: p      !< Parameters [-]
    TYPE(IceFloe_InputType)  :: u      !< System inputs [-]
    TYPE(IceFloe_OutputType)  :: y      !< System outputs [-]
    TYPE(IceFloe_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(IceFloe_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE IceFloe_Data
! =======================
! =========  MAP_Data  =======
  TYPE, PUBLIC :: MAP_Data
    TYPE(MAP_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(MAP_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(MAP_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(MAP_OtherStateType)  :: OtherSt      !< Other/optimization states [-]
    TYPE(MAP_ParameterType)  :: p      !< Parameters [-]
    TYPE(MAP_InputType)  :: u      !< System inputs [-]
    TYPE(MAP_OutputType)  :: y      !< System outputs [-]
    TYPE(MAP_OtherStateType)  :: OtherSt_old      !< Other/optimization states (copied for the case of subcycling) [-]
    TYPE(MAP_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(MAP_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(MAP_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE MAP_Data
! =======================
! =========  FEAMooring_Data  =======
  TYPE, PUBLIC :: FEAMooring_Data
    TYPE(FEAM_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(FEAM_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(FEAM_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(FEAM_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(FEAM_ParameterType)  :: p      !< Parameters [-]
    TYPE(FEAM_InputType)  :: u      !< System inputs [-]
    TYPE(FEAM_OutputType)  :: y      !< System outputs [-]
    TYPE(FEAM_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(FEAM_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE FEAMooring_Data
! =======================
! =========  MoorDyn_Data  =======
  TYPE, PUBLIC :: MoorDyn_Data
    TYPE(MD_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(MD_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(MD_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(MD_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(MD_ParameterType)  :: p      !< Parameters [-]
    TYPE(MD_InputType)  :: u      !< System inputs [-]
    TYPE(MD_OutputType)  :: y      !< System outputs [-]
    TYPE(MD_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(MD_OutputType) , DIMENSION(:), ALLOCATABLE  :: Output      !< Array of outputs associated with CalcSteady Azimuths [-]
    TYPE(MD_OutputType)  :: y_interp      !< interpolated system outputs for CalcSteady [-]
    TYPE(MD_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE MoorDyn_Data
! =======================
! =========  OrcaFlex_Data  =======
  TYPE, PUBLIC :: OrcaFlex_Data
    TYPE(Orca_ContinuousStateType) , DIMENSION(1:2)  :: x      !< Continuous states [-]
    TYPE(Orca_DiscreteStateType) , DIMENSION(1:2)  :: xd      !< Discrete states [-]
    TYPE(Orca_ConstraintStateType) , DIMENSION(1:2)  :: z      !< Constraint states [-]
    TYPE(Orca_OtherStateType) , DIMENSION(1:2)  :: OtherSt      !< Other states [-]
    TYPE(Orca_ParameterType)  :: p      !< Parameters [-]
    TYPE(Orca_InputType)  :: u      !< System inputs [-]
    TYPE(Orca_OutputType)  :: y      !< System outputs [-]
    TYPE(Orca_MiscVarType)  :: m      !< Misc/optimization variables [-]
    TYPE(Orca_InputType) , DIMENSION(:), ALLOCATABLE  :: Input      !< Array of inputs associated with InputTimes [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: InputTimes      !< Array of times associated with Input Array [-]
  END TYPE OrcaFlex_Data
! =======================
! =========  FAST_ModuleMapType  =======
  TYPE, PUBLIC :: FAST_ModuleMapType
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: ED_P_2_BD_P      !< Map ElastoDyn BladeRootMotion meshes to BeamDyn RootMotion point meshes [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: BD_P_2_ED_P      !< Map BeamDyn ReactionForce loads point meshes to ElastoDyn HubPtLoad point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: ED_P_2_BD_P_Hub      !< ElastoDyn hub to BeamDyn for hub orientation necessary for pitch actuator [-]
    TYPE(MeshMapType)  :: ED_P_2_HD_PRP_P      !< Map ElastoDyn PlatformPtMesh to HydroDyn platform reference Point [-]
    TYPE(MeshMapType)  :: SubStructure_2_HD_W_P      !< Map ElastoDyn PlatformPtMesh or SubDyn y2Mesh to HydroDyn WAMIT Point [-]
    TYPE(MeshMapType)  :: HD_W_P_2_SubStructure      !< Map HydroDyn WAMIT Point from y%WAMITMesh to ElastoDyn PlatformPtMesh or SD LMesh [-]
    TYPE(MeshMapType)  :: SubStructure_2_HD_M_P      !< Map ElastoDyn PlatformPtMesh or SubDyn y2Mesh to HydroDyn Morison Point [-]
    TYPE(MeshMapType)  :: HD_M_P_2_SubStructure      !< Map HydroDyn Morison Point to ElastoDyn PlatformPtMesh or SD LMesh [-]
    TYPE(MeshMapType)  :: Structure_2_Mooring      !< Map structural SD (y3Mesh)/ED to MAP/FEAM/MoorDyn/OrcaFlex point mesh [Motions]
    TYPE(MeshMapType)  :: Mooring_2_Structure      !< Map FEAM/MAP/MoorDyn/OrcaFlex mesh to SD (LMesh)/ED (PlatformPtMesh)/ExtPtfm mesh [Loads]
    TYPE(MeshMapType)  :: ED_P_2_SD_TP      !< Map ElastoDyn PlatformPtMesh to SubDyn transition-piece point mesh [-]
    TYPE(MeshMapType)  :: SD_TP_2_ED_P      !< Map SubDyn transition-piece point mesh to ElastoDyn PlatformPtMesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: ED_P_2_NStC_P_N      !< Map ElastoDyn      nacelle point mesh to ServoDyn/NStC point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: NStC_P_2_ED_P_N      !< Map ServoDyn/NStC  nacelle point mesh to ElastoDyn     point mesh on the nacelle [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: ED_L_2_TStC_P_T      !< Map ElastoDyn      tower   line2 mesh to ServoDyn/TStC point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: TStC_P_2_ED_P_T      !< Map ServoDyn/TStC  tower   point mesh to ElastoDyn     point load mesh on the tower [-]
    TYPE(MeshMapType) , DIMENSION(:,:), ALLOCATABLE  :: ED_L_2_BStC_P_B      !< Map ElastoDyn blade line2 mesh to ServoDyn/BStC point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:,:), ALLOCATABLE  :: BStC_P_2_ED_P_B      !< Map ServoDyn/BStC point mesh to ElastoDyn point load mesh on the blade [-]
    TYPE(MeshMapType) , DIMENSION(:,:), ALLOCATABLE  :: BD_L_2_BStC_P_B      !< Map BeamDyn blade line2 mesh to ServoDyn/BStC point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:,:), ALLOCATABLE  :: BStC_P_2_BD_P_B      !< Map ServoDyn/BStC point mesh to BeamDyn point load mesh on the blade [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: SStC_P_P_2_SubStructure      !< Map ServoDyn/SStC platform point mesh load   to SubDyn/ElastoDyn  point load mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: SubStructure_2_SStC_P_P      !< Map SubDyn y3mesh or ED platform mesh motion to ServoDyn/SStC point mesh [-]
    TYPE(MeshMapType)  :: ED_P_2_SrvD_P_P      !< Map ElastoDyn     platform point mesh motion to ServoDyn      point mesh -- for passing to controller [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: BDED_L_2_AD_L_B      !< Map ElastoDyn BladeLn2Mesh point meshes OR BeamDyn BldMotion line2 meshes to AeroDyn14 InputMarkers OR AeroDyn BladeMotion line2 meshes [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: AD_L_2_BDED_B      !< Map AeroDyn14 InputMarkers or AeroDyn BladeLoad line2 meshes to ElastoDyn BladePtLoad point meshes or BeamDyn BldMotion line2 meshes [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: BD_L_2_BD_L      !< Map BeamDyn BldMotion output meshes to locations on the BD input DistrLoad mesh stored in MeshMapType%y_BD_BldMotion_4Loads (BD input and output meshes are not siblings and in fact have nodes at different locations [-]
    TYPE(MeshMapType)  :: ED_P_2_AD_P_N      !< Map ElastoDyn Nacelle point motion mesh to AeroDyn Nacelle point motion mesh [-]
    TYPE(MeshMapType)  :: AD_P_2_ED_P_N      !< Map AeroDyn Nacelle point load mesh to ElastoDyn nacelle point load mesh [-]
    TYPE(MeshMapType)  :: ED_P_2_AD_P_TF      !< Map ElastoDyn TailFin CM point motion mesh to AeroDyn TailFin ref point motion mesh [-]
    TYPE(MeshMapType)  :: AD_P_2_ED_P_TF      !< Map AeroDyn TailFin ref point load mesh to ElastoDyn TailFin CM point load mesh [-]
    TYPE(MeshMapType)  :: ED_L_2_AD_L_T      !< Map ElastoDyn TowerLn2Mesh line2 mesh to AeroDyn14 Twr_InputMarkers or AeroDyn TowerMotion line2 mesh [-]
    TYPE(MeshMapType)  :: AD_L_2_ED_P_T      !< Map AeroDyn14 Twr_InputMarkers or AeroDyn TowerLoad line2 mesh to ElastoDyn TowerPtLoads point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: ED_P_2_AD_P_R      !< Map ElastoDyn BladeRootMotion point meshes to AeroDyn BladeRootMotion point meshes [-]
    TYPE(MeshMapType)  :: ED_P_2_AD_P_H      !< Map ElastoDyn HubPtMotion point mesh to AeroDyn HubMotion point mesh [-]
    TYPE(MeshMapType)  :: AD_P_2_ED_P_H      !< Map AeroDyn HubLoad point mesh to ElastoDyn HubPtLoad point mesh [-]
    TYPE(MeshMapType)  :: IceF_P_2_SD_P      !< Map IceFloe point mesh to SubDyn LMesh point mesh [-]
    TYPE(MeshMapType)  :: SDy3_P_2_IceF_P      !< Map SubDyn y3Mesh point mesh to IceFloe point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: IceD_P_2_SD_P      !< Map IceDyn point mesh to SubDyn LMesh point mesh [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: SDy3_P_2_IceD_P      !< Map SubDyn y3Mesh point mesh to IceDyn point mesh [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Jacobian_Opt1      !< Stored Jacobian in ED_HD_InputOutputSolve or FullOpt1_InputOutputSolve [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Jacobian_pivot      !< Pivot array used for LU decomposition of Jacobian_Opt1 [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    TYPE(MeshType)  :: u_ED_NacelleLoads      !< copy of ED input mesh [-]
    TYPE(MeshType)  :: SubstructureLoads_Tmp      !< copy of substructure loads input mesh (ED or SD) [-]
    TYPE(MeshType)  :: SubstructureLoads_Tmp2      !< copy of substructure loads input mesh (ED or SD, used only for temporary storage) [-]
    TYPE(MeshType)  :: PlatformLoads_Tmp      !< copy of platform loads input mesh (ED) [-]
    TYPE(MeshType)  :: PlatformLoads_Tmp2      !< copy of platform loads input mesh (ED, used only for temporary storage) [-]
    TYPE(MeshType)  :: SubstructureLoads_Tmp_Farm      !< copy of substructure mesh used to store loads from farm-level MD [-]
    TYPE(MeshType)  :: u_ED_TowerPtloads      !< copy of ED input mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: u_ED_BladePtLoads      !< copy of ED input mesh [-]
    TYPE(MeshType)  :: u_SD_TPMesh      !< copy of SD input mesh [-]
    TYPE(MeshType)  :: u_HD_M_Mesh      !< copy of HD morison input mesh [-]
    TYPE(MeshType)  :: u_HD_W_Mesh      !< copy of HD wamit input mesh [-]
    TYPE(MeshType)  :: u_ED_HubPtLoad      !< copy of  ED input mesh [-]
    TYPE(MeshType)  :: u_ED_HubPtLoad_2      !< copy of  ED input mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: u_BD_RootMotion      !< copy of  BD input meshes [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: y_BD_BldMotion_4Loads      !< BD blade motion output at locations on DistrLoad input meshes [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: u_BD_Distrload      !< copy of BD DistrLoad input meshes [-]
    TYPE(MeshType)  :: u_Orca_PtfmMesh      !< copy of Orca PtfmMesh input mesh [-]
    TYPE(MeshType)  :: u_ExtPtfm_PtfmMesh      !< copy of ExtPtfm_MCKF PtfmMesh input mesh [-]
  END TYPE FAST_ModuleMapType
! =======================
! =========  FAST_ExternInputType  =======
  TYPE, PUBLIC :: FAST_ExternInputType
    REAL(ReKi)  :: GenTrq      !< generator torque input from Simulink/Labview [-]
    REAL(ReKi)  :: ElecPwr      !< electric power input from Simulink/Labview [-]
    REAL(ReKi)  :: YawPosCom      !< yaw position command from Simulink/Labview [-]
    REAL(ReKi)  :: YawRateCom      !< yaw rate command from Simulink/Labview [-]
    REAL(ReKi) , DIMENSION(1:3)  :: BlPitchCom      !< blade pitch commands from Simulink/Labview [rad]
    REAL(ReKi) , DIMENSION(1:3)  :: BlAirfoilCom      !< blade airfoil commands from Simulink/Labview [-]
    REAL(ReKi)  :: HSSBrFrac      !< Fraction of full braking torque: 0 (off) <= HSSBrFrac <= 1 (full) from Simulink or LabVIEW [-]
    REAL(ReKi) , DIMENSION(1:3)  :: LidarFocus      !< lidar focus (relative to lidar location) [m]
    REAL(ReKi) , DIMENSION(1:20)  :: CableDeltaL      !< Cable control DeltaL [m]
    REAL(ReKi) , DIMENSION(1:20)  :: CableDeltaLdot      !< Cable control DeltaLdot [m/s]
  END TYPE FAST_ExternInputType
! =======================
! =========  FAST_MiscVarType  =======
  TYPE, PUBLIC :: FAST_MiscVarType
    REAL(DbKi)  :: TiLstPrn      !< The simulation time of the last print (to file) [(s)]
    REAL(DbKi)  :: t_global      !< Current simulation time (for global/FAST simulation) [(s)]
    REAL(DbKi)  :: NextJacCalcTime      !< Time between calculating Jacobians in the HD-ED and SD-ED simulations [(s)]
    REAL(ReKi)  :: PrevClockTime      !< Clock time at start of simulation in seconds [(s)]
    REAL(ReKi)  :: UsrTime1      !< User CPU time for simulation initialization [(s)]
    REAL(ReKi)  :: UsrTime2      !< User CPU time for simulation (without intialization) [(s)]
    INTEGER(IntKi) , DIMENSION(1:8)  :: StrtTime      !< Start time of simulation (including intialization) [-]
    INTEGER(IntKi) , DIMENSION(1:8)  :: SimStrtTime      !< Start time of simulation (after initialization) [-]
    LOGICAL  :: calcJacobian      !< Should we calculate Jacobians in Option 1? [(flag)]
    TYPE(FAST_ExternInputType)  :: ExternInput      !< external input values [-]
    TYPE(FAST_MiscLinType)  :: Lin      !< misc data for linearization analysis [-]
  END TYPE FAST_MiscVarType
! =======================
! =========  FAST_InitData  =======
  TYPE, PUBLIC :: FAST_InitData
    TYPE(ED_InitInputType)  :: InData_ED      !< ED Initialization input data [-]
    TYPE(ED_InitOutputType)  :: OutData_ED      !< ED Initialization output data [-]
    TYPE(BD_InitInputType)  :: InData_BD      !< BD Initialization input data [-]
    TYPE(BD_InitOutputType) , DIMENSION(:), ALLOCATABLE  :: OutData_BD      !< BD Initialization output data [-]
    TYPE(SrvD_InitInputType)  :: InData_SrvD      !< SrvD Initialization input data [-]
    TYPE(SrvD_InitOutputType)  :: OutData_SrvD      !< SrvD Initialization output data [-]
    TYPE(AD14_InitInputType)  :: InData_AD14      !< AD14 Initialization input data [-]
    TYPE(AD14_InitOutputType)  :: OutData_AD14      !< AD14 Initialization output data [-]
    TYPE(AD_InitInputType)  :: InData_AD      !< AD Initialization input data [-]
    TYPE(AD_InitOutputType)  :: OutData_AD      !< AD Initialization output data [-]
    TYPE(InflowWind_InitInputType)  :: InData_IfW      !< IfW Initialization input data [-]
    TYPE(InflowWind_InitOutputType)  :: OutData_IfW      !< IfW Initialization output data [-]
    TYPE(OpFM_InitInputType)  :: InData_OpFM      !< OpFM Initialization input data [-]
    TYPE(OpFM_InitOutputType)  :: OutData_OpFM      !< OpFM Initialization output data [-]
    TYPE(SeaSt_InitInputType)  :: InData_SeaSt      !< SeaSt Initialization input data [-]
    TYPE(SeaSt_InitOutputType)  :: OutData_SeaSt      !< SeaSt Initialization output data [-]
    TYPE(HydroDyn_InitInputType)  :: InData_HD      !< HD Initialization input data [-]
    TYPE(HydroDyn_InitOutputType)  :: OutData_HD      !< HD Initialization output data [-]
    TYPE(SD_InitInputType)  :: InData_SD      !< SD Initialization input data [-]
    TYPE(SD_InitOutputType)  :: OutData_SD      !< SD Initialization output data [-]
    TYPE(ExtPtfm_InitInputType)  :: InData_ExtPtfm      !< ExtPtfm Initialization input data [-]
    TYPE(ExtPtfm_InitOutputType)  :: OutData_ExtPtfm      !< ExtPtfm Initialization output data [-]
    TYPE(MAP_InitInputType)  :: InData_MAP      !< MAP Initialization input data [-]
    TYPE(MAP_InitOutputType)  :: OutData_MAP      !< MAP Initialization output data [-]
    TYPE(FEAM_InitInputType)  :: InData_FEAM      !< FEAM Initialization input data [-]
    TYPE(FEAM_InitOutputType)  :: OutData_FEAM      !< FEAM Initialization output data [-]
    TYPE(MD_InitInputType)  :: InData_MD      !< MD Initialization input data [-]
    TYPE(MD_InitOutputType)  :: OutData_MD      !< MD Initialization output data [-]
    TYPE(Orca_InitInputType)  :: InData_Orca      !< Orca Initialization input data [-]
    TYPE(Orca_InitOutputType)  :: OutData_Orca      !< Orca Initialization output data [-]
    TYPE(IceFloe_InitInputType)  :: InData_IceF      !< IceF Initialization input data [-]
    TYPE(IceFloe_InitOutputType)  :: OutData_IceF      !< IceF Initialization output data [-]
    TYPE(IceD_InitInputType)  :: InData_IceD      !< IceD Initialization input data [-]
    TYPE(IceD_InitOutputType)  :: OutData_IceD      !< IceD Initialization output data (each instance will have the same output channels) [-]
  END TYPE FAST_InitData
! =======================
! =========  FAST_ExternInitType  =======
  TYPE, PUBLIC :: FAST_ExternInitType
    REAL(DbKi)  :: Tmax = -1      !< External code specified Tmax [s]
    INTEGER(IntKi)  :: SensorType = SensorType_None      !< lidar sensor type, which should not be pulsed at the moment; this input should be replaced with a section in the InflowWind input file [-]
    LOGICAL  :: LidRadialVel      !< TRUE => return radial component, FALSE => return 'x' direction estimate [-]
    INTEGER(IntKi)  :: TurbineID = 0      !< ID number for turbine (used to create output file naming convention) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TurbinePos      !< Initial position of turbine base (origin used for graphics or in FAST.Farm) [m]
    INTEGER(IntKi)  :: WaveFieldMod      !< Wave field handling (-) (switch) 0: use individual HydroDyn inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    INTEGER(IntKi)  :: NumSC2CtrlGlob      !< number of global controller inputs [from supercontroller] [-]
    INTEGER(IntKi)  :: NumSC2Ctrl      !< number of turbine specific controller inputs [from supercontroller] [-]
    INTEGER(IntKi)  :: NumCtrl2SC      !< number of controller outputs [to supercontroller] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: fromSCGlob      !< Initial global inputs to the controller [from the supercontroller] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: fromSC      !< Initial turbine specific inputs to the controller [from the supercontroller] [-]
    LOGICAL  :: FarmIntegration = .false.      !< whether this is called from FAST.Farm (or another program that doesn't want FAST to call all of the init stuff first) [-]
    INTEGER(IntKi) , DIMENSION(1:4)  :: windGrid_n      !< number of grid points in the x, y, z, and t directions for IfW [-]
    REAL(ReKi) , DIMENSION(1:4)  :: windGrid_delta      !< size between 2 consecutive grid points in each grid direction for IfW [m,m,m,s]
    REAL(ReKi) , DIMENSION(1:3)  :: windGrid_pZero      !< fixed position of the XYZ grid (i.e., XYZ coordinates of IfW m%V(:,1,1,1,:)) [m]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: windGrid_data => NULL()      !< Pointers to Wind velocity of disturbed wind (ambient + wakes) across each high-resolution domain around a turbine for each high-resolution step within a low-resolution step [m/s]
    CHARACTER(1024)  :: RootName      !< Root name of FAST output files (overrides normal operation) [-]
    INTEGER(IntKi)  :: NumActForcePtsBlade      !< number of actuator line force points in blade [-]
    INTEGER(IntKi)  :: NumActForcePtsTower      !< number of actuator line force points in tower [-]
    INTEGER(IntKi)  :: NodeClusterType      !< Node clustering for actuator line (0 - Uniform, 1 - Non-uniform clustered towards tip) [-]
  END TYPE FAST_ExternInitType
! =======================
! =========  FAST_TurbineType  =======
  TYPE, PUBLIC :: FAST_TurbineType
    INTEGER(IntKi)  :: TurbID = 1      !< Turbine ID Number [-]
    TYPE(FAST_ParameterType)  :: p_FAST      !< Parameters for the glue code [-]
    TYPE(FAST_OutputFileType)  :: y_FAST      !< Output variables for the glue code [-]
    TYPE(FAST_MiscVarType)  :: m_FAST      !< Miscellaneous variables [-]
    TYPE(FAST_ModuleMapType)  :: MeshMapData      !< Data for mapping between modules [-]
    TYPE(ElastoDyn_Data)  :: ED      !< Data for the ElastoDyn module [-]
    TYPE(BeamDyn_Data)  :: BD      !< Data for the BeamDyn module [-]
    TYPE(ServoDyn_Data)  :: SrvD      !< Data for the ServoDyn module [-]
    TYPE(AeroDyn_Data)  :: AD      !< Data for the AeroDyn module [-]
    TYPE(AeroDyn14_Data)  :: AD14      !< Data for the AeroDyn14 module [-]
    TYPE(InflowWind_Data)  :: IfW      !< Data for InflowWind module [-]
    TYPE(OpenFOAM_Data)  :: OpFM      !< Data for OpenFOAM integration module [-]
    TYPE(SCDataEx_Data)  :: SC_DX      !< Data for SuperController integration module [-]
    TYPE(SeaState_Data)  :: SeaSt      !< Data for the SeaState module [-]
    TYPE(HydroDyn_Data)  :: HD      !< Data for the HydroDyn module [-]
    TYPE(SubDyn_Data)  :: SD      !< Data for the SubDyn module [-]
    TYPE(MAP_Data)  :: MAP      !< Data for the MAP (Mooring Analysis Program) module [-]
    TYPE(FEAMooring_Data)  :: FEAM      !< Data for the FEAMooring module [-]
    TYPE(MoorDyn_Data)  :: MD      !< Data for the MoorDyn module [-]
    TYPE(OrcaFlex_Data)  :: Orca      !< Data for the OrcaFlex interface module [-]
    TYPE(IceFloe_Data)  :: IceF      !< Data for the IceFloe module [-]
    TYPE(IceDyn_Data)  :: IceD      !< Data for the IceDyn module [-]
    TYPE(ExtPtfm_Data)  :: ExtPtfm      !< Data for the ExtPtfm (external platform loading) module [-]
  END TYPE FAST_TurbineType
! =======================
CONTAINS
 SUBROUTINE FAST_CopyVTK_BLSurfaceType( SrcVTK_BLSurfaceTypeData, DstVTK_BLSurfaceTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_VTK_BLSurfaceType), INTENT(IN) :: SrcVTK_BLSurfaceTypeData
   TYPE(FAST_VTK_BLSurfaceType), INTENT(INOUT) :: DstVTK_BLSurfaceTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyVTK_BLSurfaceType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcVTK_BLSurfaceTypeData%AirfoilCoords)) THEN
  i1_l = LBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,1)
  i1_u = UBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,1)
  i2_l = LBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,2)
  i2_u = UBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,2)
  i3_l = LBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,3)
  i3_u = UBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,3)
  IF (.NOT. ALLOCATED(DstVTK_BLSurfaceTypeData%AirfoilCoords)) THEN 
    ALLOCATE(DstVTK_BLSurfaceTypeData%AirfoilCoords(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_BLSurfaceTypeData%AirfoilCoords.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_BLSurfaceTypeData%AirfoilCoords = SrcVTK_BLSurfaceTypeData%AirfoilCoords
ENDIF
 END SUBROUTINE FAST_CopyVTK_BLSurfaceType

 SUBROUTINE FAST_DestroyVTK_BLSurfaceType( VTK_BLSurfaceTypeData, ErrStat, ErrMsg )
  TYPE(FAST_VTK_BLSurfaceType), INTENT(INOUT) :: VTK_BLSurfaceTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyVTK_BLSurfaceType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(VTK_BLSurfaceTypeData%AirfoilCoords)) THEN
  DEALLOCATE(VTK_BLSurfaceTypeData%AirfoilCoords)
ENDIF
 END SUBROUTINE FAST_DestroyVTK_BLSurfaceType


subroutine FAST_PackVTK_BLSurfaceType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_VTK_BLSurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackVTK_BLSurfaceType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AirfoilCoords
   call RegPack(Buf, allocated(InData%AirfoilCoords))
   if (allocated(InData%AirfoilCoords)) then
      call RegPackBounds(Buf, 3, lbound(InData%AirfoilCoords), ubound(InData%AirfoilCoords))
      call RegPack(Buf, InData%AirfoilCoords)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackVTK_BLSurfaceType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_VTK_BLSurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackVTK_BLSurfaceType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AirfoilCoords
   if (allocated(OutData%AirfoilCoords)) deallocate(OutData%AirfoilCoords)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AirfoilCoords.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AirfoilCoords)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyVTK_SurfaceType( SrcVTK_SurfaceTypeData, DstVTK_SurfaceTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_VTK_SurfaceType), INTENT(IN) :: SrcVTK_SurfaceTypeData
   TYPE(FAST_VTK_SurfaceType), INTENT(INOUT) :: DstVTK_SurfaceTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyVTK_SurfaceType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstVTK_SurfaceTypeData%NumSectors = SrcVTK_SurfaceTypeData%NumSectors
    DstVTK_SurfaceTypeData%HubRad = SrcVTK_SurfaceTypeData%HubRad
    DstVTK_SurfaceTypeData%GroundRad = SrcVTK_SurfaceTypeData%GroundRad
    DstVTK_SurfaceTypeData%NacelleBox = SrcVTK_SurfaceTypeData%NacelleBox
IF (ALLOCATED(SrcVTK_SurfaceTypeData%TowerRad)) THEN
  i1_l = LBOUND(SrcVTK_SurfaceTypeData%TowerRad,1)
  i1_u = UBOUND(SrcVTK_SurfaceTypeData%TowerRad,1)
  IF (.NOT. ALLOCATED(DstVTK_SurfaceTypeData%TowerRad)) THEN 
    ALLOCATE(DstVTK_SurfaceTypeData%TowerRad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%TowerRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_SurfaceTypeData%TowerRad = SrcVTK_SurfaceTypeData%TowerRad
ENDIF
    DstVTK_SurfaceTypeData%NWaveElevPts = SrcVTK_SurfaceTypeData%NWaveElevPts
IF (ALLOCATED(SrcVTK_SurfaceTypeData%WaveElevXY)) THEN
  i1_l = LBOUND(SrcVTK_SurfaceTypeData%WaveElevXY,1)
  i1_u = UBOUND(SrcVTK_SurfaceTypeData%WaveElevXY,1)
  i2_l = LBOUND(SrcVTK_SurfaceTypeData%WaveElevXY,2)
  i2_u = UBOUND(SrcVTK_SurfaceTypeData%WaveElevXY,2)
  IF (.NOT. ALLOCATED(DstVTK_SurfaceTypeData%WaveElevXY)) THEN 
    ALLOCATE(DstVTK_SurfaceTypeData%WaveElevXY(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%WaveElevXY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_SurfaceTypeData%WaveElevXY = SrcVTK_SurfaceTypeData%WaveElevXY
ENDIF
IF (ALLOCATED(SrcVTK_SurfaceTypeData%WaveElev)) THEN
  i1_l = LBOUND(SrcVTK_SurfaceTypeData%WaveElev,1)
  i1_u = UBOUND(SrcVTK_SurfaceTypeData%WaveElev,1)
  i2_l = LBOUND(SrcVTK_SurfaceTypeData%WaveElev,2)
  i2_u = UBOUND(SrcVTK_SurfaceTypeData%WaveElev,2)
  IF (.NOT. ALLOCATED(DstVTK_SurfaceTypeData%WaveElev)) THEN 
    ALLOCATE(DstVTK_SurfaceTypeData%WaveElev(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%WaveElev.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_SurfaceTypeData%WaveElev = SrcVTK_SurfaceTypeData%WaveElev
ENDIF
IF (ALLOCATED(SrcVTK_SurfaceTypeData%BladeShape)) THEN
  i1_l = LBOUND(SrcVTK_SurfaceTypeData%BladeShape,1)
  i1_u = UBOUND(SrcVTK_SurfaceTypeData%BladeShape,1)
  IF (.NOT. ALLOCATED(DstVTK_SurfaceTypeData%BladeShape)) THEN 
    ALLOCATE(DstVTK_SurfaceTypeData%BladeShape(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%BladeShape.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcVTK_SurfaceTypeData%BladeShape,1), UBOUND(SrcVTK_SurfaceTypeData%BladeShape,1)
      CALL FAST_Copyvtk_blsurfacetype( SrcVTK_SurfaceTypeData%BladeShape(i1), DstVTK_SurfaceTypeData%BladeShape(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcVTK_SurfaceTypeData%MorisonRad)) THEN
  i1_l = LBOUND(SrcVTK_SurfaceTypeData%MorisonRad,1)
  i1_u = UBOUND(SrcVTK_SurfaceTypeData%MorisonRad,1)
  IF (.NOT. ALLOCATED(DstVTK_SurfaceTypeData%MorisonRad)) THEN 
    ALLOCATE(DstVTK_SurfaceTypeData%MorisonRad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_SurfaceTypeData%MorisonRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_SurfaceTypeData%MorisonRad = SrcVTK_SurfaceTypeData%MorisonRad
ENDIF
 END SUBROUTINE FAST_CopyVTK_SurfaceType

 SUBROUTINE FAST_DestroyVTK_SurfaceType( VTK_SurfaceTypeData, ErrStat, ErrMsg )
  TYPE(FAST_VTK_SurfaceType), INTENT(INOUT) :: VTK_SurfaceTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyVTK_SurfaceType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(VTK_SurfaceTypeData%TowerRad)) THEN
  DEALLOCATE(VTK_SurfaceTypeData%TowerRad)
ENDIF
IF (ALLOCATED(VTK_SurfaceTypeData%WaveElevXY)) THEN
  DEALLOCATE(VTK_SurfaceTypeData%WaveElevXY)
ENDIF
IF (ALLOCATED(VTK_SurfaceTypeData%WaveElev)) THEN
  DEALLOCATE(VTK_SurfaceTypeData%WaveElev)
ENDIF
IF (ALLOCATED(VTK_SurfaceTypeData%BladeShape)) THEN
DO i1 = LBOUND(VTK_SurfaceTypeData%BladeShape,1), UBOUND(VTK_SurfaceTypeData%BladeShape,1)
  CALL FAST_DestroyVTK_BLSurfaceType( VTK_SurfaceTypeData%BladeShape(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(VTK_SurfaceTypeData%BladeShape)
ENDIF
IF (ALLOCATED(VTK_SurfaceTypeData%MorisonRad)) THEN
  DEALLOCATE(VTK_SurfaceTypeData%MorisonRad)
ENDIF
 END SUBROUTINE FAST_DestroyVTK_SurfaceType


subroutine FAST_PackVTK_SurfaceType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_VTK_SurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackVTK_SurfaceType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumSectors
   call RegPack(Buf, InData%NumSectors)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubRad
   call RegPack(Buf, InData%HubRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GroundRad
   call RegPack(Buf, InData%GroundRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacelleBox
   call RegPack(Buf, InData%NacelleBox)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerRad
   call RegPack(Buf, allocated(InData%TowerRad))
   if (allocated(InData%TowerRad)) then
      call RegPackBounds(Buf, 1, lbound(InData%TowerRad), ubound(InData%TowerRad))
      call RegPack(Buf, InData%TowerRad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElevPts
   call RegPack(Buf, InData%NWaveElevPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevXY
   call RegPack(Buf, allocated(InData%WaveElevXY))
   if (allocated(InData%WaveElevXY)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevXY), ubound(InData%WaveElevXY))
      call RegPack(Buf, InData%WaveElevXY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev
   call RegPack(Buf, allocated(InData%WaveElev))
   if (allocated(InData%WaveElev)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElev), ubound(InData%WaveElev))
      call RegPack(Buf, InData%WaveElev)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeShape
   call RegPack(Buf, allocated(InData%BladeShape))
   if (allocated(InData%BladeShape)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeShape), ubound(InData%BladeShape))
      LB(1:1) = lbound(InData%BladeShape)
      UB(1:1) = ubound(InData%BladeShape)
      do i1 = LB(1), UB(1)
         call FAST_PackVTK_BLSurfaceType(Buf, InData%BladeShape(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MorisonRad
   call RegPack(Buf, allocated(InData%MorisonRad))
   if (allocated(InData%MorisonRad)) then
      call RegPackBounds(Buf, 1, lbound(InData%MorisonRad), ubound(InData%MorisonRad))
      call RegPack(Buf, InData%MorisonRad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackVTK_SurfaceType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_VTK_SurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackVTK_SurfaceType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NumSectors
   call RegUnpack(Buf, OutData%NumSectors)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubRad
   call RegUnpack(Buf, OutData%HubRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GroundRad
   call RegUnpack(Buf, OutData%GroundRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacelleBox
   call RegUnpack(Buf, OutData%NacelleBox)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerRad
   if (allocated(OutData%TowerRad)) deallocate(OutData%TowerRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TowerRad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TowerRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TowerRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NWaveElevPts
   call RegUnpack(Buf, OutData%NWaveElevPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevXY
   if (allocated(OutData%WaveElevXY)) deallocate(OutData%WaveElevXY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevXY(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevXY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevXY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveElev
   if (allocated(OutData%WaveElev)) deallocate(OutData%WaveElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElev(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElev)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeShape
   if (allocated(OutData%BladeShape)) deallocate(OutData%BladeShape)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeShape(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeShape.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FAST_UnpackVTK_BLSurfaceType(Buf, OutData%BladeShape(i1)) ! BladeShape 
      end do
   end if
   ! MorisonRad
   if (allocated(OutData%MorisonRad)) deallocate(OutData%MorisonRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MorisonRad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MorisonRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MorisonRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyVTK_ModeShapeType( SrcVTK_ModeShapeTypeData, DstVTK_ModeShapeTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_VTK_ModeShapeType), INTENT(IN) :: SrcVTK_ModeShapeTypeData
   TYPE(FAST_VTK_ModeShapeType), INTENT(INOUT) :: DstVTK_ModeShapeTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyVTK_ModeShapeType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstVTK_ModeShapeTypeData%CheckpointRoot = SrcVTK_ModeShapeTypeData%CheckpointRoot
    DstVTK_ModeShapeTypeData%MatlabFileName = SrcVTK_ModeShapeTypeData%MatlabFileName
    DstVTK_ModeShapeTypeData%VTKLinModes = SrcVTK_ModeShapeTypeData%VTKLinModes
IF (ALLOCATED(SrcVTK_ModeShapeTypeData%VTKModes)) THEN
  i1_l = LBOUND(SrcVTK_ModeShapeTypeData%VTKModes,1)
  i1_u = UBOUND(SrcVTK_ModeShapeTypeData%VTKModes,1)
  IF (.NOT. ALLOCATED(DstVTK_ModeShapeTypeData%VTKModes)) THEN 
    ALLOCATE(DstVTK_ModeShapeTypeData%VTKModes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%VTKModes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_ModeShapeTypeData%VTKModes = SrcVTK_ModeShapeTypeData%VTKModes
ENDIF
    DstVTK_ModeShapeTypeData%VTKLinTim = SrcVTK_ModeShapeTypeData%VTKLinTim
    DstVTK_ModeShapeTypeData%VTKNLinTimes = SrcVTK_ModeShapeTypeData%VTKNLinTimes
    DstVTK_ModeShapeTypeData%VTKLinScale = SrcVTK_ModeShapeTypeData%VTKLinScale
    DstVTK_ModeShapeTypeData%VTKLinPhase = SrcVTK_ModeShapeTypeData%VTKLinPhase
IF (ALLOCATED(SrcVTK_ModeShapeTypeData%DampingRatio)) THEN
  i1_l = LBOUND(SrcVTK_ModeShapeTypeData%DampingRatio,1)
  i1_u = UBOUND(SrcVTK_ModeShapeTypeData%DampingRatio,1)
  IF (.NOT. ALLOCATED(DstVTK_ModeShapeTypeData%DampingRatio)) THEN 
    ALLOCATE(DstVTK_ModeShapeTypeData%DampingRatio(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%DampingRatio.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_ModeShapeTypeData%DampingRatio = SrcVTK_ModeShapeTypeData%DampingRatio
ENDIF
IF (ALLOCATED(SrcVTK_ModeShapeTypeData%NaturalFreq_Hz)) THEN
  i1_l = LBOUND(SrcVTK_ModeShapeTypeData%NaturalFreq_Hz,1)
  i1_u = UBOUND(SrcVTK_ModeShapeTypeData%NaturalFreq_Hz,1)
  IF (.NOT. ALLOCATED(DstVTK_ModeShapeTypeData%NaturalFreq_Hz)) THEN 
    ALLOCATE(DstVTK_ModeShapeTypeData%NaturalFreq_Hz(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%NaturalFreq_Hz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_ModeShapeTypeData%NaturalFreq_Hz = SrcVTK_ModeShapeTypeData%NaturalFreq_Hz
ENDIF
IF (ALLOCATED(SrcVTK_ModeShapeTypeData%DampedFreq_Hz)) THEN
  i1_l = LBOUND(SrcVTK_ModeShapeTypeData%DampedFreq_Hz,1)
  i1_u = UBOUND(SrcVTK_ModeShapeTypeData%DampedFreq_Hz,1)
  IF (.NOT. ALLOCATED(DstVTK_ModeShapeTypeData%DampedFreq_Hz)) THEN 
    ALLOCATE(DstVTK_ModeShapeTypeData%DampedFreq_Hz(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%DampedFreq_Hz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_ModeShapeTypeData%DampedFreq_Hz = SrcVTK_ModeShapeTypeData%DampedFreq_Hz
ENDIF
IF (ALLOCATED(SrcVTK_ModeShapeTypeData%x_eig_magnitude)) THEN
  i1_l = LBOUND(SrcVTK_ModeShapeTypeData%x_eig_magnitude,1)
  i1_u = UBOUND(SrcVTK_ModeShapeTypeData%x_eig_magnitude,1)
  i2_l = LBOUND(SrcVTK_ModeShapeTypeData%x_eig_magnitude,2)
  i2_u = UBOUND(SrcVTK_ModeShapeTypeData%x_eig_magnitude,2)
  i3_l = LBOUND(SrcVTK_ModeShapeTypeData%x_eig_magnitude,3)
  i3_u = UBOUND(SrcVTK_ModeShapeTypeData%x_eig_magnitude,3)
  IF (.NOT. ALLOCATED(DstVTK_ModeShapeTypeData%x_eig_magnitude)) THEN 
    ALLOCATE(DstVTK_ModeShapeTypeData%x_eig_magnitude(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%x_eig_magnitude.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_ModeShapeTypeData%x_eig_magnitude = SrcVTK_ModeShapeTypeData%x_eig_magnitude
ENDIF
IF (ALLOCATED(SrcVTK_ModeShapeTypeData%x_eig_phase)) THEN
  i1_l = LBOUND(SrcVTK_ModeShapeTypeData%x_eig_phase,1)
  i1_u = UBOUND(SrcVTK_ModeShapeTypeData%x_eig_phase,1)
  i2_l = LBOUND(SrcVTK_ModeShapeTypeData%x_eig_phase,2)
  i2_u = UBOUND(SrcVTK_ModeShapeTypeData%x_eig_phase,2)
  i3_l = LBOUND(SrcVTK_ModeShapeTypeData%x_eig_phase,3)
  i3_u = UBOUND(SrcVTK_ModeShapeTypeData%x_eig_phase,3)
  IF (.NOT. ALLOCATED(DstVTK_ModeShapeTypeData%x_eig_phase)) THEN 
    ALLOCATE(DstVTK_ModeShapeTypeData%x_eig_phase(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_ModeShapeTypeData%x_eig_phase.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_ModeShapeTypeData%x_eig_phase = SrcVTK_ModeShapeTypeData%x_eig_phase
ENDIF
 END SUBROUTINE FAST_CopyVTK_ModeShapeType

 SUBROUTINE FAST_DestroyVTK_ModeShapeType( VTK_ModeShapeTypeData, ErrStat, ErrMsg )
  TYPE(FAST_VTK_ModeShapeType), INTENT(INOUT) :: VTK_ModeShapeTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyVTK_ModeShapeType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(VTK_ModeShapeTypeData%VTKModes)) THEN
  DEALLOCATE(VTK_ModeShapeTypeData%VTKModes)
ENDIF
IF (ALLOCATED(VTK_ModeShapeTypeData%DampingRatio)) THEN
  DEALLOCATE(VTK_ModeShapeTypeData%DampingRatio)
ENDIF
IF (ALLOCATED(VTK_ModeShapeTypeData%NaturalFreq_Hz)) THEN
  DEALLOCATE(VTK_ModeShapeTypeData%NaturalFreq_Hz)
ENDIF
IF (ALLOCATED(VTK_ModeShapeTypeData%DampedFreq_Hz)) THEN
  DEALLOCATE(VTK_ModeShapeTypeData%DampedFreq_Hz)
ENDIF
IF (ALLOCATED(VTK_ModeShapeTypeData%x_eig_magnitude)) THEN
  DEALLOCATE(VTK_ModeShapeTypeData%x_eig_magnitude)
ENDIF
IF (ALLOCATED(VTK_ModeShapeTypeData%x_eig_phase)) THEN
  DEALLOCATE(VTK_ModeShapeTypeData%x_eig_phase)
ENDIF
 END SUBROUTINE FAST_DestroyVTK_ModeShapeType


subroutine FAST_PackVTK_ModeShapeType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_VTK_ModeShapeType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackVTK_ModeShapeType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! CheckpointRoot
   call RegPack(Buf, InData%CheckpointRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MatlabFileName
   call RegPack(Buf, InData%MatlabFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinModes
   call RegPack(Buf, InData%VTKLinModes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKModes
   call RegPack(Buf, allocated(InData%VTKModes))
   if (allocated(InData%VTKModes)) then
      call RegPackBounds(Buf, 1, lbound(InData%VTKModes), ubound(InData%VTKModes))
      call RegPack(Buf, InData%VTKModes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinTim
   call RegPack(Buf, InData%VTKLinTim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKNLinTimes
   call RegPack(Buf, InData%VTKNLinTimes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinScale
   call RegPack(Buf, InData%VTKLinScale)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinPhase
   call RegPack(Buf, InData%VTKLinPhase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DampingRatio
   call RegPack(Buf, allocated(InData%DampingRatio))
   if (allocated(InData%DampingRatio)) then
      call RegPackBounds(Buf, 1, lbound(InData%DampingRatio), ubound(InData%DampingRatio))
      call RegPack(Buf, InData%DampingRatio)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NaturalFreq_Hz
   call RegPack(Buf, allocated(InData%NaturalFreq_Hz))
   if (allocated(InData%NaturalFreq_Hz)) then
      call RegPackBounds(Buf, 1, lbound(InData%NaturalFreq_Hz), ubound(InData%NaturalFreq_Hz))
      call RegPack(Buf, InData%NaturalFreq_Hz)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DampedFreq_Hz
   call RegPack(Buf, allocated(InData%DampedFreq_Hz))
   if (allocated(InData%DampedFreq_Hz)) then
      call RegPackBounds(Buf, 1, lbound(InData%DampedFreq_Hz), ubound(InData%DampedFreq_Hz))
      call RegPack(Buf, InData%DampedFreq_Hz)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_eig_magnitude
   call RegPack(Buf, allocated(InData%x_eig_magnitude))
   if (allocated(InData%x_eig_magnitude)) then
      call RegPackBounds(Buf, 3, lbound(InData%x_eig_magnitude), ubound(InData%x_eig_magnitude))
      call RegPack(Buf, InData%x_eig_magnitude)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_eig_phase
   call RegPack(Buf, allocated(InData%x_eig_phase))
   if (allocated(InData%x_eig_phase)) then
      call RegPackBounds(Buf, 3, lbound(InData%x_eig_phase), ubound(InData%x_eig_phase))
      call RegPack(Buf, InData%x_eig_phase)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackVTK_ModeShapeType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_VTK_ModeShapeType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackVTK_ModeShapeType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! CheckpointRoot
   call RegUnpack(Buf, OutData%CheckpointRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MatlabFileName
   call RegUnpack(Buf, OutData%MatlabFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinModes
   call RegUnpack(Buf, OutData%VTKLinModes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKModes
   if (allocated(OutData%VTKModes)) deallocate(OutData%VTKModes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VTKModes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VTKModes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VTKModes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VTKLinTim
   call RegUnpack(Buf, OutData%VTKLinTim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKNLinTimes
   call RegUnpack(Buf, OutData%VTKNLinTimes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinScale
   call RegUnpack(Buf, OutData%VTKLinScale)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKLinPhase
   call RegUnpack(Buf, OutData%VTKLinPhase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DampingRatio
   if (allocated(OutData%DampingRatio)) deallocate(OutData%DampingRatio)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DampingRatio(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DampingRatio.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DampingRatio)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NaturalFreq_Hz
   if (allocated(OutData%NaturalFreq_Hz)) deallocate(OutData%NaturalFreq_Hz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NaturalFreq_Hz(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NaturalFreq_Hz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NaturalFreq_Hz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DampedFreq_Hz
   if (allocated(OutData%DampedFreq_Hz)) deallocate(OutData%DampedFreq_Hz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DampedFreq_Hz(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DampedFreq_Hz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DampedFreq_Hz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! x_eig_magnitude
   if (allocated(OutData%x_eig_magnitude)) deallocate(OutData%x_eig_magnitude)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_eig_magnitude(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_eig_magnitude.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%x_eig_magnitude)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! x_eig_phase
   if (allocated(OutData%x_eig_phase)) deallocate(OutData%x_eig_phase)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_eig_phase(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_eig_phase.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%x_eig_phase)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(FAST_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%DT_module = SrcParamData%DT_module
    DstParamData%n_substeps = SrcParamData%n_substeps
    DstParamData%n_TMax_m1 = SrcParamData%n_TMax_m1
    DstParamData%TMax = SrcParamData%TMax
    DstParamData%InterpOrder = SrcParamData%InterpOrder
    DstParamData%NumCrctn = SrcParamData%NumCrctn
    DstParamData%KMax = SrcParamData%KMax
    DstParamData%numIceLegs = SrcParamData%numIceLegs
    DstParamData%nBeams = SrcParamData%nBeams
    DstParamData%BD_OutputSibling = SrcParamData%BD_OutputSibling
    DstParamData%ModuleInitialized = SrcParamData%ModuleInitialized
    DstParamData%DT_Ujac = SrcParamData%DT_Ujac
    DstParamData%UJacSclFact = SrcParamData%UJacSclFact
    DstParamData%SizeJac_Opt1 = SrcParamData%SizeJac_Opt1
    DstParamData%SolveOption = SrcParamData%SolveOption
    DstParamData%CompElast = SrcParamData%CompElast
    DstParamData%CompInflow = SrcParamData%CompInflow
    DstParamData%CompAero = SrcParamData%CompAero
    DstParamData%CompServo = SrcParamData%CompServo
    DstParamData%CompSeaSt = SrcParamData%CompSeaSt
    DstParamData%CompHydro = SrcParamData%CompHydro
    DstParamData%CompSub = SrcParamData%CompSub
    DstParamData%CompMooring = SrcParamData%CompMooring
    DstParamData%CompIce = SrcParamData%CompIce
    DstParamData%MHK = SrcParamData%MHK
    DstParamData%UseDWM = SrcParamData%UseDWM
    DstParamData%Linearize = SrcParamData%Linearize
    DstParamData%WaveFieldMod = SrcParamData%WaveFieldMod
    DstParamData%FarmIntegration = SrcParamData%FarmIntegration
    DstParamData%TurbinePos = SrcParamData%TurbinePos
    DstParamData%Gravity = SrcParamData%Gravity
    DstParamData%AirDens = SrcParamData%AirDens
    DstParamData%WtrDens = SrcParamData%WtrDens
    DstParamData%KinVisc = SrcParamData%KinVisc
    DstParamData%SpdSound = SrcParamData%SpdSound
    DstParamData%Patm = SrcParamData%Patm
    DstParamData%Pvap = SrcParamData%Pvap
    DstParamData%WtrDpth = SrcParamData%WtrDpth
    DstParamData%MSL2SWL = SrcParamData%MSL2SWL
    DstParamData%EDFile = SrcParamData%EDFile
    DstParamData%BDBldFile = SrcParamData%BDBldFile
    DstParamData%InflowFile = SrcParamData%InflowFile
    DstParamData%AeroFile = SrcParamData%AeroFile
    DstParamData%ServoFile = SrcParamData%ServoFile
    DstParamData%SeaStFile = SrcParamData%SeaStFile
    DstParamData%HydroFile = SrcParamData%HydroFile
    DstParamData%SubFile = SrcParamData%SubFile
    DstParamData%MooringFile = SrcParamData%MooringFile
    DstParamData%IceFile = SrcParamData%IceFile
    DstParamData%TStart = SrcParamData%TStart
    DstParamData%DT_Out = SrcParamData%DT_Out
    DstParamData%WrSttsTime = SrcParamData%WrSttsTime
    DstParamData%n_SttsTime = SrcParamData%n_SttsTime
    DstParamData%n_ChkptTime = SrcParamData%n_ChkptTime
    DstParamData%n_DT_Out = SrcParamData%n_DT_Out
    DstParamData%n_VTKTime = SrcParamData%n_VTKTime
    DstParamData%TurbineType = SrcParamData%TurbineType
    DstParamData%WrBinOutFile = SrcParamData%WrBinOutFile
    DstParamData%WrTxtOutFile = SrcParamData%WrTxtOutFile
    DstParamData%WrBinMod = SrcParamData%WrBinMod
    DstParamData%SumPrint = SrcParamData%SumPrint
    DstParamData%WrVTK = SrcParamData%WrVTK
    DstParamData%VTK_Type = SrcParamData%VTK_Type
    DstParamData%VTK_fields = SrcParamData%VTK_fields
    DstParamData%Delim = SrcParamData%Delim
    DstParamData%OutFmt = SrcParamData%OutFmt
    DstParamData%OutFmt_t = SrcParamData%OutFmt_t
    DstParamData%FmtWidth = SrcParamData%FmtWidth
    DstParamData%TChanLen = SrcParamData%TChanLen
    DstParamData%OutFileRoot = SrcParamData%OutFileRoot
    DstParamData%FTitle = SrcParamData%FTitle
    DstParamData%VTK_OutFileRoot = SrcParamData%VTK_OutFileRoot
    DstParamData%VTK_tWidth = SrcParamData%VTK_tWidth
    DstParamData%VTK_fps = SrcParamData%VTK_fps
      CALL FAST_Copyvtk_surfacetype( SrcParamData%VTK_surface, DstParamData%VTK_surface, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstParamData%Tdesc = SrcParamData%Tdesc
    DstParamData%CalcSteady = SrcParamData%CalcSteady
    DstParamData%TrimCase = SrcParamData%TrimCase
    DstParamData%TrimTol = SrcParamData%TrimTol
    DstParamData%TrimGain = SrcParamData%TrimGain
    DstParamData%Twr_Kdmp = SrcParamData%Twr_Kdmp
    DstParamData%Bld_Kdmp = SrcParamData%Bld_Kdmp
    DstParamData%NLinTimes = SrcParamData%NLinTimes
    DstParamData%AzimDelta = SrcParamData%AzimDelta
    DstParamData%LinInputs = SrcParamData%LinInputs
    DstParamData%LinOutputs = SrcParamData%LinOutputs
    DstParamData%LinOutJac = SrcParamData%LinOutJac
    DstParamData%LinOutMod = SrcParamData%LinOutMod
      CALL FAST_Copyvtk_modeshapetype( SrcParamData%VTK_modes, DstParamData%VTK_modes, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstParamData%UseSC = SrcParamData%UseSC
    DstParamData%Lin_NumMods = SrcParamData%Lin_NumMods
    DstParamData%Lin_ModOrder = SrcParamData%Lin_ModOrder
    DstParamData%LinInterpOrder = SrcParamData%LinInterpOrder
 END SUBROUTINE FAST_CopyParam

 SUBROUTINE FAST_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FAST_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL FAST_DestroyVTK_SurfaceType( ParamData%VTK_surface, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyVTK_ModeShapeType( ParamData%VTK_modes, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyParam


subroutine FAST_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT_module
   call RegPack(Buf, InData%DT_module)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_substeps
   call RegPack(Buf, InData%n_substeps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_TMax_m1
   call RegPack(Buf, InData%n_TMax_m1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMax
   call RegPack(Buf, InData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InterpOrder
   call RegPack(Buf, InData%InterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCrctn
   call RegPack(Buf, InData%NumCrctn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KMax
   call RegPack(Buf, InData%KMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! numIceLegs
   call RegPack(Buf, InData%numIceLegs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBeams
   call RegPack(Buf, InData%nBeams)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BD_OutputSibling
   call RegPack(Buf, InData%BD_OutputSibling)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ModuleInitialized
   call RegPack(Buf, InData%ModuleInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT_Ujac
   call RegPack(Buf, InData%DT_Ujac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UJacSclFact
   call RegPack(Buf, InData%UJacSclFact)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SizeJac_Opt1
   call RegPack(Buf, InData%SizeJac_Opt1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SolveOption
   call RegPack(Buf, InData%SolveOption)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompElast
   call RegPack(Buf, InData%CompElast)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompInflow
   call RegPack(Buf, InData%CompInflow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAero
   call RegPack(Buf, InData%CompAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompServo
   call RegPack(Buf, InData%CompServo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompSeaSt
   call RegPack(Buf, InData%CompSeaSt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompHydro
   call RegPack(Buf, InData%CompHydro)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompSub
   call RegPack(Buf, InData%CompSub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompMooring
   call RegPack(Buf, InData%CompMooring)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompIce
   call RegPack(Buf, InData%CompIce)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegPack(Buf, InData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseDWM
   call RegPack(Buf, InData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegPack(Buf, InData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FarmIntegration
   call RegPack(Buf, InData%FarmIntegration)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbinePos
   call RegPack(Buf, InData%TurbinePos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdSound
   call RegPack(Buf, InData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Patm
   call RegPack(Buf, InData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pvap
   call RegPack(Buf, InData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EDFile
   call RegPack(Buf, InData%EDFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BDBldFile
   call RegPack(Buf, InData%BDBldFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowFile
   call RegPack(Buf, InData%InflowFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroFile
   call RegPack(Buf, InData%AeroFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ServoFile
   call RegPack(Buf, InData%ServoFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaStFile
   call RegPack(Buf, InData%SeaStFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HydroFile
   call RegPack(Buf, InData%HydroFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubFile
   call RegPack(Buf, InData%SubFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MooringFile
   call RegPack(Buf, InData%MooringFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IceFile
   call RegPack(Buf, InData%IceFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStart
   call RegPack(Buf, InData%TStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT_Out
   call RegPack(Buf, InData%DT_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrSttsTime
   call RegPack(Buf, InData%WrSttsTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_SttsTime
   call RegPack(Buf, InData%n_SttsTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_ChkptTime
   call RegPack(Buf, InData%n_ChkptTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_DT_Out
   call RegPack(Buf, InData%n_DT_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_VTKTime
   call RegPack(Buf, InData%n_VTKTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineType
   call RegPack(Buf, InData%TurbineType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrBinOutFile
   call RegPack(Buf, InData%WrBinOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrTxtOutFile
   call RegPack(Buf, InData%WrTxtOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrBinMod
   call RegPack(Buf, InData%WrBinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegPack(Buf, InData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrVTK
   call RegPack(Buf, InData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_Type
   call RegPack(Buf, InData%VTK_Type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_fields
   call RegPack(Buf, InData%VTK_fields)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt_t
   call RegPack(Buf, InData%OutFmt_t)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FmtWidth
   call RegPack(Buf, InData%FmtWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TChanLen
   call RegPack(Buf, InData%TChanLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegPack(Buf, InData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FTitle
   call RegPack(Buf, InData%FTitle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_OutFileRoot
   call RegPack(Buf, InData%VTK_OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_tWidth
   call RegPack(Buf, InData%VTK_tWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_fps
   call RegPack(Buf, InData%VTK_fps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_surface
   call FAST_PackVTK_SurfaceType(Buf, InData%VTK_surface) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tdesc
   call RegPack(Buf, InData%Tdesc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CalcSteady
   call RegPack(Buf, InData%CalcSteady)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimCase
   call RegPack(Buf, InData%TrimCase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimTol
   call RegPack(Buf, InData%TrimTol)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimGain
   call RegPack(Buf, InData%TrimGain)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Twr_Kdmp
   call RegPack(Buf, InData%Twr_Kdmp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Bld_Kdmp
   call RegPack(Buf, InData%Bld_Kdmp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NLinTimes
   call RegPack(Buf, InData%NLinTimes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AzimDelta
   call RegPack(Buf, InData%AzimDelta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinInputs
   call RegPack(Buf, InData%LinInputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinOutputs
   call RegPack(Buf, InData%LinOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinOutJac
   call RegPack(Buf, InData%LinOutJac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinOutMod
   call RegPack(Buf, InData%LinOutMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_modes
   call FAST_PackVTK_ModeShapeType(Buf, InData%VTK_modes) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseSC
   call RegPack(Buf, InData%UseSC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin_NumMods
   call RegPack(Buf, InData%Lin_NumMods)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin_ModOrder
   call RegPack(Buf, InData%Lin_ModOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinInterpOrder
   call RegPack(Buf, InData%LinInterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackParam'
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT_module
   call RegUnpack(Buf, OutData%DT_module)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_substeps
   call RegUnpack(Buf, OutData%n_substeps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_TMax_m1
   call RegUnpack(Buf, OutData%n_TMax_m1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMax
   call RegUnpack(Buf, OutData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InterpOrder
   call RegUnpack(Buf, OutData%InterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCrctn
   call RegUnpack(Buf, OutData%NumCrctn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KMax
   call RegUnpack(Buf, OutData%KMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! numIceLegs
   call RegUnpack(Buf, OutData%numIceLegs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBeams
   call RegUnpack(Buf, OutData%nBeams)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BD_OutputSibling
   call RegUnpack(Buf, OutData%BD_OutputSibling)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ModuleInitialized
   call RegUnpack(Buf, OutData%ModuleInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT_Ujac
   call RegUnpack(Buf, OutData%DT_Ujac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UJacSclFact
   call RegUnpack(Buf, OutData%UJacSclFact)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SizeJac_Opt1
   call RegUnpack(Buf, OutData%SizeJac_Opt1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SolveOption
   call RegUnpack(Buf, OutData%SolveOption)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompElast
   call RegUnpack(Buf, OutData%CompElast)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompInflow
   call RegUnpack(Buf, OutData%CompInflow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAero
   call RegUnpack(Buf, OutData%CompAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompServo
   call RegUnpack(Buf, OutData%CompServo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompSeaSt
   call RegUnpack(Buf, OutData%CompSeaSt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompHydro
   call RegUnpack(Buf, OutData%CompHydro)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompSub
   call RegUnpack(Buf, OutData%CompSub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompMooring
   call RegUnpack(Buf, OutData%CompMooring)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompIce
   call RegUnpack(Buf, OutData%CompIce)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseDWM
   call RegUnpack(Buf, OutData%UseDWM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegUnpack(Buf, OutData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FarmIntegration
   call RegUnpack(Buf, OutData%FarmIntegration)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbinePos
   call RegUnpack(Buf, OutData%TurbinePos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdSound
   call RegUnpack(Buf, OutData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Patm
   call RegUnpack(Buf, OutData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pvap
   call RegUnpack(Buf, OutData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EDFile
   call RegUnpack(Buf, OutData%EDFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BDBldFile
   call RegUnpack(Buf, OutData%BDBldFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowFile
   call RegUnpack(Buf, OutData%InflowFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroFile
   call RegUnpack(Buf, OutData%AeroFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ServoFile
   call RegUnpack(Buf, OutData%ServoFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaStFile
   call RegUnpack(Buf, OutData%SeaStFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HydroFile
   call RegUnpack(Buf, OutData%HydroFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubFile
   call RegUnpack(Buf, OutData%SubFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MooringFile
   call RegUnpack(Buf, OutData%MooringFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IceFile
   call RegUnpack(Buf, OutData%IceFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStart
   call RegUnpack(Buf, OutData%TStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT_Out
   call RegUnpack(Buf, OutData%DT_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrSttsTime
   call RegUnpack(Buf, OutData%WrSttsTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_SttsTime
   call RegUnpack(Buf, OutData%n_SttsTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_ChkptTime
   call RegUnpack(Buf, OutData%n_ChkptTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_DT_Out
   call RegUnpack(Buf, OutData%n_DT_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_VTKTime
   call RegUnpack(Buf, OutData%n_VTKTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineType
   call RegUnpack(Buf, OutData%TurbineType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrBinOutFile
   call RegUnpack(Buf, OutData%WrBinOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrTxtOutFile
   call RegUnpack(Buf, OutData%WrTxtOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrBinMod
   call RegUnpack(Buf, OutData%WrBinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrVTK
   call RegUnpack(Buf, OutData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_Type
   call RegUnpack(Buf, OutData%VTK_Type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_fields
   call RegUnpack(Buf, OutData%VTK_fields)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt_t
   call RegUnpack(Buf, OutData%OutFmt_t)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FmtWidth
   call RegUnpack(Buf, OutData%FmtWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TChanLen
   call RegUnpack(Buf, OutData%TChanLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegUnpack(Buf, OutData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FTitle
   call RegUnpack(Buf, OutData%FTitle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_OutFileRoot
   call RegUnpack(Buf, OutData%VTK_OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_tWidth
   call RegUnpack(Buf, OutData%VTK_tWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_fps
   call RegUnpack(Buf, OutData%VTK_fps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_surface
   call FAST_UnpackVTK_SurfaceType(Buf, OutData%VTK_surface) ! VTK_surface 
   ! Tdesc
   call RegUnpack(Buf, OutData%Tdesc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CalcSteady
   call RegUnpack(Buf, OutData%CalcSteady)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimCase
   call RegUnpack(Buf, OutData%TrimCase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimTol
   call RegUnpack(Buf, OutData%TrimTol)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TrimGain
   call RegUnpack(Buf, OutData%TrimGain)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Twr_Kdmp
   call RegUnpack(Buf, OutData%Twr_Kdmp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Bld_Kdmp
   call RegUnpack(Buf, OutData%Bld_Kdmp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NLinTimes
   call RegUnpack(Buf, OutData%NLinTimes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AzimDelta
   call RegUnpack(Buf, OutData%AzimDelta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinInputs
   call RegUnpack(Buf, OutData%LinInputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinOutputs
   call RegUnpack(Buf, OutData%LinOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinOutJac
   call RegUnpack(Buf, OutData%LinOutJac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinOutMod
   call RegUnpack(Buf, OutData%LinOutMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_modes
   call FAST_UnpackVTK_ModeShapeType(Buf, OutData%VTK_modes) ! VTK_modes 
   ! UseSC
   call RegUnpack(Buf, OutData%UseSC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin_NumMods
   call RegUnpack(Buf, OutData%Lin_NumMods)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin_ModOrder
   call RegUnpack(Buf, OutData%Lin_ModOrder)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinInterpOrder
   call RegUnpack(Buf, OutData%LinInterpOrder)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FAST_CopyLinStateSave( SrcLinStateSaveData, DstLinStateSaveData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_LinStateSave), INTENT(INOUT) :: SrcLinStateSaveData
   TYPE(FAST_LinStateSave), INTENT(INOUT) :: DstLinStateSaveData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyLinStateSave'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcLinStateSaveData%x_IceD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_IceD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_IceD,1)
  i2_l = LBOUND(SrcLinStateSaveData%x_IceD,2)
  i2_u = UBOUND(SrcLinStateSaveData%x_IceD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_IceD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_IceD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_IceD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%x_IceD,2), UBOUND(SrcLinStateSaveData%x_IceD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%x_IceD,1), UBOUND(SrcLinStateSaveData%x_IceD,1)
      CALL IceD_CopyContState( SrcLinStateSaveData%x_IceD(i1,i2), DstLinStateSaveData%x_IceD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_IceD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_IceD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_IceD,1)
  i2_l = LBOUND(SrcLinStateSaveData%xd_IceD,2)
  i2_u = UBOUND(SrcLinStateSaveData%xd_IceD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_IceD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_IceD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_IceD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%xd_IceD,2), UBOUND(SrcLinStateSaveData%xd_IceD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%xd_IceD,1), UBOUND(SrcLinStateSaveData%xd_IceD,1)
      CALL IceD_CopyDiscState( SrcLinStateSaveData%xd_IceD(i1,i2), DstLinStateSaveData%xd_IceD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_IceD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_IceD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_IceD,1)
  i2_l = LBOUND(SrcLinStateSaveData%z_IceD,2)
  i2_u = UBOUND(SrcLinStateSaveData%z_IceD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_IceD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_IceD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_IceD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%z_IceD,2), UBOUND(SrcLinStateSaveData%z_IceD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%z_IceD,1), UBOUND(SrcLinStateSaveData%z_IceD,1)
      CALL IceD_CopyConstrState( SrcLinStateSaveData%z_IceD(i1,i2), DstLinStateSaveData%z_IceD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_IceD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_IceD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_IceD,1)
  i2_l = LBOUND(SrcLinStateSaveData%OtherSt_IceD,2)
  i2_u = UBOUND(SrcLinStateSaveData%OtherSt_IceD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_IceD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_IceD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_IceD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%OtherSt_IceD,2), UBOUND(SrcLinStateSaveData%OtherSt_IceD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_IceD,1), UBOUND(SrcLinStateSaveData%OtherSt_IceD,1)
      CALL IceD_CopyOtherState( SrcLinStateSaveData%OtherSt_IceD(i1,i2), DstLinStateSaveData%OtherSt_IceD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_IceD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_IceD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_IceD,1)
  i2_l = LBOUND(SrcLinStateSaveData%u_IceD,2)
  i2_u = UBOUND(SrcLinStateSaveData%u_IceD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_IceD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_IceD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_IceD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%u_IceD,2), UBOUND(SrcLinStateSaveData%u_IceD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%u_IceD,1), UBOUND(SrcLinStateSaveData%u_IceD,1)
      CALL IceD_CopyInput( SrcLinStateSaveData%u_IceD(i1,i2), DstLinStateSaveData%u_IceD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_BD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_BD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_BD,1)
  i2_l = LBOUND(SrcLinStateSaveData%x_BD,2)
  i2_u = UBOUND(SrcLinStateSaveData%x_BD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_BD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_BD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_BD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%x_BD,2), UBOUND(SrcLinStateSaveData%x_BD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%x_BD,1), UBOUND(SrcLinStateSaveData%x_BD,1)
      CALL BD_CopyContState( SrcLinStateSaveData%x_BD(i1,i2), DstLinStateSaveData%x_BD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_BD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_BD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_BD,1)
  i2_l = LBOUND(SrcLinStateSaveData%xd_BD,2)
  i2_u = UBOUND(SrcLinStateSaveData%xd_BD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_BD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_BD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_BD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%xd_BD,2), UBOUND(SrcLinStateSaveData%xd_BD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%xd_BD,1), UBOUND(SrcLinStateSaveData%xd_BD,1)
      CALL BD_CopyDiscState( SrcLinStateSaveData%xd_BD(i1,i2), DstLinStateSaveData%xd_BD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_BD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_BD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_BD,1)
  i2_l = LBOUND(SrcLinStateSaveData%z_BD,2)
  i2_u = UBOUND(SrcLinStateSaveData%z_BD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_BD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_BD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_BD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%z_BD,2), UBOUND(SrcLinStateSaveData%z_BD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%z_BD,1), UBOUND(SrcLinStateSaveData%z_BD,1)
      CALL BD_CopyConstrState( SrcLinStateSaveData%z_BD(i1,i2), DstLinStateSaveData%z_BD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_BD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_BD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_BD,1)
  i2_l = LBOUND(SrcLinStateSaveData%OtherSt_BD,2)
  i2_u = UBOUND(SrcLinStateSaveData%OtherSt_BD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_BD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_BD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_BD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%OtherSt_BD,2), UBOUND(SrcLinStateSaveData%OtherSt_BD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_BD,1), UBOUND(SrcLinStateSaveData%OtherSt_BD,1)
      CALL BD_CopyOtherState( SrcLinStateSaveData%OtherSt_BD(i1,i2), DstLinStateSaveData%OtherSt_BD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_BD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_BD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_BD,1)
  i2_l = LBOUND(SrcLinStateSaveData%u_BD,2)
  i2_u = UBOUND(SrcLinStateSaveData%u_BD,2)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_BD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_BD(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_BD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcLinStateSaveData%u_BD,2), UBOUND(SrcLinStateSaveData%u_BD,2)
    DO i1 = LBOUND(SrcLinStateSaveData%u_BD,1), UBOUND(SrcLinStateSaveData%u_BD,1)
      CALL BD_CopyInput( SrcLinStateSaveData%u_BD(i1,i2), DstLinStateSaveData%u_BD(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_ED)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_ED,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_ED,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_ED)) THEN 
    ALLOCATE(DstLinStateSaveData%x_ED(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_ED.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_ED,1), UBOUND(SrcLinStateSaveData%x_ED,1)
      CALL ED_CopyContState( SrcLinStateSaveData%x_ED(i1), DstLinStateSaveData%x_ED(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_ED)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_ED,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_ED,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_ED)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_ED(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_ED.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_ED,1), UBOUND(SrcLinStateSaveData%xd_ED,1)
      CALL ED_CopyDiscState( SrcLinStateSaveData%xd_ED(i1), DstLinStateSaveData%xd_ED(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_ED)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_ED,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_ED,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_ED)) THEN 
    ALLOCATE(DstLinStateSaveData%z_ED(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_ED.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_ED,1), UBOUND(SrcLinStateSaveData%z_ED,1)
      CALL ED_CopyConstrState( SrcLinStateSaveData%z_ED(i1), DstLinStateSaveData%z_ED(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_ED)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_ED,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_ED,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_ED)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_ED(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_ED.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_ED,1), UBOUND(SrcLinStateSaveData%OtherSt_ED,1)
      CALL ED_CopyOtherState( SrcLinStateSaveData%OtherSt_ED(i1), DstLinStateSaveData%OtherSt_ED(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_ED)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_ED,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_ED,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_ED)) THEN 
    ALLOCATE(DstLinStateSaveData%u_ED(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_ED.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_ED,1), UBOUND(SrcLinStateSaveData%u_ED,1)
      CALL ED_CopyInput( SrcLinStateSaveData%u_ED(i1), DstLinStateSaveData%u_ED(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_SrvD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_SrvD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_SrvD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_SrvD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_SrvD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_SrvD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_SrvD,1), UBOUND(SrcLinStateSaveData%x_SrvD,1)
      CALL SrvD_CopyContState( SrcLinStateSaveData%x_SrvD(i1), DstLinStateSaveData%x_SrvD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_SrvD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_SrvD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_SrvD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_SrvD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_SrvD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_SrvD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_SrvD,1), UBOUND(SrcLinStateSaveData%xd_SrvD,1)
      CALL SrvD_CopyDiscState( SrcLinStateSaveData%xd_SrvD(i1), DstLinStateSaveData%xd_SrvD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_SrvD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_SrvD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_SrvD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_SrvD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_SrvD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_SrvD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_SrvD,1), UBOUND(SrcLinStateSaveData%z_SrvD,1)
      CALL SrvD_CopyConstrState( SrcLinStateSaveData%z_SrvD(i1), DstLinStateSaveData%z_SrvD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_SrvD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_SrvD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_SrvD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_SrvD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_SrvD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_SrvD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_SrvD,1), UBOUND(SrcLinStateSaveData%OtherSt_SrvD,1)
      CALL SrvD_CopyOtherState( SrcLinStateSaveData%OtherSt_SrvD(i1), DstLinStateSaveData%OtherSt_SrvD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_SrvD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_SrvD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_SrvD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_SrvD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_SrvD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_SrvD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_SrvD,1), UBOUND(SrcLinStateSaveData%u_SrvD,1)
      CALL SrvD_CopyInput( SrcLinStateSaveData%u_SrvD(i1), DstLinStateSaveData%u_SrvD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_AD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_AD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_AD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_AD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_AD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_AD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_AD,1), UBOUND(SrcLinStateSaveData%x_AD,1)
      CALL AD_CopyContState( SrcLinStateSaveData%x_AD(i1), DstLinStateSaveData%x_AD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_AD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_AD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_AD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_AD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_AD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_AD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_AD,1), UBOUND(SrcLinStateSaveData%xd_AD,1)
      CALL AD_CopyDiscState( SrcLinStateSaveData%xd_AD(i1), DstLinStateSaveData%xd_AD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_AD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_AD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_AD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_AD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_AD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_AD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_AD,1), UBOUND(SrcLinStateSaveData%z_AD,1)
      CALL AD_CopyConstrState( SrcLinStateSaveData%z_AD(i1), DstLinStateSaveData%z_AD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_AD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_AD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_AD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_AD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_AD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_AD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_AD,1), UBOUND(SrcLinStateSaveData%OtherSt_AD,1)
      CALL AD_CopyOtherState( SrcLinStateSaveData%OtherSt_AD(i1), DstLinStateSaveData%OtherSt_AD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_AD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_AD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_AD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_AD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_AD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_AD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_AD,1), UBOUND(SrcLinStateSaveData%u_AD,1)
      CALL AD_CopyInput( SrcLinStateSaveData%u_AD(i1), DstLinStateSaveData%u_AD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_IfW)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_IfW,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_IfW,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_IfW)) THEN 
    ALLOCATE(DstLinStateSaveData%x_IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_IfW,1), UBOUND(SrcLinStateSaveData%x_IfW,1)
      CALL InflowWind_CopyContState( SrcLinStateSaveData%x_IfW(i1), DstLinStateSaveData%x_IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_IfW)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_IfW,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_IfW,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_IfW)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_IfW,1), UBOUND(SrcLinStateSaveData%xd_IfW,1)
      CALL InflowWind_CopyDiscState( SrcLinStateSaveData%xd_IfW(i1), DstLinStateSaveData%xd_IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_IfW)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_IfW,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_IfW,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_IfW)) THEN 
    ALLOCATE(DstLinStateSaveData%z_IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_IfW,1), UBOUND(SrcLinStateSaveData%z_IfW,1)
      CALL InflowWind_CopyConstrState( SrcLinStateSaveData%z_IfW(i1), DstLinStateSaveData%z_IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_IfW)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_IfW,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_IfW,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_IfW)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_IfW,1), UBOUND(SrcLinStateSaveData%OtherSt_IfW,1)
      CALL InflowWind_CopyOtherState( SrcLinStateSaveData%OtherSt_IfW(i1), DstLinStateSaveData%OtherSt_IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_IfW)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_IfW,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_IfW,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_IfW)) THEN 
    ALLOCATE(DstLinStateSaveData%u_IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_IfW,1), UBOUND(SrcLinStateSaveData%u_IfW,1)
      CALL InflowWind_CopyInput( SrcLinStateSaveData%u_IfW(i1), DstLinStateSaveData%u_IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_SD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_SD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_SD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_SD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_SD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_SD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_SD,1), UBOUND(SrcLinStateSaveData%x_SD,1)
      CALL SD_CopyContState( SrcLinStateSaveData%x_SD(i1), DstLinStateSaveData%x_SD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_SD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_SD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_SD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_SD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_SD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_SD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_SD,1), UBOUND(SrcLinStateSaveData%xd_SD,1)
      CALL SD_CopyDiscState( SrcLinStateSaveData%xd_SD(i1), DstLinStateSaveData%xd_SD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_SD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_SD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_SD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_SD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_SD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_SD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_SD,1), UBOUND(SrcLinStateSaveData%z_SD,1)
      CALL SD_CopyConstrState( SrcLinStateSaveData%z_SD(i1), DstLinStateSaveData%z_SD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_SD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_SD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_SD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_SD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_SD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_SD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_SD,1), UBOUND(SrcLinStateSaveData%OtherSt_SD,1)
      CALL SD_CopyOtherState( SrcLinStateSaveData%OtherSt_SD(i1), DstLinStateSaveData%OtherSt_SD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_SD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_SD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_SD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_SD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_SD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_SD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_SD,1), UBOUND(SrcLinStateSaveData%u_SD,1)
      CALL SD_CopyInput( SrcLinStateSaveData%u_SD(i1), DstLinStateSaveData%u_SD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_ExtPtfm)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_ExtPtfm,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_ExtPtfm,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_ExtPtfm)) THEN 
    ALLOCATE(DstLinStateSaveData%x_ExtPtfm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_ExtPtfm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_ExtPtfm,1), UBOUND(SrcLinStateSaveData%x_ExtPtfm,1)
      CALL ExtPtfm_CopyContState( SrcLinStateSaveData%x_ExtPtfm(i1), DstLinStateSaveData%x_ExtPtfm(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_ExtPtfm)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_ExtPtfm,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_ExtPtfm,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_ExtPtfm)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_ExtPtfm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_ExtPtfm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_ExtPtfm,1), UBOUND(SrcLinStateSaveData%xd_ExtPtfm,1)
      CALL ExtPtfm_CopyDiscState( SrcLinStateSaveData%xd_ExtPtfm(i1), DstLinStateSaveData%xd_ExtPtfm(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_ExtPtfm)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_ExtPtfm,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_ExtPtfm,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_ExtPtfm)) THEN 
    ALLOCATE(DstLinStateSaveData%z_ExtPtfm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_ExtPtfm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_ExtPtfm,1), UBOUND(SrcLinStateSaveData%z_ExtPtfm,1)
      CALL ExtPtfm_CopyConstrState( SrcLinStateSaveData%z_ExtPtfm(i1), DstLinStateSaveData%z_ExtPtfm(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_ExtPtfm)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_ExtPtfm,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_ExtPtfm,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_ExtPtfm)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_ExtPtfm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_ExtPtfm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_ExtPtfm,1), UBOUND(SrcLinStateSaveData%OtherSt_ExtPtfm,1)
      CALL ExtPtfm_CopyOtherState( SrcLinStateSaveData%OtherSt_ExtPtfm(i1), DstLinStateSaveData%OtherSt_ExtPtfm(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_ExtPtfm)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_ExtPtfm,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_ExtPtfm,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_ExtPtfm)) THEN 
    ALLOCATE(DstLinStateSaveData%u_ExtPtfm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_ExtPtfm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_ExtPtfm,1), UBOUND(SrcLinStateSaveData%u_ExtPtfm,1)
      CALL ExtPtfm_CopyInput( SrcLinStateSaveData%u_ExtPtfm(i1), DstLinStateSaveData%u_ExtPtfm(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_HD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_HD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_HD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_HD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_HD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_HD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_HD,1), UBOUND(SrcLinStateSaveData%x_HD,1)
      CALL HydroDyn_CopyContState( SrcLinStateSaveData%x_HD(i1), DstLinStateSaveData%x_HD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_HD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_HD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_HD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_HD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_HD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_HD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_HD,1), UBOUND(SrcLinStateSaveData%xd_HD,1)
      CALL HydroDyn_CopyDiscState( SrcLinStateSaveData%xd_HD(i1), DstLinStateSaveData%xd_HD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_HD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_HD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_HD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_HD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_HD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_HD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_HD,1), UBOUND(SrcLinStateSaveData%z_HD,1)
      CALL HydroDyn_CopyConstrState( SrcLinStateSaveData%z_HD(i1), DstLinStateSaveData%z_HD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_HD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_HD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_HD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_HD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_HD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_HD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_HD,1), UBOUND(SrcLinStateSaveData%OtherSt_HD,1)
      CALL HydroDyn_CopyOtherState( SrcLinStateSaveData%OtherSt_HD(i1), DstLinStateSaveData%OtherSt_HD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_HD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_HD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_HD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_HD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_HD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_HD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_HD,1), UBOUND(SrcLinStateSaveData%u_HD,1)
      CALL HydroDyn_CopyInput( SrcLinStateSaveData%u_HD(i1), DstLinStateSaveData%u_HD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_IceF)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_IceF,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_IceF,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_IceF)) THEN 
    ALLOCATE(DstLinStateSaveData%x_IceF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_IceF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_IceF,1), UBOUND(SrcLinStateSaveData%x_IceF,1)
      CALL IceFloe_CopyContState( SrcLinStateSaveData%x_IceF(i1), DstLinStateSaveData%x_IceF(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_IceF)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_IceF,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_IceF,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_IceF)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_IceF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_IceF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_IceF,1), UBOUND(SrcLinStateSaveData%xd_IceF,1)
      CALL IceFloe_CopyDiscState( SrcLinStateSaveData%xd_IceF(i1), DstLinStateSaveData%xd_IceF(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_IceF)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_IceF,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_IceF,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_IceF)) THEN 
    ALLOCATE(DstLinStateSaveData%z_IceF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_IceF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_IceF,1), UBOUND(SrcLinStateSaveData%z_IceF,1)
      CALL IceFloe_CopyConstrState( SrcLinStateSaveData%z_IceF(i1), DstLinStateSaveData%z_IceF(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_IceF)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_IceF,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_IceF,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_IceF)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_IceF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_IceF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_IceF,1), UBOUND(SrcLinStateSaveData%OtherSt_IceF,1)
      CALL IceFloe_CopyOtherState( SrcLinStateSaveData%OtherSt_IceF(i1), DstLinStateSaveData%OtherSt_IceF(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_IceF)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_IceF,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_IceF,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_IceF)) THEN 
    ALLOCATE(DstLinStateSaveData%u_IceF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_IceF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_IceF,1), UBOUND(SrcLinStateSaveData%u_IceF,1)
      CALL IceFloe_CopyInput( SrcLinStateSaveData%u_IceF(i1), DstLinStateSaveData%u_IceF(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_MAP)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_MAP,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_MAP,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_MAP)) THEN 
    ALLOCATE(DstLinStateSaveData%x_MAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_MAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_MAP,1), UBOUND(SrcLinStateSaveData%x_MAP,1)
      CALL MAP_CopyContState( SrcLinStateSaveData%x_MAP(i1), DstLinStateSaveData%x_MAP(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_MAP)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_MAP,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_MAP,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_MAP)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_MAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_MAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_MAP,1), UBOUND(SrcLinStateSaveData%xd_MAP,1)
      CALL MAP_CopyDiscState( SrcLinStateSaveData%xd_MAP(i1), DstLinStateSaveData%xd_MAP(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_MAP)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_MAP,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_MAP,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_MAP)) THEN 
    ALLOCATE(DstLinStateSaveData%z_MAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_MAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_MAP,1), UBOUND(SrcLinStateSaveData%z_MAP,1)
      CALL MAP_CopyConstrState( SrcLinStateSaveData%z_MAP(i1), DstLinStateSaveData%z_MAP(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_MAP)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_MAP,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_MAP,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_MAP)) THEN 
    ALLOCATE(DstLinStateSaveData%u_MAP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_MAP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_MAP,1), UBOUND(SrcLinStateSaveData%u_MAP,1)
      CALL MAP_CopyInput( SrcLinStateSaveData%u_MAP(i1), DstLinStateSaveData%u_MAP(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_FEAM)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_FEAM,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_FEAM,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_FEAM)) THEN 
    ALLOCATE(DstLinStateSaveData%x_FEAM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_FEAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_FEAM,1), UBOUND(SrcLinStateSaveData%x_FEAM,1)
      CALL FEAM_CopyContState( SrcLinStateSaveData%x_FEAM(i1), DstLinStateSaveData%x_FEAM(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_FEAM)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_FEAM,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_FEAM,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_FEAM)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_FEAM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_FEAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_FEAM,1), UBOUND(SrcLinStateSaveData%xd_FEAM,1)
      CALL FEAM_CopyDiscState( SrcLinStateSaveData%xd_FEAM(i1), DstLinStateSaveData%xd_FEAM(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_FEAM)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_FEAM,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_FEAM,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_FEAM)) THEN 
    ALLOCATE(DstLinStateSaveData%z_FEAM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_FEAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_FEAM,1), UBOUND(SrcLinStateSaveData%z_FEAM,1)
      CALL FEAM_CopyConstrState( SrcLinStateSaveData%z_FEAM(i1), DstLinStateSaveData%z_FEAM(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_FEAM)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_FEAM,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_FEAM,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_FEAM)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_FEAM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_FEAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_FEAM,1), UBOUND(SrcLinStateSaveData%OtherSt_FEAM,1)
      CALL FEAM_CopyOtherState( SrcLinStateSaveData%OtherSt_FEAM(i1), DstLinStateSaveData%OtherSt_FEAM(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_FEAM)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_FEAM,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_FEAM,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_FEAM)) THEN 
    ALLOCATE(DstLinStateSaveData%u_FEAM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_FEAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_FEAM,1), UBOUND(SrcLinStateSaveData%u_FEAM,1)
      CALL FEAM_CopyInput( SrcLinStateSaveData%u_FEAM(i1), DstLinStateSaveData%u_FEAM(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%x_MD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%x_MD,1)
  i1_u = UBOUND(SrcLinStateSaveData%x_MD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%x_MD)) THEN 
    ALLOCATE(DstLinStateSaveData%x_MD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%x_MD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%x_MD,1), UBOUND(SrcLinStateSaveData%x_MD,1)
      CALL MD_CopyContState( SrcLinStateSaveData%x_MD(i1), DstLinStateSaveData%x_MD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%xd_MD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%xd_MD,1)
  i1_u = UBOUND(SrcLinStateSaveData%xd_MD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%xd_MD)) THEN 
    ALLOCATE(DstLinStateSaveData%xd_MD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%xd_MD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%xd_MD,1), UBOUND(SrcLinStateSaveData%xd_MD,1)
      CALL MD_CopyDiscState( SrcLinStateSaveData%xd_MD(i1), DstLinStateSaveData%xd_MD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%z_MD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%z_MD,1)
  i1_u = UBOUND(SrcLinStateSaveData%z_MD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%z_MD)) THEN 
    ALLOCATE(DstLinStateSaveData%z_MD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%z_MD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%z_MD,1), UBOUND(SrcLinStateSaveData%z_MD,1)
      CALL MD_CopyConstrState( SrcLinStateSaveData%z_MD(i1), DstLinStateSaveData%z_MD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%OtherSt_MD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%OtherSt_MD,1)
  i1_u = UBOUND(SrcLinStateSaveData%OtherSt_MD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%OtherSt_MD)) THEN 
    ALLOCATE(DstLinStateSaveData%OtherSt_MD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%OtherSt_MD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%OtherSt_MD,1), UBOUND(SrcLinStateSaveData%OtherSt_MD,1)
      CALL MD_CopyOtherState( SrcLinStateSaveData%OtherSt_MD(i1), DstLinStateSaveData%OtherSt_MD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcLinStateSaveData%u_MD)) THEN
  i1_l = LBOUND(SrcLinStateSaveData%u_MD,1)
  i1_u = UBOUND(SrcLinStateSaveData%u_MD,1)
  IF (.NOT. ALLOCATED(DstLinStateSaveData%u_MD)) THEN 
    ALLOCATE(DstLinStateSaveData%u_MD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinStateSaveData%u_MD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcLinStateSaveData%u_MD,1), UBOUND(SrcLinStateSaveData%u_MD,1)
      CALL MD_CopyInput( SrcLinStateSaveData%u_MD(i1), DstLinStateSaveData%u_MD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FAST_CopyLinStateSave

 SUBROUTINE FAST_DestroyLinStateSave( LinStateSaveData, ErrStat, ErrMsg )
  TYPE(FAST_LinStateSave), INTENT(INOUT) :: LinStateSaveData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyLinStateSave'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(LinStateSaveData%x_IceD)) THEN
DO i2 = LBOUND(LinStateSaveData%x_IceD,2), UBOUND(LinStateSaveData%x_IceD,2)
DO i1 = LBOUND(LinStateSaveData%x_IceD,1), UBOUND(LinStateSaveData%x_IceD,1)
  CALL IceD_DestroyContState( LinStateSaveData%x_IceD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%x_IceD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_IceD)) THEN
DO i2 = LBOUND(LinStateSaveData%xd_IceD,2), UBOUND(LinStateSaveData%xd_IceD,2)
DO i1 = LBOUND(LinStateSaveData%xd_IceD,1), UBOUND(LinStateSaveData%xd_IceD,1)
  CALL IceD_DestroyDiscState( LinStateSaveData%xd_IceD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%xd_IceD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_IceD)) THEN
DO i2 = LBOUND(LinStateSaveData%z_IceD,2), UBOUND(LinStateSaveData%z_IceD,2)
DO i1 = LBOUND(LinStateSaveData%z_IceD,1), UBOUND(LinStateSaveData%z_IceD,1)
  CALL IceD_DestroyConstrState( LinStateSaveData%z_IceD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%z_IceD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_IceD)) THEN
DO i2 = LBOUND(LinStateSaveData%OtherSt_IceD,2), UBOUND(LinStateSaveData%OtherSt_IceD,2)
DO i1 = LBOUND(LinStateSaveData%OtherSt_IceD,1), UBOUND(LinStateSaveData%OtherSt_IceD,1)
  CALL IceD_DestroyOtherState( LinStateSaveData%OtherSt_IceD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_IceD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_IceD)) THEN
DO i2 = LBOUND(LinStateSaveData%u_IceD,2), UBOUND(LinStateSaveData%u_IceD,2)
DO i1 = LBOUND(LinStateSaveData%u_IceD,1), UBOUND(LinStateSaveData%u_IceD,1)
  CALL IceD_DestroyInput( LinStateSaveData%u_IceD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%u_IceD)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_BD)) THEN
DO i2 = LBOUND(LinStateSaveData%x_BD,2), UBOUND(LinStateSaveData%x_BD,2)
DO i1 = LBOUND(LinStateSaveData%x_BD,1), UBOUND(LinStateSaveData%x_BD,1)
  CALL BD_DestroyContState( LinStateSaveData%x_BD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%x_BD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_BD)) THEN
DO i2 = LBOUND(LinStateSaveData%xd_BD,2), UBOUND(LinStateSaveData%xd_BD,2)
DO i1 = LBOUND(LinStateSaveData%xd_BD,1), UBOUND(LinStateSaveData%xd_BD,1)
  CALL BD_DestroyDiscState( LinStateSaveData%xd_BD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%xd_BD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_BD)) THEN
DO i2 = LBOUND(LinStateSaveData%z_BD,2), UBOUND(LinStateSaveData%z_BD,2)
DO i1 = LBOUND(LinStateSaveData%z_BD,1), UBOUND(LinStateSaveData%z_BD,1)
  CALL BD_DestroyConstrState( LinStateSaveData%z_BD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%z_BD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_BD)) THEN
DO i2 = LBOUND(LinStateSaveData%OtherSt_BD,2), UBOUND(LinStateSaveData%OtherSt_BD,2)
DO i1 = LBOUND(LinStateSaveData%OtherSt_BD,1), UBOUND(LinStateSaveData%OtherSt_BD,1)
  CALL BD_DestroyOtherState( LinStateSaveData%OtherSt_BD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_BD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_BD)) THEN
DO i2 = LBOUND(LinStateSaveData%u_BD,2), UBOUND(LinStateSaveData%u_BD,2)
DO i1 = LBOUND(LinStateSaveData%u_BD,1), UBOUND(LinStateSaveData%u_BD,1)
  CALL BD_DestroyInput( LinStateSaveData%u_BD(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(LinStateSaveData%u_BD)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_ED)) THEN
DO i1 = LBOUND(LinStateSaveData%x_ED,1), UBOUND(LinStateSaveData%x_ED,1)
  CALL ED_DestroyContState( LinStateSaveData%x_ED(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_ED)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_ED)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_ED,1), UBOUND(LinStateSaveData%xd_ED,1)
  CALL ED_DestroyDiscState( LinStateSaveData%xd_ED(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_ED)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_ED)) THEN
DO i1 = LBOUND(LinStateSaveData%z_ED,1), UBOUND(LinStateSaveData%z_ED,1)
  CALL ED_DestroyConstrState( LinStateSaveData%z_ED(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_ED)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_ED)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_ED,1), UBOUND(LinStateSaveData%OtherSt_ED,1)
  CALL ED_DestroyOtherState( LinStateSaveData%OtherSt_ED(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_ED)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_ED)) THEN
DO i1 = LBOUND(LinStateSaveData%u_ED,1), UBOUND(LinStateSaveData%u_ED,1)
  CALL ED_DestroyInput( LinStateSaveData%u_ED(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_ED)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_SrvD)) THEN
DO i1 = LBOUND(LinStateSaveData%x_SrvD,1), UBOUND(LinStateSaveData%x_SrvD,1)
  CALL SrvD_DestroyContState( LinStateSaveData%x_SrvD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_SrvD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_SrvD)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_SrvD,1), UBOUND(LinStateSaveData%xd_SrvD,1)
  CALL SrvD_DestroyDiscState( LinStateSaveData%xd_SrvD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_SrvD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_SrvD)) THEN
DO i1 = LBOUND(LinStateSaveData%z_SrvD,1), UBOUND(LinStateSaveData%z_SrvD,1)
  CALL SrvD_DestroyConstrState( LinStateSaveData%z_SrvD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_SrvD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_SrvD)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_SrvD,1), UBOUND(LinStateSaveData%OtherSt_SrvD,1)
  CALL SrvD_DestroyOtherState( LinStateSaveData%OtherSt_SrvD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_SrvD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_SrvD)) THEN
DO i1 = LBOUND(LinStateSaveData%u_SrvD,1), UBOUND(LinStateSaveData%u_SrvD,1)
  CALL SrvD_DestroyInput( LinStateSaveData%u_SrvD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_SrvD)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_AD)) THEN
DO i1 = LBOUND(LinStateSaveData%x_AD,1), UBOUND(LinStateSaveData%x_AD,1)
  CALL AD_DestroyContState( LinStateSaveData%x_AD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_AD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_AD)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_AD,1), UBOUND(LinStateSaveData%xd_AD,1)
  CALL AD_DestroyDiscState( LinStateSaveData%xd_AD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_AD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_AD)) THEN
DO i1 = LBOUND(LinStateSaveData%z_AD,1), UBOUND(LinStateSaveData%z_AD,1)
  CALL AD_DestroyConstrState( LinStateSaveData%z_AD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_AD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_AD)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_AD,1), UBOUND(LinStateSaveData%OtherSt_AD,1)
  CALL AD_DestroyOtherState( LinStateSaveData%OtherSt_AD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_AD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_AD)) THEN
DO i1 = LBOUND(LinStateSaveData%u_AD,1), UBOUND(LinStateSaveData%u_AD,1)
  CALL AD_DestroyInput( LinStateSaveData%u_AD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_AD)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_IfW)) THEN
DO i1 = LBOUND(LinStateSaveData%x_IfW,1), UBOUND(LinStateSaveData%x_IfW,1)
  CALL InflowWind_DestroyContState( LinStateSaveData%x_IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_IfW)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_IfW)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_IfW,1), UBOUND(LinStateSaveData%xd_IfW,1)
  CALL InflowWind_DestroyDiscState( LinStateSaveData%xd_IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_IfW)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_IfW)) THEN
DO i1 = LBOUND(LinStateSaveData%z_IfW,1), UBOUND(LinStateSaveData%z_IfW,1)
  CALL InflowWind_DestroyConstrState( LinStateSaveData%z_IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_IfW)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_IfW)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_IfW,1), UBOUND(LinStateSaveData%OtherSt_IfW,1)
  CALL InflowWind_DestroyOtherState( LinStateSaveData%OtherSt_IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_IfW)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_IfW)) THEN
DO i1 = LBOUND(LinStateSaveData%u_IfW,1), UBOUND(LinStateSaveData%u_IfW,1)
  CALL InflowWind_DestroyInput( LinStateSaveData%u_IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_IfW)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_SD)) THEN
DO i1 = LBOUND(LinStateSaveData%x_SD,1), UBOUND(LinStateSaveData%x_SD,1)
  CALL SD_DestroyContState( LinStateSaveData%x_SD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_SD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_SD)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_SD,1), UBOUND(LinStateSaveData%xd_SD,1)
  CALL SD_DestroyDiscState( LinStateSaveData%xd_SD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_SD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_SD)) THEN
DO i1 = LBOUND(LinStateSaveData%z_SD,1), UBOUND(LinStateSaveData%z_SD,1)
  CALL SD_DestroyConstrState( LinStateSaveData%z_SD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_SD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_SD)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_SD,1), UBOUND(LinStateSaveData%OtherSt_SD,1)
  CALL SD_DestroyOtherState( LinStateSaveData%OtherSt_SD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_SD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_SD)) THEN
DO i1 = LBOUND(LinStateSaveData%u_SD,1), UBOUND(LinStateSaveData%u_SD,1)
  CALL SD_DestroyInput( LinStateSaveData%u_SD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_SD)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_ExtPtfm)) THEN
DO i1 = LBOUND(LinStateSaveData%x_ExtPtfm,1), UBOUND(LinStateSaveData%x_ExtPtfm,1)
  CALL ExtPtfm_DestroyContState( LinStateSaveData%x_ExtPtfm(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_ExtPtfm)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_ExtPtfm)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_ExtPtfm,1), UBOUND(LinStateSaveData%xd_ExtPtfm,1)
  CALL ExtPtfm_DestroyDiscState( LinStateSaveData%xd_ExtPtfm(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_ExtPtfm)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_ExtPtfm)) THEN
DO i1 = LBOUND(LinStateSaveData%z_ExtPtfm,1), UBOUND(LinStateSaveData%z_ExtPtfm,1)
  CALL ExtPtfm_DestroyConstrState( LinStateSaveData%z_ExtPtfm(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_ExtPtfm)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_ExtPtfm)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_ExtPtfm,1), UBOUND(LinStateSaveData%OtherSt_ExtPtfm,1)
  CALL ExtPtfm_DestroyOtherState( LinStateSaveData%OtherSt_ExtPtfm(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_ExtPtfm)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_ExtPtfm)) THEN
DO i1 = LBOUND(LinStateSaveData%u_ExtPtfm,1), UBOUND(LinStateSaveData%u_ExtPtfm,1)
  CALL ExtPtfm_DestroyInput( LinStateSaveData%u_ExtPtfm(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_ExtPtfm)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_HD)) THEN
DO i1 = LBOUND(LinStateSaveData%x_HD,1), UBOUND(LinStateSaveData%x_HD,1)
  CALL HydroDyn_DestroyContState( LinStateSaveData%x_HD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_HD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_HD)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_HD,1), UBOUND(LinStateSaveData%xd_HD,1)
  CALL HydroDyn_DestroyDiscState( LinStateSaveData%xd_HD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_HD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_HD)) THEN
DO i1 = LBOUND(LinStateSaveData%z_HD,1), UBOUND(LinStateSaveData%z_HD,1)
  CALL HydroDyn_DestroyConstrState( LinStateSaveData%z_HD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_HD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_HD)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_HD,1), UBOUND(LinStateSaveData%OtherSt_HD,1)
  CALL HydroDyn_DestroyOtherState( LinStateSaveData%OtherSt_HD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_HD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_HD)) THEN
DO i1 = LBOUND(LinStateSaveData%u_HD,1), UBOUND(LinStateSaveData%u_HD,1)
  CALL HydroDyn_DestroyInput( LinStateSaveData%u_HD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_HD)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_IceF)) THEN
DO i1 = LBOUND(LinStateSaveData%x_IceF,1), UBOUND(LinStateSaveData%x_IceF,1)
  CALL IceFloe_DestroyContState( LinStateSaveData%x_IceF(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_IceF)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_IceF)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_IceF,1), UBOUND(LinStateSaveData%xd_IceF,1)
  CALL IceFloe_DestroyDiscState( LinStateSaveData%xd_IceF(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_IceF)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_IceF)) THEN
DO i1 = LBOUND(LinStateSaveData%z_IceF,1), UBOUND(LinStateSaveData%z_IceF,1)
  CALL IceFloe_DestroyConstrState( LinStateSaveData%z_IceF(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_IceF)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_IceF)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_IceF,1), UBOUND(LinStateSaveData%OtherSt_IceF,1)
  CALL IceFloe_DestroyOtherState( LinStateSaveData%OtherSt_IceF(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_IceF)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_IceF)) THEN
DO i1 = LBOUND(LinStateSaveData%u_IceF,1), UBOUND(LinStateSaveData%u_IceF,1)
  CALL IceFloe_DestroyInput( LinStateSaveData%u_IceF(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_IceF)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_MAP)) THEN
DO i1 = LBOUND(LinStateSaveData%x_MAP,1), UBOUND(LinStateSaveData%x_MAP,1)
  CALL MAP_DestroyContState( LinStateSaveData%x_MAP(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_MAP)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_MAP)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_MAP,1), UBOUND(LinStateSaveData%xd_MAP,1)
  CALL MAP_DestroyDiscState( LinStateSaveData%xd_MAP(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_MAP)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_MAP)) THEN
DO i1 = LBOUND(LinStateSaveData%z_MAP,1), UBOUND(LinStateSaveData%z_MAP,1)
  CALL MAP_DestroyConstrState( LinStateSaveData%z_MAP(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_MAP)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_MAP)) THEN
DO i1 = LBOUND(LinStateSaveData%u_MAP,1), UBOUND(LinStateSaveData%u_MAP,1)
  CALL MAP_DestroyInput( LinStateSaveData%u_MAP(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_MAP)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_FEAM)) THEN
DO i1 = LBOUND(LinStateSaveData%x_FEAM,1), UBOUND(LinStateSaveData%x_FEAM,1)
  CALL FEAM_DestroyContState( LinStateSaveData%x_FEAM(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_FEAM)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_FEAM)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_FEAM,1), UBOUND(LinStateSaveData%xd_FEAM,1)
  CALL FEAM_DestroyDiscState( LinStateSaveData%xd_FEAM(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_FEAM)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_FEAM)) THEN
DO i1 = LBOUND(LinStateSaveData%z_FEAM,1), UBOUND(LinStateSaveData%z_FEAM,1)
  CALL FEAM_DestroyConstrState( LinStateSaveData%z_FEAM(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_FEAM)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_FEAM)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_FEAM,1), UBOUND(LinStateSaveData%OtherSt_FEAM,1)
  CALL FEAM_DestroyOtherState( LinStateSaveData%OtherSt_FEAM(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_FEAM)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_FEAM)) THEN
DO i1 = LBOUND(LinStateSaveData%u_FEAM,1), UBOUND(LinStateSaveData%u_FEAM,1)
  CALL FEAM_DestroyInput( LinStateSaveData%u_FEAM(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_FEAM)
ENDIF
IF (ALLOCATED(LinStateSaveData%x_MD)) THEN
DO i1 = LBOUND(LinStateSaveData%x_MD,1), UBOUND(LinStateSaveData%x_MD,1)
  CALL MD_DestroyContState( LinStateSaveData%x_MD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%x_MD)
ENDIF
IF (ALLOCATED(LinStateSaveData%xd_MD)) THEN
DO i1 = LBOUND(LinStateSaveData%xd_MD,1), UBOUND(LinStateSaveData%xd_MD,1)
  CALL MD_DestroyDiscState( LinStateSaveData%xd_MD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%xd_MD)
ENDIF
IF (ALLOCATED(LinStateSaveData%z_MD)) THEN
DO i1 = LBOUND(LinStateSaveData%z_MD,1), UBOUND(LinStateSaveData%z_MD,1)
  CALL MD_DestroyConstrState( LinStateSaveData%z_MD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%z_MD)
ENDIF
IF (ALLOCATED(LinStateSaveData%OtherSt_MD)) THEN
DO i1 = LBOUND(LinStateSaveData%OtherSt_MD,1), UBOUND(LinStateSaveData%OtherSt_MD,1)
  CALL MD_DestroyOtherState( LinStateSaveData%OtherSt_MD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%OtherSt_MD)
ENDIF
IF (ALLOCATED(LinStateSaveData%u_MD)) THEN
DO i1 = LBOUND(LinStateSaveData%u_MD,1), UBOUND(LinStateSaveData%u_MD,1)
  CALL MD_DestroyInput( LinStateSaveData%u_MD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(LinStateSaveData%u_MD)
ENDIF
 END SUBROUTINE FAST_DestroyLinStateSave


subroutine FAST_PackLinStateSave(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_LinStateSave), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackLinStateSave'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x_IceD
   call RegPack(Buf, allocated(InData%x_IceD))
   if (allocated(InData%x_IceD)) then
      call RegPackBounds(Buf, 2, lbound(InData%x_IceD), ubound(InData%x_IceD))
      LB(1:2) = lbound(InData%x_IceD)
      UB(1:2) = ubound(InData%x_IceD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackContState(Buf, InData%x_IceD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_IceD
   call RegPack(Buf, allocated(InData%xd_IceD))
   if (allocated(InData%xd_IceD)) then
      call RegPackBounds(Buf, 2, lbound(InData%xd_IceD), ubound(InData%xd_IceD))
      LB(1:2) = lbound(InData%xd_IceD)
      UB(1:2) = ubound(InData%xd_IceD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackDiscState(Buf, InData%xd_IceD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_IceD
   call RegPack(Buf, allocated(InData%z_IceD))
   if (allocated(InData%z_IceD)) then
      call RegPackBounds(Buf, 2, lbound(InData%z_IceD), ubound(InData%z_IceD))
      LB(1:2) = lbound(InData%z_IceD)
      UB(1:2) = ubound(InData%z_IceD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackConstrState(Buf, InData%z_IceD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_IceD
   call RegPack(Buf, allocated(InData%OtherSt_IceD))
   if (allocated(InData%OtherSt_IceD)) then
      call RegPackBounds(Buf, 2, lbound(InData%OtherSt_IceD), ubound(InData%OtherSt_IceD))
      LB(1:2) = lbound(InData%OtherSt_IceD)
      UB(1:2) = ubound(InData%OtherSt_IceD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackOtherState(Buf, InData%OtherSt_IceD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_IceD
   call RegPack(Buf, allocated(InData%u_IceD))
   if (allocated(InData%u_IceD)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_IceD), ubound(InData%u_IceD))
      LB(1:2) = lbound(InData%u_IceD)
      UB(1:2) = ubound(InData%u_IceD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackInput(Buf, InData%u_IceD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_BD
   call RegPack(Buf, allocated(InData%x_BD))
   if (allocated(InData%x_BD)) then
      call RegPackBounds(Buf, 2, lbound(InData%x_BD), ubound(InData%x_BD))
      LB(1:2) = lbound(InData%x_BD)
      UB(1:2) = ubound(InData%x_BD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackContState(Buf, InData%x_BD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_BD
   call RegPack(Buf, allocated(InData%xd_BD))
   if (allocated(InData%xd_BD)) then
      call RegPackBounds(Buf, 2, lbound(InData%xd_BD), ubound(InData%xd_BD))
      LB(1:2) = lbound(InData%xd_BD)
      UB(1:2) = ubound(InData%xd_BD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackDiscState(Buf, InData%xd_BD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_BD
   call RegPack(Buf, allocated(InData%z_BD))
   if (allocated(InData%z_BD)) then
      call RegPackBounds(Buf, 2, lbound(InData%z_BD), ubound(InData%z_BD))
      LB(1:2) = lbound(InData%z_BD)
      UB(1:2) = ubound(InData%z_BD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackConstrState(Buf, InData%z_BD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_BD
   call RegPack(Buf, allocated(InData%OtherSt_BD))
   if (allocated(InData%OtherSt_BD)) then
      call RegPackBounds(Buf, 2, lbound(InData%OtherSt_BD), ubound(InData%OtherSt_BD))
      LB(1:2) = lbound(InData%OtherSt_BD)
      UB(1:2) = ubound(InData%OtherSt_BD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackOtherState(Buf, InData%OtherSt_BD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_BD
   call RegPack(Buf, allocated(InData%u_BD))
   if (allocated(InData%u_BD)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_BD), ubound(InData%u_BD))
      LB(1:2) = lbound(InData%u_BD)
      UB(1:2) = ubound(InData%u_BD)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackInput(Buf, InData%u_BD(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_ED
   call RegPack(Buf, allocated(InData%x_ED))
   if (allocated(InData%x_ED)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_ED), ubound(InData%x_ED))
      LB(1:1) = lbound(InData%x_ED)
      UB(1:1) = ubound(InData%x_ED)
      do i1 = LB(1), UB(1)
         call ED_PackContState(Buf, InData%x_ED(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_ED
   call RegPack(Buf, allocated(InData%xd_ED))
   if (allocated(InData%xd_ED)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_ED), ubound(InData%xd_ED))
      LB(1:1) = lbound(InData%xd_ED)
      UB(1:1) = ubound(InData%xd_ED)
      do i1 = LB(1), UB(1)
         call ED_PackDiscState(Buf, InData%xd_ED(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_ED
   call RegPack(Buf, allocated(InData%z_ED))
   if (allocated(InData%z_ED)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_ED), ubound(InData%z_ED))
      LB(1:1) = lbound(InData%z_ED)
      UB(1:1) = ubound(InData%z_ED)
      do i1 = LB(1), UB(1)
         call ED_PackConstrState(Buf, InData%z_ED(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_ED
   call RegPack(Buf, allocated(InData%OtherSt_ED))
   if (allocated(InData%OtherSt_ED)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_ED), ubound(InData%OtherSt_ED))
      LB(1:1) = lbound(InData%OtherSt_ED)
      UB(1:1) = ubound(InData%OtherSt_ED)
      do i1 = LB(1), UB(1)
         call ED_PackOtherState(Buf, InData%OtherSt_ED(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ED
   call RegPack(Buf, allocated(InData%u_ED))
   if (allocated(InData%u_ED)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_ED), ubound(InData%u_ED))
      LB(1:1) = lbound(InData%u_ED)
      UB(1:1) = ubound(InData%u_ED)
      do i1 = LB(1), UB(1)
         call ED_PackInput(Buf, InData%u_ED(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_SrvD
   call RegPack(Buf, allocated(InData%x_SrvD))
   if (allocated(InData%x_SrvD)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_SrvD), ubound(InData%x_SrvD))
      LB(1:1) = lbound(InData%x_SrvD)
      UB(1:1) = ubound(InData%x_SrvD)
      do i1 = LB(1), UB(1)
         call SrvD_PackContState(Buf, InData%x_SrvD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_SrvD
   call RegPack(Buf, allocated(InData%xd_SrvD))
   if (allocated(InData%xd_SrvD)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_SrvD), ubound(InData%xd_SrvD))
      LB(1:1) = lbound(InData%xd_SrvD)
      UB(1:1) = ubound(InData%xd_SrvD)
      do i1 = LB(1), UB(1)
         call SrvD_PackDiscState(Buf, InData%xd_SrvD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_SrvD
   call RegPack(Buf, allocated(InData%z_SrvD))
   if (allocated(InData%z_SrvD)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_SrvD), ubound(InData%z_SrvD))
      LB(1:1) = lbound(InData%z_SrvD)
      UB(1:1) = ubound(InData%z_SrvD)
      do i1 = LB(1), UB(1)
         call SrvD_PackConstrState(Buf, InData%z_SrvD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_SrvD
   call RegPack(Buf, allocated(InData%OtherSt_SrvD))
   if (allocated(InData%OtherSt_SrvD)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_SrvD), ubound(InData%OtherSt_SrvD))
      LB(1:1) = lbound(InData%OtherSt_SrvD)
      UB(1:1) = ubound(InData%OtherSt_SrvD)
      do i1 = LB(1), UB(1)
         call SrvD_PackOtherState(Buf, InData%OtherSt_SrvD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_SrvD
   call RegPack(Buf, allocated(InData%u_SrvD))
   if (allocated(InData%u_SrvD)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_SrvD), ubound(InData%u_SrvD))
      LB(1:1) = lbound(InData%u_SrvD)
      UB(1:1) = ubound(InData%u_SrvD)
      do i1 = LB(1), UB(1)
         call SrvD_PackInput(Buf, InData%u_SrvD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_AD
   call RegPack(Buf, allocated(InData%x_AD))
   if (allocated(InData%x_AD)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_AD), ubound(InData%x_AD))
      LB(1:1) = lbound(InData%x_AD)
      UB(1:1) = ubound(InData%x_AD)
      do i1 = LB(1), UB(1)
         call AD_PackContState(Buf, InData%x_AD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_AD
   call RegPack(Buf, allocated(InData%xd_AD))
   if (allocated(InData%xd_AD)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_AD), ubound(InData%xd_AD))
      LB(1:1) = lbound(InData%xd_AD)
      UB(1:1) = ubound(InData%xd_AD)
      do i1 = LB(1), UB(1)
         call AD_PackDiscState(Buf, InData%xd_AD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_AD
   call RegPack(Buf, allocated(InData%z_AD))
   if (allocated(InData%z_AD)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_AD), ubound(InData%z_AD))
      LB(1:1) = lbound(InData%z_AD)
      UB(1:1) = ubound(InData%z_AD)
      do i1 = LB(1), UB(1)
         call AD_PackConstrState(Buf, InData%z_AD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_AD
   call RegPack(Buf, allocated(InData%OtherSt_AD))
   if (allocated(InData%OtherSt_AD)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_AD), ubound(InData%OtherSt_AD))
      LB(1:1) = lbound(InData%OtherSt_AD)
      UB(1:1) = ubound(InData%OtherSt_AD)
      do i1 = LB(1), UB(1)
         call AD_PackOtherState(Buf, InData%OtherSt_AD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_AD
   call RegPack(Buf, allocated(InData%u_AD))
   if (allocated(InData%u_AD)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_AD), ubound(InData%u_AD))
      LB(1:1) = lbound(InData%u_AD)
      UB(1:1) = ubound(InData%u_AD)
      do i1 = LB(1), UB(1)
         call AD_PackInput(Buf, InData%u_AD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_IfW
   call RegPack(Buf, allocated(InData%x_IfW))
   if (allocated(InData%x_IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_IfW), ubound(InData%x_IfW))
      LB(1:1) = lbound(InData%x_IfW)
      UB(1:1) = ubound(InData%x_IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackContState(Buf, InData%x_IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_IfW
   call RegPack(Buf, allocated(InData%xd_IfW))
   if (allocated(InData%xd_IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_IfW), ubound(InData%xd_IfW))
      LB(1:1) = lbound(InData%xd_IfW)
      UB(1:1) = ubound(InData%xd_IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackDiscState(Buf, InData%xd_IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_IfW
   call RegPack(Buf, allocated(InData%z_IfW))
   if (allocated(InData%z_IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_IfW), ubound(InData%z_IfW))
      LB(1:1) = lbound(InData%z_IfW)
      UB(1:1) = ubound(InData%z_IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackConstrState(Buf, InData%z_IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_IfW
   call RegPack(Buf, allocated(InData%OtherSt_IfW))
   if (allocated(InData%OtherSt_IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_IfW), ubound(InData%OtherSt_IfW))
      LB(1:1) = lbound(InData%OtherSt_IfW)
      UB(1:1) = ubound(InData%OtherSt_IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackOtherState(Buf, InData%OtherSt_IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_IfW
   call RegPack(Buf, allocated(InData%u_IfW))
   if (allocated(InData%u_IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_IfW), ubound(InData%u_IfW))
      LB(1:1) = lbound(InData%u_IfW)
      UB(1:1) = ubound(InData%u_IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackInput(Buf, InData%u_IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_SD
   call RegPack(Buf, allocated(InData%x_SD))
   if (allocated(InData%x_SD)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_SD), ubound(InData%x_SD))
      LB(1:1) = lbound(InData%x_SD)
      UB(1:1) = ubound(InData%x_SD)
      do i1 = LB(1), UB(1)
         call SD_PackContState(Buf, InData%x_SD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_SD
   call RegPack(Buf, allocated(InData%xd_SD))
   if (allocated(InData%xd_SD)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_SD), ubound(InData%xd_SD))
      LB(1:1) = lbound(InData%xd_SD)
      UB(1:1) = ubound(InData%xd_SD)
      do i1 = LB(1), UB(1)
         call SD_PackDiscState(Buf, InData%xd_SD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_SD
   call RegPack(Buf, allocated(InData%z_SD))
   if (allocated(InData%z_SD)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_SD), ubound(InData%z_SD))
      LB(1:1) = lbound(InData%z_SD)
      UB(1:1) = ubound(InData%z_SD)
      do i1 = LB(1), UB(1)
         call SD_PackConstrState(Buf, InData%z_SD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_SD
   call RegPack(Buf, allocated(InData%OtherSt_SD))
   if (allocated(InData%OtherSt_SD)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_SD), ubound(InData%OtherSt_SD))
      LB(1:1) = lbound(InData%OtherSt_SD)
      UB(1:1) = ubound(InData%OtherSt_SD)
      do i1 = LB(1), UB(1)
         call SD_PackOtherState(Buf, InData%OtherSt_SD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_SD
   call RegPack(Buf, allocated(InData%u_SD))
   if (allocated(InData%u_SD)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_SD), ubound(InData%u_SD))
      LB(1:1) = lbound(InData%u_SD)
      UB(1:1) = ubound(InData%u_SD)
      do i1 = LB(1), UB(1)
         call SD_PackInput(Buf, InData%u_SD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_ExtPtfm
   call RegPack(Buf, allocated(InData%x_ExtPtfm))
   if (allocated(InData%x_ExtPtfm)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_ExtPtfm), ubound(InData%x_ExtPtfm))
      LB(1:1) = lbound(InData%x_ExtPtfm)
      UB(1:1) = ubound(InData%x_ExtPtfm)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackContState(Buf, InData%x_ExtPtfm(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_ExtPtfm
   call RegPack(Buf, allocated(InData%xd_ExtPtfm))
   if (allocated(InData%xd_ExtPtfm)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_ExtPtfm), ubound(InData%xd_ExtPtfm))
      LB(1:1) = lbound(InData%xd_ExtPtfm)
      UB(1:1) = ubound(InData%xd_ExtPtfm)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackDiscState(Buf, InData%xd_ExtPtfm(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_ExtPtfm
   call RegPack(Buf, allocated(InData%z_ExtPtfm))
   if (allocated(InData%z_ExtPtfm)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_ExtPtfm), ubound(InData%z_ExtPtfm))
      LB(1:1) = lbound(InData%z_ExtPtfm)
      UB(1:1) = ubound(InData%z_ExtPtfm)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackConstrState(Buf, InData%z_ExtPtfm(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_ExtPtfm
   call RegPack(Buf, allocated(InData%OtherSt_ExtPtfm))
   if (allocated(InData%OtherSt_ExtPtfm)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_ExtPtfm), ubound(InData%OtherSt_ExtPtfm))
      LB(1:1) = lbound(InData%OtherSt_ExtPtfm)
      UB(1:1) = ubound(InData%OtherSt_ExtPtfm)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackOtherState(Buf, InData%OtherSt_ExtPtfm(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ExtPtfm
   call RegPack(Buf, allocated(InData%u_ExtPtfm))
   if (allocated(InData%u_ExtPtfm)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_ExtPtfm), ubound(InData%u_ExtPtfm))
      LB(1:1) = lbound(InData%u_ExtPtfm)
      UB(1:1) = ubound(InData%u_ExtPtfm)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackInput(Buf, InData%u_ExtPtfm(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_HD
   call RegPack(Buf, allocated(InData%x_HD))
   if (allocated(InData%x_HD)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_HD), ubound(InData%x_HD))
      LB(1:1) = lbound(InData%x_HD)
      UB(1:1) = ubound(InData%x_HD)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackContState(Buf, InData%x_HD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_HD
   call RegPack(Buf, allocated(InData%xd_HD))
   if (allocated(InData%xd_HD)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_HD), ubound(InData%xd_HD))
      LB(1:1) = lbound(InData%xd_HD)
      UB(1:1) = ubound(InData%xd_HD)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackDiscState(Buf, InData%xd_HD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_HD
   call RegPack(Buf, allocated(InData%z_HD))
   if (allocated(InData%z_HD)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_HD), ubound(InData%z_HD))
      LB(1:1) = lbound(InData%z_HD)
      UB(1:1) = ubound(InData%z_HD)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackConstrState(Buf, InData%z_HD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_HD
   call RegPack(Buf, allocated(InData%OtherSt_HD))
   if (allocated(InData%OtherSt_HD)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_HD), ubound(InData%OtherSt_HD))
      LB(1:1) = lbound(InData%OtherSt_HD)
      UB(1:1) = ubound(InData%OtherSt_HD)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackOtherState(Buf, InData%OtherSt_HD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_HD
   call RegPack(Buf, allocated(InData%u_HD))
   if (allocated(InData%u_HD)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_HD), ubound(InData%u_HD))
      LB(1:1) = lbound(InData%u_HD)
      UB(1:1) = ubound(InData%u_HD)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackInput(Buf, InData%u_HD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_IceF
   call RegPack(Buf, allocated(InData%x_IceF))
   if (allocated(InData%x_IceF)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_IceF), ubound(InData%x_IceF))
      LB(1:1) = lbound(InData%x_IceF)
      UB(1:1) = ubound(InData%x_IceF)
      do i1 = LB(1), UB(1)
         call IceFloe_PackContState(Buf, InData%x_IceF(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_IceF
   call RegPack(Buf, allocated(InData%xd_IceF))
   if (allocated(InData%xd_IceF)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_IceF), ubound(InData%xd_IceF))
      LB(1:1) = lbound(InData%xd_IceF)
      UB(1:1) = ubound(InData%xd_IceF)
      do i1 = LB(1), UB(1)
         call IceFloe_PackDiscState(Buf, InData%xd_IceF(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_IceF
   call RegPack(Buf, allocated(InData%z_IceF))
   if (allocated(InData%z_IceF)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_IceF), ubound(InData%z_IceF))
      LB(1:1) = lbound(InData%z_IceF)
      UB(1:1) = ubound(InData%z_IceF)
      do i1 = LB(1), UB(1)
         call IceFloe_PackConstrState(Buf, InData%z_IceF(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_IceF
   call RegPack(Buf, allocated(InData%OtherSt_IceF))
   if (allocated(InData%OtherSt_IceF)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_IceF), ubound(InData%OtherSt_IceF))
      LB(1:1) = lbound(InData%OtherSt_IceF)
      UB(1:1) = ubound(InData%OtherSt_IceF)
      do i1 = LB(1), UB(1)
         call IceFloe_PackOtherState(Buf, InData%OtherSt_IceF(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_IceF
   call RegPack(Buf, allocated(InData%u_IceF))
   if (allocated(InData%u_IceF)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_IceF), ubound(InData%u_IceF))
      LB(1:1) = lbound(InData%u_IceF)
      UB(1:1) = ubound(InData%u_IceF)
      do i1 = LB(1), UB(1)
         call IceFloe_PackInput(Buf, InData%u_IceF(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_MAP
   call RegPack(Buf, allocated(InData%x_MAP))
   if (allocated(InData%x_MAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_MAP), ubound(InData%x_MAP))
      LB(1:1) = lbound(InData%x_MAP)
      UB(1:1) = ubound(InData%x_MAP)
      do i1 = LB(1), UB(1)
         call MAP_PackContState(Buf, InData%x_MAP(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_MAP
   call RegPack(Buf, allocated(InData%xd_MAP))
   if (allocated(InData%xd_MAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_MAP), ubound(InData%xd_MAP))
      LB(1:1) = lbound(InData%xd_MAP)
      UB(1:1) = ubound(InData%xd_MAP)
      do i1 = LB(1), UB(1)
         call MAP_PackDiscState(Buf, InData%xd_MAP(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_MAP
   call RegPack(Buf, allocated(InData%z_MAP))
   if (allocated(InData%z_MAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_MAP), ubound(InData%z_MAP))
      LB(1:1) = lbound(InData%z_MAP)
      UB(1:1) = ubound(InData%z_MAP)
      do i1 = LB(1), UB(1)
         call MAP_PackConstrState(Buf, InData%z_MAP(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_MAP
   call RegPack(Buf, allocated(InData%u_MAP))
   if (allocated(InData%u_MAP)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_MAP), ubound(InData%u_MAP))
      LB(1:1) = lbound(InData%u_MAP)
      UB(1:1) = ubound(InData%u_MAP)
      do i1 = LB(1), UB(1)
         call MAP_PackInput(Buf, InData%u_MAP(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_FEAM
   call RegPack(Buf, allocated(InData%x_FEAM))
   if (allocated(InData%x_FEAM)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_FEAM), ubound(InData%x_FEAM))
      LB(1:1) = lbound(InData%x_FEAM)
      UB(1:1) = ubound(InData%x_FEAM)
      do i1 = LB(1), UB(1)
         call FEAM_PackContState(Buf, InData%x_FEAM(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_FEAM
   call RegPack(Buf, allocated(InData%xd_FEAM))
   if (allocated(InData%xd_FEAM)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_FEAM), ubound(InData%xd_FEAM))
      LB(1:1) = lbound(InData%xd_FEAM)
      UB(1:1) = ubound(InData%xd_FEAM)
      do i1 = LB(1), UB(1)
         call FEAM_PackDiscState(Buf, InData%xd_FEAM(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_FEAM
   call RegPack(Buf, allocated(InData%z_FEAM))
   if (allocated(InData%z_FEAM)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_FEAM), ubound(InData%z_FEAM))
      LB(1:1) = lbound(InData%z_FEAM)
      UB(1:1) = ubound(InData%z_FEAM)
      do i1 = LB(1), UB(1)
         call FEAM_PackConstrState(Buf, InData%z_FEAM(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_FEAM
   call RegPack(Buf, allocated(InData%OtherSt_FEAM))
   if (allocated(InData%OtherSt_FEAM)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_FEAM), ubound(InData%OtherSt_FEAM))
      LB(1:1) = lbound(InData%OtherSt_FEAM)
      UB(1:1) = ubound(InData%OtherSt_FEAM)
      do i1 = LB(1), UB(1)
         call FEAM_PackOtherState(Buf, InData%OtherSt_FEAM(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_FEAM
   call RegPack(Buf, allocated(InData%u_FEAM))
   if (allocated(InData%u_FEAM)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_FEAM), ubound(InData%u_FEAM))
      LB(1:1) = lbound(InData%u_FEAM)
      UB(1:1) = ubound(InData%u_FEAM)
      do i1 = LB(1), UB(1)
         call FEAM_PackInput(Buf, InData%u_FEAM(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_MD
   call RegPack(Buf, allocated(InData%x_MD))
   if (allocated(InData%x_MD)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_MD), ubound(InData%x_MD))
      LB(1:1) = lbound(InData%x_MD)
      UB(1:1) = ubound(InData%x_MD)
      do i1 = LB(1), UB(1)
         call MD_PackContState(Buf, InData%x_MD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd_MD
   call RegPack(Buf, allocated(InData%xd_MD))
   if (allocated(InData%xd_MD)) then
      call RegPackBounds(Buf, 1, lbound(InData%xd_MD), ubound(InData%xd_MD))
      LB(1:1) = lbound(InData%xd_MD)
      UB(1:1) = ubound(InData%xd_MD)
      do i1 = LB(1), UB(1)
         call MD_PackDiscState(Buf, InData%xd_MD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z_MD
   call RegPack(Buf, allocated(InData%z_MD))
   if (allocated(InData%z_MD)) then
      call RegPackBounds(Buf, 1, lbound(InData%z_MD), ubound(InData%z_MD))
      LB(1:1) = lbound(InData%z_MD)
      UB(1:1) = ubound(InData%z_MD)
      do i1 = LB(1), UB(1)
         call MD_PackConstrState(Buf, InData%z_MD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_MD
   call RegPack(Buf, allocated(InData%OtherSt_MD))
   if (allocated(InData%OtherSt_MD)) then
      call RegPackBounds(Buf, 1, lbound(InData%OtherSt_MD), ubound(InData%OtherSt_MD))
      LB(1:1) = lbound(InData%OtherSt_MD)
      UB(1:1) = ubound(InData%OtherSt_MD)
      do i1 = LB(1), UB(1)
         call MD_PackOtherState(Buf, InData%OtherSt_MD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_MD
   call RegPack(Buf, allocated(InData%u_MD))
   if (allocated(InData%u_MD)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_MD), ubound(InData%u_MD))
      LB(1:1) = lbound(InData%u_MD)
      UB(1:1) = ubound(InData%u_MD)
      do i1 = LB(1), UB(1)
         call MD_PackInput(Buf, InData%u_MD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackLinStateSave(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_LinStateSave), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackLinStateSave'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x_IceD
   if (allocated(OutData%x_IceD)) deallocate(OutData%x_IceD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_IceD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_IceD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackContState(Buf, OutData%x_IceD(i1,i2)) ! x_IceD 
         end do
      end do
   end if
   ! xd_IceD
   if (allocated(OutData%xd_IceD)) deallocate(OutData%xd_IceD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_IceD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_IceD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackDiscState(Buf, OutData%xd_IceD(i1,i2)) ! xd_IceD 
         end do
      end do
   end if
   ! z_IceD
   if (allocated(OutData%z_IceD)) deallocate(OutData%z_IceD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_IceD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_IceD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackConstrState(Buf, OutData%z_IceD(i1,i2)) ! z_IceD 
         end do
      end do
   end if
   ! OtherSt_IceD
   if (allocated(OutData%OtherSt_IceD)) deallocate(OutData%OtherSt_IceD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_IceD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_IceD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackOtherState(Buf, OutData%OtherSt_IceD(i1,i2)) ! OtherSt_IceD 
         end do
      end do
   end if
   ! u_IceD
   if (allocated(OutData%u_IceD)) deallocate(OutData%u_IceD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_IceD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_IceD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackInput(Buf, OutData%u_IceD(i1,i2)) ! u_IceD 
         end do
      end do
   end if
   ! x_BD
   if (allocated(OutData%x_BD)) deallocate(OutData%x_BD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_BD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_BD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackContState(Buf, OutData%x_BD(i1,i2)) ! x_BD 
         end do
      end do
   end if
   ! xd_BD
   if (allocated(OutData%xd_BD)) deallocate(OutData%xd_BD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_BD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_BD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackDiscState(Buf, OutData%xd_BD(i1,i2)) ! xd_BD 
         end do
      end do
   end if
   ! z_BD
   if (allocated(OutData%z_BD)) deallocate(OutData%z_BD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_BD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_BD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackConstrState(Buf, OutData%z_BD(i1,i2)) ! z_BD 
         end do
      end do
   end if
   ! OtherSt_BD
   if (allocated(OutData%OtherSt_BD)) deallocate(OutData%OtherSt_BD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_BD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_BD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackOtherState(Buf, OutData%OtherSt_BD(i1,i2)) ! OtherSt_BD 
         end do
      end do
   end if
   ! u_BD
   if (allocated(OutData%u_BD)) deallocate(OutData%u_BD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_BD(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_BD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackInput(Buf, OutData%u_BD(i1,i2)) ! u_BD 
         end do
      end do
   end if
   ! x_ED
   if (allocated(OutData%x_ED)) deallocate(OutData%x_ED)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_ED(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_ED.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackContState(Buf, OutData%x_ED(i1)) ! x_ED 
      end do
   end if
   ! xd_ED
   if (allocated(OutData%xd_ED)) deallocate(OutData%xd_ED)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_ED(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_ED.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackDiscState(Buf, OutData%xd_ED(i1)) ! xd_ED 
      end do
   end if
   ! z_ED
   if (allocated(OutData%z_ED)) deallocate(OutData%z_ED)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_ED(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_ED.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackConstrState(Buf, OutData%z_ED(i1)) ! z_ED 
      end do
   end if
   ! OtherSt_ED
   if (allocated(OutData%OtherSt_ED)) deallocate(OutData%OtherSt_ED)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_ED(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_ED.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackOtherState(Buf, OutData%OtherSt_ED(i1)) ! OtherSt_ED 
      end do
   end if
   ! u_ED
   if (allocated(OutData%u_ED)) deallocate(OutData%u_ED)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_ED(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_ED.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackInput(Buf, OutData%u_ED(i1)) ! u_ED 
      end do
   end if
   ! x_SrvD
   if (allocated(OutData%x_SrvD)) deallocate(OutData%x_SrvD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_SrvD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_SrvD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackContState(Buf, OutData%x_SrvD(i1)) ! x_SrvD 
      end do
   end if
   ! xd_SrvD
   if (allocated(OutData%xd_SrvD)) deallocate(OutData%xd_SrvD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_SrvD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_SrvD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackDiscState(Buf, OutData%xd_SrvD(i1)) ! xd_SrvD 
      end do
   end if
   ! z_SrvD
   if (allocated(OutData%z_SrvD)) deallocate(OutData%z_SrvD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_SrvD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_SrvD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackConstrState(Buf, OutData%z_SrvD(i1)) ! z_SrvD 
      end do
   end if
   ! OtherSt_SrvD
   if (allocated(OutData%OtherSt_SrvD)) deallocate(OutData%OtherSt_SrvD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_SrvD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_SrvD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackOtherState(Buf, OutData%OtherSt_SrvD(i1)) ! OtherSt_SrvD 
      end do
   end if
   ! u_SrvD
   if (allocated(OutData%u_SrvD)) deallocate(OutData%u_SrvD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_SrvD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_SrvD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackInput(Buf, OutData%u_SrvD(i1)) ! u_SrvD 
      end do
   end if
   ! x_AD
   if (allocated(OutData%x_AD)) deallocate(OutData%x_AD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_AD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_AD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackContState(Buf, OutData%x_AD(i1)) ! x_AD 
      end do
   end if
   ! xd_AD
   if (allocated(OutData%xd_AD)) deallocate(OutData%xd_AD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_AD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_AD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackDiscState(Buf, OutData%xd_AD(i1)) ! xd_AD 
      end do
   end if
   ! z_AD
   if (allocated(OutData%z_AD)) deallocate(OutData%z_AD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_AD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_AD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackConstrState(Buf, OutData%z_AD(i1)) ! z_AD 
      end do
   end if
   ! OtherSt_AD
   if (allocated(OutData%OtherSt_AD)) deallocate(OutData%OtherSt_AD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_AD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_AD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackOtherState(Buf, OutData%OtherSt_AD(i1)) ! OtherSt_AD 
      end do
   end if
   ! u_AD
   if (allocated(OutData%u_AD)) deallocate(OutData%u_AD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_AD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_AD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackInput(Buf, OutData%u_AD(i1)) ! u_AD 
      end do
   end if
   ! x_IfW
   if (allocated(OutData%x_IfW)) deallocate(OutData%x_IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackContState(Buf, OutData%x_IfW(i1)) ! x_IfW 
      end do
   end if
   ! xd_IfW
   if (allocated(OutData%xd_IfW)) deallocate(OutData%xd_IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackDiscState(Buf, OutData%xd_IfW(i1)) ! xd_IfW 
      end do
   end if
   ! z_IfW
   if (allocated(OutData%z_IfW)) deallocate(OutData%z_IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackConstrState(Buf, OutData%z_IfW(i1)) ! z_IfW 
      end do
   end if
   ! OtherSt_IfW
   if (allocated(OutData%OtherSt_IfW)) deallocate(OutData%OtherSt_IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackOtherState(Buf, OutData%OtherSt_IfW(i1)) ! OtherSt_IfW 
      end do
   end if
   ! u_IfW
   if (allocated(OutData%u_IfW)) deallocate(OutData%u_IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackInput(Buf, OutData%u_IfW(i1)) ! u_IfW 
      end do
   end if
   ! x_SD
   if (allocated(OutData%x_SD)) deallocate(OutData%x_SD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_SD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_SD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackContState(Buf, OutData%x_SD(i1)) ! x_SD 
      end do
   end if
   ! xd_SD
   if (allocated(OutData%xd_SD)) deallocate(OutData%xd_SD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_SD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_SD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackDiscState(Buf, OutData%xd_SD(i1)) ! xd_SD 
      end do
   end if
   ! z_SD
   if (allocated(OutData%z_SD)) deallocate(OutData%z_SD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_SD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_SD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackConstrState(Buf, OutData%z_SD(i1)) ! z_SD 
      end do
   end if
   ! OtherSt_SD
   if (allocated(OutData%OtherSt_SD)) deallocate(OutData%OtherSt_SD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_SD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_SD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackOtherState(Buf, OutData%OtherSt_SD(i1)) ! OtherSt_SD 
      end do
   end if
   ! u_SD
   if (allocated(OutData%u_SD)) deallocate(OutData%u_SD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_SD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_SD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackInput(Buf, OutData%u_SD(i1)) ! u_SD 
      end do
   end if
   ! x_ExtPtfm
   if (allocated(OutData%x_ExtPtfm)) deallocate(OutData%x_ExtPtfm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_ExtPtfm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_ExtPtfm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackContState(Buf, OutData%x_ExtPtfm(i1)) ! x_ExtPtfm 
      end do
   end if
   ! xd_ExtPtfm
   if (allocated(OutData%xd_ExtPtfm)) deallocate(OutData%xd_ExtPtfm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_ExtPtfm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_ExtPtfm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackDiscState(Buf, OutData%xd_ExtPtfm(i1)) ! xd_ExtPtfm 
      end do
   end if
   ! z_ExtPtfm
   if (allocated(OutData%z_ExtPtfm)) deallocate(OutData%z_ExtPtfm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_ExtPtfm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_ExtPtfm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackConstrState(Buf, OutData%z_ExtPtfm(i1)) ! z_ExtPtfm 
      end do
   end if
   ! OtherSt_ExtPtfm
   if (allocated(OutData%OtherSt_ExtPtfm)) deallocate(OutData%OtherSt_ExtPtfm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_ExtPtfm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_ExtPtfm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackOtherState(Buf, OutData%OtherSt_ExtPtfm(i1)) ! OtherSt_ExtPtfm 
      end do
   end if
   ! u_ExtPtfm
   if (allocated(OutData%u_ExtPtfm)) deallocate(OutData%u_ExtPtfm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_ExtPtfm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_ExtPtfm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackInput(Buf, OutData%u_ExtPtfm(i1)) ! u_ExtPtfm 
      end do
   end if
   ! x_HD
   if (allocated(OutData%x_HD)) deallocate(OutData%x_HD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_HD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_HD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackContState(Buf, OutData%x_HD(i1)) ! x_HD 
      end do
   end if
   ! xd_HD
   if (allocated(OutData%xd_HD)) deallocate(OutData%xd_HD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_HD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_HD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackDiscState(Buf, OutData%xd_HD(i1)) ! xd_HD 
      end do
   end if
   ! z_HD
   if (allocated(OutData%z_HD)) deallocate(OutData%z_HD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_HD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_HD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackConstrState(Buf, OutData%z_HD(i1)) ! z_HD 
      end do
   end if
   ! OtherSt_HD
   if (allocated(OutData%OtherSt_HD)) deallocate(OutData%OtherSt_HD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_HD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_HD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackOtherState(Buf, OutData%OtherSt_HD(i1)) ! OtherSt_HD 
      end do
   end if
   ! u_HD
   if (allocated(OutData%u_HD)) deallocate(OutData%u_HD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_HD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_HD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackInput(Buf, OutData%u_HD(i1)) ! u_HD 
      end do
   end if
   ! x_IceF
   if (allocated(OutData%x_IceF)) deallocate(OutData%x_IceF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_IceF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_IceF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackContState(Buf, OutData%x_IceF(i1)) ! x_IceF 
      end do
   end if
   ! xd_IceF
   if (allocated(OutData%xd_IceF)) deallocate(OutData%xd_IceF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_IceF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_IceF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackDiscState(Buf, OutData%xd_IceF(i1)) ! xd_IceF 
      end do
   end if
   ! z_IceF
   if (allocated(OutData%z_IceF)) deallocate(OutData%z_IceF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_IceF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_IceF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackConstrState(Buf, OutData%z_IceF(i1)) ! z_IceF 
      end do
   end if
   ! OtherSt_IceF
   if (allocated(OutData%OtherSt_IceF)) deallocate(OutData%OtherSt_IceF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_IceF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_IceF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackOtherState(Buf, OutData%OtherSt_IceF(i1)) ! OtherSt_IceF 
      end do
   end if
   ! u_IceF
   if (allocated(OutData%u_IceF)) deallocate(OutData%u_IceF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_IceF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_IceF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackInput(Buf, OutData%u_IceF(i1)) ! u_IceF 
      end do
   end if
   ! x_MAP
   if (allocated(OutData%x_MAP)) deallocate(OutData%x_MAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_MAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_MAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackContState(Buf, OutData%x_MAP(i1)) ! x_MAP 
      end do
   end if
   ! xd_MAP
   if (allocated(OutData%xd_MAP)) deallocate(OutData%xd_MAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_MAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_MAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackDiscState(Buf, OutData%xd_MAP(i1)) ! xd_MAP 
      end do
   end if
   ! z_MAP
   if (allocated(OutData%z_MAP)) deallocate(OutData%z_MAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_MAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_MAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackConstrState(Buf, OutData%z_MAP(i1)) ! z_MAP 
      end do
   end if
   ! u_MAP
   if (allocated(OutData%u_MAP)) deallocate(OutData%u_MAP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_MAP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_MAP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackInput(Buf, OutData%u_MAP(i1)) ! u_MAP 
      end do
   end if
   ! x_FEAM
   if (allocated(OutData%x_FEAM)) deallocate(OutData%x_FEAM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_FEAM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_FEAM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackContState(Buf, OutData%x_FEAM(i1)) ! x_FEAM 
      end do
   end if
   ! xd_FEAM
   if (allocated(OutData%xd_FEAM)) deallocate(OutData%xd_FEAM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_FEAM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_FEAM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackDiscState(Buf, OutData%xd_FEAM(i1)) ! xd_FEAM 
      end do
   end if
   ! z_FEAM
   if (allocated(OutData%z_FEAM)) deallocate(OutData%z_FEAM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_FEAM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_FEAM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackConstrState(Buf, OutData%z_FEAM(i1)) ! z_FEAM 
      end do
   end if
   ! OtherSt_FEAM
   if (allocated(OutData%OtherSt_FEAM)) deallocate(OutData%OtherSt_FEAM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_FEAM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_FEAM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackOtherState(Buf, OutData%OtherSt_FEAM(i1)) ! OtherSt_FEAM 
      end do
   end if
   ! u_FEAM
   if (allocated(OutData%u_FEAM)) deallocate(OutData%u_FEAM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_FEAM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_FEAM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackInput(Buf, OutData%u_FEAM(i1)) ! u_FEAM 
      end do
   end if
   ! x_MD
   if (allocated(OutData%x_MD)) deallocate(OutData%x_MD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_MD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_MD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackContState(Buf, OutData%x_MD(i1)) ! x_MD 
      end do
   end if
   ! xd_MD
   if (allocated(OutData%xd_MD)) deallocate(OutData%xd_MD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd_MD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd_MD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackDiscState(Buf, OutData%xd_MD(i1)) ! xd_MD 
      end do
   end if
   ! z_MD
   if (allocated(OutData%z_MD)) deallocate(OutData%z_MD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z_MD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z_MD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackConstrState(Buf, OutData%z_MD(i1)) ! z_MD 
      end do
   end if
   ! OtherSt_MD
   if (allocated(OutData%OtherSt_MD)) deallocate(OutData%OtherSt_MD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt_MD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt_MD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackOtherState(Buf, OutData%OtherSt_MD(i1)) ! OtherSt_MD 
      end do
   end if
   ! u_MD
   if (allocated(OutData%u_MD)) deallocate(OutData%u_MD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_MD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_MD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackInput(Buf, OutData%u_MD(i1)) ! u_MD 
      end do
   end if
end subroutine
 SUBROUTINE FAST_CopyLinType( SrcLinTypeData, DstLinTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_LinType), INTENT(IN) :: SrcLinTypeData
   TYPE(FAST_LinType), INTENT(INOUT) :: DstLinTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyLinType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcLinTypeData%Names_u)) THEN
  i1_l = LBOUND(SrcLinTypeData%Names_u,1)
  i1_u = UBOUND(SrcLinTypeData%Names_u,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Names_u)) THEN 
    ALLOCATE(DstLinTypeData%Names_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Names_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Names_u = SrcLinTypeData%Names_u
ENDIF
IF (ALLOCATED(SrcLinTypeData%Names_y)) THEN
  i1_l = LBOUND(SrcLinTypeData%Names_y,1)
  i1_u = UBOUND(SrcLinTypeData%Names_y,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Names_y)) THEN 
    ALLOCATE(DstLinTypeData%Names_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Names_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Names_y = SrcLinTypeData%Names_y
ENDIF
IF (ALLOCATED(SrcLinTypeData%Names_x)) THEN
  i1_l = LBOUND(SrcLinTypeData%Names_x,1)
  i1_u = UBOUND(SrcLinTypeData%Names_x,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Names_x)) THEN 
    ALLOCATE(DstLinTypeData%Names_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Names_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Names_x = SrcLinTypeData%Names_x
ENDIF
IF (ALLOCATED(SrcLinTypeData%Names_xd)) THEN
  i1_l = LBOUND(SrcLinTypeData%Names_xd,1)
  i1_u = UBOUND(SrcLinTypeData%Names_xd,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Names_xd)) THEN 
    ALLOCATE(DstLinTypeData%Names_xd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Names_xd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Names_xd = SrcLinTypeData%Names_xd
ENDIF
IF (ALLOCATED(SrcLinTypeData%Names_z)) THEN
  i1_l = LBOUND(SrcLinTypeData%Names_z,1)
  i1_u = UBOUND(SrcLinTypeData%Names_z,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Names_z)) THEN 
    ALLOCATE(DstLinTypeData%Names_z(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Names_z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Names_z = SrcLinTypeData%Names_z
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_u)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_u,1)
  i1_u = UBOUND(SrcLinTypeData%op_u,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_u)) THEN 
    ALLOCATE(DstLinTypeData%op_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_u = SrcLinTypeData%op_u
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_y)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_y,1)
  i1_u = UBOUND(SrcLinTypeData%op_y,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_y)) THEN 
    ALLOCATE(DstLinTypeData%op_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_y = SrcLinTypeData%op_y
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_x)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_x,1)
  i1_u = UBOUND(SrcLinTypeData%op_x,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_x)) THEN 
    ALLOCATE(DstLinTypeData%op_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_x = SrcLinTypeData%op_x
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_dx)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_dx,1)
  i1_u = UBOUND(SrcLinTypeData%op_dx,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_dx)) THEN 
    ALLOCATE(DstLinTypeData%op_dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_dx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_dx = SrcLinTypeData%op_dx
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_xd)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_xd,1)
  i1_u = UBOUND(SrcLinTypeData%op_xd,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_xd)) THEN 
    ALLOCATE(DstLinTypeData%op_xd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_xd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_xd = SrcLinTypeData%op_xd
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_z)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_z,1)
  i1_u = UBOUND(SrcLinTypeData%op_z,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_z)) THEN 
    ALLOCATE(DstLinTypeData%op_z(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_z = SrcLinTypeData%op_z
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_x_eig_mag)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_x_eig_mag,1)
  i1_u = UBOUND(SrcLinTypeData%op_x_eig_mag,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_x_eig_mag)) THEN 
    ALLOCATE(DstLinTypeData%op_x_eig_mag(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_x_eig_mag.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_x_eig_mag = SrcLinTypeData%op_x_eig_mag
ENDIF
IF (ALLOCATED(SrcLinTypeData%op_x_eig_phase)) THEN
  i1_l = LBOUND(SrcLinTypeData%op_x_eig_phase,1)
  i1_u = UBOUND(SrcLinTypeData%op_x_eig_phase,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%op_x_eig_phase)) THEN 
    ALLOCATE(DstLinTypeData%op_x_eig_phase(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%op_x_eig_phase.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%op_x_eig_phase = SrcLinTypeData%op_x_eig_phase
ENDIF
IF (ALLOCATED(SrcLinTypeData%Use_u)) THEN
  i1_l = LBOUND(SrcLinTypeData%Use_u,1)
  i1_u = UBOUND(SrcLinTypeData%Use_u,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Use_u)) THEN 
    ALLOCATE(DstLinTypeData%Use_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Use_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Use_u = SrcLinTypeData%Use_u
ENDIF
IF (ALLOCATED(SrcLinTypeData%Use_y)) THEN
  i1_l = LBOUND(SrcLinTypeData%Use_y,1)
  i1_u = UBOUND(SrcLinTypeData%Use_y,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%Use_y)) THEN 
    ALLOCATE(DstLinTypeData%Use_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%Use_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%Use_y = SrcLinTypeData%Use_y
ENDIF
IF (ALLOCATED(SrcLinTypeData%A)) THEN
  i1_l = LBOUND(SrcLinTypeData%A,1)
  i1_u = UBOUND(SrcLinTypeData%A,1)
  i2_l = LBOUND(SrcLinTypeData%A,2)
  i2_u = UBOUND(SrcLinTypeData%A,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%A)) THEN 
    ALLOCATE(DstLinTypeData%A(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%A.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%A = SrcLinTypeData%A
ENDIF
IF (ALLOCATED(SrcLinTypeData%B)) THEN
  i1_l = LBOUND(SrcLinTypeData%B,1)
  i1_u = UBOUND(SrcLinTypeData%B,1)
  i2_l = LBOUND(SrcLinTypeData%B,2)
  i2_u = UBOUND(SrcLinTypeData%B,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%B)) THEN 
    ALLOCATE(DstLinTypeData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%B = SrcLinTypeData%B
ENDIF
IF (ALLOCATED(SrcLinTypeData%C)) THEN
  i1_l = LBOUND(SrcLinTypeData%C,1)
  i1_u = UBOUND(SrcLinTypeData%C,1)
  i2_l = LBOUND(SrcLinTypeData%C,2)
  i2_u = UBOUND(SrcLinTypeData%C,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%C)) THEN 
    ALLOCATE(DstLinTypeData%C(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%C.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%C = SrcLinTypeData%C
ENDIF
IF (ALLOCATED(SrcLinTypeData%D)) THEN
  i1_l = LBOUND(SrcLinTypeData%D,1)
  i1_u = UBOUND(SrcLinTypeData%D,1)
  i2_l = LBOUND(SrcLinTypeData%D,2)
  i2_u = UBOUND(SrcLinTypeData%D,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%D)) THEN 
    ALLOCATE(DstLinTypeData%D(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%D.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%D = SrcLinTypeData%D
ENDIF
IF (ALLOCATED(SrcLinTypeData%StateRotation)) THEN
  i1_l = LBOUND(SrcLinTypeData%StateRotation,1)
  i1_u = UBOUND(SrcLinTypeData%StateRotation,1)
  i2_l = LBOUND(SrcLinTypeData%StateRotation,2)
  i2_u = UBOUND(SrcLinTypeData%StateRotation,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%StateRotation)) THEN 
    ALLOCATE(DstLinTypeData%StateRotation(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%StateRotation.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%StateRotation = SrcLinTypeData%StateRotation
ENDIF
IF (ALLOCATED(SrcLinTypeData%StateRel_x)) THEN
  i1_l = LBOUND(SrcLinTypeData%StateRel_x,1)
  i1_u = UBOUND(SrcLinTypeData%StateRel_x,1)
  i2_l = LBOUND(SrcLinTypeData%StateRel_x,2)
  i2_u = UBOUND(SrcLinTypeData%StateRel_x,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%StateRel_x)) THEN 
    ALLOCATE(DstLinTypeData%StateRel_x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%StateRel_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%StateRel_x = SrcLinTypeData%StateRel_x
ENDIF
IF (ALLOCATED(SrcLinTypeData%StateRel_xdot)) THEN
  i1_l = LBOUND(SrcLinTypeData%StateRel_xdot,1)
  i1_u = UBOUND(SrcLinTypeData%StateRel_xdot,1)
  i2_l = LBOUND(SrcLinTypeData%StateRel_xdot,2)
  i2_u = UBOUND(SrcLinTypeData%StateRel_xdot,2)
  IF (.NOT. ALLOCATED(DstLinTypeData%StateRel_xdot)) THEN 
    ALLOCATE(DstLinTypeData%StateRel_xdot(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%StateRel_xdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%StateRel_xdot = SrcLinTypeData%StateRel_xdot
ENDIF
IF (ALLOCATED(SrcLinTypeData%IsLoad_u)) THEN
  i1_l = LBOUND(SrcLinTypeData%IsLoad_u,1)
  i1_u = UBOUND(SrcLinTypeData%IsLoad_u,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%IsLoad_u)) THEN 
    ALLOCATE(DstLinTypeData%IsLoad_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%IsLoad_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%IsLoad_u = SrcLinTypeData%IsLoad_u
ENDIF
IF (ALLOCATED(SrcLinTypeData%RotFrame_u)) THEN
  i1_l = LBOUND(SrcLinTypeData%RotFrame_u,1)
  i1_u = UBOUND(SrcLinTypeData%RotFrame_u,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%RotFrame_u)) THEN 
    ALLOCATE(DstLinTypeData%RotFrame_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%RotFrame_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%RotFrame_u = SrcLinTypeData%RotFrame_u
ENDIF
IF (ALLOCATED(SrcLinTypeData%RotFrame_y)) THEN
  i1_l = LBOUND(SrcLinTypeData%RotFrame_y,1)
  i1_u = UBOUND(SrcLinTypeData%RotFrame_y,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%RotFrame_y)) THEN 
    ALLOCATE(DstLinTypeData%RotFrame_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%RotFrame_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%RotFrame_y = SrcLinTypeData%RotFrame_y
ENDIF
IF (ALLOCATED(SrcLinTypeData%RotFrame_x)) THEN
  i1_l = LBOUND(SrcLinTypeData%RotFrame_x,1)
  i1_u = UBOUND(SrcLinTypeData%RotFrame_x,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%RotFrame_x)) THEN 
    ALLOCATE(DstLinTypeData%RotFrame_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%RotFrame_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%RotFrame_x = SrcLinTypeData%RotFrame_x
ENDIF
IF (ALLOCATED(SrcLinTypeData%RotFrame_z)) THEN
  i1_l = LBOUND(SrcLinTypeData%RotFrame_z,1)
  i1_u = UBOUND(SrcLinTypeData%RotFrame_z,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%RotFrame_z)) THEN 
    ALLOCATE(DstLinTypeData%RotFrame_z(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%RotFrame_z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%RotFrame_z = SrcLinTypeData%RotFrame_z
ENDIF
IF (ALLOCATED(SrcLinTypeData%DerivOrder_x)) THEN
  i1_l = LBOUND(SrcLinTypeData%DerivOrder_x,1)
  i1_u = UBOUND(SrcLinTypeData%DerivOrder_x,1)
  IF (.NOT. ALLOCATED(DstLinTypeData%DerivOrder_x)) THEN 
    ALLOCATE(DstLinTypeData%DerivOrder_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLinTypeData%DerivOrder_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLinTypeData%DerivOrder_x = SrcLinTypeData%DerivOrder_x
ENDIF
    DstLinTypeData%SizeLin = SrcLinTypeData%SizeLin
    DstLinTypeData%LinStartIndx = SrcLinTypeData%LinStartIndx
    DstLinTypeData%NumOutputs = SrcLinTypeData%NumOutputs
 END SUBROUTINE FAST_CopyLinType

 SUBROUTINE FAST_DestroyLinType( LinTypeData, ErrStat, ErrMsg )
  TYPE(FAST_LinType), INTENT(INOUT) :: LinTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyLinType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(LinTypeData%Names_u)) THEN
  DEALLOCATE(LinTypeData%Names_u)
ENDIF
IF (ALLOCATED(LinTypeData%Names_y)) THEN
  DEALLOCATE(LinTypeData%Names_y)
ENDIF
IF (ALLOCATED(LinTypeData%Names_x)) THEN
  DEALLOCATE(LinTypeData%Names_x)
ENDIF
IF (ALLOCATED(LinTypeData%Names_xd)) THEN
  DEALLOCATE(LinTypeData%Names_xd)
ENDIF
IF (ALLOCATED(LinTypeData%Names_z)) THEN
  DEALLOCATE(LinTypeData%Names_z)
ENDIF
IF (ALLOCATED(LinTypeData%op_u)) THEN
  DEALLOCATE(LinTypeData%op_u)
ENDIF
IF (ALLOCATED(LinTypeData%op_y)) THEN
  DEALLOCATE(LinTypeData%op_y)
ENDIF
IF (ALLOCATED(LinTypeData%op_x)) THEN
  DEALLOCATE(LinTypeData%op_x)
ENDIF
IF (ALLOCATED(LinTypeData%op_dx)) THEN
  DEALLOCATE(LinTypeData%op_dx)
ENDIF
IF (ALLOCATED(LinTypeData%op_xd)) THEN
  DEALLOCATE(LinTypeData%op_xd)
ENDIF
IF (ALLOCATED(LinTypeData%op_z)) THEN
  DEALLOCATE(LinTypeData%op_z)
ENDIF
IF (ALLOCATED(LinTypeData%op_x_eig_mag)) THEN
  DEALLOCATE(LinTypeData%op_x_eig_mag)
ENDIF
IF (ALLOCATED(LinTypeData%op_x_eig_phase)) THEN
  DEALLOCATE(LinTypeData%op_x_eig_phase)
ENDIF
IF (ALLOCATED(LinTypeData%Use_u)) THEN
  DEALLOCATE(LinTypeData%Use_u)
ENDIF
IF (ALLOCATED(LinTypeData%Use_y)) THEN
  DEALLOCATE(LinTypeData%Use_y)
ENDIF
IF (ALLOCATED(LinTypeData%A)) THEN
  DEALLOCATE(LinTypeData%A)
ENDIF
IF (ALLOCATED(LinTypeData%B)) THEN
  DEALLOCATE(LinTypeData%B)
ENDIF
IF (ALLOCATED(LinTypeData%C)) THEN
  DEALLOCATE(LinTypeData%C)
ENDIF
IF (ALLOCATED(LinTypeData%D)) THEN
  DEALLOCATE(LinTypeData%D)
ENDIF
IF (ALLOCATED(LinTypeData%StateRotation)) THEN
  DEALLOCATE(LinTypeData%StateRotation)
ENDIF
IF (ALLOCATED(LinTypeData%StateRel_x)) THEN
  DEALLOCATE(LinTypeData%StateRel_x)
ENDIF
IF (ALLOCATED(LinTypeData%StateRel_xdot)) THEN
  DEALLOCATE(LinTypeData%StateRel_xdot)
ENDIF
IF (ALLOCATED(LinTypeData%IsLoad_u)) THEN
  DEALLOCATE(LinTypeData%IsLoad_u)
ENDIF
IF (ALLOCATED(LinTypeData%RotFrame_u)) THEN
  DEALLOCATE(LinTypeData%RotFrame_u)
ENDIF
IF (ALLOCATED(LinTypeData%RotFrame_y)) THEN
  DEALLOCATE(LinTypeData%RotFrame_y)
ENDIF
IF (ALLOCATED(LinTypeData%RotFrame_x)) THEN
  DEALLOCATE(LinTypeData%RotFrame_x)
ENDIF
IF (ALLOCATED(LinTypeData%RotFrame_z)) THEN
  DEALLOCATE(LinTypeData%RotFrame_z)
ENDIF
IF (ALLOCATED(LinTypeData%DerivOrder_x)) THEN
  DEALLOCATE(LinTypeData%DerivOrder_x)
ENDIF
 END SUBROUTINE FAST_DestroyLinType


subroutine FAST_PackLinType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_LinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackLinType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Names_u
   call RegPack(Buf, allocated(InData%Names_u))
   if (allocated(InData%Names_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%Names_u), ubound(InData%Names_u))
      call RegPack(Buf, InData%Names_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Names_y
   call RegPack(Buf, allocated(InData%Names_y))
   if (allocated(InData%Names_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%Names_y), ubound(InData%Names_y))
      call RegPack(Buf, InData%Names_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Names_x
   call RegPack(Buf, allocated(InData%Names_x))
   if (allocated(InData%Names_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%Names_x), ubound(InData%Names_x))
      call RegPack(Buf, InData%Names_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Names_xd
   call RegPack(Buf, allocated(InData%Names_xd))
   if (allocated(InData%Names_xd)) then
      call RegPackBounds(Buf, 1, lbound(InData%Names_xd), ubound(InData%Names_xd))
      call RegPack(Buf, InData%Names_xd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Names_z
   call RegPack(Buf, allocated(InData%Names_z))
   if (allocated(InData%Names_z)) then
      call RegPackBounds(Buf, 1, lbound(InData%Names_z), ubound(InData%Names_z))
      call RegPack(Buf, InData%Names_z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_u
   call RegPack(Buf, allocated(InData%op_u))
   if (allocated(InData%op_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_u), ubound(InData%op_u))
      call RegPack(Buf, InData%op_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_y
   call RegPack(Buf, allocated(InData%op_y))
   if (allocated(InData%op_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_y), ubound(InData%op_y))
      call RegPack(Buf, InData%op_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_x
   call RegPack(Buf, allocated(InData%op_x))
   if (allocated(InData%op_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_x), ubound(InData%op_x))
      call RegPack(Buf, InData%op_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_dx
   call RegPack(Buf, allocated(InData%op_dx))
   if (allocated(InData%op_dx)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_dx), ubound(InData%op_dx))
      call RegPack(Buf, InData%op_dx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_xd
   call RegPack(Buf, allocated(InData%op_xd))
   if (allocated(InData%op_xd)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_xd), ubound(InData%op_xd))
      call RegPack(Buf, InData%op_xd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_z
   call RegPack(Buf, allocated(InData%op_z))
   if (allocated(InData%op_z)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_z), ubound(InData%op_z))
      call RegPack(Buf, InData%op_z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_x_eig_mag
   call RegPack(Buf, allocated(InData%op_x_eig_mag))
   if (allocated(InData%op_x_eig_mag)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_x_eig_mag), ubound(InData%op_x_eig_mag))
      call RegPack(Buf, InData%op_x_eig_mag)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! op_x_eig_phase
   call RegPack(Buf, allocated(InData%op_x_eig_phase))
   if (allocated(InData%op_x_eig_phase)) then
      call RegPackBounds(Buf, 1, lbound(InData%op_x_eig_phase), ubound(InData%op_x_eig_phase))
      call RegPack(Buf, InData%op_x_eig_phase)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Use_u
   call RegPack(Buf, allocated(InData%Use_u))
   if (allocated(InData%Use_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%Use_u), ubound(InData%Use_u))
      call RegPack(Buf, InData%Use_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Use_y
   call RegPack(Buf, allocated(InData%Use_y))
   if (allocated(InData%Use_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%Use_y), ubound(InData%Use_y))
      call RegPack(Buf, InData%Use_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! A
   call RegPack(Buf, allocated(InData%A))
   if (allocated(InData%A)) then
      call RegPackBounds(Buf, 2, lbound(InData%A), ubound(InData%A))
      call RegPack(Buf, InData%A)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! B
   call RegPack(Buf, allocated(InData%B))
   if (allocated(InData%B)) then
      call RegPackBounds(Buf, 2, lbound(InData%B), ubound(InData%B))
      call RegPack(Buf, InData%B)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C
   call RegPack(Buf, allocated(InData%C))
   if (allocated(InData%C)) then
      call RegPackBounds(Buf, 2, lbound(InData%C), ubound(InData%C))
      call RegPack(Buf, InData%C)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D
   call RegPack(Buf, allocated(InData%D))
   if (allocated(InData%D)) then
      call RegPackBounds(Buf, 2, lbound(InData%D), ubound(InData%D))
      call RegPack(Buf, InData%D)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StateRotation
   call RegPack(Buf, allocated(InData%StateRotation))
   if (allocated(InData%StateRotation)) then
      call RegPackBounds(Buf, 2, lbound(InData%StateRotation), ubound(InData%StateRotation))
      call RegPack(Buf, InData%StateRotation)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StateRel_x
   call RegPack(Buf, allocated(InData%StateRel_x))
   if (allocated(InData%StateRel_x)) then
      call RegPackBounds(Buf, 2, lbound(InData%StateRel_x), ubound(InData%StateRel_x))
      call RegPack(Buf, InData%StateRel_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! StateRel_xdot
   call RegPack(Buf, allocated(InData%StateRel_xdot))
   if (allocated(InData%StateRel_xdot)) then
      call RegPackBounds(Buf, 2, lbound(InData%StateRel_xdot), ubound(InData%StateRel_xdot))
      call RegPack(Buf, InData%StateRel_xdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsLoad_u
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_u
   call RegPack(Buf, allocated(InData%RotFrame_u))
   if (allocated(InData%RotFrame_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_u), ubound(InData%RotFrame_u))
      call RegPack(Buf, InData%RotFrame_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_y
   call RegPack(Buf, allocated(InData%RotFrame_y))
   if (allocated(InData%RotFrame_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_y), ubound(InData%RotFrame_y))
      call RegPack(Buf, InData%RotFrame_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_x
   call RegPack(Buf, allocated(InData%RotFrame_x))
   if (allocated(InData%RotFrame_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_x), ubound(InData%RotFrame_x))
      call RegPack(Buf, InData%RotFrame_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_z
   call RegPack(Buf, allocated(InData%RotFrame_z))
   if (allocated(InData%RotFrame_z)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_z), ubound(InData%RotFrame_z))
      call RegPack(Buf, InData%RotFrame_z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DerivOrder_x
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SizeLin
   call RegPack(Buf, InData%SizeLin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinStartIndx
   call RegPack(Buf, InData%LinStartIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOutputs
   call RegPack(Buf, InData%NumOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackLinType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_LinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackLinType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Names_u
   if (allocated(OutData%Names_u)) deallocate(OutData%Names_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Names_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Names_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Names_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Names_y
   if (allocated(OutData%Names_y)) deallocate(OutData%Names_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Names_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Names_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Names_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Names_x
   if (allocated(OutData%Names_x)) deallocate(OutData%Names_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Names_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Names_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Names_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Names_xd
   if (allocated(OutData%Names_xd)) deallocate(OutData%Names_xd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Names_xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Names_xd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Names_xd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Names_z
   if (allocated(OutData%Names_z)) deallocate(OutData%Names_z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Names_z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Names_z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Names_z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_u
   if (allocated(OutData%op_u)) deallocate(OutData%op_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_y
   if (allocated(OutData%op_y)) deallocate(OutData%op_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_x
   if (allocated(OutData%op_x)) deallocate(OutData%op_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_dx
   if (allocated(OutData%op_dx)) deallocate(OutData%op_dx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_dx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_dx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_dx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_xd
   if (allocated(OutData%op_xd)) deallocate(OutData%op_xd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_xd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_xd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_xd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_z
   if (allocated(OutData%op_z)) deallocate(OutData%op_z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_x_eig_mag
   if (allocated(OutData%op_x_eig_mag)) deallocate(OutData%op_x_eig_mag)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_x_eig_mag(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_x_eig_mag.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_x_eig_mag)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! op_x_eig_phase
   if (allocated(OutData%op_x_eig_phase)) deallocate(OutData%op_x_eig_phase)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%op_x_eig_phase(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%op_x_eig_phase.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%op_x_eig_phase)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Use_u
   if (allocated(OutData%Use_u)) deallocate(OutData%Use_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Use_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Use_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Use_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Use_y
   if (allocated(OutData%Use_y)) deallocate(OutData%Use_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Use_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Use_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Use_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! A
   if (allocated(OutData%A)) deallocate(OutData%A)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%A(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%A.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%A)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! B
   if (allocated(OutData%B)) deallocate(OutData%B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%B)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C
   if (allocated(OutData%C)) deallocate(OutData%C)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D
   if (allocated(OutData%D)) deallocate(OutData%D)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StateRotation
   if (allocated(OutData%StateRotation)) deallocate(OutData%StateRotation)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StateRotation(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StateRotation.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StateRotation)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StateRel_x
   if (allocated(OutData%StateRel_x)) deallocate(OutData%StateRel_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StateRel_x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StateRel_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StateRel_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! StateRel_xdot
   if (allocated(OutData%StateRel_xdot)) deallocate(OutData%StateRel_xdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%StateRel_xdot(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%StateRel_xdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%StateRel_xdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsLoad_u
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_u
   if (allocated(OutData%RotFrame_u)) deallocate(OutData%RotFrame_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_y
   if (allocated(OutData%RotFrame_y)) deallocate(OutData%RotFrame_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_x
   if (allocated(OutData%RotFrame_x)) deallocate(OutData%RotFrame_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_z
   if (allocated(OutData%RotFrame_z)) deallocate(OutData%RotFrame_z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DerivOrder_x
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SizeLin
   call RegUnpack(Buf, OutData%SizeLin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinStartIndx
   call RegUnpack(Buf, OutData%LinStartIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOutputs
   call RegUnpack(Buf, OutData%NumOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FAST_CopyModLinType( SrcModLinTypeData, DstModLinTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_ModLinType), INTENT(IN) :: SrcModLinTypeData
   TYPE(FAST_ModLinType), INTENT(INOUT) :: DstModLinTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyModLinType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcModLinTypeData%Instance)) THEN
  i1_l = LBOUND(SrcModLinTypeData%Instance,1)
  i1_u = UBOUND(SrcModLinTypeData%Instance,1)
  IF (.NOT. ALLOCATED(DstModLinTypeData%Instance)) THEN 
    ALLOCATE(DstModLinTypeData%Instance(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModLinTypeData%Instance.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModLinTypeData%Instance,1), UBOUND(SrcModLinTypeData%Instance,1)
      CALL FAST_Copylintype( SrcModLinTypeData%Instance(i1), DstModLinTypeData%Instance(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FAST_CopyModLinType

 SUBROUTINE FAST_DestroyModLinType( ModLinTypeData, ErrStat, ErrMsg )
  TYPE(FAST_ModLinType), INTENT(INOUT) :: ModLinTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyModLinType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ModLinTypeData%Instance)) THEN
DO i1 = LBOUND(ModLinTypeData%Instance,1), UBOUND(ModLinTypeData%Instance,1)
  CALL FAST_DestroyLinType( ModLinTypeData%Instance(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModLinTypeData%Instance)
ENDIF
 END SUBROUTINE FAST_DestroyModLinType


subroutine FAST_PackModLinType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_ModLinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackModLinType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Instance
   call RegPack(Buf, allocated(InData%Instance))
   if (allocated(InData%Instance)) then
      call RegPackBounds(Buf, 1, lbound(InData%Instance), ubound(InData%Instance))
      LB(1:1) = lbound(InData%Instance)
      UB(1:1) = ubound(InData%Instance)
      do i1 = LB(1), UB(1)
         call FAST_PackLinType(Buf, InData%Instance(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackModLinType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_ModLinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackModLinType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Instance
   if (allocated(OutData%Instance)) deallocate(OutData%Instance)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Instance(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Instance.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FAST_UnpackLinType(Buf, OutData%Instance(i1)) ! Instance 
      end do
   end if
end subroutine
 SUBROUTINE FAST_CopyLinFileType( SrcLinFileTypeData, DstLinFileTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_LinFileType), INTENT(IN) :: SrcLinFileTypeData
   TYPE(FAST_LinFileType), INTENT(INOUT) :: DstLinFileTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyLinFileType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcLinFileTypeData%Modules,1), UBOUND(SrcLinFileTypeData%Modules,1)
      CALL FAST_Copymodlintype( SrcLinFileTypeData%Modules(i1), DstLinFileTypeData%Modules(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL FAST_Copylintype( SrcLinFileTypeData%Glue, DstLinFileTypeData%Glue, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstLinFileTypeData%RotSpeed = SrcLinFileTypeData%RotSpeed
    DstLinFileTypeData%Azimuth = SrcLinFileTypeData%Azimuth
    DstLinFileTypeData%WindSpeed = SrcLinFileTypeData%WindSpeed
 END SUBROUTINE FAST_CopyLinFileType

 SUBROUTINE FAST_DestroyLinFileType( LinFileTypeData, ErrStat, ErrMsg )
  TYPE(FAST_LinFileType), INTENT(INOUT) :: LinFileTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyLinFileType'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(LinFileTypeData%Modules,1), UBOUND(LinFileTypeData%Modules,1)
  CALL FAST_DestroyModLinType( LinFileTypeData%Modules(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL FAST_DestroyLinType( LinFileTypeData%Glue, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyLinFileType


subroutine FAST_PackLinFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_LinFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackLinFileType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Modules
   LB(1:1) = lbound(InData%Modules)
   UB(1:1) = ubound(InData%Modules)
   do i1 = LB(1), UB(1)
      call FAST_PackModLinType(Buf, InData%Modules(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! Glue
   call FAST_PackLinType(Buf, InData%Glue) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotSpeed
   call RegPack(Buf, InData%RotSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Azimuth
   call RegPack(Buf, InData%Azimuth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindSpeed
   call RegPack(Buf, InData%WindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackLinFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_LinFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackLinFileType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat /= ErrID_None) return
   ! Modules
   LB(1:1) = lbound(OutData%Modules)
   UB(1:1) = ubound(OutData%Modules)
   do i1 = LB(1), UB(1)
      call FAST_UnpackModLinType(Buf, OutData%Modules(i1)) ! Modules 
   end do
   ! Glue
   call FAST_UnpackLinType(Buf, OutData%Glue) ! Glue 
   ! RotSpeed
   call RegUnpack(Buf, OutData%RotSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Azimuth
   call RegUnpack(Buf, OutData%Azimuth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindSpeed
   call RegUnpack(Buf, OutData%WindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FAST_CopyMiscLinType( SrcMiscLinTypeData, DstMiscLinTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_MiscLinType), INTENT(IN) :: SrcMiscLinTypeData
   TYPE(FAST_MiscLinType), INTENT(INOUT) :: DstMiscLinTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyMiscLinType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscLinTypeData%LinTimes)) THEN
  i1_l = LBOUND(SrcMiscLinTypeData%LinTimes,1)
  i1_u = UBOUND(SrcMiscLinTypeData%LinTimes,1)
  IF (.NOT. ALLOCATED(DstMiscLinTypeData%LinTimes)) THEN 
    ALLOCATE(DstMiscLinTypeData%LinTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%LinTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscLinTypeData%LinTimes = SrcMiscLinTypeData%LinTimes
ENDIF
    DstMiscLinTypeData%CopyOP_CtrlCode = SrcMiscLinTypeData%CopyOP_CtrlCode
IF (ALLOCATED(SrcMiscLinTypeData%AzimTarget)) THEN
  i1_l = LBOUND(SrcMiscLinTypeData%AzimTarget,1)
  i1_u = UBOUND(SrcMiscLinTypeData%AzimTarget,1)
  IF (.NOT. ALLOCATED(DstMiscLinTypeData%AzimTarget)) THEN 
    ALLOCATE(DstMiscLinTypeData%AzimTarget(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%AzimTarget.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscLinTypeData%AzimTarget = SrcMiscLinTypeData%AzimTarget
ENDIF
    DstMiscLinTypeData%IsConverged = SrcMiscLinTypeData%IsConverged
    DstMiscLinTypeData%FoundSteady = SrcMiscLinTypeData%FoundSteady
    DstMiscLinTypeData%ForceLin = SrcMiscLinTypeData%ForceLin
    DstMiscLinTypeData%n_rot = SrcMiscLinTypeData%n_rot
    DstMiscLinTypeData%AzimIndx = SrcMiscLinTypeData%AzimIndx
    DstMiscLinTypeData%NextLinTimeIndx = SrcMiscLinTypeData%NextLinTimeIndx
IF (ALLOCATED(SrcMiscLinTypeData%Psi)) THEN
  i1_l = LBOUND(SrcMiscLinTypeData%Psi,1)
  i1_u = UBOUND(SrcMiscLinTypeData%Psi,1)
  IF (.NOT. ALLOCATED(DstMiscLinTypeData%Psi)) THEN 
    ALLOCATE(DstMiscLinTypeData%Psi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%Psi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscLinTypeData%Psi = SrcMiscLinTypeData%Psi
ENDIF
IF (ALLOCATED(SrcMiscLinTypeData%y_interp)) THEN
  i1_l = LBOUND(SrcMiscLinTypeData%y_interp,1)
  i1_u = UBOUND(SrcMiscLinTypeData%y_interp,1)
  IF (.NOT. ALLOCATED(DstMiscLinTypeData%y_interp)) THEN 
    ALLOCATE(DstMiscLinTypeData%y_interp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%y_interp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscLinTypeData%y_interp = SrcMiscLinTypeData%y_interp
ENDIF
IF (ALLOCATED(SrcMiscLinTypeData%y_ref)) THEN
  i1_l = LBOUND(SrcMiscLinTypeData%y_ref,1)
  i1_u = UBOUND(SrcMiscLinTypeData%y_ref,1)
  IF (.NOT. ALLOCATED(DstMiscLinTypeData%y_ref)) THEN 
    ALLOCATE(DstMiscLinTypeData%y_ref(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%y_ref.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscLinTypeData%y_ref = SrcMiscLinTypeData%y_ref
ENDIF
IF (ALLOCATED(SrcMiscLinTypeData%Y_prevRot)) THEN
  i1_l = LBOUND(SrcMiscLinTypeData%Y_prevRot,1)
  i1_u = UBOUND(SrcMiscLinTypeData%Y_prevRot,1)
  i2_l = LBOUND(SrcMiscLinTypeData%Y_prevRot,2)
  i2_u = UBOUND(SrcMiscLinTypeData%Y_prevRot,2)
  IF (.NOT. ALLOCATED(DstMiscLinTypeData%Y_prevRot)) THEN 
    ALLOCATE(DstMiscLinTypeData%Y_prevRot(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscLinTypeData%Y_prevRot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscLinTypeData%Y_prevRot = SrcMiscLinTypeData%Y_prevRot
ENDIF
 END SUBROUTINE FAST_CopyMiscLinType

 SUBROUTINE FAST_DestroyMiscLinType( MiscLinTypeData, ErrStat, ErrMsg )
  TYPE(FAST_MiscLinType), INTENT(INOUT) :: MiscLinTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyMiscLinType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscLinTypeData%LinTimes)) THEN
  DEALLOCATE(MiscLinTypeData%LinTimes)
ENDIF
IF (ALLOCATED(MiscLinTypeData%AzimTarget)) THEN
  DEALLOCATE(MiscLinTypeData%AzimTarget)
ENDIF
IF (ALLOCATED(MiscLinTypeData%Psi)) THEN
  DEALLOCATE(MiscLinTypeData%Psi)
ENDIF
IF (ALLOCATED(MiscLinTypeData%y_interp)) THEN
  DEALLOCATE(MiscLinTypeData%y_interp)
ENDIF
IF (ALLOCATED(MiscLinTypeData%y_ref)) THEN
  DEALLOCATE(MiscLinTypeData%y_ref)
ENDIF
IF (ALLOCATED(MiscLinTypeData%Y_prevRot)) THEN
  DEALLOCATE(MiscLinTypeData%Y_prevRot)
ENDIF
 END SUBROUTINE FAST_DestroyMiscLinType


subroutine FAST_PackMiscLinType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_MiscLinType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMiscLinType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! LinTimes
   call RegPack(Buf, allocated(InData%LinTimes))
   if (allocated(InData%LinTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinTimes), ubound(InData%LinTimes))
      call RegPack(Buf, InData%LinTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CopyOP_CtrlCode
   call RegPack(Buf, InData%CopyOP_CtrlCode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AzimTarget
   call RegPack(Buf, allocated(InData%AzimTarget))
   if (allocated(InData%AzimTarget)) then
      call RegPackBounds(Buf, 1, lbound(InData%AzimTarget), ubound(InData%AzimTarget))
      call RegPack(Buf, InData%AzimTarget)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsConverged
   call RegPack(Buf, InData%IsConverged)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FoundSteady
   call RegPack(Buf, InData%FoundSteady)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ForceLin
   call RegPack(Buf, InData%ForceLin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_rot
   call RegPack(Buf, InData%n_rot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AzimIndx
   call RegPack(Buf, InData%AzimIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NextLinTimeIndx
   call RegPack(Buf, InData%NextLinTimeIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Psi
   call RegPack(Buf, allocated(InData%Psi))
   if (allocated(InData%Psi)) then
      call RegPackBounds(Buf, 1, lbound(InData%Psi), ubound(InData%Psi))
      call RegPack(Buf, InData%Psi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call RegPack(Buf, allocated(InData%y_interp))
   if (allocated(InData%y_interp)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_interp), ubound(InData%y_interp))
      call RegPack(Buf, InData%y_interp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_ref
   call RegPack(Buf, allocated(InData%y_ref))
   if (allocated(InData%y_ref)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_ref), ubound(InData%y_ref))
      call RegPack(Buf, InData%y_ref)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y_prevRot
   call RegPack(Buf, allocated(InData%Y_prevRot))
   if (allocated(InData%Y_prevRot)) then
      call RegPackBounds(Buf, 2, lbound(InData%Y_prevRot), ubound(InData%Y_prevRot))
      call RegPack(Buf, InData%Y_prevRot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackMiscLinType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_MiscLinType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMiscLinType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LinTimes
   if (allocated(OutData%LinTimes)) deallocate(OutData%LinTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CopyOP_CtrlCode
   call RegUnpack(Buf, OutData%CopyOP_CtrlCode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AzimTarget
   if (allocated(OutData%AzimTarget)) deallocate(OutData%AzimTarget)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AzimTarget(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AzimTarget.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AzimTarget)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsConverged
   call RegUnpack(Buf, OutData%IsConverged)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FoundSteady
   call RegUnpack(Buf, OutData%FoundSteady)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ForceLin
   call RegUnpack(Buf, OutData%ForceLin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_rot
   call RegUnpack(Buf, OutData%n_rot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AzimIndx
   call RegUnpack(Buf, OutData%AzimIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NextLinTimeIndx
   call RegUnpack(Buf, OutData%NextLinTimeIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Psi
   if (allocated(OutData%Psi)) deallocate(OutData%Psi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Psi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Psi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Psi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! y_interp
   if (allocated(OutData%y_interp)) deallocate(OutData%y_interp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_interp(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_interp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%y_interp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! y_ref
   if (allocated(OutData%y_ref)) deallocate(OutData%y_ref)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_ref(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_ref.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%y_ref)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Y_prevRot
   if (allocated(OutData%Y_prevRot)) deallocate(OutData%Y_prevRot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y_prevRot(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y_prevRot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y_prevRot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyOutputFileType( SrcOutputFileTypeData, DstOutputFileTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_OutputFileType), INTENT(INOUT) :: SrcOutputFileTypeData
   TYPE(FAST_OutputFileType), INTENT(INOUT) :: DstOutputFileTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyOutputFileType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputFileTypeData%TimeData)) THEN
  i1_l = LBOUND(SrcOutputFileTypeData%TimeData,1)
  i1_u = UBOUND(SrcOutputFileTypeData%TimeData,1)
  IF (.NOT. ALLOCATED(DstOutputFileTypeData%TimeData)) THEN 
    ALLOCATE(DstOutputFileTypeData%TimeData(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%TimeData.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputFileTypeData%TimeData = SrcOutputFileTypeData%TimeData
ENDIF
IF (ALLOCATED(SrcOutputFileTypeData%AllOutData)) THEN
  i1_l = LBOUND(SrcOutputFileTypeData%AllOutData,1)
  i1_u = UBOUND(SrcOutputFileTypeData%AllOutData,1)
  i2_l = LBOUND(SrcOutputFileTypeData%AllOutData,2)
  i2_u = UBOUND(SrcOutputFileTypeData%AllOutData,2)
  IF (.NOT. ALLOCATED(DstOutputFileTypeData%AllOutData)) THEN 
    ALLOCATE(DstOutputFileTypeData%AllOutData(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%AllOutData.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputFileTypeData%AllOutData = SrcOutputFileTypeData%AllOutData
ENDIF
    DstOutputFileTypeData%n_Out = SrcOutputFileTypeData%n_Out
    DstOutputFileTypeData%NOutSteps = SrcOutputFileTypeData%NOutSteps
    DstOutputFileTypeData%numOuts = SrcOutputFileTypeData%numOuts
    DstOutputFileTypeData%UnOu = SrcOutputFileTypeData%UnOu
    DstOutputFileTypeData%UnSum = SrcOutputFileTypeData%UnSum
    DstOutputFileTypeData%UnGra = SrcOutputFileTypeData%UnGra
    DstOutputFileTypeData%FileDescLines = SrcOutputFileTypeData%FileDescLines
IF (ALLOCATED(SrcOutputFileTypeData%ChannelNames)) THEN
  i1_l = LBOUND(SrcOutputFileTypeData%ChannelNames,1)
  i1_u = UBOUND(SrcOutputFileTypeData%ChannelNames,1)
  IF (.NOT. ALLOCATED(DstOutputFileTypeData%ChannelNames)) THEN 
    ALLOCATE(DstOutputFileTypeData%ChannelNames(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%ChannelNames.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputFileTypeData%ChannelNames = SrcOutputFileTypeData%ChannelNames
ENDIF
IF (ALLOCATED(SrcOutputFileTypeData%ChannelUnits)) THEN
  i1_l = LBOUND(SrcOutputFileTypeData%ChannelUnits,1)
  i1_u = UBOUND(SrcOutputFileTypeData%ChannelUnits,1)
  IF (.NOT. ALLOCATED(DstOutputFileTypeData%ChannelUnits)) THEN 
    ALLOCATE(DstOutputFileTypeData%ChannelUnits(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputFileTypeData%ChannelUnits.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputFileTypeData%ChannelUnits = SrcOutputFileTypeData%ChannelUnits
ENDIF
    DO i1 = LBOUND(SrcOutputFileTypeData%Module_Ver,1), UBOUND(SrcOutputFileTypeData%Module_Ver,1)
      CALL NWTC_Library_Copyprogdesc( SrcOutputFileTypeData%Module_Ver(i1), DstOutputFileTypeData%Module_Ver(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DstOutputFileTypeData%Module_Abrev = SrcOutputFileTypeData%Module_Abrev
    DstOutputFileTypeData%WriteThisStep = SrcOutputFileTypeData%WriteThisStep
    DstOutputFileTypeData%VTK_count = SrcOutputFileTypeData%VTK_count
    DstOutputFileTypeData%VTK_LastWaveIndx = SrcOutputFileTypeData%VTK_LastWaveIndx
      CALL FAST_Copylinfiletype( SrcOutputFileTypeData%Lin, DstOutputFileTypeData%Lin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstOutputFileTypeData%ActualChanLen = SrcOutputFileTypeData%ActualChanLen
      CALL FAST_Copylinstatesave( SrcOutputFileTypeData%op, DstOutputFileTypeData%op, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstOutputFileTypeData%DriverWriteOutput = SrcOutputFileTypeData%DriverWriteOutput
 END SUBROUTINE FAST_CopyOutputFileType

 SUBROUTINE FAST_DestroyOutputFileType( OutputFileTypeData, ErrStat, ErrMsg )
  TYPE(FAST_OutputFileType), INTENT(INOUT) :: OutputFileTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyOutputFileType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputFileTypeData%TimeData)) THEN
  DEALLOCATE(OutputFileTypeData%TimeData)
ENDIF
IF (ALLOCATED(OutputFileTypeData%AllOutData)) THEN
  DEALLOCATE(OutputFileTypeData%AllOutData)
ENDIF
IF (ALLOCATED(OutputFileTypeData%ChannelNames)) THEN
  DEALLOCATE(OutputFileTypeData%ChannelNames)
ENDIF
IF (ALLOCATED(OutputFileTypeData%ChannelUnits)) THEN
  DEALLOCATE(OutputFileTypeData%ChannelUnits)
ENDIF
DO i1 = LBOUND(OutputFileTypeData%Module_Ver,1), UBOUND(OutputFileTypeData%Module_Ver,1)
  CALL NWTC_Library_DestroyProgDesc( OutputFileTypeData%Module_Ver(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL FAST_DestroyLinFileType( OutputFileTypeData%Lin, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyLinStateSave( OutputFileTypeData%op, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyOutputFileType


subroutine FAST_PackOutputFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_OutputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackOutputFileType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! TimeData
   call RegPack(Buf, allocated(InData%TimeData))
   if (allocated(InData%TimeData)) then
      call RegPackBounds(Buf, 1, lbound(InData%TimeData), ubound(InData%TimeData))
      call RegPack(Buf, InData%TimeData)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AllOutData
   call RegPack(Buf, allocated(InData%AllOutData))
   if (allocated(InData%AllOutData)) then
      call RegPackBounds(Buf, 2, lbound(InData%AllOutData), ubound(InData%AllOutData))
      call RegPack(Buf, InData%AllOutData)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_Out
   call RegPack(Buf, InData%n_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutSteps
   call RegPack(Buf, InData%NOutSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! numOuts
   call RegPack(Buf, InData%numOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnOu
   call RegPack(Buf, InData%UnOu)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnSum
   call RegPack(Buf, InData%UnSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnGra
   call RegPack(Buf, InData%UnGra)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileDescLines
   call RegPack(Buf, InData%FileDescLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChannelNames
   call RegPack(Buf, allocated(InData%ChannelNames))
   if (allocated(InData%ChannelNames)) then
      call RegPackBounds(Buf, 1, lbound(InData%ChannelNames), ubound(InData%ChannelNames))
      call RegPack(Buf, InData%ChannelNames)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChannelUnits
   call RegPack(Buf, allocated(InData%ChannelUnits))
   if (allocated(InData%ChannelUnits)) then
      call RegPackBounds(Buf, 1, lbound(InData%ChannelUnits), ubound(InData%ChannelUnits))
      call RegPack(Buf, InData%ChannelUnits)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Module_Ver
   LB(1:1) = lbound(InData%Module_Ver)
   UB(1:1) = ubound(InData%Module_Ver)
   do i1 = LB(1), UB(1)
      call NWTC_Library_PackProgDesc(Buf, InData%Module_Ver(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! Module_Abrev
   call RegPack(Buf, InData%Module_Abrev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteThisStep
   call RegPack(Buf, InData%WriteThisStep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_count
   call RegPack(Buf, InData%VTK_count)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_LastWaveIndx
   call RegPack(Buf, InData%VTK_LastWaveIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin
   call FAST_PackLinFileType(Buf, InData%Lin) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ActualChanLen
   call RegPack(Buf, InData%ActualChanLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! op
   call FAST_PackLinStateSave(Buf, InData%op) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DriverWriteOutput
   call RegPack(Buf, InData%DriverWriteOutput)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackOutputFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_OutputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackOutputFileType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! TimeData
   if (allocated(OutData%TimeData)) deallocate(OutData%TimeData)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TimeData(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TimeData.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TimeData)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AllOutData
   if (allocated(OutData%AllOutData)) deallocate(OutData%AllOutData)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AllOutData(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOutData.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AllOutData)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! n_Out
   call RegUnpack(Buf, OutData%n_Out)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutSteps
   call RegUnpack(Buf, OutData%NOutSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! numOuts
   call RegUnpack(Buf, OutData%numOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnOu
   call RegUnpack(Buf, OutData%UnOu)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnSum
   call RegUnpack(Buf, OutData%UnSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnGra
   call RegUnpack(Buf, OutData%UnGra)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileDescLines
   call RegUnpack(Buf, OutData%FileDescLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChannelNames
   if (allocated(OutData%ChannelNames)) deallocate(OutData%ChannelNames)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ChannelNames(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ChannelNames.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ChannelNames)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ChannelUnits
   if (allocated(OutData%ChannelUnits)) deallocate(OutData%ChannelUnits)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ChannelUnits(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ChannelUnits.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ChannelUnits)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Module_Ver
   LB(1:1) = lbound(OutData%Module_Ver)
   UB(1:1) = ubound(OutData%Module_Ver)
   do i1 = LB(1), UB(1)
      call NWTC_Library_UnpackProgDesc(Buf, OutData%Module_Ver(i1)) ! Module_Ver 
   end do
   ! Module_Abrev
   call RegUnpack(Buf, OutData%Module_Abrev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteThisStep
   call RegUnpack(Buf, OutData%WriteThisStep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_count
   call RegUnpack(Buf, OutData%VTK_count)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_LastWaveIndx
   call RegUnpack(Buf, OutData%VTK_LastWaveIndx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin
   call FAST_UnpackLinFileType(Buf, OutData%Lin) ! Lin 
   ! ActualChanLen
   call RegUnpack(Buf, OutData%ActualChanLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! op
   call FAST_UnpackLinStateSave(Buf, OutData%op) ! op 
   ! DriverWriteOutput
   call RegUnpack(Buf, OutData%DriverWriteOutput)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FAST_CopyIceDyn_Data( SrcIceDyn_DataData, DstIceDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceDyn_Data), INTENT(INOUT) :: SrcIceDyn_DataData
   TYPE(IceDyn_Data), INTENT(INOUT) :: DstIceDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyIceDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcIceDyn_DataData%x)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%x,1)
  i1_u = UBOUND(SrcIceDyn_DataData%x,1)
  i2_l = LBOUND(SrcIceDyn_DataData%x,2)
  i2_u = UBOUND(SrcIceDyn_DataData%x,2)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%x)) THEN 
    ALLOCATE(DstIceDyn_DataData%x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcIceDyn_DataData%x,2), UBOUND(SrcIceDyn_DataData%x,2)
    DO i1 = LBOUND(SrcIceDyn_DataData%x,1), UBOUND(SrcIceDyn_DataData%x,1)
      CALL IceD_CopyContState( SrcIceDyn_DataData%x(i1,i2), DstIceDyn_DataData%x(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%xd)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%xd,1)
  i1_u = UBOUND(SrcIceDyn_DataData%xd,1)
  i2_l = LBOUND(SrcIceDyn_DataData%xd,2)
  i2_u = UBOUND(SrcIceDyn_DataData%xd,2)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%xd)) THEN 
    ALLOCATE(DstIceDyn_DataData%xd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%xd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcIceDyn_DataData%xd,2), UBOUND(SrcIceDyn_DataData%xd,2)
    DO i1 = LBOUND(SrcIceDyn_DataData%xd,1), UBOUND(SrcIceDyn_DataData%xd,1)
      CALL IceD_CopyDiscState( SrcIceDyn_DataData%xd(i1,i2), DstIceDyn_DataData%xd(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%z)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%z,1)
  i1_u = UBOUND(SrcIceDyn_DataData%z,1)
  i2_l = LBOUND(SrcIceDyn_DataData%z,2)
  i2_u = UBOUND(SrcIceDyn_DataData%z,2)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%z)) THEN 
    ALLOCATE(DstIceDyn_DataData%z(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcIceDyn_DataData%z,2), UBOUND(SrcIceDyn_DataData%z,2)
    DO i1 = LBOUND(SrcIceDyn_DataData%z,1), UBOUND(SrcIceDyn_DataData%z,1)
      CALL IceD_CopyConstrState( SrcIceDyn_DataData%z(i1,i2), DstIceDyn_DataData%z(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%OtherSt)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%OtherSt,1)
  i1_u = UBOUND(SrcIceDyn_DataData%OtherSt,1)
  i2_l = LBOUND(SrcIceDyn_DataData%OtherSt,2)
  i2_u = UBOUND(SrcIceDyn_DataData%OtherSt,2)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%OtherSt)) THEN 
    ALLOCATE(DstIceDyn_DataData%OtherSt(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%OtherSt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcIceDyn_DataData%OtherSt,2), UBOUND(SrcIceDyn_DataData%OtherSt,2)
    DO i1 = LBOUND(SrcIceDyn_DataData%OtherSt,1), UBOUND(SrcIceDyn_DataData%OtherSt,1)
      CALL IceD_CopyOtherState( SrcIceDyn_DataData%OtherSt(i1,i2), DstIceDyn_DataData%OtherSt(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%p)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%p,1)
  i1_u = UBOUND(SrcIceDyn_DataData%p,1)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%p)) THEN 
    ALLOCATE(DstIceDyn_DataData%p(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%p.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcIceDyn_DataData%p,1), UBOUND(SrcIceDyn_DataData%p,1)
      CALL IceD_CopyParam( SrcIceDyn_DataData%p(i1), DstIceDyn_DataData%p(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%u)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%u,1)
  i1_u = UBOUND(SrcIceDyn_DataData%u,1)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%u)) THEN 
    ALLOCATE(DstIceDyn_DataData%u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcIceDyn_DataData%u,1), UBOUND(SrcIceDyn_DataData%u,1)
      CALL IceD_CopyInput( SrcIceDyn_DataData%u(i1), DstIceDyn_DataData%u(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%y)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%y,1)
  i1_u = UBOUND(SrcIceDyn_DataData%y,1)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%y)) THEN 
    ALLOCATE(DstIceDyn_DataData%y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcIceDyn_DataData%y,1), UBOUND(SrcIceDyn_DataData%y,1)
      CALL IceD_CopyOutput( SrcIceDyn_DataData%y(i1), DstIceDyn_DataData%y(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%m)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%m,1)
  i1_u = UBOUND(SrcIceDyn_DataData%m,1)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%m)) THEN 
    ALLOCATE(DstIceDyn_DataData%m(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%m.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcIceDyn_DataData%m,1), UBOUND(SrcIceDyn_DataData%m,1)
      CALL IceD_CopyMisc( SrcIceDyn_DataData%m(i1), DstIceDyn_DataData%m(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%Input,1)
  i1_u = UBOUND(SrcIceDyn_DataData%Input,1)
  i2_l = LBOUND(SrcIceDyn_DataData%Input,2)
  i2_u = UBOUND(SrcIceDyn_DataData%Input,2)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%Input)) THEN 
    ALLOCATE(DstIceDyn_DataData%Input(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcIceDyn_DataData%Input,2), UBOUND(SrcIceDyn_DataData%Input,2)
    DO i1 = LBOUND(SrcIceDyn_DataData%Input,1), UBOUND(SrcIceDyn_DataData%Input,1)
      CALL IceD_CopyInput( SrcIceDyn_DataData%Input(i1,i2), DstIceDyn_DataData%Input(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcIceDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcIceDyn_DataData%InputTimes,1)
  i2_l = LBOUND(SrcIceDyn_DataData%InputTimes,2)
  i2_u = UBOUND(SrcIceDyn_DataData%InputTimes,2)
  IF (.NOT. ALLOCATED(DstIceDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstIceDyn_DataData%InputTimes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstIceDyn_DataData%InputTimes = SrcIceDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyIceDyn_Data

 SUBROUTINE FAST_DestroyIceDyn_Data( IceDyn_DataData, ErrStat, ErrMsg )
  TYPE(IceDyn_Data), INTENT(INOUT) :: IceDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyIceDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(IceDyn_DataData%x)) THEN
DO i2 = LBOUND(IceDyn_DataData%x,2), UBOUND(IceDyn_DataData%x,2)
DO i1 = LBOUND(IceDyn_DataData%x,1), UBOUND(IceDyn_DataData%x,1)
  CALL IceD_DestroyContState( IceDyn_DataData%x(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(IceDyn_DataData%x)
ENDIF
IF (ALLOCATED(IceDyn_DataData%xd)) THEN
DO i2 = LBOUND(IceDyn_DataData%xd,2), UBOUND(IceDyn_DataData%xd,2)
DO i1 = LBOUND(IceDyn_DataData%xd,1), UBOUND(IceDyn_DataData%xd,1)
  CALL IceD_DestroyDiscState( IceDyn_DataData%xd(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(IceDyn_DataData%xd)
ENDIF
IF (ALLOCATED(IceDyn_DataData%z)) THEN
DO i2 = LBOUND(IceDyn_DataData%z,2), UBOUND(IceDyn_DataData%z,2)
DO i1 = LBOUND(IceDyn_DataData%z,1), UBOUND(IceDyn_DataData%z,1)
  CALL IceD_DestroyConstrState( IceDyn_DataData%z(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(IceDyn_DataData%z)
ENDIF
IF (ALLOCATED(IceDyn_DataData%OtherSt)) THEN
DO i2 = LBOUND(IceDyn_DataData%OtherSt,2), UBOUND(IceDyn_DataData%OtherSt,2)
DO i1 = LBOUND(IceDyn_DataData%OtherSt,1), UBOUND(IceDyn_DataData%OtherSt,1)
  CALL IceD_DestroyOtherState( IceDyn_DataData%OtherSt(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(IceDyn_DataData%OtherSt)
ENDIF
IF (ALLOCATED(IceDyn_DataData%p)) THEN
DO i1 = LBOUND(IceDyn_DataData%p,1), UBOUND(IceDyn_DataData%p,1)
  CALL IceD_DestroyParam( IceDyn_DataData%p(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(IceDyn_DataData%p)
ENDIF
IF (ALLOCATED(IceDyn_DataData%u)) THEN
DO i1 = LBOUND(IceDyn_DataData%u,1), UBOUND(IceDyn_DataData%u,1)
  CALL IceD_DestroyInput( IceDyn_DataData%u(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(IceDyn_DataData%u)
ENDIF
IF (ALLOCATED(IceDyn_DataData%y)) THEN
DO i1 = LBOUND(IceDyn_DataData%y,1), UBOUND(IceDyn_DataData%y,1)
  CALL IceD_DestroyOutput( IceDyn_DataData%y(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(IceDyn_DataData%y)
ENDIF
IF (ALLOCATED(IceDyn_DataData%m)) THEN
DO i1 = LBOUND(IceDyn_DataData%m,1), UBOUND(IceDyn_DataData%m,1)
  CALL IceD_DestroyMisc( IceDyn_DataData%m(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(IceDyn_DataData%m)
ENDIF
IF (ALLOCATED(IceDyn_DataData%Input)) THEN
DO i2 = LBOUND(IceDyn_DataData%Input,2), UBOUND(IceDyn_DataData%Input,2)
DO i1 = LBOUND(IceDyn_DataData%Input,1), UBOUND(IceDyn_DataData%Input,1)
  CALL IceD_DestroyInput( IceDyn_DataData%Input(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(IceDyn_DataData%Input)
ENDIF
IF (ALLOCATED(IceDyn_DataData%InputTimes)) THEN
  DEALLOCATE(IceDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyIceDyn_Data


subroutine FAST_PackIceDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(IceDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackIceDyn_Data'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   call RegPack(Buf, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(Buf, 2, lbound(InData%x), ubound(InData%x))
      LB(1:2) = lbound(InData%x)
      UB(1:2) = ubound(InData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackContState(Buf, InData%x(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   call RegPack(Buf, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(Buf, 2, lbound(InData%xd), ubound(InData%xd))
      LB(1:2) = lbound(InData%xd)
      UB(1:2) = ubound(InData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackDiscState(Buf, InData%xd(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   call RegPack(Buf, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(Buf, 2, lbound(InData%z), ubound(InData%z))
      LB(1:2) = lbound(InData%z)
      UB(1:2) = ubound(InData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackConstrState(Buf, InData%z(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   call RegPack(Buf, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(Buf, 2, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:2) = lbound(InData%OtherSt)
      UB(1:2) = ubound(InData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackOtherState(Buf, InData%OtherSt(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call RegPack(Buf, allocated(InData%p))
   if (allocated(InData%p)) then
      call RegPackBounds(Buf, 1, lbound(InData%p), ubound(InData%p))
      LB(1:1) = lbound(InData%p)
      UB(1:1) = ubound(InData%p)
      do i1 = LB(1), UB(1)
         call IceD_PackParam(Buf, InData%p(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call RegPack(Buf, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(Buf, 1, lbound(InData%u), ubound(InData%u))
      LB(1:1) = lbound(InData%u)
      UB(1:1) = ubound(InData%u)
      do i1 = LB(1), UB(1)
         call IceD_PackInput(Buf, InData%u(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call RegPack(Buf, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(Buf, 1, lbound(InData%y), ubound(InData%y))
      LB(1:1) = lbound(InData%y)
      UB(1:1) = ubound(InData%y)
      do i1 = LB(1), UB(1)
         call IceD_PackOutput(Buf, InData%y(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call RegPack(Buf, allocated(InData%m))
   if (allocated(InData%m)) then
      call RegPackBounds(Buf, 1, lbound(InData%m), ubound(InData%m))
      LB(1:1) = lbound(InData%m)
      UB(1:1) = ubound(InData%m)
      do i1 = LB(1), UB(1)
         call IceD_PackMisc(Buf, InData%m(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 2, lbound(InData%Input), ubound(InData%Input))
      LB(1:2) = lbound(InData%Input)
      UB(1:2) = ubound(InData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_PackInput(Buf, InData%Input(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 2, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackIceDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(IceDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackIceDyn_Data'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackContState(Buf, OutData%x(i1,i2)) ! x 
         end do
      end do
   end if
   ! xd
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackDiscState(Buf, OutData%xd(i1,i2)) ! xd 
         end do
      end do
   end if
   ! z
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackConstrState(Buf, OutData%z(i1,i2)) ! z 
         end do
      end do
   end if
   ! OtherSt
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackOtherState(Buf, OutData%OtherSt(i1,i2)) ! OtherSt 
         end do
      end do
   end if
   ! p
   if (allocated(OutData%p)) deallocate(OutData%p)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%p(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackParam(Buf, OutData%p(i1)) ! p 
      end do
   end if
   ! u
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackInput(Buf, OutData%u(i1)) ! u 
      end do
   end if
   ! y
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackOutput(Buf, OutData%y(i1)) ! y 
      end do
   end if
   ! m
   if (allocated(OutData%m)) deallocate(OutData%m)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%m(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%m.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceD_UnpackMisc(Buf, OutData%m(i1)) ! m 
      end do
   end if
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call IceD_UnpackInput(Buf, OutData%Input(i1,i2)) ! Input 
         end do
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyBeamDyn_Data( SrcBeamDyn_DataData, DstBeamDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(BeamDyn_Data), INTENT(INOUT) :: SrcBeamDyn_DataData
   TYPE(BeamDyn_Data), INTENT(INOUT) :: DstBeamDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyBeamDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBeamDyn_DataData%x)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%x,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%x,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%x,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%x,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%x)) THEN 
    ALLOCATE(DstBeamDyn_DataData%x(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcBeamDyn_DataData%x,2), UBOUND(SrcBeamDyn_DataData%x,2)
    DO i1 = LBOUND(SrcBeamDyn_DataData%x,1), UBOUND(SrcBeamDyn_DataData%x,1)
      CALL BD_CopyContState( SrcBeamDyn_DataData%x(i1,i2), DstBeamDyn_DataData%x(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%xd)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%xd,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%xd,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%xd,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%xd,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%xd)) THEN 
    ALLOCATE(DstBeamDyn_DataData%xd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%xd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcBeamDyn_DataData%xd,2), UBOUND(SrcBeamDyn_DataData%xd,2)
    DO i1 = LBOUND(SrcBeamDyn_DataData%xd,1), UBOUND(SrcBeamDyn_DataData%xd,1)
      CALL BD_CopyDiscState( SrcBeamDyn_DataData%xd(i1,i2), DstBeamDyn_DataData%xd(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%z)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%z,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%z,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%z,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%z,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%z)) THEN 
    ALLOCATE(DstBeamDyn_DataData%z(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcBeamDyn_DataData%z,2), UBOUND(SrcBeamDyn_DataData%z,2)
    DO i1 = LBOUND(SrcBeamDyn_DataData%z,1), UBOUND(SrcBeamDyn_DataData%z,1)
      CALL BD_CopyConstrState( SrcBeamDyn_DataData%z(i1,i2), DstBeamDyn_DataData%z(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%OtherSt)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%OtherSt,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%OtherSt,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%OtherSt,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%OtherSt,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%OtherSt)) THEN 
    ALLOCATE(DstBeamDyn_DataData%OtherSt(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%OtherSt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcBeamDyn_DataData%OtherSt,2), UBOUND(SrcBeamDyn_DataData%OtherSt,2)
    DO i1 = LBOUND(SrcBeamDyn_DataData%OtherSt,1), UBOUND(SrcBeamDyn_DataData%OtherSt,1)
      CALL BD_CopyOtherState( SrcBeamDyn_DataData%OtherSt(i1,i2), DstBeamDyn_DataData%OtherSt(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%p)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%p,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%p,1)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%p)) THEN 
    ALLOCATE(DstBeamDyn_DataData%p(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%p.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcBeamDyn_DataData%p,1), UBOUND(SrcBeamDyn_DataData%p,1)
      CALL BD_CopyParam( SrcBeamDyn_DataData%p(i1), DstBeamDyn_DataData%p(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%u)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%u,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%u,1)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%u)) THEN 
    ALLOCATE(DstBeamDyn_DataData%u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcBeamDyn_DataData%u,1), UBOUND(SrcBeamDyn_DataData%u,1)
      CALL BD_CopyInput( SrcBeamDyn_DataData%u(i1), DstBeamDyn_DataData%u(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%y)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%y,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%y,1)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%y)) THEN 
    ALLOCATE(DstBeamDyn_DataData%y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcBeamDyn_DataData%y,1), UBOUND(SrcBeamDyn_DataData%y,1)
      CALL BD_CopyOutput( SrcBeamDyn_DataData%y(i1), DstBeamDyn_DataData%y(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%m)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%m,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%m,1)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%m)) THEN 
    ALLOCATE(DstBeamDyn_DataData%m(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%m.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcBeamDyn_DataData%m,1), UBOUND(SrcBeamDyn_DataData%m,1)
      CALL BD_CopyMisc( SrcBeamDyn_DataData%m(i1), DstBeamDyn_DataData%m(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%Output,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%Output,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%Output,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%Output,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%Output)) THEN 
    ALLOCATE(DstBeamDyn_DataData%Output(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcBeamDyn_DataData%Output,2), UBOUND(SrcBeamDyn_DataData%Output,2)
    DO i1 = LBOUND(SrcBeamDyn_DataData%Output,1), UBOUND(SrcBeamDyn_DataData%Output,1)
      CALL BD_CopyOutput( SrcBeamDyn_DataData%Output(i1,i2), DstBeamDyn_DataData%Output(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%y_interp)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%y_interp,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%y_interp,1)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%y_interp)) THEN 
    ALLOCATE(DstBeamDyn_DataData%y_interp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%y_interp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcBeamDyn_DataData%y_interp,1), UBOUND(SrcBeamDyn_DataData%y_interp,1)
      CALL BD_CopyOutput( SrcBeamDyn_DataData%y_interp(i1), DstBeamDyn_DataData%y_interp(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%Input,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%Input,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%Input,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%Input,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%Input)) THEN 
    ALLOCATE(DstBeamDyn_DataData%Input(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcBeamDyn_DataData%Input,2), UBOUND(SrcBeamDyn_DataData%Input,2)
    DO i1 = LBOUND(SrcBeamDyn_DataData%Input,1), UBOUND(SrcBeamDyn_DataData%Input,1)
      CALL BD_CopyInput( SrcBeamDyn_DataData%Input(i1,i2), DstBeamDyn_DataData%Input(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcBeamDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcBeamDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcBeamDyn_DataData%InputTimes,1)
  i2_l = LBOUND(SrcBeamDyn_DataData%InputTimes,2)
  i2_u = UBOUND(SrcBeamDyn_DataData%InputTimes,2)
  IF (.NOT. ALLOCATED(DstBeamDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstBeamDyn_DataData%InputTimes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBeamDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBeamDyn_DataData%InputTimes = SrcBeamDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyBeamDyn_Data

 SUBROUTINE FAST_DestroyBeamDyn_Data( BeamDyn_DataData, ErrStat, ErrMsg )
  TYPE(BeamDyn_Data), INTENT(INOUT) :: BeamDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyBeamDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(BeamDyn_DataData%x)) THEN
DO i2 = LBOUND(BeamDyn_DataData%x,2), UBOUND(BeamDyn_DataData%x,2)
DO i1 = LBOUND(BeamDyn_DataData%x,1), UBOUND(BeamDyn_DataData%x,1)
  CALL BD_DestroyContState( BeamDyn_DataData%x(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(BeamDyn_DataData%x)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%xd)) THEN
DO i2 = LBOUND(BeamDyn_DataData%xd,2), UBOUND(BeamDyn_DataData%xd,2)
DO i1 = LBOUND(BeamDyn_DataData%xd,1), UBOUND(BeamDyn_DataData%xd,1)
  CALL BD_DestroyDiscState( BeamDyn_DataData%xd(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(BeamDyn_DataData%xd)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%z)) THEN
DO i2 = LBOUND(BeamDyn_DataData%z,2), UBOUND(BeamDyn_DataData%z,2)
DO i1 = LBOUND(BeamDyn_DataData%z,1), UBOUND(BeamDyn_DataData%z,1)
  CALL BD_DestroyConstrState( BeamDyn_DataData%z(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(BeamDyn_DataData%z)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%OtherSt)) THEN
DO i2 = LBOUND(BeamDyn_DataData%OtherSt,2), UBOUND(BeamDyn_DataData%OtherSt,2)
DO i1 = LBOUND(BeamDyn_DataData%OtherSt,1), UBOUND(BeamDyn_DataData%OtherSt,1)
  CALL BD_DestroyOtherState( BeamDyn_DataData%OtherSt(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(BeamDyn_DataData%OtherSt)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%p)) THEN
DO i1 = LBOUND(BeamDyn_DataData%p,1), UBOUND(BeamDyn_DataData%p,1)
  CALL BD_DestroyParam( BeamDyn_DataData%p(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(BeamDyn_DataData%p)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%u)) THEN
DO i1 = LBOUND(BeamDyn_DataData%u,1), UBOUND(BeamDyn_DataData%u,1)
  CALL BD_DestroyInput( BeamDyn_DataData%u(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(BeamDyn_DataData%u)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%y)) THEN
DO i1 = LBOUND(BeamDyn_DataData%y,1), UBOUND(BeamDyn_DataData%y,1)
  CALL BD_DestroyOutput( BeamDyn_DataData%y(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(BeamDyn_DataData%y)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%m)) THEN
DO i1 = LBOUND(BeamDyn_DataData%m,1), UBOUND(BeamDyn_DataData%m,1)
  CALL BD_DestroyMisc( BeamDyn_DataData%m(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(BeamDyn_DataData%m)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%Output)) THEN
DO i2 = LBOUND(BeamDyn_DataData%Output,2), UBOUND(BeamDyn_DataData%Output,2)
DO i1 = LBOUND(BeamDyn_DataData%Output,1), UBOUND(BeamDyn_DataData%Output,1)
  CALL BD_DestroyOutput( BeamDyn_DataData%Output(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(BeamDyn_DataData%Output)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%y_interp)) THEN
DO i1 = LBOUND(BeamDyn_DataData%y_interp,1), UBOUND(BeamDyn_DataData%y_interp,1)
  CALL BD_DestroyOutput( BeamDyn_DataData%y_interp(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(BeamDyn_DataData%y_interp)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%Input)) THEN
DO i2 = LBOUND(BeamDyn_DataData%Input,2), UBOUND(BeamDyn_DataData%Input,2)
DO i1 = LBOUND(BeamDyn_DataData%Input,1), UBOUND(BeamDyn_DataData%Input,1)
  CALL BD_DestroyInput( BeamDyn_DataData%Input(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(BeamDyn_DataData%Input)
ENDIF
IF (ALLOCATED(BeamDyn_DataData%InputTimes)) THEN
  DEALLOCATE(BeamDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyBeamDyn_Data


subroutine FAST_PackBeamDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BeamDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackBeamDyn_Data'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   call RegPack(Buf, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(Buf, 2, lbound(InData%x), ubound(InData%x))
      LB(1:2) = lbound(InData%x)
      UB(1:2) = ubound(InData%x)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackContState(Buf, InData%x(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   call RegPack(Buf, allocated(InData%xd))
   if (allocated(InData%xd)) then
      call RegPackBounds(Buf, 2, lbound(InData%xd), ubound(InData%xd))
      LB(1:2) = lbound(InData%xd)
      UB(1:2) = ubound(InData%xd)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackDiscState(Buf, InData%xd(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   call RegPack(Buf, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(Buf, 2, lbound(InData%z), ubound(InData%z))
      LB(1:2) = lbound(InData%z)
      UB(1:2) = ubound(InData%z)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackConstrState(Buf, InData%z(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   call RegPack(Buf, allocated(InData%OtherSt))
   if (allocated(InData%OtherSt)) then
      call RegPackBounds(Buf, 2, lbound(InData%OtherSt), ubound(InData%OtherSt))
      LB(1:2) = lbound(InData%OtherSt)
      UB(1:2) = ubound(InData%OtherSt)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackOtherState(Buf, InData%OtherSt(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call RegPack(Buf, allocated(InData%p))
   if (allocated(InData%p)) then
      call RegPackBounds(Buf, 1, lbound(InData%p), ubound(InData%p))
      LB(1:1) = lbound(InData%p)
      UB(1:1) = ubound(InData%p)
      do i1 = LB(1), UB(1)
         call BD_PackParam(Buf, InData%p(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call RegPack(Buf, allocated(InData%u))
   if (allocated(InData%u)) then
      call RegPackBounds(Buf, 1, lbound(InData%u), ubound(InData%u))
      LB(1:1) = lbound(InData%u)
      UB(1:1) = ubound(InData%u)
      do i1 = LB(1), UB(1)
         call BD_PackInput(Buf, InData%u(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call RegPack(Buf, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(Buf, 1, lbound(InData%y), ubound(InData%y))
      LB(1:1) = lbound(InData%y)
      UB(1:1) = ubound(InData%y)
      do i1 = LB(1), UB(1)
         call BD_PackOutput(Buf, InData%y(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call RegPack(Buf, allocated(InData%m))
   if (allocated(InData%m)) then
      call RegPackBounds(Buf, 1, lbound(InData%m), ubound(InData%m))
      LB(1:1) = lbound(InData%m)
      UB(1:1) = ubound(InData%m)
      do i1 = LB(1), UB(1)
         call BD_PackMisc(Buf, InData%m(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 2, lbound(InData%Output), ubound(InData%Output))
      LB(1:2) = lbound(InData%Output)
      UB(1:2) = ubound(InData%Output)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackOutput(Buf, InData%Output(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call RegPack(Buf, allocated(InData%y_interp))
   if (allocated(InData%y_interp)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_interp), ubound(InData%y_interp))
      LB(1:1) = lbound(InData%y_interp)
      UB(1:1) = ubound(InData%y_interp)
      do i1 = LB(1), UB(1)
         call BD_PackOutput(Buf, InData%y_interp(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 2, lbound(InData%Input), ubound(InData%Input))
      LB(1:2) = lbound(InData%Input)
      UB(1:2) = ubound(InData%Input)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_PackInput(Buf, InData%Input(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 2, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackBeamDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BeamDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackBeamDyn_Data'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackContState(Buf, OutData%x(i1,i2)) ! x 
         end do
      end do
   end if
   ! xd
   if (allocated(OutData%xd)) deallocate(OutData%xd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackDiscState(Buf, OutData%xd(i1,i2)) ! xd 
         end do
      end do
   end if
   ! z
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackConstrState(Buf, OutData%z(i1,i2)) ! z 
         end do
      end do
   end if
   ! OtherSt
   if (allocated(OutData%OtherSt)) deallocate(OutData%OtherSt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OtherSt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OtherSt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackOtherState(Buf, OutData%OtherSt(i1,i2)) ! OtherSt 
         end do
      end do
   end if
   ! p
   if (allocated(OutData%p)) deallocate(OutData%p)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%p(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackParam(Buf, OutData%p(i1)) ! p 
      end do
   end if
   ! u
   if (allocated(OutData%u)) deallocate(OutData%u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackInput(Buf, OutData%u(i1)) ! u 
      end do
   end if
   ! y
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackOutput(Buf, OutData%y(i1)) ! y 
      end do
   end if
   ! m
   if (allocated(OutData%m)) deallocate(OutData%m)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%m(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%m.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackMisc(Buf, OutData%m(i1)) ! m 
      end do
   end if
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackOutput(Buf, OutData%Output(i1,i2)) ! Output 
         end do
      end do
   end if
   ! y_interp
   if (allocated(OutData%y_interp)) deallocate(OutData%y_interp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_interp(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_interp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackOutput(Buf, OutData%y_interp(i1)) ! y_interp 
      end do
   end if
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call BD_UnpackInput(Buf, OutData%Input(i1,i2)) ! Input 
         end do
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyElastoDyn_Data( SrcElastoDyn_DataData, DstElastoDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElastoDyn_Data), INTENT(INOUT) :: SrcElastoDyn_DataData
   TYPE(ElastoDyn_Data), INTENT(INOUT) :: DstElastoDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyElastoDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcElastoDyn_DataData%x,1), UBOUND(SrcElastoDyn_DataData%x,1)
      CALL ED_CopyContState( SrcElastoDyn_DataData%x(i1), DstElastoDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcElastoDyn_DataData%xd,1), UBOUND(SrcElastoDyn_DataData%xd,1)
      CALL ED_CopyDiscState( SrcElastoDyn_DataData%xd(i1), DstElastoDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcElastoDyn_DataData%z,1), UBOUND(SrcElastoDyn_DataData%z,1)
      CALL ED_CopyConstrState( SrcElastoDyn_DataData%z(i1), DstElastoDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcElastoDyn_DataData%OtherSt,1), UBOUND(SrcElastoDyn_DataData%OtherSt,1)
      CALL ED_CopyOtherState( SrcElastoDyn_DataData%OtherSt(i1), DstElastoDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL ED_CopyParam( SrcElastoDyn_DataData%p, DstElastoDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ED_CopyInput( SrcElastoDyn_DataData%u, DstElastoDyn_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ED_CopyOutput( SrcElastoDyn_DataData%y, DstElastoDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ED_CopyMisc( SrcElastoDyn_DataData%m, DstElastoDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcElastoDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcElastoDyn_DataData%Output,1)
  i1_u = UBOUND(SrcElastoDyn_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstElastoDyn_DataData%Output)) THEN 
    ALLOCATE(DstElastoDyn_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcElastoDyn_DataData%Output,1), UBOUND(SrcElastoDyn_DataData%Output,1)
      CALL ED_CopyOutput( SrcElastoDyn_DataData%Output(i1), DstElastoDyn_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL ED_CopyOutput( SrcElastoDyn_DataData%y_interp, DstElastoDyn_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcElastoDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcElastoDyn_DataData%Input,1)
  i1_u = UBOUND(SrcElastoDyn_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstElastoDyn_DataData%Input)) THEN 
    ALLOCATE(DstElastoDyn_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcElastoDyn_DataData%Input,1), UBOUND(SrcElastoDyn_DataData%Input,1)
      CALL ED_CopyInput( SrcElastoDyn_DataData%Input(i1), DstElastoDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcElastoDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcElastoDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcElastoDyn_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstElastoDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstElastoDyn_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstElastoDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstElastoDyn_DataData%InputTimes = SrcElastoDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyElastoDyn_Data

 SUBROUTINE FAST_DestroyElastoDyn_Data( ElastoDyn_DataData, ErrStat, ErrMsg )
  TYPE(ElastoDyn_Data), INTENT(INOUT) :: ElastoDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyElastoDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(ElastoDyn_DataData%x,1), UBOUND(ElastoDyn_DataData%x,1)
  CALL ED_DestroyContState( ElastoDyn_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ElastoDyn_DataData%xd,1), UBOUND(ElastoDyn_DataData%xd,1)
  CALL ED_DestroyDiscState( ElastoDyn_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ElastoDyn_DataData%z,1), UBOUND(ElastoDyn_DataData%z,1)
  CALL ED_DestroyConstrState( ElastoDyn_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ElastoDyn_DataData%OtherSt,1), UBOUND(ElastoDyn_DataData%OtherSt,1)
  CALL ED_DestroyOtherState( ElastoDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL ED_DestroyParam( ElastoDyn_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ED_DestroyInput( ElastoDyn_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ED_DestroyOutput( ElastoDyn_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ED_DestroyMisc( ElastoDyn_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ElastoDyn_DataData%Output)) THEN
DO i1 = LBOUND(ElastoDyn_DataData%Output,1), UBOUND(ElastoDyn_DataData%Output,1)
  CALL ED_DestroyOutput( ElastoDyn_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ElastoDyn_DataData%Output)
ENDIF
  CALL ED_DestroyOutput( ElastoDyn_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ElastoDyn_DataData%Input)) THEN
DO i1 = LBOUND(ElastoDyn_DataData%Input,1), UBOUND(ElastoDyn_DataData%Input,1)
  CALL ED_DestroyInput( ElastoDyn_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ElastoDyn_DataData%Input)
ENDIF
IF (ALLOCATED(ElastoDyn_DataData%InputTimes)) THEN
  DEALLOCATE(ElastoDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyElastoDyn_Data


subroutine FAST_PackElastoDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ElastoDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackElastoDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call ED_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call ED_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call ED_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call ED_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call ED_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call ED_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call ED_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call ED_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call ED_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call ED_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call ED_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackElastoDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ElastoDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackElastoDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call ED_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call ED_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call ED_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call ED_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call ED_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call ED_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call ED_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call ED_UnpackMisc(Buf, OutData%m) ! m 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call ED_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ED_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyServoDyn_Data( SrcServoDyn_DataData, DstServoDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ServoDyn_Data), INTENT(INOUT) :: SrcServoDyn_DataData
   TYPE(ServoDyn_Data), INTENT(INOUT) :: DstServoDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyServoDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcServoDyn_DataData%x,1), UBOUND(SrcServoDyn_DataData%x,1)
      CALL SrvD_CopyContState( SrcServoDyn_DataData%x(i1), DstServoDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcServoDyn_DataData%xd,1), UBOUND(SrcServoDyn_DataData%xd,1)
      CALL SrvD_CopyDiscState( SrcServoDyn_DataData%xd(i1), DstServoDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcServoDyn_DataData%z,1), UBOUND(SrcServoDyn_DataData%z,1)
      CALL SrvD_CopyConstrState( SrcServoDyn_DataData%z(i1), DstServoDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcServoDyn_DataData%OtherSt,1), UBOUND(SrcServoDyn_DataData%OtherSt,1)
      CALL SrvD_CopyOtherState( SrcServoDyn_DataData%OtherSt(i1), DstServoDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL SrvD_CopyParam( SrcServoDyn_DataData%p, DstServoDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SrvD_CopyInput( SrcServoDyn_DataData%u, DstServoDyn_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SrvD_CopyOutput( SrcServoDyn_DataData%y, DstServoDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SrvD_CopyMisc( SrcServoDyn_DataData%m, DstServoDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcServoDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcServoDyn_DataData%Output,1)
  i1_u = UBOUND(SrcServoDyn_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstServoDyn_DataData%Output)) THEN 
    ALLOCATE(DstServoDyn_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcServoDyn_DataData%Output,1), UBOUND(SrcServoDyn_DataData%Output,1)
      CALL SrvD_CopyOutput( SrcServoDyn_DataData%Output(i1), DstServoDyn_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL SrvD_CopyOutput( SrcServoDyn_DataData%y_interp, DstServoDyn_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcServoDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcServoDyn_DataData%Input,1)
  i1_u = UBOUND(SrcServoDyn_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstServoDyn_DataData%Input)) THEN 
    ALLOCATE(DstServoDyn_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcServoDyn_DataData%Input,1), UBOUND(SrcServoDyn_DataData%Input,1)
      CALL SrvD_CopyInput( SrcServoDyn_DataData%Input(i1), DstServoDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcServoDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcServoDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcServoDyn_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstServoDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstServoDyn_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstServoDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstServoDyn_DataData%InputTimes = SrcServoDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyServoDyn_Data

 SUBROUTINE FAST_DestroyServoDyn_Data( ServoDyn_DataData, ErrStat, ErrMsg )
  TYPE(ServoDyn_Data), INTENT(INOUT) :: ServoDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyServoDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(ServoDyn_DataData%x,1), UBOUND(ServoDyn_DataData%x,1)
  CALL SrvD_DestroyContState( ServoDyn_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ServoDyn_DataData%xd,1), UBOUND(ServoDyn_DataData%xd,1)
  CALL SrvD_DestroyDiscState( ServoDyn_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ServoDyn_DataData%z,1), UBOUND(ServoDyn_DataData%z,1)
  CALL SrvD_DestroyConstrState( ServoDyn_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ServoDyn_DataData%OtherSt,1), UBOUND(ServoDyn_DataData%OtherSt,1)
  CALL SrvD_DestroyOtherState( ServoDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL SrvD_DestroyParam( ServoDyn_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SrvD_DestroyInput( ServoDyn_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SrvD_DestroyOutput( ServoDyn_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SrvD_DestroyMisc( ServoDyn_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ServoDyn_DataData%Output)) THEN
DO i1 = LBOUND(ServoDyn_DataData%Output,1), UBOUND(ServoDyn_DataData%Output,1)
  CALL SrvD_DestroyOutput( ServoDyn_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ServoDyn_DataData%Output)
ENDIF
  CALL SrvD_DestroyOutput( ServoDyn_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ServoDyn_DataData%Input)) THEN
DO i1 = LBOUND(ServoDyn_DataData%Input,1), UBOUND(ServoDyn_DataData%Input,1)
  CALL SrvD_DestroyInput( ServoDyn_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ServoDyn_DataData%Input)
ENDIF
IF (ALLOCATED(ServoDyn_DataData%InputTimes)) THEN
  DEALLOCATE(ServoDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyServoDyn_Data


subroutine FAST_PackServoDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ServoDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackServoDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call SrvD_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call SrvD_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call SrvD_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call SrvD_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call SrvD_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call SrvD_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call SrvD_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call SrvD_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call SrvD_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call SrvD_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SrvD_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackServoDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ServoDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackServoDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call SrvD_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call SrvD_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call SrvD_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call SrvD_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call SrvD_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call SrvD_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call SrvD_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call SrvD_UnpackMisc(Buf, OutData%m) ! m 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call SrvD_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SrvD_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyAeroDyn14_Data( SrcAeroDyn14_DataData, DstAeroDyn14_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AeroDyn14_Data), INTENT(INOUT) :: SrcAeroDyn14_DataData
   TYPE(AeroDyn14_Data), INTENT(INOUT) :: DstAeroDyn14_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyAeroDyn14_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcAeroDyn14_DataData%x,1), UBOUND(SrcAeroDyn14_DataData%x,1)
      CALL AD14_CopyContState( SrcAeroDyn14_DataData%x(i1), DstAeroDyn14_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcAeroDyn14_DataData%xd,1), UBOUND(SrcAeroDyn14_DataData%xd,1)
      CALL AD14_CopyDiscState( SrcAeroDyn14_DataData%xd(i1), DstAeroDyn14_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcAeroDyn14_DataData%z,1), UBOUND(SrcAeroDyn14_DataData%z,1)
      CALL AD14_CopyConstrState( SrcAeroDyn14_DataData%z(i1), DstAeroDyn14_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcAeroDyn14_DataData%OtherSt,1), UBOUND(SrcAeroDyn14_DataData%OtherSt,1)
      CALL AD14_CopyOtherState( SrcAeroDyn14_DataData%OtherSt(i1), DstAeroDyn14_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL AD14_CopyParam( SrcAeroDyn14_DataData%p, DstAeroDyn14_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_CopyInput( SrcAeroDyn14_DataData%u, DstAeroDyn14_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_CopyOutput( SrcAeroDyn14_DataData%y, DstAeroDyn14_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_CopyMisc( SrcAeroDyn14_DataData%m, DstAeroDyn14_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcAeroDyn14_DataData%Input)) THEN
  i1_l = LBOUND(SrcAeroDyn14_DataData%Input,1)
  i1_u = UBOUND(SrcAeroDyn14_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstAeroDyn14_DataData%Input)) THEN 
    ALLOCATE(DstAeroDyn14_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn14_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcAeroDyn14_DataData%Input,1), UBOUND(SrcAeroDyn14_DataData%Input,1)
      CALL AD14_CopyInput( SrcAeroDyn14_DataData%Input(i1), DstAeroDyn14_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcAeroDyn14_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcAeroDyn14_DataData%InputTimes,1)
  i1_u = UBOUND(SrcAeroDyn14_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstAeroDyn14_DataData%InputTimes)) THEN 
    ALLOCATE(DstAeroDyn14_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn14_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAeroDyn14_DataData%InputTimes = SrcAeroDyn14_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyAeroDyn14_Data

 SUBROUTINE FAST_DestroyAeroDyn14_Data( AeroDyn14_DataData, ErrStat, ErrMsg )
  TYPE(AeroDyn14_Data), INTENT(INOUT) :: AeroDyn14_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyAeroDyn14_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(AeroDyn14_DataData%x,1), UBOUND(AeroDyn14_DataData%x,1)
  CALL AD14_DestroyContState( AeroDyn14_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(AeroDyn14_DataData%xd,1), UBOUND(AeroDyn14_DataData%xd,1)
  CALL AD14_DestroyDiscState( AeroDyn14_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(AeroDyn14_DataData%z,1), UBOUND(AeroDyn14_DataData%z,1)
  CALL AD14_DestroyConstrState( AeroDyn14_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(AeroDyn14_DataData%OtherSt,1), UBOUND(AeroDyn14_DataData%OtherSt,1)
  CALL AD14_DestroyOtherState( AeroDyn14_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL AD14_DestroyParam( AeroDyn14_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyInput( AeroDyn14_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyOutput( AeroDyn14_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyMisc( AeroDyn14_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(AeroDyn14_DataData%Input)) THEN
DO i1 = LBOUND(AeroDyn14_DataData%Input,1), UBOUND(AeroDyn14_DataData%Input,1)
  CALL AD14_DestroyInput( AeroDyn14_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(AeroDyn14_DataData%Input)
ENDIF
IF (ALLOCATED(AeroDyn14_DataData%InputTimes)) THEN
  DEALLOCATE(AeroDyn14_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyAeroDyn14_Data


subroutine FAST_PackAeroDyn14_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AeroDyn14_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackAeroDyn14_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call AD14_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call AD14_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call AD14_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call AD14_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call AD14_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call AD14_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call AD14_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call AD14_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call AD14_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackAeroDyn14_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AeroDyn14_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackAeroDyn14_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call AD14_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call AD14_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call AD14_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call AD14_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call AD14_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call AD14_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call AD14_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call AD14_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD14_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyAeroDyn_Data( SrcAeroDyn_DataData, DstAeroDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AeroDyn_Data), INTENT(INOUT) :: SrcAeroDyn_DataData
   TYPE(AeroDyn_Data), INTENT(INOUT) :: DstAeroDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyAeroDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcAeroDyn_DataData%x,1), UBOUND(SrcAeroDyn_DataData%x,1)
      CALL AD_CopyContState( SrcAeroDyn_DataData%x(i1), DstAeroDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcAeroDyn_DataData%xd,1), UBOUND(SrcAeroDyn_DataData%xd,1)
      CALL AD_CopyDiscState( SrcAeroDyn_DataData%xd(i1), DstAeroDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcAeroDyn_DataData%z,1), UBOUND(SrcAeroDyn_DataData%z,1)
      CALL AD_CopyConstrState( SrcAeroDyn_DataData%z(i1), DstAeroDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcAeroDyn_DataData%OtherSt,1), UBOUND(SrcAeroDyn_DataData%OtherSt,1)
      CALL AD_CopyOtherState( SrcAeroDyn_DataData%OtherSt(i1), DstAeroDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL AD_CopyParam( SrcAeroDyn_DataData%p, DstAeroDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD_CopyInput( SrcAeroDyn_DataData%u, DstAeroDyn_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD_CopyOutput( SrcAeroDyn_DataData%y, DstAeroDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD_CopyMisc( SrcAeroDyn_DataData%m, DstAeroDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcAeroDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcAeroDyn_DataData%Output,1)
  i1_u = UBOUND(SrcAeroDyn_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstAeroDyn_DataData%Output)) THEN 
    ALLOCATE(DstAeroDyn_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcAeroDyn_DataData%Output,1), UBOUND(SrcAeroDyn_DataData%Output,1)
      CALL AD_CopyOutput( SrcAeroDyn_DataData%Output(i1), DstAeroDyn_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL AD_CopyOutput( SrcAeroDyn_DataData%y_interp, DstAeroDyn_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcAeroDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcAeroDyn_DataData%Input,1)
  i1_u = UBOUND(SrcAeroDyn_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstAeroDyn_DataData%Input)) THEN 
    ALLOCATE(DstAeroDyn_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcAeroDyn_DataData%Input,1), UBOUND(SrcAeroDyn_DataData%Input,1)
      CALL AD_CopyInput( SrcAeroDyn_DataData%Input(i1), DstAeroDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcAeroDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcAeroDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcAeroDyn_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstAeroDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstAeroDyn_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstAeroDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstAeroDyn_DataData%InputTimes = SrcAeroDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyAeroDyn_Data

 SUBROUTINE FAST_DestroyAeroDyn_Data( AeroDyn_DataData, ErrStat, ErrMsg )
  TYPE(AeroDyn_Data), INTENT(INOUT) :: AeroDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyAeroDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(AeroDyn_DataData%x,1), UBOUND(AeroDyn_DataData%x,1)
  CALL AD_DestroyContState( AeroDyn_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(AeroDyn_DataData%xd,1), UBOUND(AeroDyn_DataData%xd,1)
  CALL AD_DestroyDiscState( AeroDyn_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(AeroDyn_DataData%z,1), UBOUND(AeroDyn_DataData%z,1)
  CALL AD_DestroyConstrState( AeroDyn_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(AeroDyn_DataData%OtherSt,1), UBOUND(AeroDyn_DataData%OtherSt,1)
  CALL AD_DestroyOtherState( AeroDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL AD_DestroyParam( AeroDyn_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD_DestroyInput( AeroDyn_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD_DestroyOutput( AeroDyn_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD_DestroyMisc( AeroDyn_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(AeroDyn_DataData%Output)) THEN
DO i1 = LBOUND(AeroDyn_DataData%Output,1), UBOUND(AeroDyn_DataData%Output,1)
  CALL AD_DestroyOutput( AeroDyn_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(AeroDyn_DataData%Output)
ENDIF
  CALL AD_DestroyOutput( AeroDyn_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(AeroDyn_DataData%Input)) THEN
DO i1 = LBOUND(AeroDyn_DataData%Input,1), UBOUND(AeroDyn_DataData%Input,1)
  CALL AD_DestroyInput( AeroDyn_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(AeroDyn_DataData%Input)
ENDIF
IF (ALLOCATED(AeroDyn_DataData%InputTimes)) THEN
  DEALLOCATE(AeroDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyAeroDyn_Data


subroutine FAST_PackAeroDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AeroDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackAeroDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call AD_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call AD_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call AD_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call AD_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call AD_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call AD_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call AD_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call AD_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call AD_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call AD_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call AD_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackAeroDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AeroDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackAeroDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call AD_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call AD_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call AD_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call AD_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call AD_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call AD_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call AD_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call AD_UnpackMisc(Buf, OutData%m) ! m 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call AD_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyInflowWind_Data( SrcInflowWind_DataData, DstInflowWind_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(InflowWind_Data), INTENT(IN) :: SrcInflowWind_DataData
   TYPE(InflowWind_Data), INTENT(INOUT) :: DstInflowWind_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyInflowWind_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcInflowWind_DataData%x,1), UBOUND(SrcInflowWind_DataData%x,1)
      CALL InflowWind_CopyContState( SrcInflowWind_DataData%x(i1), DstInflowWind_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcInflowWind_DataData%xd,1), UBOUND(SrcInflowWind_DataData%xd,1)
      CALL InflowWind_CopyDiscState( SrcInflowWind_DataData%xd(i1), DstInflowWind_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcInflowWind_DataData%z,1), UBOUND(SrcInflowWind_DataData%z,1)
      CALL InflowWind_CopyConstrState( SrcInflowWind_DataData%z(i1), DstInflowWind_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcInflowWind_DataData%OtherSt,1), UBOUND(SrcInflowWind_DataData%OtherSt,1)
      CALL InflowWind_CopyOtherState( SrcInflowWind_DataData%OtherSt(i1), DstInflowWind_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL InflowWind_CopyParam( SrcInflowWind_DataData%p, DstInflowWind_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyInput( SrcInflowWind_DataData%u, DstInflowWind_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyOutput( SrcInflowWind_DataData%y, DstInflowWind_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyMisc( SrcInflowWind_DataData%m, DstInflowWind_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInflowWind_DataData%Output)) THEN
  i1_l = LBOUND(SrcInflowWind_DataData%Output,1)
  i1_u = UBOUND(SrcInflowWind_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstInflowWind_DataData%Output)) THEN 
    ALLOCATE(DstInflowWind_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInflowWind_DataData%Output,1), UBOUND(SrcInflowWind_DataData%Output,1)
      CALL InflowWind_CopyOutput( SrcInflowWind_DataData%Output(i1), DstInflowWind_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL InflowWind_CopyOutput( SrcInflowWind_DataData%y_interp, DstInflowWind_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInflowWind_DataData%Input)) THEN
  i1_l = LBOUND(SrcInflowWind_DataData%Input,1)
  i1_u = UBOUND(SrcInflowWind_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstInflowWind_DataData%Input)) THEN 
    ALLOCATE(DstInflowWind_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInflowWind_DataData%Input,1), UBOUND(SrcInflowWind_DataData%Input,1)
      CALL InflowWind_CopyInput( SrcInflowWind_DataData%Input(i1), DstInflowWind_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInflowWind_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcInflowWind_DataData%InputTimes,1)
  i1_u = UBOUND(SrcInflowWind_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstInflowWind_DataData%InputTimes)) THEN 
    ALLOCATE(DstInflowWind_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInflowWind_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInflowWind_DataData%InputTimes = SrcInflowWind_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyInflowWind_Data

 SUBROUTINE FAST_DestroyInflowWind_Data( InflowWind_DataData, ErrStat, ErrMsg )
  TYPE(InflowWind_Data), INTENT(INOUT) :: InflowWind_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyInflowWind_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(InflowWind_DataData%x,1), UBOUND(InflowWind_DataData%x,1)
  CALL InflowWind_DestroyContState( InflowWind_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(InflowWind_DataData%xd,1), UBOUND(InflowWind_DataData%xd,1)
  CALL InflowWind_DestroyDiscState( InflowWind_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(InflowWind_DataData%z,1), UBOUND(InflowWind_DataData%z,1)
  CALL InflowWind_DestroyConstrState( InflowWind_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(InflowWind_DataData%OtherSt,1), UBOUND(InflowWind_DataData%OtherSt,1)
  CALL InflowWind_DestroyOtherState( InflowWind_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL InflowWind_DestroyParam( InflowWind_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyInput( InflowWind_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyOutput( InflowWind_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyMisc( InflowWind_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InflowWind_DataData%Output)) THEN
DO i1 = LBOUND(InflowWind_DataData%Output,1), UBOUND(InflowWind_DataData%Output,1)
  CALL InflowWind_DestroyOutput( InflowWind_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InflowWind_DataData%Output)
ENDIF
  CALL InflowWind_DestroyOutput( InflowWind_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InflowWind_DataData%Input)) THEN
DO i1 = LBOUND(InflowWind_DataData%Input,1), UBOUND(InflowWind_DataData%Input,1)
  CALL InflowWind_DestroyInput( InflowWind_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InflowWind_DataData%Input)
ENDIF
IF (ALLOCATED(InflowWind_DataData%InputTimes)) THEN
  DEALLOCATE(InflowWind_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyInflowWind_Data


subroutine FAST_PackInflowWind_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(InflowWind_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackInflowWind_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call InflowWind_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call InflowWind_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call InflowWind_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call InflowWind_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call InflowWind_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call InflowWind_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call InflowWind_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call InflowWind_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call InflowWind_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call InflowWind_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call InflowWind_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackInflowWind_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(InflowWind_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackInflowWind_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call InflowWind_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call InflowWind_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call InflowWind_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call InflowWind_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call InflowWind_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call InflowWind_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call InflowWind_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call InflowWind_UnpackMisc(Buf, OutData%m) ! m 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call InflowWind_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyOpenFOAM_Data( SrcOpenFOAM_DataData, DstOpenFOAM_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(OpenFOAM_Data), INTENT(INOUT) :: SrcOpenFOAM_DataData
   TYPE(OpenFOAM_Data), INTENT(INOUT) :: DstOpenFOAM_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyOpenFOAM_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL OpFM_CopyInput( SrcOpenFOAM_DataData%u, DstOpenFOAM_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL OpFM_CopyOutput( SrcOpenFOAM_DataData%y, DstOpenFOAM_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL OpFM_CopyParam( SrcOpenFOAM_DataData%p, DstOpenFOAM_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL OpFM_CopyMisc( SrcOpenFOAM_DataData%m, DstOpenFOAM_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FAST_CopyOpenFOAM_Data

 SUBROUTINE FAST_DestroyOpenFOAM_Data( OpenFOAM_DataData, ErrStat, ErrMsg )
  TYPE(OpenFOAM_Data), INTENT(INOUT) :: OpenFOAM_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyOpenFOAM_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL OpFM_DestroyInput( OpenFOAM_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL OpFM_DestroyOutput( OpenFOAM_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL OpFM_DestroyParam( OpenFOAM_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL OpFM_DestroyMisc( OpenFOAM_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyOpenFOAM_Data


subroutine FAST_PackOpenFOAM_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OpenFOAM_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackOpenFOAM_Data'
   if (Buf%ErrStat >= AbortErrLev) return
   ! u
   call OpFM_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call OpFM_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call OpFM_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call OpFM_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackOpenFOAM_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OpenFOAM_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackOpenFOAM_Data'
   if (Buf%ErrStat /= ErrID_None) return
   ! u
   call OpFM_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call OpFM_UnpackOutput(Buf, OutData%y) ! y 
   ! p
   call OpFM_UnpackParam(Buf, OutData%p) ! p 
   ! m
   call OpFM_UnpackMisc(Buf, OutData%m) ! m 
end subroutine
 SUBROUTINE FAST_CopySCDataEx_Data( SrcSCDataEx_DataData, DstSCDataEx_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SCDataEx_Data), INTENT(IN) :: SrcSCDataEx_DataData
   TYPE(SCDataEx_Data), INTENT(INOUT) :: DstSCDataEx_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopySCDataEx_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SC_DX_CopyInput( SrcSCDataEx_DataData%u, DstSCDataEx_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SC_DX_CopyOutput( SrcSCDataEx_DataData%y, DstSCDataEx_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SC_DX_CopyParam( SrcSCDataEx_DataData%p, DstSCDataEx_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FAST_CopySCDataEx_Data

 SUBROUTINE FAST_DestroySCDataEx_Data( SCDataEx_DataData, ErrStat, ErrMsg )
  TYPE(SCDataEx_Data), INTENT(INOUT) :: SCDataEx_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroySCDataEx_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL SC_DX_DestroyInput( SCDataEx_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SC_DX_DestroyOutput( SCDataEx_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SC_DX_DestroyParam( SCDataEx_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroySCDataEx_Data


subroutine FAST_PackSCDataEx_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SCDataEx_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackSCDataEx_Data'
   if (Buf%ErrStat >= AbortErrLev) return
   ! u
   call SC_DX_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call SC_DX_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call SC_DX_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackSCDataEx_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SCDataEx_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackSCDataEx_Data'
   if (Buf%ErrStat /= ErrID_None) return
   ! u
   call SC_DX_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call SC_DX_UnpackOutput(Buf, OutData%y) ! y 
   ! p
   call SC_DX_UnpackParam(Buf, OutData%p) ! p 
end subroutine
 SUBROUTINE FAST_CopySubDyn_Data( SrcSubDyn_DataData, DstSubDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SubDyn_Data), INTENT(INOUT) :: SrcSubDyn_DataData
   TYPE(SubDyn_Data), INTENT(INOUT) :: DstSubDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopySubDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcSubDyn_DataData%x,1), UBOUND(SrcSubDyn_DataData%x,1)
      CALL SD_CopyContState( SrcSubDyn_DataData%x(i1), DstSubDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcSubDyn_DataData%xd,1), UBOUND(SrcSubDyn_DataData%xd,1)
      CALL SD_CopyDiscState( SrcSubDyn_DataData%xd(i1), DstSubDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcSubDyn_DataData%z,1), UBOUND(SrcSubDyn_DataData%z,1)
      CALL SD_CopyConstrState( SrcSubDyn_DataData%z(i1), DstSubDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcSubDyn_DataData%OtherSt,1), UBOUND(SrcSubDyn_DataData%OtherSt,1)
      CALL SD_CopyOtherState( SrcSubDyn_DataData%OtherSt(i1), DstSubDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL SD_CopyParam( SrcSubDyn_DataData%p, DstSubDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SD_CopyInput( SrcSubDyn_DataData%u, DstSubDyn_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SD_CopyOutput( SrcSubDyn_DataData%y, DstSubDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SD_CopyMisc( SrcSubDyn_DataData%m, DstSubDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcSubDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcSubDyn_DataData%Input,1)
  i1_u = UBOUND(SrcSubDyn_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstSubDyn_DataData%Input)) THEN 
    ALLOCATE(DstSubDyn_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcSubDyn_DataData%Input,1), UBOUND(SrcSubDyn_DataData%Input,1)
      CALL SD_CopyInput( SrcSubDyn_DataData%Input(i1), DstSubDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcSubDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcSubDyn_DataData%Output,1)
  i1_u = UBOUND(SrcSubDyn_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstSubDyn_DataData%Output)) THEN 
    ALLOCATE(DstSubDyn_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcSubDyn_DataData%Output,1), UBOUND(SrcSubDyn_DataData%Output,1)
      CALL SD_CopyOutput( SrcSubDyn_DataData%Output(i1), DstSubDyn_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL SD_CopyOutput( SrcSubDyn_DataData%y_interp, DstSubDyn_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcSubDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcSubDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcSubDyn_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstSubDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstSubDyn_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstSubDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstSubDyn_DataData%InputTimes = SrcSubDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopySubDyn_Data

 SUBROUTINE FAST_DestroySubDyn_Data( SubDyn_DataData, ErrStat, ErrMsg )
  TYPE(SubDyn_Data), INTENT(INOUT) :: SubDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroySubDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(SubDyn_DataData%x,1), UBOUND(SubDyn_DataData%x,1)
  CALL SD_DestroyContState( SubDyn_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(SubDyn_DataData%xd,1), UBOUND(SubDyn_DataData%xd,1)
  CALL SD_DestroyDiscState( SubDyn_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(SubDyn_DataData%z,1), UBOUND(SubDyn_DataData%z,1)
  CALL SD_DestroyConstrState( SubDyn_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(SubDyn_DataData%OtherSt,1), UBOUND(SubDyn_DataData%OtherSt,1)
  CALL SD_DestroyOtherState( SubDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL SD_DestroyParam( SubDyn_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SD_DestroyInput( SubDyn_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SD_DestroyOutput( SubDyn_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SD_DestroyMisc( SubDyn_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(SubDyn_DataData%Input)) THEN
DO i1 = LBOUND(SubDyn_DataData%Input,1), UBOUND(SubDyn_DataData%Input,1)
  CALL SD_DestroyInput( SubDyn_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(SubDyn_DataData%Input)
ENDIF
IF (ALLOCATED(SubDyn_DataData%Output)) THEN
DO i1 = LBOUND(SubDyn_DataData%Output,1), UBOUND(SubDyn_DataData%Output,1)
  CALL SD_DestroyOutput( SubDyn_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(SubDyn_DataData%Output)
ENDIF
  CALL SD_DestroyOutput( SubDyn_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(SubDyn_DataData%InputTimes)) THEN
  DEALLOCATE(SubDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroySubDyn_Data


subroutine FAST_PackSubDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SubDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackSubDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call SD_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call SD_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call SD_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call SD_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call SD_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call SD_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call SD_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call SD_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SD_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call SD_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call SD_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackSubDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SubDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackSubDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call SD_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call SD_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call SD_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call SD_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call SD_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call SD_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call SD_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call SD_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call SD_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyExtPtfm_Data( SrcExtPtfm_DataData, DstExtPtfm_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ExtPtfm_Data), INTENT(INOUT) :: SrcExtPtfm_DataData
   TYPE(ExtPtfm_Data), INTENT(INOUT) :: DstExtPtfm_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyExtPtfm_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcExtPtfm_DataData%x,1), UBOUND(SrcExtPtfm_DataData%x,1)
      CALL ExtPtfm_CopyContState( SrcExtPtfm_DataData%x(i1), DstExtPtfm_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcExtPtfm_DataData%xd,1), UBOUND(SrcExtPtfm_DataData%xd,1)
      CALL ExtPtfm_CopyDiscState( SrcExtPtfm_DataData%xd(i1), DstExtPtfm_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcExtPtfm_DataData%z,1), UBOUND(SrcExtPtfm_DataData%z,1)
      CALL ExtPtfm_CopyConstrState( SrcExtPtfm_DataData%z(i1), DstExtPtfm_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcExtPtfm_DataData%OtherSt,1), UBOUND(SrcExtPtfm_DataData%OtherSt,1)
      CALL ExtPtfm_CopyOtherState( SrcExtPtfm_DataData%OtherSt(i1), DstExtPtfm_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL ExtPtfm_CopyParam( SrcExtPtfm_DataData%p, DstExtPtfm_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ExtPtfm_CopyInput( SrcExtPtfm_DataData%u, DstExtPtfm_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ExtPtfm_CopyOutput( SrcExtPtfm_DataData%y, DstExtPtfm_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ExtPtfm_CopyMisc( SrcExtPtfm_DataData%m, DstExtPtfm_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcExtPtfm_DataData%Input)) THEN
  i1_l = LBOUND(SrcExtPtfm_DataData%Input,1)
  i1_u = UBOUND(SrcExtPtfm_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstExtPtfm_DataData%Input)) THEN 
    ALLOCATE(DstExtPtfm_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcExtPtfm_DataData%Input,1), UBOUND(SrcExtPtfm_DataData%Input,1)
      CALL ExtPtfm_CopyInput( SrcExtPtfm_DataData%Input(i1), DstExtPtfm_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcExtPtfm_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcExtPtfm_DataData%InputTimes,1)
  i1_u = UBOUND(SrcExtPtfm_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstExtPtfm_DataData%InputTimes)) THEN 
    ALLOCATE(DstExtPtfm_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstExtPtfm_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstExtPtfm_DataData%InputTimes = SrcExtPtfm_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyExtPtfm_Data

 SUBROUTINE FAST_DestroyExtPtfm_Data( ExtPtfm_DataData, ErrStat, ErrMsg )
  TYPE(ExtPtfm_Data), INTENT(INOUT) :: ExtPtfm_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyExtPtfm_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(ExtPtfm_DataData%x,1), UBOUND(ExtPtfm_DataData%x,1)
  CALL ExtPtfm_DestroyContState( ExtPtfm_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ExtPtfm_DataData%xd,1), UBOUND(ExtPtfm_DataData%xd,1)
  CALL ExtPtfm_DestroyDiscState( ExtPtfm_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ExtPtfm_DataData%z,1), UBOUND(ExtPtfm_DataData%z,1)
  CALL ExtPtfm_DestroyConstrState( ExtPtfm_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(ExtPtfm_DataData%OtherSt,1), UBOUND(ExtPtfm_DataData%OtherSt,1)
  CALL ExtPtfm_DestroyOtherState( ExtPtfm_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL ExtPtfm_DestroyParam( ExtPtfm_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ExtPtfm_DestroyInput( ExtPtfm_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ExtPtfm_DestroyOutput( ExtPtfm_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ExtPtfm_DestroyMisc( ExtPtfm_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ExtPtfm_DataData%Input)) THEN
DO i1 = LBOUND(ExtPtfm_DataData%Input,1), UBOUND(ExtPtfm_DataData%Input,1)
  CALL ExtPtfm_DestroyInput( ExtPtfm_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ExtPtfm_DataData%Input)
ENDIF
IF (ALLOCATED(ExtPtfm_DataData%InputTimes)) THEN
  DEALLOCATE(ExtPtfm_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyExtPtfm_Data


subroutine FAST_PackExtPtfm_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ExtPtfm_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExtPtfm_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call ExtPtfm_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call ExtPtfm_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call ExtPtfm_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call ExtPtfm_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call ExtPtfm_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call ExtPtfm_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call ExtPtfm_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call ExtPtfm_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call ExtPtfm_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackExtPtfm_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ExtPtfm_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExtPtfm_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call ExtPtfm_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call ExtPtfm_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call ExtPtfm_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call ExtPtfm_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call ExtPtfm_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call ExtPtfm_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call ExtPtfm_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call ExtPtfm_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call ExtPtfm_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopySeaState_Data( SrcSeaState_DataData, DstSeaState_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaState_Data), INTENT(IN) :: SrcSeaState_DataData
   TYPE(SeaState_Data), INTENT(INOUT) :: DstSeaState_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopySeaState_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcSeaState_DataData%x,1), UBOUND(SrcSeaState_DataData%x,1)
      CALL SeaSt_CopyContState( SrcSeaState_DataData%x(i1), DstSeaState_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcSeaState_DataData%xd,1), UBOUND(SrcSeaState_DataData%xd,1)
      CALL SeaSt_CopyDiscState( SrcSeaState_DataData%xd(i1), DstSeaState_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcSeaState_DataData%z,1), UBOUND(SrcSeaState_DataData%z,1)
      CALL SeaSt_CopyConstrState( SrcSeaState_DataData%z(i1), DstSeaState_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcSeaState_DataData%OtherSt,1), UBOUND(SrcSeaState_DataData%OtherSt,1)
      CALL SeaSt_CopyOtherState( SrcSeaState_DataData%OtherSt(i1), DstSeaState_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL SeaSt_CopyParam( SrcSeaState_DataData%p, DstSeaState_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SeaSt_CopyInput( SrcSeaState_DataData%u, DstSeaState_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SeaSt_CopyOutput( SrcSeaState_DataData%y, DstSeaState_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SeaSt_CopyMisc( SrcSeaState_DataData%m, DstSeaState_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcSeaState_DataData%Input)) THEN
  i1_l = LBOUND(SrcSeaState_DataData%Input,1)
  i1_u = UBOUND(SrcSeaState_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstSeaState_DataData%Input)) THEN 
    ALLOCATE(DstSeaState_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcSeaState_DataData%Input,1), UBOUND(SrcSeaState_DataData%Input,1)
      CALL SeaSt_CopyInput( SrcSeaState_DataData%Input(i1), DstSeaState_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcSeaState_DataData%Output)) THEN
  i1_l = LBOUND(SrcSeaState_DataData%Output,1)
  i1_u = UBOUND(SrcSeaState_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstSeaState_DataData%Output)) THEN 
    ALLOCATE(DstSeaState_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcSeaState_DataData%Output,1), UBOUND(SrcSeaState_DataData%Output,1)
      CALL SeaSt_CopyOutput( SrcSeaState_DataData%Output(i1), DstSeaState_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL SeaSt_CopyOutput( SrcSeaState_DataData%y_interp, DstSeaState_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcSeaState_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcSeaState_DataData%InputTimes,1)
  i1_u = UBOUND(SrcSeaState_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstSeaState_DataData%InputTimes)) THEN 
    ALLOCATE(DstSeaState_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstSeaState_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstSeaState_DataData%InputTimes = SrcSeaState_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopySeaState_Data

 SUBROUTINE FAST_DestroySeaState_Data( SeaState_DataData, ErrStat, ErrMsg )
  TYPE(SeaState_Data), INTENT(INOUT) :: SeaState_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroySeaState_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(SeaState_DataData%x,1), UBOUND(SeaState_DataData%x,1)
  CALL SeaSt_DestroyContState( SeaState_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(SeaState_DataData%xd,1), UBOUND(SeaState_DataData%xd,1)
  CALL SeaSt_DestroyDiscState( SeaState_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(SeaState_DataData%z,1), UBOUND(SeaState_DataData%z,1)
  CALL SeaSt_DestroyConstrState( SeaState_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(SeaState_DataData%OtherSt,1), UBOUND(SeaState_DataData%OtherSt,1)
  CALL SeaSt_DestroyOtherState( SeaState_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL SeaSt_DestroyParam( SeaState_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_DestroyInput( SeaState_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_DestroyOutput( SeaState_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_DestroyMisc( SeaState_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(SeaState_DataData%Input)) THEN
DO i1 = LBOUND(SeaState_DataData%Input,1), UBOUND(SeaState_DataData%Input,1)
  CALL SeaSt_DestroyInput( SeaState_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(SeaState_DataData%Input)
ENDIF
IF (ALLOCATED(SeaState_DataData%Output)) THEN
DO i1 = LBOUND(SeaState_DataData%Output,1), UBOUND(SeaState_DataData%Output,1)
  CALL SeaSt_DestroyOutput( SeaState_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(SeaState_DataData%Output)
ENDIF
  CALL SeaSt_DestroyOutput( SeaState_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(SeaState_DataData%InputTimes)) THEN
  DEALLOCATE(SeaState_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroySeaState_Data


subroutine FAST_PackSeaState_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaState_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackSeaState_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call SeaSt_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call SeaSt_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call SeaSt_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call SeaSt_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call SeaSt_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call SeaSt_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call SeaSt_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call SeaSt_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call SeaSt_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call SeaSt_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call SeaSt_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackSeaState_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaState_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackSeaState_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call SeaSt_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call SeaSt_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call SeaSt_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call SeaSt_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call SeaSt_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call SeaSt_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call SeaSt_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call SeaSt_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SeaSt_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call SeaSt_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyHydroDyn_Data( SrcHydroDyn_DataData, DstHydroDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_Data), INTENT(INOUT) :: SrcHydroDyn_DataData
   TYPE(HydroDyn_Data), INTENT(INOUT) :: DstHydroDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyHydroDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcHydroDyn_DataData%x,1), UBOUND(SrcHydroDyn_DataData%x,1)
      CALL HydroDyn_CopyContState( SrcHydroDyn_DataData%x(i1), DstHydroDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcHydroDyn_DataData%xd,1), UBOUND(SrcHydroDyn_DataData%xd,1)
      CALL HydroDyn_CopyDiscState( SrcHydroDyn_DataData%xd(i1), DstHydroDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcHydroDyn_DataData%z,1), UBOUND(SrcHydroDyn_DataData%z,1)
      CALL HydroDyn_CopyConstrState( SrcHydroDyn_DataData%z(i1), DstHydroDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcHydroDyn_DataData%OtherSt,1), UBOUND(SrcHydroDyn_DataData%OtherSt,1)
      CALL HydroDyn_CopyOtherState( SrcHydroDyn_DataData%OtherSt(i1), DstHydroDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL HydroDyn_CopyParam( SrcHydroDyn_DataData%p, DstHydroDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL HydroDyn_CopyInput( SrcHydroDyn_DataData%u, DstHydroDyn_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL HydroDyn_CopyOutput( SrcHydroDyn_DataData%y, DstHydroDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL HydroDyn_CopyMisc( SrcHydroDyn_DataData%m, DstHydroDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcHydroDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcHydroDyn_DataData%Output,1)
  i1_u = UBOUND(SrcHydroDyn_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstHydroDyn_DataData%Output)) THEN 
    ALLOCATE(DstHydroDyn_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcHydroDyn_DataData%Output,1), UBOUND(SrcHydroDyn_DataData%Output,1)
      CALL HydroDyn_CopyOutput( SrcHydroDyn_DataData%Output(i1), DstHydroDyn_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL HydroDyn_CopyOutput( SrcHydroDyn_DataData%y_interp, DstHydroDyn_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcHydroDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcHydroDyn_DataData%Input,1)
  i1_u = UBOUND(SrcHydroDyn_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstHydroDyn_DataData%Input)) THEN 
    ALLOCATE(DstHydroDyn_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcHydroDyn_DataData%Input,1), UBOUND(SrcHydroDyn_DataData%Input,1)
      CALL HydroDyn_CopyInput( SrcHydroDyn_DataData%Input(i1), DstHydroDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcHydroDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcHydroDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcHydroDyn_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstHydroDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstHydroDyn_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstHydroDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstHydroDyn_DataData%InputTimes = SrcHydroDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyHydroDyn_Data

 SUBROUTINE FAST_DestroyHydroDyn_Data( HydroDyn_DataData, ErrStat, ErrMsg )
  TYPE(HydroDyn_Data), INTENT(INOUT) :: HydroDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyHydroDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(HydroDyn_DataData%x,1), UBOUND(HydroDyn_DataData%x,1)
  CALL HydroDyn_DestroyContState( HydroDyn_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(HydroDyn_DataData%xd,1), UBOUND(HydroDyn_DataData%xd,1)
  CALL HydroDyn_DestroyDiscState( HydroDyn_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(HydroDyn_DataData%z,1), UBOUND(HydroDyn_DataData%z,1)
  CALL HydroDyn_DestroyConstrState( HydroDyn_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(HydroDyn_DataData%OtherSt,1), UBOUND(HydroDyn_DataData%OtherSt,1)
  CALL HydroDyn_DestroyOtherState( HydroDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL HydroDyn_DestroyParam( HydroDyn_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL HydroDyn_DestroyInput( HydroDyn_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL HydroDyn_DestroyOutput( HydroDyn_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL HydroDyn_DestroyMisc( HydroDyn_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(HydroDyn_DataData%Output)) THEN
DO i1 = LBOUND(HydroDyn_DataData%Output,1), UBOUND(HydroDyn_DataData%Output,1)
  CALL HydroDyn_DestroyOutput( HydroDyn_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(HydroDyn_DataData%Output)
ENDIF
  CALL HydroDyn_DestroyOutput( HydroDyn_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(HydroDyn_DataData%Input)) THEN
DO i1 = LBOUND(HydroDyn_DataData%Input,1), UBOUND(HydroDyn_DataData%Input,1)
  CALL HydroDyn_DestroyInput( HydroDyn_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(HydroDyn_DataData%Input)
ENDIF
IF (ALLOCATED(HydroDyn_DataData%InputTimes)) THEN
  DEALLOCATE(HydroDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyHydroDyn_Data


subroutine FAST_PackHydroDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackHydroDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call HydroDyn_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call HydroDyn_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call HydroDyn_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call HydroDyn_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call HydroDyn_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call HydroDyn_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call HydroDyn_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call HydroDyn_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call HydroDyn_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call HydroDyn_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackHydroDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackHydroDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call HydroDyn_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call HydroDyn_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call HydroDyn_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call HydroDyn_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call HydroDyn_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call HydroDyn_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call HydroDyn_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call HydroDyn_UnpackMisc(Buf, OutData%m) ! m 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call HydroDyn_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call HydroDyn_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyIceFloe_Data( SrcIceFloe_DataData, DstIceFloe_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IceFloe_Data), INTENT(INOUT) :: SrcIceFloe_DataData
   TYPE(IceFloe_Data), INTENT(INOUT) :: DstIceFloe_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyIceFloe_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcIceFloe_DataData%x,1), UBOUND(SrcIceFloe_DataData%x,1)
      CALL IceFloe_CopyContState( SrcIceFloe_DataData%x(i1), DstIceFloe_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcIceFloe_DataData%xd,1), UBOUND(SrcIceFloe_DataData%xd,1)
      CALL IceFloe_CopyDiscState( SrcIceFloe_DataData%xd(i1), DstIceFloe_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcIceFloe_DataData%z,1), UBOUND(SrcIceFloe_DataData%z,1)
      CALL IceFloe_CopyConstrState( SrcIceFloe_DataData%z(i1), DstIceFloe_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcIceFloe_DataData%OtherSt,1), UBOUND(SrcIceFloe_DataData%OtherSt,1)
      CALL IceFloe_CopyOtherState( SrcIceFloe_DataData%OtherSt(i1), DstIceFloe_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL IceFloe_CopyParam( SrcIceFloe_DataData%p, DstIceFloe_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceFloe_CopyInput( SrcIceFloe_DataData%u, DstIceFloe_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceFloe_CopyOutput( SrcIceFloe_DataData%y, DstIceFloe_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceFloe_CopyMisc( SrcIceFloe_DataData%m, DstIceFloe_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcIceFloe_DataData%Input)) THEN
  i1_l = LBOUND(SrcIceFloe_DataData%Input,1)
  i1_u = UBOUND(SrcIceFloe_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstIceFloe_DataData%Input)) THEN 
    ALLOCATE(DstIceFloe_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcIceFloe_DataData%Input,1), UBOUND(SrcIceFloe_DataData%Input,1)
      CALL IceFloe_CopyInput( SrcIceFloe_DataData%Input(i1), DstIceFloe_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcIceFloe_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcIceFloe_DataData%InputTimes,1)
  i1_u = UBOUND(SrcIceFloe_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstIceFloe_DataData%InputTimes)) THEN 
    ALLOCATE(DstIceFloe_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIceFloe_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstIceFloe_DataData%InputTimes = SrcIceFloe_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyIceFloe_Data

 SUBROUTINE FAST_DestroyIceFloe_Data( IceFloe_DataData, ErrStat, ErrMsg )
  TYPE(IceFloe_Data), INTENT(INOUT) :: IceFloe_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyIceFloe_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(IceFloe_DataData%x,1), UBOUND(IceFloe_DataData%x,1)
  CALL IceFloe_DestroyContState( IceFloe_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(IceFloe_DataData%xd,1), UBOUND(IceFloe_DataData%xd,1)
  CALL IceFloe_DestroyDiscState( IceFloe_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(IceFloe_DataData%z,1), UBOUND(IceFloe_DataData%z,1)
  CALL IceFloe_DestroyConstrState( IceFloe_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(IceFloe_DataData%OtherSt,1), UBOUND(IceFloe_DataData%OtherSt,1)
  CALL IceFloe_DestroyOtherState( IceFloe_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL IceFloe_DestroyParam( IceFloe_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceFloe_DestroyInput( IceFloe_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceFloe_DestroyOutput( IceFloe_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceFloe_DestroyMisc( IceFloe_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(IceFloe_DataData%Input)) THEN
DO i1 = LBOUND(IceFloe_DataData%Input,1), UBOUND(IceFloe_DataData%Input,1)
  CALL IceFloe_DestroyInput( IceFloe_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(IceFloe_DataData%Input)
ENDIF
IF (ALLOCATED(IceFloe_DataData%InputTimes)) THEN
  DEALLOCATE(IceFloe_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyIceFloe_Data


subroutine FAST_PackIceFloe_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(IceFloe_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackIceFloe_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call IceFloe_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call IceFloe_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call IceFloe_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call IceFloe_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call IceFloe_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call IceFloe_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call IceFloe_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call IceFloe_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call IceFloe_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackIceFloe_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(IceFloe_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackIceFloe_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call IceFloe_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call IceFloe_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call IceFloe_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call IceFloe_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call IceFloe_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call IceFloe_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call IceFloe_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call IceFloe_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call IceFloe_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyMAP_Data( SrcMAP_DataData, DstMAP_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MAP_Data), INTENT(INOUT) :: SrcMAP_DataData
   TYPE(MAP_Data), INTENT(INOUT) :: DstMAP_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyMAP_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcMAP_DataData%x,1), UBOUND(SrcMAP_DataData%x,1)
      CALL MAP_CopyContState( SrcMAP_DataData%x(i1), DstMAP_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcMAP_DataData%xd,1), UBOUND(SrcMAP_DataData%xd,1)
      CALL MAP_CopyDiscState( SrcMAP_DataData%xd(i1), DstMAP_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcMAP_DataData%z,1), UBOUND(SrcMAP_DataData%z,1)
      CALL MAP_CopyConstrState( SrcMAP_DataData%z(i1), DstMAP_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL MAP_CopyOtherState( SrcMAP_DataData%OtherSt, DstMAP_DataData%OtherSt, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MAP_CopyParam( SrcMAP_DataData%p, DstMAP_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MAP_CopyInput( SrcMAP_DataData%u, DstMAP_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MAP_CopyOutput( SrcMAP_DataData%y, DstMAP_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MAP_CopyOtherState( SrcMAP_DataData%OtherSt_old, DstMAP_DataData%OtherSt_old, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMAP_DataData%Output)) THEN
  i1_l = LBOUND(SrcMAP_DataData%Output,1)
  i1_u = UBOUND(SrcMAP_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstMAP_DataData%Output)) THEN 
    ALLOCATE(DstMAP_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMAP_DataData%Output,1), UBOUND(SrcMAP_DataData%Output,1)
      CALL MAP_CopyOutput( SrcMAP_DataData%Output(i1), DstMAP_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MAP_CopyOutput( SrcMAP_DataData%y_interp, DstMAP_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMAP_DataData%Input)) THEN
  i1_l = LBOUND(SrcMAP_DataData%Input,1)
  i1_u = UBOUND(SrcMAP_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstMAP_DataData%Input)) THEN 
    ALLOCATE(DstMAP_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMAP_DataData%Input,1), UBOUND(SrcMAP_DataData%Input,1)
      CALL MAP_CopyInput( SrcMAP_DataData%Input(i1), DstMAP_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMAP_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcMAP_DataData%InputTimes,1)
  i1_u = UBOUND(SrcMAP_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstMAP_DataData%InputTimes)) THEN 
    ALLOCATE(DstMAP_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMAP_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMAP_DataData%InputTimes = SrcMAP_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyMAP_Data

 SUBROUTINE FAST_DestroyMAP_Data( MAP_DataData, ErrStat, ErrMsg )
  TYPE(MAP_Data), INTENT(INOUT) :: MAP_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyMAP_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(MAP_DataData%x,1), UBOUND(MAP_DataData%x,1)
  CALL MAP_DestroyContState( MAP_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(MAP_DataData%xd,1), UBOUND(MAP_DataData%xd,1)
  CALL MAP_DestroyDiscState( MAP_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(MAP_DataData%z,1), UBOUND(MAP_DataData%z,1)
  CALL MAP_DestroyConstrState( MAP_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL MAP_DestroyOtherState( MAP_DataData%OtherSt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MAP_DestroyParam( MAP_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MAP_DestroyInput( MAP_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MAP_DestroyOutput( MAP_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MAP_DestroyOtherState( MAP_DataData%OtherSt_old, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MAP_DataData%Output)) THEN
DO i1 = LBOUND(MAP_DataData%Output,1), UBOUND(MAP_DataData%Output,1)
  CALL MAP_DestroyOutput( MAP_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MAP_DataData%Output)
ENDIF
  CALL MAP_DestroyOutput( MAP_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MAP_DataData%Input)) THEN
DO i1 = LBOUND(MAP_DataData%Input,1), UBOUND(MAP_DataData%Input,1)
  CALL MAP_DestroyInput( MAP_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MAP_DataData%Input)
ENDIF
IF (ALLOCATED(MAP_DataData%InputTimes)) THEN
  DEALLOCATE(MAP_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyMAP_Data


subroutine FAST_PackMAP_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MAP_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMAP_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call MAP_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call MAP_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call MAP_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   call MAP_PackOtherState(Buf, InData%OtherSt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call MAP_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call MAP_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call MAP_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt_old
   call MAP_PackOtherState(Buf, InData%OtherSt_old) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call MAP_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call MAP_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call MAP_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackMAP_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MAP_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMAP_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call MAP_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call MAP_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call MAP_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   call MAP_UnpackOtherState(Buf, OutData%OtherSt) ! OtherSt 
   ! p
   call MAP_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call MAP_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call MAP_UnpackOutput(Buf, OutData%y) ! y 
   ! OtherSt_old
   call MAP_UnpackOtherState(Buf, OutData%OtherSt_old) ! OtherSt_old 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call MAP_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MAP_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyFEAMooring_Data( SrcFEAMooring_DataData, DstFEAMooring_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAMooring_Data), INTENT(INOUT) :: SrcFEAMooring_DataData
   TYPE(FEAMooring_Data), INTENT(INOUT) :: DstFEAMooring_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyFEAMooring_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcFEAMooring_DataData%x,1), UBOUND(SrcFEAMooring_DataData%x,1)
      CALL FEAM_CopyContState( SrcFEAMooring_DataData%x(i1), DstFEAMooring_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcFEAMooring_DataData%xd,1), UBOUND(SrcFEAMooring_DataData%xd,1)
      CALL FEAM_CopyDiscState( SrcFEAMooring_DataData%xd(i1), DstFEAMooring_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcFEAMooring_DataData%z,1), UBOUND(SrcFEAMooring_DataData%z,1)
      CALL FEAM_CopyConstrState( SrcFEAMooring_DataData%z(i1), DstFEAMooring_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcFEAMooring_DataData%OtherSt,1), UBOUND(SrcFEAMooring_DataData%OtherSt,1)
      CALL FEAM_CopyOtherState( SrcFEAMooring_DataData%OtherSt(i1), DstFEAMooring_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL FEAM_CopyParam( SrcFEAMooring_DataData%p, DstFEAMooring_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FEAM_CopyInput( SrcFEAMooring_DataData%u, DstFEAMooring_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FEAM_CopyOutput( SrcFEAMooring_DataData%y, DstFEAMooring_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FEAM_CopyMisc( SrcFEAMooring_DataData%m, DstFEAMooring_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcFEAMooring_DataData%Input)) THEN
  i1_l = LBOUND(SrcFEAMooring_DataData%Input,1)
  i1_u = UBOUND(SrcFEAMooring_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstFEAMooring_DataData%Input)) THEN 
    ALLOCATE(DstFEAMooring_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcFEAMooring_DataData%Input,1), UBOUND(SrcFEAMooring_DataData%Input,1)
      CALL FEAM_CopyInput( SrcFEAMooring_DataData%Input(i1), DstFEAMooring_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcFEAMooring_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcFEAMooring_DataData%InputTimes,1)
  i1_u = UBOUND(SrcFEAMooring_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstFEAMooring_DataData%InputTimes)) THEN 
    ALLOCATE(DstFEAMooring_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFEAMooring_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFEAMooring_DataData%InputTimes = SrcFEAMooring_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyFEAMooring_Data

 SUBROUTINE FAST_DestroyFEAMooring_Data( FEAMooring_DataData, ErrStat, ErrMsg )
  TYPE(FEAMooring_Data), INTENT(INOUT) :: FEAMooring_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyFEAMooring_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(FEAMooring_DataData%x,1), UBOUND(FEAMooring_DataData%x,1)
  CALL FEAM_DestroyContState( FEAMooring_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(FEAMooring_DataData%xd,1), UBOUND(FEAMooring_DataData%xd,1)
  CALL FEAM_DestroyDiscState( FEAMooring_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(FEAMooring_DataData%z,1), UBOUND(FEAMooring_DataData%z,1)
  CALL FEAM_DestroyConstrState( FEAMooring_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(FEAMooring_DataData%OtherSt,1), UBOUND(FEAMooring_DataData%OtherSt,1)
  CALL FEAM_DestroyOtherState( FEAMooring_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL FEAM_DestroyParam( FEAMooring_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FEAM_DestroyInput( FEAMooring_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FEAM_DestroyOutput( FEAMooring_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FEAM_DestroyMisc( FEAMooring_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(FEAMooring_DataData%Input)) THEN
DO i1 = LBOUND(FEAMooring_DataData%Input,1), UBOUND(FEAMooring_DataData%Input,1)
  CALL FEAM_DestroyInput( FEAMooring_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(FEAMooring_DataData%Input)
ENDIF
IF (ALLOCATED(FEAMooring_DataData%InputTimes)) THEN
  DEALLOCATE(FEAMooring_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyFEAMooring_Data


subroutine FAST_PackFEAMooring_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAMooring_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackFEAMooring_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call FEAM_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call FEAM_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call FEAM_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call FEAM_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call FEAM_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call FEAM_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call FEAM_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call FEAM_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call FEAM_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackFEAMooring_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAMooring_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackFEAMooring_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call FEAM_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call FEAM_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call FEAM_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call FEAM_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call FEAM_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call FEAM_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call FEAM_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call FEAM_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FEAM_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyMoorDyn_Data( SrcMoorDyn_DataData, DstMoorDyn_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MoorDyn_Data), INTENT(INOUT) :: SrcMoorDyn_DataData
   TYPE(MoorDyn_Data), INTENT(INOUT) :: DstMoorDyn_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyMoorDyn_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcMoorDyn_DataData%x,1), UBOUND(SrcMoorDyn_DataData%x,1)
      CALL MD_CopyContState( SrcMoorDyn_DataData%x(i1), DstMoorDyn_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcMoorDyn_DataData%xd,1), UBOUND(SrcMoorDyn_DataData%xd,1)
      CALL MD_CopyDiscState( SrcMoorDyn_DataData%xd(i1), DstMoorDyn_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcMoorDyn_DataData%z,1), UBOUND(SrcMoorDyn_DataData%z,1)
      CALL MD_CopyConstrState( SrcMoorDyn_DataData%z(i1), DstMoorDyn_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcMoorDyn_DataData%OtherSt,1), UBOUND(SrcMoorDyn_DataData%OtherSt,1)
      CALL MD_CopyOtherState( SrcMoorDyn_DataData%OtherSt(i1), DstMoorDyn_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL MD_CopyParam( SrcMoorDyn_DataData%p, DstMoorDyn_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyInput( SrcMoorDyn_DataData%u, DstMoorDyn_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyOutput( SrcMoorDyn_DataData%y, DstMoorDyn_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyMisc( SrcMoorDyn_DataData%m, DstMoorDyn_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMoorDyn_DataData%Output)) THEN
  i1_l = LBOUND(SrcMoorDyn_DataData%Output,1)
  i1_u = UBOUND(SrcMoorDyn_DataData%Output,1)
  IF (.NOT. ALLOCATED(DstMoorDyn_DataData%Output)) THEN 
    ALLOCATE(DstMoorDyn_DataData%Output(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%Output.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMoorDyn_DataData%Output,1), UBOUND(SrcMoorDyn_DataData%Output,1)
      CALL MD_CopyOutput( SrcMoorDyn_DataData%Output(i1), DstMoorDyn_DataData%Output(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MD_CopyOutput( SrcMoorDyn_DataData%y_interp, DstMoorDyn_DataData%y_interp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMoorDyn_DataData%Input)) THEN
  i1_l = LBOUND(SrcMoorDyn_DataData%Input,1)
  i1_u = UBOUND(SrcMoorDyn_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstMoorDyn_DataData%Input)) THEN 
    ALLOCATE(DstMoorDyn_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMoorDyn_DataData%Input,1), UBOUND(SrcMoorDyn_DataData%Input,1)
      CALL MD_CopyInput( SrcMoorDyn_DataData%Input(i1), DstMoorDyn_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMoorDyn_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcMoorDyn_DataData%InputTimes,1)
  i1_u = UBOUND(SrcMoorDyn_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstMoorDyn_DataData%InputTimes)) THEN 
    ALLOCATE(DstMoorDyn_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMoorDyn_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMoorDyn_DataData%InputTimes = SrcMoorDyn_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyMoorDyn_Data

 SUBROUTINE FAST_DestroyMoorDyn_Data( MoorDyn_DataData, ErrStat, ErrMsg )
  TYPE(MoorDyn_Data), INTENT(INOUT) :: MoorDyn_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyMoorDyn_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(MoorDyn_DataData%x,1), UBOUND(MoorDyn_DataData%x,1)
  CALL MD_DestroyContState( MoorDyn_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(MoorDyn_DataData%xd,1), UBOUND(MoorDyn_DataData%xd,1)
  CALL MD_DestroyDiscState( MoorDyn_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(MoorDyn_DataData%z,1), UBOUND(MoorDyn_DataData%z,1)
  CALL MD_DestroyConstrState( MoorDyn_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(MoorDyn_DataData%OtherSt,1), UBOUND(MoorDyn_DataData%OtherSt,1)
  CALL MD_DestroyOtherState( MoorDyn_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL MD_DestroyParam( MoorDyn_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyInput( MoorDyn_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyOutput( MoorDyn_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyMisc( MoorDyn_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MoorDyn_DataData%Output)) THEN
DO i1 = LBOUND(MoorDyn_DataData%Output,1), UBOUND(MoorDyn_DataData%Output,1)
  CALL MD_DestroyOutput( MoorDyn_DataData%Output(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MoorDyn_DataData%Output)
ENDIF
  CALL MD_DestroyOutput( MoorDyn_DataData%y_interp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MoorDyn_DataData%Input)) THEN
DO i1 = LBOUND(MoorDyn_DataData%Input,1), UBOUND(MoorDyn_DataData%Input,1)
  CALL MD_DestroyInput( MoorDyn_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MoorDyn_DataData%Input)
ENDIF
IF (ALLOCATED(MoorDyn_DataData%InputTimes)) THEN
  DEALLOCATE(MoorDyn_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyMoorDyn_Data


subroutine FAST_PackMoorDyn_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MoorDyn_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMoorDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call MD_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call MD_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call MD_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call MD_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call MD_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call MD_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call MD_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call MD_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Output
   call RegPack(Buf, allocated(InData%Output))
   if (allocated(InData%Output)) then
      call RegPackBounds(Buf, 1, lbound(InData%Output), ubound(InData%Output))
      LB(1:1) = lbound(InData%Output)
      UB(1:1) = ubound(InData%Output)
      do i1 = LB(1), UB(1)
         call MD_PackOutput(Buf, InData%Output(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_interp
   call MD_PackOutput(Buf, InData%y_interp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call MD_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackMoorDyn_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MoorDyn_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMoorDyn_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call MD_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call MD_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call MD_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call MD_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call MD_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call MD_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call MD_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call MD_UnpackMisc(Buf, OutData%m) ! m 
   ! Output
   if (allocated(OutData%Output)) deallocate(OutData%Output)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Output(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Output.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackOutput(Buf, OutData%Output(i1)) ! Output 
      end do
   end if
   ! y_interp
   call MD_UnpackOutput(Buf, OutData%y_interp) ! y_interp 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyOrcaFlex_Data( SrcOrcaFlex_DataData, DstOrcaFlex_DataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(OrcaFlex_Data), INTENT(INOUT) :: SrcOrcaFlex_DataData
   TYPE(OrcaFlex_Data), INTENT(INOUT) :: DstOrcaFlex_DataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyOrcaFlex_Data'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DO i1 = LBOUND(SrcOrcaFlex_DataData%x,1), UBOUND(SrcOrcaFlex_DataData%x,1)
      CALL Orca_CopyContState( SrcOrcaFlex_DataData%x(i1), DstOrcaFlex_DataData%x(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcOrcaFlex_DataData%xd,1), UBOUND(SrcOrcaFlex_DataData%xd,1)
      CALL Orca_CopyDiscState( SrcOrcaFlex_DataData%xd(i1), DstOrcaFlex_DataData%xd(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcOrcaFlex_DataData%z,1), UBOUND(SrcOrcaFlex_DataData%z,1)
      CALL Orca_CopyConstrState( SrcOrcaFlex_DataData%z(i1), DstOrcaFlex_DataData%z(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    DO i1 = LBOUND(SrcOrcaFlex_DataData%OtherSt,1), UBOUND(SrcOrcaFlex_DataData%OtherSt,1)
      CALL Orca_CopyOtherState( SrcOrcaFlex_DataData%OtherSt(i1), DstOrcaFlex_DataData%OtherSt(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL Orca_CopyParam( SrcOrcaFlex_DataData%p, DstOrcaFlex_DataData%p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Orca_CopyInput( SrcOrcaFlex_DataData%u, DstOrcaFlex_DataData%u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Orca_CopyOutput( SrcOrcaFlex_DataData%y, DstOrcaFlex_DataData%y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Orca_CopyMisc( SrcOrcaFlex_DataData%m, DstOrcaFlex_DataData%m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOrcaFlex_DataData%Input)) THEN
  i1_l = LBOUND(SrcOrcaFlex_DataData%Input,1)
  i1_u = UBOUND(SrcOrcaFlex_DataData%Input,1)
  IF (.NOT. ALLOCATED(DstOrcaFlex_DataData%Input)) THEN 
    ALLOCATE(DstOrcaFlex_DataData%Input(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%Input.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOrcaFlex_DataData%Input,1), UBOUND(SrcOrcaFlex_DataData%Input,1)
      CALL Orca_CopyInput( SrcOrcaFlex_DataData%Input(i1), DstOrcaFlex_DataData%Input(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOrcaFlex_DataData%InputTimes)) THEN
  i1_l = LBOUND(SrcOrcaFlex_DataData%InputTimes,1)
  i1_u = UBOUND(SrcOrcaFlex_DataData%InputTimes,1)
  IF (.NOT. ALLOCATED(DstOrcaFlex_DataData%InputTimes)) THEN 
    ALLOCATE(DstOrcaFlex_DataData%InputTimes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOrcaFlex_DataData%InputTimes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOrcaFlex_DataData%InputTimes = SrcOrcaFlex_DataData%InputTimes
ENDIF
 END SUBROUTINE FAST_CopyOrcaFlex_Data

 SUBROUTINE FAST_DestroyOrcaFlex_Data( OrcaFlex_DataData, ErrStat, ErrMsg )
  TYPE(OrcaFlex_Data), INTENT(INOUT) :: OrcaFlex_DataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyOrcaFlex_Data'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(OrcaFlex_DataData%x,1), UBOUND(OrcaFlex_DataData%x,1)
  CALL Orca_DestroyContState( OrcaFlex_DataData%x(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(OrcaFlex_DataData%xd,1), UBOUND(OrcaFlex_DataData%xd,1)
  CALL Orca_DestroyDiscState( OrcaFlex_DataData%xd(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(OrcaFlex_DataData%z,1), UBOUND(OrcaFlex_DataData%z,1)
  CALL Orca_DestroyConstrState( OrcaFlex_DataData%z(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
DO i1 = LBOUND(OrcaFlex_DataData%OtherSt,1), UBOUND(OrcaFlex_DataData%OtherSt,1)
  CALL Orca_DestroyOtherState( OrcaFlex_DataData%OtherSt(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL Orca_DestroyParam( OrcaFlex_DataData%p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Orca_DestroyInput( OrcaFlex_DataData%u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Orca_DestroyOutput( OrcaFlex_DataData%y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Orca_DestroyMisc( OrcaFlex_DataData%m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(OrcaFlex_DataData%Input)) THEN
DO i1 = LBOUND(OrcaFlex_DataData%Input,1), UBOUND(OrcaFlex_DataData%Input,1)
  CALL Orca_DestroyInput( OrcaFlex_DataData%Input(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OrcaFlex_DataData%Input)
ENDIF
IF (ALLOCATED(OrcaFlex_DataData%InputTimes)) THEN
  DEALLOCATE(OrcaFlex_DataData%InputTimes)
ENDIF
 END SUBROUTINE FAST_DestroyOrcaFlex_Data


subroutine FAST_PackOrcaFlex_Data(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OrcaFlex_Data), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackOrcaFlex_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   LB(1:1) = lbound(InData%x)
   UB(1:1) = ubound(InData%x)
   do i1 = LB(1), UB(1)
      call Orca_PackContState(Buf, InData%x(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! xd
   LB(1:1) = lbound(InData%xd)
   UB(1:1) = ubound(InData%xd)
   do i1 = LB(1), UB(1)
      call Orca_PackDiscState(Buf, InData%xd(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   LB(1:1) = lbound(InData%z)
   UB(1:1) = ubound(InData%z)
   do i1 = LB(1), UB(1)
      call Orca_PackConstrState(Buf, InData%z(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! OtherSt
   LB(1:1) = lbound(InData%OtherSt)
   UB(1:1) = ubound(InData%OtherSt)
   do i1 = LB(1), UB(1)
      call Orca_PackOtherState(Buf, InData%OtherSt(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! p
   call Orca_PackParam(Buf, InData%p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u
   call Orca_PackInput(Buf, InData%u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call Orca_PackOutput(Buf, InData%y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m
   call Orca_PackMisc(Buf, InData%m) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Input
   call RegPack(Buf, allocated(InData%Input))
   if (allocated(InData%Input)) then
      call RegPackBounds(Buf, 1, lbound(InData%Input), ubound(InData%Input))
      LB(1:1) = lbound(InData%Input)
      UB(1:1) = ubound(InData%Input)
      do i1 = LB(1), UB(1)
         call Orca_PackInput(Buf, InData%Input(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputTimes
   call RegPack(Buf, allocated(InData%InputTimes))
   if (allocated(InData%InputTimes)) then
      call RegPackBounds(Buf, 1, lbound(InData%InputTimes), ubound(InData%InputTimes))
      call RegPack(Buf, InData%InputTimes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackOrcaFlex_Data(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OrcaFlex_Data), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackOrcaFlex_Data'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   LB(1:1) = lbound(OutData%x)
   UB(1:1) = ubound(OutData%x)
   do i1 = LB(1), UB(1)
      call Orca_UnpackContState(Buf, OutData%x(i1)) ! x 
   end do
   ! xd
   LB(1:1) = lbound(OutData%xd)
   UB(1:1) = ubound(OutData%xd)
   do i1 = LB(1), UB(1)
      call Orca_UnpackDiscState(Buf, OutData%xd(i1)) ! xd 
   end do
   ! z
   LB(1:1) = lbound(OutData%z)
   UB(1:1) = ubound(OutData%z)
   do i1 = LB(1), UB(1)
      call Orca_UnpackConstrState(Buf, OutData%z(i1)) ! z 
   end do
   ! OtherSt
   LB(1:1) = lbound(OutData%OtherSt)
   UB(1:1) = ubound(OutData%OtherSt)
   do i1 = LB(1), UB(1)
      call Orca_UnpackOtherState(Buf, OutData%OtherSt(i1)) ! OtherSt 
   end do
   ! p
   call Orca_UnpackParam(Buf, OutData%p) ! p 
   ! u
   call Orca_UnpackInput(Buf, OutData%u) ! u 
   ! y
   call Orca_UnpackOutput(Buf, OutData%y) ! y 
   ! m
   call Orca_UnpackMisc(Buf, OutData%m) ! m 
   ! Input
   if (allocated(OutData%Input)) deallocate(OutData%Input)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Input(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Input.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call Orca_UnpackInput(Buf, OutData%Input(i1)) ! Input 
      end do
   end if
   ! InputTimes
   if (allocated(OutData%InputTimes)) deallocate(OutData%InputTimes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InputTimes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InputTimes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InputTimes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FAST_CopyModuleMapType( SrcModuleMapTypeData, DstModuleMapTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_ModuleMapType), INTENT(INOUT) :: SrcModuleMapTypeData
   TYPE(FAST_ModuleMapType), INTENT(INOUT) :: DstModuleMapTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyModuleMapType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcModuleMapTypeData%ED_P_2_BD_P)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%ED_P_2_BD_P,1)
  i1_u = UBOUND(SrcModuleMapTypeData%ED_P_2_BD_P,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%ED_P_2_BD_P)) THEN 
    ALLOCATE(DstModuleMapTypeData%ED_P_2_BD_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%ED_P_2_BD_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%ED_P_2_BD_P,1), UBOUND(SrcModuleMapTypeData%ED_P_2_BD_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_BD_P(i1), DstModuleMapTypeData%ED_P_2_BD_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%BD_P_2_ED_P)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BD_P_2_ED_P,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BD_P_2_ED_P,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BD_P_2_ED_P)) THEN 
    ALLOCATE(DstModuleMapTypeData%BD_P_2_ED_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BD_P_2_ED_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%BD_P_2_ED_P,1), UBOUND(SrcModuleMapTypeData%BD_P_2_ED_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BD_P_2_ED_P(i1), DstModuleMapTypeData%BD_P_2_ED_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%ED_P_2_BD_P_Hub)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%ED_P_2_BD_P_Hub,1)
  i1_u = UBOUND(SrcModuleMapTypeData%ED_P_2_BD_P_Hub,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%ED_P_2_BD_P_Hub)) THEN 
    ALLOCATE(DstModuleMapTypeData%ED_P_2_BD_P_Hub(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%ED_P_2_BD_P_Hub.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%ED_P_2_BD_P_Hub,1), UBOUND(SrcModuleMapTypeData%ED_P_2_BD_P_Hub,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_BD_P_Hub(i1), DstModuleMapTypeData%ED_P_2_BD_P_Hub(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_HD_PRP_P, DstModuleMapTypeData%ED_P_2_HD_PRP_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SubStructure_2_HD_W_P, DstModuleMapTypeData%SubStructure_2_HD_W_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%HD_W_P_2_SubStructure, DstModuleMapTypeData%HD_W_P_2_SubStructure, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SubStructure_2_HD_M_P, DstModuleMapTypeData%SubStructure_2_HD_M_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%HD_M_P_2_SubStructure, DstModuleMapTypeData%HD_M_P_2_SubStructure, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%Structure_2_Mooring, DstModuleMapTypeData%Structure_2_Mooring, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%Mooring_2_Structure, DstModuleMapTypeData%Mooring_2_Structure, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_SD_TP, DstModuleMapTypeData%ED_P_2_SD_TP, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SD_TP_2_ED_P, DstModuleMapTypeData%SD_TP_2_ED_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcModuleMapTypeData%ED_P_2_NStC_P_N)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%ED_P_2_NStC_P_N,1)
  i1_u = UBOUND(SrcModuleMapTypeData%ED_P_2_NStC_P_N,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%ED_P_2_NStC_P_N)) THEN 
    ALLOCATE(DstModuleMapTypeData%ED_P_2_NStC_P_N(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%ED_P_2_NStC_P_N.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%ED_P_2_NStC_P_N,1), UBOUND(SrcModuleMapTypeData%ED_P_2_NStC_P_N,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_NStC_P_N(i1), DstModuleMapTypeData%ED_P_2_NStC_P_N(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%NStC_P_2_ED_P_N)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%NStC_P_2_ED_P_N,1)
  i1_u = UBOUND(SrcModuleMapTypeData%NStC_P_2_ED_P_N,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%NStC_P_2_ED_P_N)) THEN 
    ALLOCATE(DstModuleMapTypeData%NStC_P_2_ED_P_N(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%NStC_P_2_ED_P_N.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%NStC_P_2_ED_P_N,1), UBOUND(SrcModuleMapTypeData%NStC_P_2_ED_P_N,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%NStC_P_2_ED_P_N(i1), DstModuleMapTypeData%NStC_P_2_ED_P_N(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%ED_L_2_TStC_P_T)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%ED_L_2_TStC_P_T,1)
  i1_u = UBOUND(SrcModuleMapTypeData%ED_L_2_TStC_P_T,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%ED_L_2_TStC_P_T)) THEN 
    ALLOCATE(DstModuleMapTypeData%ED_L_2_TStC_P_T(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%ED_L_2_TStC_P_T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%ED_L_2_TStC_P_T,1), UBOUND(SrcModuleMapTypeData%ED_L_2_TStC_P_T,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_L_2_TStC_P_T(i1), DstModuleMapTypeData%ED_L_2_TStC_P_T(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%TStC_P_2_ED_P_T)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%TStC_P_2_ED_P_T,1)
  i1_u = UBOUND(SrcModuleMapTypeData%TStC_P_2_ED_P_T,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%TStC_P_2_ED_P_T)) THEN 
    ALLOCATE(DstModuleMapTypeData%TStC_P_2_ED_P_T(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%TStC_P_2_ED_P_T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%TStC_P_2_ED_P_T,1), UBOUND(SrcModuleMapTypeData%TStC_P_2_ED_P_T,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%TStC_P_2_ED_P_T(i1), DstModuleMapTypeData%TStC_P_2_ED_P_T(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%ED_L_2_BStC_P_B)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,1)
  i1_u = UBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,1)
  i2_l = LBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,2)
  i2_u = UBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%ED_L_2_BStC_P_B)) THEN 
    ALLOCATE(DstModuleMapTypeData%ED_L_2_BStC_P_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%ED_L_2_BStC_P_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,2), UBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,2)
    DO i1 = LBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,1), UBOUND(SrcModuleMapTypeData%ED_L_2_BStC_P_B,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_L_2_BStC_P_B(i1,i2), DstModuleMapTypeData%ED_L_2_BStC_P_B(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%BStC_P_2_ED_P_B)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,1)
  i2_l = LBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,2)
  i2_u = UBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BStC_P_2_ED_P_B)) THEN 
    ALLOCATE(DstModuleMapTypeData%BStC_P_2_ED_P_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BStC_P_2_ED_P_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,2), UBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,2)
    DO i1 = LBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,1), UBOUND(SrcModuleMapTypeData%BStC_P_2_ED_P_B,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BStC_P_2_ED_P_B(i1,i2), DstModuleMapTypeData%BStC_P_2_ED_P_B(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%BD_L_2_BStC_P_B)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,1)
  i2_l = LBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,2)
  i2_u = UBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BD_L_2_BStC_P_B)) THEN 
    ALLOCATE(DstModuleMapTypeData%BD_L_2_BStC_P_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BD_L_2_BStC_P_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,2), UBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,2)
    DO i1 = LBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,1), UBOUND(SrcModuleMapTypeData%BD_L_2_BStC_P_B,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BD_L_2_BStC_P_B(i1,i2), DstModuleMapTypeData%BD_L_2_BStC_P_B(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%BStC_P_2_BD_P_B)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,1)
  i2_l = LBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,2)
  i2_u = UBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BStC_P_2_BD_P_B)) THEN 
    ALLOCATE(DstModuleMapTypeData%BStC_P_2_BD_P_B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BStC_P_2_BD_P_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,2), UBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,2)
    DO i1 = LBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,1), UBOUND(SrcModuleMapTypeData%BStC_P_2_BD_P_B,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BStC_P_2_BD_P_B(i1,i2), DstModuleMapTypeData%BStC_P_2_BD_P_B(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%SStC_P_P_2_SubStructure)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%SStC_P_P_2_SubStructure,1)
  i1_u = UBOUND(SrcModuleMapTypeData%SStC_P_P_2_SubStructure,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%SStC_P_P_2_SubStructure)) THEN 
    ALLOCATE(DstModuleMapTypeData%SStC_P_P_2_SubStructure(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%SStC_P_P_2_SubStructure.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%SStC_P_P_2_SubStructure,1), UBOUND(SrcModuleMapTypeData%SStC_P_P_2_SubStructure,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SStC_P_P_2_SubStructure(i1), DstModuleMapTypeData%SStC_P_P_2_SubStructure(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%SubStructure_2_SStC_P_P)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%SubStructure_2_SStC_P_P,1)
  i1_u = UBOUND(SrcModuleMapTypeData%SubStructure_2_SStC_P_P,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%SubStructure_2_SStC_P_P)) THEN 
    ALLOCATE(DstModuleMapTypeData%SubStructure_2_SStC_P_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%SubStructure_2_SStC_P_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%SubStructure_2_SStC_P_P,1), UBOUND(SrcModuleMapTypeData%SubStructure_2_SStC_P_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SubStructure_2_SStC_P_P(i1), DstModuleMapTypeData%SubStructure_2_SStC_P_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_SrvD_P_P, DstModuleMapTypeData%ED_P_2_SrvD_P_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcModuleMapTypeData%BDED_L_2_AD_L_B)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BDED_L_2_AD_L_B,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BDED_L_2_AD_L_B,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BDED_L_2_AD_L_B)) THEN 
    ALLOCATE(DstModuleMapTypeData%BDED_L_2_AD_L_B(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BDED_L_2_AD_L_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%BDED_L_2_AD_L_B,1), UBOUND(SrcModuleMapTypeData%BDED_L_2_AD_L_B,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BDED_L_2_AD_L_B(i1), DstModuleMapTypeData%BDED_L_2_AD_L_B(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%AD_L_2_BDED_B)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%AD_L_2_BDED_B,1)
  i1_u = UBOUND(SrcModuleMapTypeData%AD_L_2_BDED_B,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%AD_L_2_BDED_B)) THEN 
    ALLOCATE(DstModuleMapTypeData%AD_L_2_BDED_B(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%AD_L_2_BDED_B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%AD_L_2_BDED_B,1), UBOUND(SrcModuleMapTypeData%AD_L_2_BDED_B,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%AD_L_2_BDED_B(i1), DstModuleMapTypeData%AD_L_2_BDED_B(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%BD_L_2_BD_L)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%BD_L_2_BD_L,1)
  i1_u = UBOUND(SrcModuleMapTypeData%BD_L_2_BD_L,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%BD_L_2_BD_L)) THEN 
    ALLOCATE(DstModuleMapTypeData%BD_L_2_BD_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%BD_L_2_BD_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%BD_L_2_BD_L,1), UBOUND(SrcModuleMapTypeData%BD_L_2_BD_L,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%BD_L_2_BD_L(i1), DstModuleMapTypeData%BD_L_2_BD_L(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_AD_P_N, DstModuleMapTypeData%ED_P_2_AD_P_N, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%AD_P_2_ED_P_N, DstModuleMapTypeData%AD_P_2_ED_P_N, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_AD_P_TF, DstModuleMapTypeData%ED_P_2_AD_P_TF, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%AD_P_2_ED_P_TF, DstModuleMapTypeData%AD_P_2_ED_P_TF, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_L_2_AD_L_T, DstModuleMapTypeData%ED_L_2_AD_L_T, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%AD_L_2_ED_P_T, DstModuleMapTypeData%AD_L_2_ED_P_T, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcModuleMapTypeData%ED_P_2_AD_P_R)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%ED_P_2_AD_P_R,1)
  i1_u = UBOUND(SrcModuleMapTypeData%ED_P_2_AD_P_R,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%ED_P_2_AD_P_R)) THEN 
    ALLOCATE(DstModuleMapTypeData%ED_P_2_AD_P_R(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%ED_P_2_AD_P_R.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%ED_P_2_AD_P_R,1), UBOUND(SrcModuleMapTypeData%ED_P_2_AD_P_R,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_AD_P_R(i1), DstModuleMapTypeData%ED_P_2_AD_P_R(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%ED_P_2_AD_P_H, DstModuleMapTypeData%ED_P_2_AD_P_H, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%AD_P_2_ED_P_H, DstModuleMapTypeData%AD_P_2_ED_P_H, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%IceF_P_2_SD_P, DstModuleMapTypeData%IceF_P_2_SD_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SDy3_P_2_IceF_P, DstModuleMapTypeData%SDy3_P_2_IceF_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcModuleMapTypeData%IceD_P_2_SD_P)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%IceD_P_2_SD_P,1)
  i1_u = UBOUND(SrcModuleMapTypeData%IceD_P_2_SD_P,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%IceD_P_2_SD_P)) THEN 
    ALLOCATE(DstModuleMapTypeData%IceD_P_2_SD_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%IceD_P_2_SD_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%IceD_P_2_SD_P,1), UBOUND(SrcModuleMapTypeData%IceD_P_2_SD_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%IceD_P_2_SD_P(i1), DstModuleMapTypeData%IceD_P_2_SD_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%SDy3_P_2_IceD_P)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%SDy3_P_2_IceD_P,1)
  i1_u = UBOUND(SrcModuleMapTypeData%SDy3_P_2_IceD_P,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%SDy3_P_2_IceD_P)) THEN 
    ALLOCATE(DstModuleMapTypeData%SDy3_P_2_IceD_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%SDy3_P_2_IceD_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%SDy3_P_2_IceD_P,1), UBOUND(SrcModuleMapTypeData%SDy3_P_2_IceD_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcModuleMapTypeData%SDy3_P_2_IceD_P(i1), DstModuleMapTypeData%SDy3_P_2_IceD_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%Jacobian_Opt1)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%Jacobian_Opt1,1)
  i1_u = UBOUND(SrcModuleMapTypeData%Jacobian_Opt1,1)
  i2_l = LBOUND(SrcModuleMapTypeData%Jacobian_Opt1,2)
  i2_u = UBOUND(SrcModuleMapTypeData%Jacobian_Opt1,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%Jacobian_Opt1)) THEN 
    ALLOCATE(DstModuleMapTypeData%Jacobian_Opt1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%Jacobian_Opt1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstModuleMapTypeData%Jacobian_Opt1 = SrcModuleMapTypeData%Jacobian_Opt1
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%Jacobian_pivot)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%Jacobian_pivot,1)
  i1_u = UBOUND(SrcModuleMapTypeData%Jacobian_pivot,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%Jacobian_pivot)) THEN 
    ALLOCATE(DstModuleMapTypeData%Jacobian_pivot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%Jacobian_pivot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstModuleMapTypeData%Jacobian_pivot = SrcModuleMapTypeData%Jacobian_pivot
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%Jac_u_indx,1)
  i1_u = UBOUND(SrcModuleMapTypeData%Jac_u_indx,1)
  i2_l = LBOUND(SrcModuleMapTypeData%Jac_u_indx,2)
  i2_u = UBOUND(SrcModuleMapTypeData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%Jac_u_indx)) THEN 
    ALLOCATE(DstModuleMapTypeData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstModuleMapTypeData%Jac_u_indx = SrcModuleMapTypeData%Jac_u_indx
ENDIF
      CALL MeshCopy( SrcModuleMapTypeData%u_ED_NacelleLoads, DstModuleMapTypeData%u_ED_NacelleLoads, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%SubstructureLoads_Tmp, DstModuleMapTypeData%SubstructureLoads_Tmp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%SubstructureLoads_Tmp2, DstModuleMapTypeData%SubstructureLoads_Tmp2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%PlatformLoads_Tmp, DstModuleMapTypeData%PlatformLoads_Tmp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%PlatformLoads_Tmp2, DstModuleMapTypeData%PlatformLoads_Tmp2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%SubstructureLoads_Tmp_Farm, DstModuleMapTypeData%SubstructureLoads_Tmp_Farm, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%u_ED_TowerPtloads, DstModuleMapTypeData%u_ED_TowerPtloads, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcModuleMapTypeData%u_ED_BladePtLoads)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_ED_BladePtLoads,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_ED_BladePtLoads,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_ED_BladePtLoads)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_ED_BladePtLoads(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_ED_BladePtLoads.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%u_ED_BladePtLoads,1), UBOUND(SrcModuleMapTypeData%u_ED_BladePtLoads,1)
      CALL MeshCopy( SrcModuleMapTypeData%u_ED_BladePtLoads(i1), DstModuleMapTypeData%u_ED_BladePtLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcModuleMapTypeData%u_SD_TPMesh, DstModuleMapTypeData%u_SD_TPMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%u_HD_M_Mesh, DstModuleMapTypeData%u_HD_M_Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%u_HD_W_Mesh, DstModuleMapTypeData%u_HD_W_Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%u_ED_HubPtLoad, DstModuleMapTypeData%u_ED_HubPtLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%u_ED_HubPtLoad_2, DstModuleMapTypeData%u_ED_HubPtLoad_2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcModuleMapTypeData%u_BD_RootMotion)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_BD_RootMotion,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_BD_RootMotion,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_BD_RootMotion)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_BD_RootMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_BD_RootMotion.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%u_BD_RootMotion,1), UBOUND(SrcModuleMapTypeData%u_BD_RootMotion,1)
      CALL MeshCopy( SrcModuleMapTypeData%u_BD_RootMotion(i1), DstModuleMapTypeData%u_BD_RootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%y_BD_BldMotion_4Loads)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%y_BD_BldMotion_4Loads,1)
  i1_u = UBOUND(SrcModuleMapTypeData%y_BD_BldMotion_4Loads,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%y_BD_BldMotion_4Loads)) THEN 
    ALLOCATE(DstModuleMapTypeData%y_BD_BldMotion_4Loads(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%y_BD_BldMotion_4Loads.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%y_BD_BldMotion_4Loads,1), UBOUND(SrcModuleMapTypeData%y_BD_BldMotion_4Loads,1)
      CALL MeshCopy( SrcModuleMapTypeData%y_BD_BldMotion_4Loads(i1), DstModuleMapTypeData%y_BD_BldMotion_4Loads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcModuleMapTypeData%u_BD_Distrload)) THEN
  i1_l = LBOUND(SrcModuleMapTypeData%u_BD_Distrload,1)
  i1_u = UBOUND(SrcModuleMapTypeData%u_BD_Distrload,1)
  IF (.NOT. ALLOCATED(DstModuleMapTypeData%u_BD_Distrload)) THEN 
    ALLOCATE(DstModuleMapTypeData%u_BD_Distrload(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstModuleMapTypeData%u_BD_Distrload.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcModuleMapTypeData%u_BD_Distrload,1), UBOUND(SrcModuleMapTypeData%u_BD_Distrload,1)
      CALL MeshCopy( SrcModuleMapTypeData%u_BD_Distrload(i1), DstModuleMapTypeData%u_BD_Distrload(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcModuleMapTypeData%u_Orca_PtfmMesh, DstModuleMapTypeData%u_Orca_PtfmMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcModuleMapTypeData%u_ExtPtfm_PtfmMesh, DstModuleMapTypeData%u_ExtPtfm_PtfmMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FAST_CopyModuleMapType

 SUBROUTINE FAST_DestroyModuleMapType( ModuleMapTypeData, ErrStat, ErrMsg )
  TYPE(FAST_ModuleMapType), INTENT(INOUT) :: ModuleMapTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyModuleMapType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ModuleMapTypeData%ED_P_2_BD_P)) THEN
DO i1 = LBOUND(ModuleMapTypeData%ED_P_2_BD_P,1), UBOUND(ModuleMapTypeData%ED_P_2_BD_P,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_BD_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%ED_P_2_BD_P)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%BD_P_2_ED_P)) THEN
DO i1 = LBOUND(ModuleMapTypeData%BD_P_2_ED_P,1), UBOUND(ModuleMapTypeData%BD_P_2_ED_P,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BD_P_2_ED_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%BD_P_2_ED_P)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%ED_P_2_BD_P_Hub)) THEN
DO i1 = LBOUND(ModuleMapTypeData%ED_P_2_BD_P_Hub,1), UBOUND(ModuleMapTypeData%ED_P_2_BD_P_Hub,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_BD_P_Hub(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%ED_P_2_BD_P_Hub)
ENDIF
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_HD_PRP_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SubStructure_2_HD_W_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%HD_W_P_2_SubStructure, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SubStructure_2_HD_M_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%HD_M_P_2_SubStructure, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%Structure_2_Mooring, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%Mooring_2_Structure, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_SD_TP, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SD_TP_2_ED_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ModuleMapTypeData%ED_P_2_NStC_P_N)) THEN
DO i1 = LBOUND(ModuleMapTypeData%ED_P_2_NStC_P_N,1), UBOUND(ModuleMapTypeData%ED_P_2_NStC_P_N,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_NStC_P_N(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%ED_P_2_NStC_P_N)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%NStC_P_2_ED_P_N)) THEN
DO i1 = LBOUND(ModuleMapTypeData%NStC_P_2_ED_P_N,1), UBOUND(ModuleMapTypeData%NStC_P_2_ED_P_N,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%NStC_P_2_ED_P_N(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%NStC_P_2_ED_P_N)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%ED_L_2_TStC_P_T)) THEN
DO i1 = LBOUND(ModuleMapTypeData%ED_L_2_TStC_P_T,1), UBOUND(ModuleMapTypeData%ED_L_2_TStC_P_T,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_L_2_TStC_P_T(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%ED_L_2_TStC_P_T)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%TStC_P_2_ED_P_T)) THEN
DO i1 = LBOUND(ModuleMapTypeData%TStC_P_2_ED_P_T,1), UBOUND(ModuleMapTypeData%TStC_P_2_ED_P_T,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%TStC_P_2_ED_P_T(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%TStC_P_2_ED_P_T)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%ED_L_2_BStC_P_B)) THEN
DO i2 = LBOUND(ModuleMapTypeData%ED_L_2_BStC_P_B,2), UBOUND(ModuleMapTypeData%ED_L_2_BStC_P_B,2)
DO i1 = LBOUND(ModuleMapTypeData%ED_L_2_BStC_P_B,1), UBOUND(ModuleMapTypeData%ED_L_2_BStC_P_B,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_L_2_BStC_P_B(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(ModuleMapTypeData%ED_L_2_BStC_P_B)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%BStC_P_2_ED_P_B)) THEN
DO i2 = LBOUND(ModuleMapTypeData%BStC_P_2_ED_P_B,2), UBOUND(ModuleMapTypeData%BStC_P_2_ED_P_B,2)
DO i1 = LBOUND(ModuleMapTypeData%BStC_P_2_ED_P_B,1), UBOUND(ModuleMapTypeData%BStC_P_2_ED_P_B,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BStC_P_2_ED_P_B(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(ModuleMapTypeData%BStC_P_2_ED_P_B)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%BD_L_2_BStC_P_B)) THEN
DO i2 = LBOUND(ModuleMapTypeData%BD_L_2_BStC_P_B,2), UBOUND(ModuleMapTypeData%BD_L_2_BStC_P_B,2)
DO i1 = LBOUND(ModuleMapTypeData%BD_L_2_BStC_P_B,1), UBOUND(ModuleMapTypeData%BD_L_2_BStC_P_B,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BD_L_2_BStC_P_B(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(ModuleMapTypeData%BD_L_2_BStC_P_B)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%BStC_P_2_BD_P_B)) THEN
DO i2 = LBOUND(ModuleMapTypeData%BStC_P_2_BD_P_B,2), UBOUND(ModuleMapTypeData%BStC_P_2_BD_P_B,2)
DO i1 = LBOUND(ModuleMapTypeData%BStC_P_2_BD_P_B,1), UBOUND(ModuleMapTypeData%BStC_P_2_BD_P_B,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BStC_P_2_BD_P_B(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(ModuleMapTypeData%BStC_P_2_BD_P_B)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%SStC_P_P_2_SubStructure)) THEN
DO i1 = LBOUND(ModuleMapTypeData%SStC_P_P_2_SubStructure,1), UBOUND(ModuleMapTypeData%SStC_P_P_2_SubStructure,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SStC_P_P_2_SubStructure(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%SStC_P_P_2_SubStructure)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%SubStructure_2_SStC_P_P)) THEN
DO i1 = LBOUND(ModuleMapTypeData%SubStructure_2_SStC_P_P,1), UBOUND(ModuleMapTypeData%SubStructure_2_SStC_P_P,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SubStructure_2_SStC_P_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%SubStructure_2_SStC_P_P)
ENDIF
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_SrvD_P_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ModuleMapTypeData%BDED_L_2_AD_L_B)) THEN
DO i1 = LBOUND(ModuleMapTypeData%BDED_L_2_AD_L_B,1), UBOUND(ModuleMapTypeData%BDED_L_2_AD_L_B,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BDED_L_2_AD_L_B(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%BDED_L_2_AD_L_B)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%AD_L_2_BDED_B)) THEN
DO i1 = LBOUND(ModuleMapTypeData%AD_L_2_BDED_B,1), UBOUND(ModuleMapTypeData%AD_L_2_BDED_B,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%AD_L_2_BDED_B(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%AD_L_2_BDED_B)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%BD_L_2_BD_L)) THEN
DO i1 = LBOUND(ModuleMapTypeData%BD_L_2_BD_L,1), UBOUND(ModuleMapTypeData%BD_L_2_BD_L,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%BD_L_2_BD_L(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%BD_L_2_BD_L)
ENDIF
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_AD_P_N, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%AD_P_2_ED_P_N, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_AD_P_TF, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%AD_P_2_ED_P_TF, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_L_2_AD_L_T, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%AD_L_2_ED_P_T, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ModuleMapTypeData%ED_P_2_AD_P_R)) THEN
DO i1 = LBOUND(ModuleMapTypeData%ED_P_2_AD_P_R,1), UBOUND(ModuleMapTypeData%ED_P_2_AD_P_R,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_AD_P_R(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%ED_P_2_AD_P_R)
ENDIF
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%ED_P_2_AD_P_H, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%AD_P_2_ED_P_H, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%IceF_P_2_SD_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SDy3_P_2_IceF_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ModuleMapTypeData%IceD_P_2_SD_P)) THEN
DO i1 = LBOUND(ModuleMapTypeData%IceD_P_2_SD_P,1), UBOUND(ModuleMapTypeData%IceD_P_2_SD_P,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%IceD_P_2_SD_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%IceD_P_2_SD_P)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%SDy3_P_2_IceD_P)) THEN
DO i1 = LBOUND(ModuleMapTypeData%SDy3_P_2_IceD_P,1), UBOUND(ModuleMapTypeData%SDy3_P_2_IceD_P,1)
  CALL NWTC_Library_DestroyMeshMapType( ModuleMapTypeData%SDy3_P_2_IceD_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%SDy3_P_2_IceD_P)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%Jacobian_Opt1)) THEN
  DEALLOCATE(ModuleMapTypeData%Jacobian_Opt1)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%Jacobian_pivot)) THEN
  DEALLOCATE(ModuleMapTypeData%Jacobian_pivot)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%Jac_u_indx)) THEN
  DEALLOCATE(ModuleMapTypeData%Jac_u_indx)
ENDIF
  CALL MeshDestroy( ModuleMapTypeData%u_ED_NacelleLoads, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%SubstructureLoads_Tmp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%SubstructureLoads_Tmp2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%PlatformLoads_Tmp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%PlatformLoads_Tmp2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%SubstructureLoads_Tmp_Farm, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%u_ED_TowerPtloads, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ModuleMapTypeData%u_ED_BladePtLoads)) THEN
DO i1 = LBOUND(ModuleMapTypeData%u_ED_BladePtLoads,1), UBOUND(ModuleMapTypeData%u_ED_BladePtLoads,1)
  CALL MeshDestroy( ModuleMapTypeData%u_ED_BladePtLoads(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_ED_BladePtLoads)
ENDIF
  CALL MeshDestroy( ModuleMapTypeData%u_SD_TPMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%u_HD_M_Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%u_HD_W_Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%u_ED_HubPtLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%u_ED_HubPtLoad_2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(ModuleMapTypeData%u_BD_RootMotion)) THEN
DO i1 = LBOUND(ModuleMapTypeData%u_BD_RootMotion,1), UBOUND(ModuleMapTypeData%u_BD_RootMotion,1)
  CALL MeshDestroy( ModuleMapTypeData%u_BD_RootMotion(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_BD_RootMotion)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%y_BD_BldMotion_4Loads)) THEN
DO i1 = LBOUND(ModuleMapTypeData%y_BD_BldMotion_4Loads,1), UBOUND(ModuleMapTypeData%y_BD_BldMotion_4Loads,1)
  CALL MeshDestroy( ModuleMapTypeData%y_BD_BldMotion_4Loads(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%y_BD_BldMotion_4Loads)
ENDIF
IF (ALLOCATED(ModuleMapTypeData%u_BD_Distrload)) THEN
DO i1 = LBOUND(ModuleMapTypeData%u_BD_Distrload,1), UBOUND(ModuleMapTypeData%u_BD_Distrload,1)
  CALL MeshDestroy( ModuleMapTypeData%u_BD_Distrload(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ModuleMapTypeData%u_BD_Distrload)
ENDIF
  CALL MeshDestroy( ModuleMapTypeData%u_Orca_PtfmMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( ModuleMapTypeData%u_ExtPtfm_PtfmMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyModuleMapType


subroutine FAST_PackModuleMapType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_ModuleMapType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackModuleMapType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! ED_P_2_BD_P
   call RegPack(Buf, allocated(InData%ED_P_2_BD_P))
   if (allocated(InData%ED_P_2_BD_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%ED_P_2_BD_P), ubound(InData%ED_P_2_BD_P))
      LB(1:1) = lbound(InData%ED_P_2_BD_P)
      UB(1:1) = ubound(InData%ED_P_2_BD_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_BD_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BD_P_2_ED_P
   call RegPack(Buf, allocated(InData%BD_P_2_ED_P))
   if (allocated(InData%BD_P_2_ED_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%BD_P_2_ED_P), ubound(InData%BD_P_2_ED_P))
      LB(1:1) = lbound(InData%BD_P_2_ED_P)
      UB(1:1) = ubound(InData%BD_P_2_ED_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%BD_P_2_ED_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_BD_P_Hub
   call RegPack(Buf, allocated(InData%ED_P_2_BD_P_Hub))
   if (allocated(InData%ED_P_2_BD_P_Hub)) then
      call RegPackBounds(Buf, 1, lbound(InData%ED_P_2_BD_P_Hub), ubound(InData%ED_P_2_BD_P_Hub))
      LB(1:1) = lbound(InData%ED_P_2_BD_P_Hub)
      UB(1:1) = ubound(InData%ED_P_2_BD_P_Hub)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_BD_P_Hub(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_HD_PRP_P
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_HD_PRP_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubStructure_2_HD_W_P
   call NWTC_Library_PackMeshMapType(Buf, InData%SubStructure_2_HD_W_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! HD_W_P_2_SubStructure
   call NWTC_Library_PackMeshMapType(Buf, InData%HD_W_P_2_SubStructure) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubStructure_2_HD_M_P
   call NWTC_Library_PackMeshMapType(Buf, InData%SubStructure_2_HD_M_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! HD_M_P_2_SubStructure
   call NWTC_Library_PackMeshMapType(Buf, InData%HD_M_P_2_SubStructure) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Structure_2_Mooring
   call NWTC_Library_PackMeshMapType(Buf, InData%Structure_2_Mooring) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mooring_2_Structure
   call NWTC_Library_PackMeshMapType(Buf, InData%Mooring_2_Structure) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_SD_TP
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_SD_TP) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SD_TP_2_ED_P
   call NWTC_Library_PackMeshMapType(Buf, InData%SD_TP_2_ED_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_NStC_P_N
   call RegPack(Buf, allocated(InData%ED_P_2_NStC_P_N))
   if (allocated(InData%ED_P_2_NStC_P_N)) then
      call RegPackBounds(Buf, 1, lbound(InData%ED_P_2_NStC_P_N), ubound(InData%ED_P_2_NStC_P_N))
      LB(1:1) = lbound(InData%ED_P_2_NStC_P_N)
      UB(1:1) = ubound(InData%ED_P_2_NStC_P_N)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_NStC_P_N(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStC_P_2_ED_P_N
   call RegPack(Buf, allocated(InData%NStC_P_2_ED_P_N))
   if (allocated(InData%NStC_P_2_ED_P_N)) then
      call RegPackBounds(Buf, 1, lbound(InData%NStC_P_2_ED_P_N), ubound(InData%NStC_P_2_ED_P_N))
      LB(1:1) = lbound(InData%NStC_P_2_ED_P_N)
      UB(1:1) = ubound(InData%NStC_P_2_ED_P_N)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%NStC_P_2_ED_P_N(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_L_2_TStC_P_T
   call RegPack(Buf, allocated(InData%ED_L_2_TStC_P_T))
   if (allocated(InData%ED_L_2_TStC_P_T)) then
      call RegPackBounds(Buf, 1, lbound(InData%ED_L_2_TStC_P_T), ubound(InData%ED_L_2_TStC_P_T))
      LB(1:1) = lbound(InData%ED_L_2_TStC_P_T)
      UB(1:1) = ubound(InData%ED_L_2_TStC_P_T)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%ED_L_2_TStC_P_T(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TStC_P_2_ED_P_T
   call RegPack(Buf, allocated(InData%TStC_P_2_ED_P_T))
   if (allocated(InData%TStC_P_2_ED_P_T)) then
      call RegPackBounds(Buf, 1, lbound(InData%TStC_P_2_ED_P_T), ubound(InData%TStC_P_2_ED_P_T))
      LB(1:1) = lbound(InData%TStC_P_2_ED_P_T)
      UB(1:1) = ubound(InData%TStC_P_2_ED_P_T)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%TStC_P_2_ED_P_T(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_L_2_BStC_P_B
   call RegPack(Buf, allocated(InData%ED_L_2_BStC_P_B))
   if (allocated(InData%ED_L_2_BStC_P_B)) then
      call RegPackBounds(Buf, 2, lbound(InData%ED_L_2_BStC_P_B), ubound(InData%ED_L_2_BStC_P_B))
      LB(1:2) = lbound(InData%ED_L_2_BStC_P_B)
      UB(1:2) = ubound(InData%ED_L_2_BStC_P_B)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_PackMeshMapType(Buf, InData%ED_L_2_BStC_P_B(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC_P_2_ED_P_B
   call RegPack(Buf, allocated(InData%BStC_P_2_ED_P_B))
   if (allocated(InData%BStC_P_2_ED_P_B)) then
      call RegPackBounds(Buf, 2, lbound(InData%BStC_P_2_ED_P_B), ubound(InData%BStC_P_2_ED_P_B))
      LB(1:2) = lbound(InData%BStC_P_2_ED_P_B)
      UB(1:2) = ubound(InData%BStC_P_2_ED_P_B)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_PackMeshMapType(Buf, InData%BStC_P_2_ED_P_B(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BD_L_2_BStC_P_B
   call RegPack(Buf, allocated(InData%BD_L_2_BStC_P_B))
   if (allocated(InData%BD_L_2_BStC_P_B)) then
      call RegPackBounds(Buf, 2, lbound(InData%BD_L_2_BStC_P_B), ubound(InData%BD_L_2_BStC_P_B))
      LB(1:2) = lbound(InData%BD_L_2_BStC_P_B)
      UB(1:2) = ubound(InData%BD_L_2_BStC_P_B)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_PackMeshMapType(Buf, InData%BD_L_2_BStC_P_B(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BStC_P_2_BD_P_B
   call RegPack(Buf, allocated(InData%BStC_P_2_BD_P_B))
   if (allocated(InData%BStC_P_2_BD_P_B)) then
      call RegPackBounds(Buf, 2, lbound(InData%BStC_P_2_BD_P_B), ubound(InData%BStC_P_2_BD_P_B))
      LB(1:2) = lbound(InData%BStC_P_2_BD_P_B)
      UB(1:2) = ubound(InData%BStC_P_2_BD_P_B)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_PackMeshMapType(Buf, InData%BStC_P_2_BD_P_B(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SStC_P_P_2_SubStructure
   call RegPack(Buf, allocated(InData%SStC_P_P_2_SubStructure))
   if (allocated(InData%SStC_P_P_2_SubStructure)) then
      call RegPackBounds(Buf, 1, lbound(InData%SStC_P_P_2_SubStructure), ubound(InData%SStC_P_P_2_SubStructure))
      LB(1:1) = lbound(InData%SStC_P_P_2_SubStructure)
      UB(1:1) = ubound(InData%SStC_P_P_2_SubStructure)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%SStC_P_P_2_SubStructure(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubStructure_2_SStC_P_P
   call RegPack(Buf, allocated(InData%SubStructure_2_SStC_P_P))
   if (allocated(InData%SubStructure_2_SStC_P_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%SubStructure_2_SStC_P_P), ubound(InData%SubStructure_2_SStC_P_P))
      LB(1:1) = lbound(InData%SubStructure_2_SStC_P_P)
      UB(1:1) = ubound(InData%SubStructure_2_SStC_P_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%SubStructure_2_SStC_P_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_SrvD_P_P
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_SrvD_P_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BDED_L_2_AD_L_B
   call RegPack(Buf, allocated(InData%BDED_L_2_AD_L_B))
   if (allocated(InData%BDED_L_2_AD_L_B)) then
      call RegPackBounds(Buf, 1, lbound(InData%BDED_L_2_AD_L_B), ubound(InData%BDED_L_2_AD_L_B))
      LB(1:1) = lbound(InData%BDED_L_2_AD_L_B)
      UB(1:1) = ubound(InData%BDED_L_2_AD_L_B)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%BDED_L_2_AD_L_B(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD_L_2_BDED_B
   call RegPack(Buf, allocated(InData%AD_L_2_BDED_B))
   if (allocated(InData%AD_L_2_BDED_B)) then
      call RegPackBounds(Buf, 1, lbound(InData%AD_L_2_BDED_B), ubound(InData%AD_L_2_BDED_B))
      LB(1:1) = lbound(InData%AD_L_2_BDED_B)
      UB(1:1) = ubound(InData%AD_L_2_BDED_B)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%AD_L_2_BDED_B(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BD_L_2_BD_L
   call RegPack(Buf, allocated(InData%BD_L_2_BD_L))
   if (allocated(InData%BD_L_2_BD_L)) then
      call RegPackBounds(Buf, 1, lbound(InData%BD_L_2_BD_L), ubound(InData%BD_L_2_BD_L))
      LB(1:1) = lbound(InData%BD_L_2_BD_L)
      UB(1:1) = ubound(InData%BD_L_2_BD_L)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%BD_L_2_BD_L(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_AD_P_N
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_AD_P_N) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD_P_2_ED_P_N
   call NWTC_Library_PackMeshMapType(Buf, InData%AD_P_2_ED_P_N) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_AD_P_TF
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_AD_P_TF) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD_P_2_ED_P_TF
   call NWTC_Library_PackMeshMapType(Buf, InData%AD_P_2_ED_P_TF) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_L_2_AD_L_T
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_L_2_AD_L_T) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD_L_2_ED_P_T
   call NWTC_Library_PackMeshMapType(Buf, InData%AD_L_2_ED_P_T) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_AD_P_R
   call RegPack(Buf, allocated(InData%ED_P_2_AD_P_R))
   if (allocated(InData%ED_P_2_AD_P_R)) then
      call RegPackBounds(Buf, 1, lbound(InData%ED_P_2_AD_P_R), ubound(InData%ED_P_2_AD_P_R))
      LB(1:1) = lbound(InData%ED_P_2_AD_P_R)
      UB(1:1) = ubound(InData%ED_P_2_AD_P_R)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_AD_P_R(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED_P_2_AD_P_H
   call NWTC_Library_PackMeshMapType(Buf, InData%ED_P_2_AD_P_H) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD_P_2_ED_P_H
   call NWTC_Library_PackMeshMapType(Buf, InData%AD_P_2_ED_P_H) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! IceF_P_2_SD_P
   call NWTC_Library_PackMeshMapType(Buf, InData%IceF_P_2_SD_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SDy3_P_2_IceF_P
   call NWTC_Library_PackMeshMapType(Buf, InData%SDy3_P_2_IceF_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! IceD_P_2_SD_P
   call RegPack(Buf, allocated(InData%IceD_P_2_SD_P))
   if (allocated(InData%IceD_P_2_SD_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%IceD_P_2_SD_P), ubound(InData%IceD_P_2_SD_P))
      LB(1:1) = lbound(InData%IceD_P_2_SD_P)
      UB(1:1) = ubound(InData%IceD_P_2_SD_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%IceD_P_2_SD_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SDy3_P_2_IceD_P
   call RegPack(Buf, allocated(InData%SDy3_P_2_IceD_P))
   if (allocated(InData%SDy3_P_2_IceD_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%SDy3_P_2_IceD_P), ubound(InData%SDy3_P_2_IceD_P))
      LB(1:1) = lbound(InData%SDy3_P_2_IceD_P)
      UB(1:1) = ubound(InData%SDy3_P_2_IceD_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%SDy3_P_2_IceD_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jacobian_Opt1
   call RegPack(Buf, allocated(InData%Jacobian_Opt1))
   if (allocated(InData%Jacobian_Opt1)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jacobian_Opt1), ubound(InData%Jacobian_Opt1))
      call RegPack(Buf, InData%Jacobian_Opt1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jacobian_pivot
   call RegPack(Buf, allocated(InData%Jacobian_pivot))
   if (allocated(InData%Jacobian_pivot)) then
      call RegPackBounds(Buf, 1, lbound(InData%Jacobian_pivot), ubound(InData%Jacobian_pivot))
      call RegPack(Buf, InData%Jacobian_pivot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ED_NacelleLoads
   call MeshPack(Buf, InData%u_ED_NacelleLoads) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubstructureLoads_Tmp
   call MeshPack(Buf, InData%SubstructureLoads_Tmp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubstructureLoads_Tmp2
   call MeshPack(Buf, InData%SubstructureLoads_Tmp2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PlatformLoads_Tmp
   call MeshPack(Buf, InData%PlatformLoads_Tmp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PlatformLoads_Tmp2
   call MeshPack(Buf, InData%PlatformLoads_Tmp2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubstructureLoads_Tmp_Farm
   call MeshPack(Buf, InData%SubstructureLoads_Tmp_Farm) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ED_TowerPtloads
   call MeshPack(Buf, InData%u_ED_TowerPtloads) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ED_BladePtLoads
   call RegPack(Buf, allocated(InData%u_ED_BladePtLoads))
   if (allocated(InData%u_ED_BladePtLoads)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_ED_BladePtLoads), ubound(InData%u_ED_BladePtLoads))
      LB(1:1) = lbound(InData%u_ED_BladePtLoads)
      UB(1:1) = ubound(InData%u_ED_BladePtLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%u_ED_BladePtLoads(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_SD_TPMesh
   call MeshPack(Buf, InData%u_SD_TPMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_HD_M_Mesh
   call MeshPack(Buf, InData%u_HD_M_Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_HD_W_Mesh
   call MeshPack(Buf, InData%u_HD_W_Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ED_HubPtLoad
   call MeshPack(Buf, InData%u_ED_HubPtLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ED_HubPtLoad_2
   call MeshPack(Buf, InData%u_ED_HubPtLoad_2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_BD_RootMotion
   call RegPack(Buf, allocated(InData%u_BD_RootMotion))
   if (allocated(InData%u_BD_RootMotion)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_BD_RootMotion), ubound(InData%u_BD_RootMotion))
      LB(1:1) = lbound(InData%u_BD_RootMotion)
      UB(1:1) = ubound(InData%u_BD_RootMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%u_BD_RootMotion(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_BD_BldMotion_4Loads
   call RegPack(Buf, allocated(InData%y_BD_BldMotion_4Loads))
   if (allocated(InData%y_BD_BldMotion_4Loads)) then
      call RegPackBounds(Buf, 1, lbound(InData%y_BD_BldMotion_4Loads), ubound(InData%y_BD_BldMotion_4Loads))
      LB(1:1) = lbound(InData%y_BD_BldMotion_4Loads)
      UB(1:1) = ubound(InData%y_BD_BldMotion_4Loads)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%y_BD_BldMotion_4Loads(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_BD_Distrload
   call RegPack(Buf, allocated(InData%u_BD_Distrload))
   if (allocated(InData%u_BD_Distrload)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_BD_Distrload), ubound(InData%u_BD_Distrload))
      LB(1:1) = lbound(InData%u_BD_Distrload)
      UB(1:1) = ubound(InData%u_BD_Distrload)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%u_BD_Distrload(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_Orca_PtfmMesh
   call MeshPack(Buf, InData%u_Orca_PtfmMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_ExtPtfm_PtfmMesh
   call MeshPack(Buf, InData%u_ExtPtfm_PtfmMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackModuleMapType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_ModuleMapType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackModuleMapType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! ED_P_2_BD_P
   if (allocated(OutData%ED_P_2_BD_P)) deallocate(OutData%ED_P_2_BD_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ED_P_2_BD_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ED_P_2_BD_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_BD_P(i1)) ! ED_P_2_BD_P 
      end do
   end if
   ! BD_P_2_ED_P
   if (allocated(OutData%BD_P_2_ED_P)) deallocate(OutData%BD_P_2_ED_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BD_P_2_ED_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BD_P_2_ED_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%BD_P_2_ED_P(i1)) ! BD_P_2_ED_P 
      end do
   end if
   ! ED_P_2_BD_P_Hub
   if (allocated(OutData%ED_P_2_BD_P_Hub)) deallocate(OutData%ED_P_2_BD_P_Hub)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ED_P_2_BD_P_Hub(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ED_P_2_BD_P_Hub.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_BD_P_Hub(i1)) ! ED_P_2_BD_P_Hub 
      end do
   end if
   ! ED_P_2_HD_PRP_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_HD_PRP_P) ! ED_P_2_HD_PRP_P 
   ! SubStructure_2_HD_W_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%SubStructure_2_HD_W_P) ! SubStructure_2_HD_W_P 
   ! HD_W_P_2_SubStructure
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%HD_W_P_2_SubStructure) ! HD_W_P_2_SubStructure 
   ! SubStructure_2_HD_M_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%SubStructure_2_HD_M_P) ! SubStructure_2_HD_M_P 
   ! HD_M_P_2_SubStructure
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%HD_M_P_2_SubStructure) ! HD_M_P_2_SubStructure 
   ! Structure_2_Mooring
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%Structure_2_Mooring) ! Structure_2_Mooring 
   ! Mooring_2_Structure
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%Mooring_2_Structure) ! Mooring_2_Structure 
   ! ED_P_2_SD_TP
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_SD_TP) ! ED_P_2_SD_TP 
   ! SD_TP_2_ED_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%SD_TP_2_ED_P) ! SD_TP_2_ED_P 
   ! ED_P_2_NStC_P_N
   if (allocated(OutData%ED_P_2_NStC_P_N)) deallocate(OutData%ED_P_2_NStC_P_N)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ED_P_2_NStC_P_N(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ED_P_2_NStC_P_N.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_NStC_P_N(i1)) ! ED_P_2_NStC_P_N 
      end do
   end if
   ! NStC_P_2_ED_P_N
   if (allocated(OutData%NStC_P_2_ED_P_N)) deallocate(OutData%NStC_P_2_ED_P_N)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NStC_P_2_ED_P_N(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NStC_P_2_ED_P_N.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%NStC_P_2_ED_P_N(i1)) ! NStC_P_2_ED_P_N 
      end do
   end if
   ! ED_L_2_TStC_P_T
   if (allocated(OutData%ED_L_2_TStC_P_T)) deallocate(OutData%ED_L_2_TStC_P_T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ED_L_2_TStC_P_T(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ED_L_2_TStC_P_T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_L_2_TStC_P_T(i1)) ! ED_L_2_TStC_P_T 
      end do
   end if
   ! TStC_P_2_ED_P_T
   if (allocated(OutData%TStC_P_2_ED_P_T)) deallocate(OutData%TStC_P_2_ED_P_T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TStC_P_2_ED_P_T(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TStC_P_2_ED_P_T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%TStC_P_2_ED_P_T(i1)) ! TStC_P_2_ED_P_T 
      end do
   end if
   ! ED_L_2_BStC_P_B
   if (allocated(OutData%ED_L_2_BStC_P_B)) deallocate(OutData%ED_L_2_BStC_P_B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ED_L_2_BStC_P_B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ED_L_2_BStC_P_B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_L_2_BStC_P_B(i1,i2)) ! ED_L_2_BStC_P_B 
         end do
      end do
   end if
   ! BStC_P_2_ED_P_B
   if (allocated(OutData%BStC_P_2_ED_P_B)) deallocate(OutData%BStC_P_2_ED_P_B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC_P_2_ED_P_B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC_P_2_ED_P_B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_UnpackMeshMapType(Buf, OutData%BStC_P_2_ED_P_B(i1,i2)) ! BStC_P_2_ED_P_B 
         end do
      end do
   end if
   ! BD_L_2_BStC_P_B
   if (allocated(OutData%BD_L_2_BStC_P_B)) deallocate(OutData%BD_L_2_BStC_P_B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BD_L_2_BStC_P_B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BD_L_2_BStC_P_B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_UnpackMeshMapType(Buf, OutData%BD_L_2_BStC_P_B(i1,i2)) ! BD_L_2_BStC_P_B 
         end do
      end do
   end if
   ! BStC_P_2_BD_P_B
   if (allocated(OutData%BStC_P_2_BD_P_B)) deallocate(OutData%BStC_P_2_BD_P_B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BStC_P_2_BD_P_B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BStC_P_2_BD_P_B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call NWTC_Library_UnpackMeshMapType(Buf, OutData%BStC_P_2_BD_P_B(i1,i2)) ! BStC_P_2_BD_P_B 
         end do
      end do
   end if
   ! SStC_P_P_2_SubStructure
   if (allocated(OutData%SStC_P_P_2_SubStructure)) deallocate(OutData%SStC_P_P_2_SubStructure)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SStC_P_P_2_SubStructure(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SStC_P_P_2_SubStructure.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%SStC_P_P_2_SubStructure(i1)) ! SStC_P_P_2_SubStructure 
      end do
   end if
   ! SubStructure_2_SStC_P_P
   if (allocated(OutData%SubStructure_2_SStC_P_P)) deallocate(OutData%SubStructure_2_SStC_P_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SubStructure_2_SStC_P_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SubStructure_2_SStC_P_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%SubStructure_2_SStC_P_P(i1)) ! SubStructure_2_SStC_P_P 
      end do
   end if
   ! ED_P_2_SrvD_P_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_SrvD_P_P) ! ED_P_2_SrvD_P_P 
   ! BDED_L_2_AD_L_B
   if (allocated(OutData%BDED_L_2_AD_L_B)) deallocate(OutData%BDED_L_2_AD_L_B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BDED_L_2_AD_L_B(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BDED_L_2_AD_L_B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%BDED_L_2_AD_L_B(i1)) ! BDED_L_2_AD_L_B 
      end do
   end if
   ! AD_L_2_BDED_B
   if (allocated(OutData%AD_L_2_BDED_B)) deallocate(OutData%AD_L_2_BDED_B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AD_L_2_BDED_B(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AD_L_2_BDED_B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%AD_L_2_BDED_B(i1)) ! AD_L_2_BDED_B 
      end do
   end if
   ! BD_L_2_BD_L
   if (allocated(OutData%BD_L_2_BD_L)) deallocate(OutData%BD_L_2_BD_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BD_L_2_BD_L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BD_L_2_BD_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%BD_L_2_BD_L(i1)) ! BD_L_2_BD_L 
      end do
   end if
   ! ED_P_2_AD_P_N
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_AD_P_N) ! ED_P_2_AD_P_N 
   ! AD_P_2_ED_P_N
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%AD_P_2_ED_P_N) ! AD_P_2_ED_P_N 
   ! ED_P_2_AD_P_TF
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_AD_P_TF) ! ED_P_2_AD_P_TF 
   ! AD_P_2_ED_P_TF
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%AD_P_2_ED_P_TF) ! AD_P_2_ED_P_TF 
   ! ED_L_2_AD_L_T
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_L_2_AD_L_T) ! ED_L_2_AD_L_T 
   ! AD_L_2_ED_P_T
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%AD_L_2_ED_P_T) ! AD_L_2_ED_P_T 
   ! ED_P_2_AD_P_R
   if (allocated(OutData%ED_P_2_AD_P_R)) deallocate(OutData%ED_P_2_AD_P_R)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ED_P_2_AD_P_R(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ED_P_2_AD_P_R.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_AD_P_R(i1)) ! ED_P_2_AD_P_R 
      end do
   end if
   ! ED_P_2_AD_P_H
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%ED_P_2_AD_P_H) ! ED_P_2_AD_P_H 
   ! AD_P_2_ED_P_H
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%AD_P_2_ED_P_H) ! AD_P_2_ED_P_H 
   ! IceF_P_2_SD_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%IceF_P_2_SD_P) ! IceF_P_2_SD_P 
   ! SDy3_P_2_IceF_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%SDy3_P_2_IceF_P) ! SDy3_P_2_IceF_P 
   ! IceD_P_2_SD_P
   if (allocated(OutData%IceD_P_2_SD_P)) deallocate(OutData%IceD_P_2_SD_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IceD_P_2_SD_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IceD_P_2_SD_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%IceD_P_2_SD_P(i1)) ! IceD_P_2_SD_P 
      end do
   end if
   ! SDy3_P_2_IceD_P
   if (allocated(OutData%SDy3_P_2_IceD_P)) deallocate(OutData%SDy3_P_2_IceD_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SDy3_P_2_IceD_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SDy3_P_2_IceD_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%SDy3_P_2_IceD_P(i1)) ! SDy3_P_2_IceD_P 
      end do
   end if
   ! Jacobian_Opt1
   if (allocated(OutData%Jacobian_Opt1)) deallocate(OutData%Jacobian_Opt1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jacobian_Opt1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jacobian_Opt1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jacobian_Opt1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jacobian_pivot
   if (allocated(OutData%Jacobian_pivot)) deallocate(OutData%Jacobian_pivot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jacobian_pivot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jacobian_pivot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jacobian_pivot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_u_indx
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! u_ED_NacelleLoads
   call MeshUnpack(Buf, OutData%u_ED_NacelleLoads) ! u_ED_NacelleLoads 
   ! SubstructureLoads_Tmp
   call MeshUnpack(Buf, OutData%SubstructureLoads_Tmp) ! SubstructureLoads_Tmp 
   ! SubstructureLoads_Tmp2
   call MeshUnpack(Buf, OutData%SubstructureLoads_Tmp2) ! SubstructureLoads_Tmp2 
   ! PlatformLoads_Tmp
   call MeshUnpack(Buf, OutData%PlatformLoads_Tmp) ! PlatformLoads_Tmp 
   ! PlatformLoads_Tmp2
   call MeshUnpack(Buf, OutData%PlatformLoads_Tmp2) ! PlatformLoads_Tmp2 
   ! SubstructureLoads_Tmp_Farm
   call MeshUnpack(Buf, OutData%SubstructureLoads_Tmp_Farm) ! SubstructureLoads_Tmp_Farm 
   ! u_ED_TowerPtloads
   call MeshUnpack(Buf, OutData%u_ED_TowerPtloads) ! u_ED_TowerPtloads 
   ! u_ED_BladePtLoads
   if (allocated(OutData%u_ED_BladePtLoads)) deallocate(OutData%u_ED_BladePtLoads)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_ED_BladePtLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_ED_BladePtLoads.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%u_ED_BladePtLoads(i1)) ! u_ED_BladePtLoads 
      end do
   end if
   ! u_SD_TPMesh
   call MeshUnpack(Buf, OutData%u_SD_TPMesh) ! u_SD_TPMesh 
   ! u_HD_M_Mesh
   call MeshUnpack(Buf, OutData%u_HD_M_Mesh) ! u_HD_M_Mesh 
   ! u_HD_W_Mesh
   call MeshUnpack(Buf, OutData%u_HD_W_Mesh) ! u_HD_W_Mesh 
   ! u_ED_HubPtLoad
   call MeshUnpack(Buf, OutData%u_ED_HubPtLoad) ! u_ED_HubPtLoad 
   ! u_ED_HubPtLoad_2
   call MeshUnpack(Buf, OutData%u_ED_HubPtLoad_2) ! u_ED_HubPtLoad_2 
   ! u_BD_RootMotion
   if (allocated(OutData%u_BD_RootMotion)) deallocate(OutData%u_BD_RootMotion)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_BD_RootMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_BD_RootMotion.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%u_BD_RootMotion(i1)) ! u_BD_RootMotion 
      end do
   end if
   ! y_BD_BldMotion_4Loads
   if (allocated(OutData%y_BD_BldMotion_4Loads)) deallocate(OutData%y_BD_BldMotion_4Loads)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y_BD_BldMotion_4Loads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y_BD_BldMotion_4Loads.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%y_BD_BldMotion_4Loads(i1)) ! y_BD_BldMotion_4Loads 
      end do
   end if
   ! u_BD_Distrload
   if (allocated(OutData%u_BD_Distrload)) deallocate(OutData%u_BD_Distrload)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_BD_Distrload(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_BD_Distrload.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%u_BD_Distrload(i1)) ! u_BD_Distrload 
      end do
   end if
   ! u_Orca_PtfmMesh
   call MeshUnpack(Buf, OutData%u_Orca_PtfmMesh) ! u_Orca_PtfmMesh 
   ! u_ExtPtfm_PtfmMesh
   call MeshUnpack(Buf, OutData%u_ExtPtfm_PtfmMesh) ! u_ExtPtfm_PtfmMesh 
end subroutine
 SUBROUTINE FAST_CopyExternInputType( SrcExternInputTypeData, DstExternInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_ExternInputType), INTENT(IN) :: SrcExternInputTypeData
   TYPE(FAST_ExternInputType), INTENT(INOUT) :: DstExternInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyExternInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstExternInputTypeData%GenTrq = SrcExternInputTypeData%GenTrq
    DstExternInputTypeData%ElecPwr = SrcExternInputTypeData%ElecPwr
    DstExternInputTypeData%YawPosCom = SrcExternInputTypeData%YawPosCom
    DstExternInputTypeData%YawRateCom = SrcExternInputTypeData%YawRateCom
    DstExternInputTypeData%BlPitchCom = SrcExternInputTypeData%BlPitchCom
    DstExternInputTypeData%BlAirfoilCom = SrcExternInputTypeData%BlAirfoilCom
    DstExternInputTypeData%HSSBrFrac = SrcExternInputTypeData%HSSBrFrac
    DstExternInputTypeData%LidarFocus = SrcExternInputTypeData%LidarFocus
    DstExternInputTypeData%CableDeltaL = SrcExternInputTypeData%CableDeltaL
    DstExternInputTypeData%CableDeltaLdot = SrcExternInputTypeData%CableDeltaLdot
 END SUBROUTINE FAST_CopyExternInputType

 SUBROUTINE FAST_DestroyExternInputType( ExternInputTypeData, ErrStat, ErrMsg )
  TYPE(FAST_ExternInputType), INTENT(INOUT) :: ExternInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyExternInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE FAST_DestroyExternInputType


subroutine FAST_PackExternInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_ExternInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExternInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! GenTrq
   call RegPack(Buf, InData%GenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElecPwr
   call RegPack(Buf, InData%ElecPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawPosCom
   call RegPack(Buf, InData%YawPosCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRateCom
   call RegPack(Buf, InData%YawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchCom
   call RegPack(Buf, InData%BlPitchCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAirfoilCom
   call RegPack(Buf, InData%BlAirfoilCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrFrac
   call RegPack(Buf, InData%HSSBrFrac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidarFocus
   call RegPack(Buf, InData%LidarFocus)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaL
   call RegPack(Buf, InData%CableDeltaL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaLdot
   call RegPack(Buf, InData%CableDeltaLdot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackExternInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_ExternInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExternInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! GenTrq
   call RegUnpack(Buf, OutData%GenTrq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElecPwr
   call RegUnpack(Buf, OutData%ElecPwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawPosCom
   call RegUnpack(Buf, OutData%YawPosCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawRateCom
   call RegUnpack(Buf, OutData%YawRateCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlPitchCom
   call RegUnpack(Buf, OutData%BlPitchCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAirfoilCom
   call RegUnpack(Buf, OutData%BlAirfoilCom)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HSSBrFrac
   call RegUnpack(Buf, OutData%HSSBrFrac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidarFocus
   call RegUnpack(Buf, OutData%LidarFocus)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaL
   call RegUnpack(Buf, OutData%CableDeltaL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaLdot
   call RegUnpack(Buf, OutData%CableDeltaLdot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FAST_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(FAST_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%TiLstPrn = SrcMiscData%TiLstPrn
    DstMiscData%t_global = SrcMiscData%t_global
    DstMiscData%NextJacCalcTime = SrcMiscData%NextJacCalcTime
    DstMiscData%PrevClockTime = SrcMiscData%PrevClockTime
    DstMiscData%UsrTime1 = SrcMiscData%UsrTime1
    DstMiscData%UsrTime2 = SrcMiscData%UsrTime2
    DstMiscData%StrtTime = SrcMiscData%StrtTime
    DstMiscData%SimStrtTime = SrcMiscData%SimStrtTime
    DstMiscData%calcJacobian = SrcMiscData%calcJacobian
      CALL FAST_Copyexterninputtype( SrcMiscData%ExternInput, DstMiscData%ExternInput, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copymisclintype( SrcMiscData%Lin, DstMiscData%Lin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FAST_CopyMisc

 SUBROUTINE FAST_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(FAST_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL FAST_DestroyExternInputType( MiscData%ExternInput, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyMiscLinType( MiscData%Lin, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyMisc


subroutine FAST_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TiLstPrn
   call RegPack(Buf, InData%TiLstPrn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! t_global
   call RegPack(Buf, InData%t_global)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NextJacCalcTime
   call RegPack(Buf, InData%NextJacCalcTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevClockTime
   call RegPack(Buf, InData%PrevClockTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsrTime1
   call RegPack(Buf, InData%UsrTime1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsrTime2
   call RegPack(Buf, InData%UsrTime2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StrtTime
   call RegPack(Buf, InData%StrtTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SimStrtTime
   call RegPack(Buf, InData%SimStrtTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! calcJacobian
   call RegPack(Buf, InData%calcJacobian)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternInput
   call FAST_PackExternInputType(Buf, InData%ExternInput) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lin
   call FAST_PackMiscLinType(Buf, InData%Lin) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   ! TiLstPrn
   call RegUnpack(Buf, OutData%TiLstPrn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! t_global
   call RegUnpack(Buf, OutData%t_global)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NextJacCalcTime
   call RegUnpack(Buf, OutData%NextJacCalcTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrevClockTime
   call RegUnpack(Buf, OutData%PrevClockTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsrTime1
   call RegUnpack(Buf, OutData%UsrTime1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsrTime2
   call RegUnpack(Buf, OutData%UsrTime2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! StrtTime
   call RegUnpack(Buf, OutData%StrtTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SimStrtTime
   call RegUnpack(Buf, OutData%SimStrtTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! calcJacobian
   call RegUnpack(Buf, OutData%calcJacobian)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExternInput
   call FAST_UnpackExternInputType(Buf, OutData%ExternInput) ! ExternInput 
   ! Lin
   call FAST_UnpackMiscLinType(Buf, OutData%Lin) ! Lin 
end subroutine
 SUBROUTINE FAST_CopyInitData( SrcInitDataData, DstInitDataData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_InitData), INTENT(INOUT) :: SrcInitDataData
   TYPE(FAST_InitData), INTENT(INOUT) :: DstInitDataData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyInitData'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL ED_CopyInitInput( SrcInitDataData%InData_ED, DstInitDataData%InData_ED, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ED_CopyInitOutput( SrcInitDataData%OutData_ED, DstInitDataData%OutData_ED, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL BD_CopyInitInput( SrcInitDataData%InData_BD, DstInitDataData%InData_BD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitDataData%OutData_BD)) THEN
  i1_l = LBOUND(SrcInitDataData%OutData_BD,1)
  i1_u = UBOUND(SrcInitDataData%OutData_BD,1)
  IF (.NOT. ALLOCATED(DstInitDataData%OutData_BD)) THEN 
    ALLOCATE(DstInitDataData%OutData_BD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitDataData%OutData_BD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitDataData%OutData_BD,1), UBOUND(SrcInitDataData%OutData_BD,1)
      CALL BD_CopyInitOutput( SrcInitDataData%OutData_BD(i1), DstInitDataData%OutData_BD(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL SrvD_CopyInitInput( SrcInitDataData%InData_SrvD, DstInitDataData%InData_SrvD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SrvD_CopyInitOutput( SrcInitDataData%OutData_SrvD, DstInitDataData%OutData_SrvD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_CopyInitInput( SrcInitDataData%InData_AD14, DstInitDataData%InData_AD14, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD14_CopyInitOutput( SrcInitDataData%OutData_AD14, DstInitDataData%OutData_AD14, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD_CopyInitInput( SrcInitDataData%InData_AD, DstInitDataData%InData_AD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AD_CopyInitOutput( SrcInitDataData%OutData_AD, DstInitDataData%OutData_AD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyInitInput( SrcInitDataData%InData_IfW, DstInitDataData%InData_IfW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyInitOutput( SrcInitDataData%OutData_IfW, DstInitDataData%OutData_IfW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL OpFM_CopyInitInput( SrcInitDataData%InData_OpFM, DstInitDataData%InData_OpFM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL OpFM_CopyInitOutput( SrcInitDataData%OutData_OpFM, DstInitDataData%OutData_OpFM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SeaSt_CopyInitInput( SrcInitDataData%InData_SeaSt, DstInitDataData%InData_SeaSt, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SeaSt_CopyInitOutput( SrcInitDataData%OutData_SeaSt, DstInitDataData%OutData_SeaSt, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL HydroDyn_CopyInitInput( SrcInitDataData%InData_HD, DstInitDataData%InData_HD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL HydroDyn_CopyInitOutput( SrcInitDataData%OutData_HD, DstInitDataData%OutData_HD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SD_CopyInitInput( SrcInitDataData%InData_SD, DstInitDataData%InData_SD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SD_CopyInitOutput( SrcInitDataData%OutData_SD, DstInitDataData%OutData_SD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ExtPtfm_CopyInitInput( SrcInitDataData%InData_ExtPtfm, DstInitDataData%InData_ExtPtfm, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL ExtPtfm_CopyInitOutput( SrcInitDataData%OutData_ExtPtfm, DstInitDataData%OutData_ExtPtfm, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MAP_CopyInitInput( SrcInitDataData%InData_MAP, DstInitDataData%InData_MAP, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MAP_CopyInitOutput( SrcInitDataData%OutData_MAP, DstInitDataData%OutData_MAP, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FEAM_CopyInitInput( SrcInitDataData%InData_FEAM, DstInitDataData%InData_FEAM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FEAM_CopyInitOutput( SrcInitDataData%OutData_FEAM, DstInitDataData%OutData_FEAM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyInitInput( SrcInitDataData%InData_MD, DstInitDataData%InData_MD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyInitOutput( SrcInitDataData%OutData_MD, DstInitDataData%OutData_MD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Orca_CopyInitInput( SrcInitDataData%InData_Orca, DstInitDataData%InData_Orca, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Orca_CopyInitOutput( SrcInitDataData%OutData_Orca, DstInitDataData%OutData_Orca, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceFloe_CopyInitInput( SrcInitDataData%InData_IceF, DstInitDataData%InData_IceF, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceFloe_CopyInitOutput( SrcInitDataData%OutData_IceF, DstInitDataData%OutData_IceF, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceD_CopyInitInput( SrcInitDataData%InData_IceD, DstInitDataData%InData_IceD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IceD_CopyInitOutput( SrcInitDataData%OutData_IceD, DstInitDataData%OutData_IceD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FAST_CopyInitData

 SUBROUTINE FAST_DestroyInitData( InitDataData, ErrStat, ErrMsg )
  TYPE(FAST_InitData), INTENT(INOUT) :: InitDataData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyInitData'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL ED_DestroyInitInput( InitDataData%InData_ED, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ED_DestroyInitOutput( InitDataData%OutData_ED, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL BD_DestroyInitInput( InitDataData%InData_BD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitDataData%OutData_BD)) THEN
DO i1 = LBOUND(InitDataData%OutData_BD,1), UBOUND(InitDataData%OutData_BD,1)
  CALL BD_DestroyInitOutput( InitDataData%OutData_BD(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InitDataData%OutData_BD)
ENDIF
  CALL SrvD_DestroyInitInput( InitDataData%InData_SrvD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SrvD_DestroyInitOutput( InitDataData%OutData_SrvD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyInitInput( InitDataData%InData_AD14, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD14_DestroyInitOutput( InitDataData%OutData_AD14, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD_DestroyInitInput( InitDataData%InData_AD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AD_DestroyInitOutput( InitDataData%OutData_AD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyInitInput( InitDataData%InData_IfW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyInitOutput( InitDataData%OutData_IfW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL OpFM_DestroyInitInput( InitDataData%InData_OpFM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL OpFM_DestroyInitOutput( InitDataData%OutData_OpFM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_DestroyInitInput( InitDataData%InData_SeaSt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_DestroyInitOutput( InitDataData%OutData_SeaSt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL HydroDyn_DestroyInitInput( InitDataData%InData_HD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL HydroDyn_DestroyInitOutput( InitDataData%OutData_HD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SD_DestroyInitInput( InitDataData%InData_SD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SD_DestroyInitOutput( InitDataData%OutData_SD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ExtPtfm_DestroyInitInput( InitDataData%InData_ExtPtfm, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL ExtPtfm_DestroyInitOutput( InitDataData%OutData_ExtPtfm, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MAP_DestroyInitInput( InitDataData%InData_MAP, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MAP_DestroyInitOutput( InitDataData%OutData_MAP, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FEAM_DestroyInitInput( InitDataData%InData_FEAM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FEAM_DestroyInitOutput( InitDataData%OutData_FEAM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyInitInput( InitDataData%InData_MD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyInitOutput( InitDataData%OutData_MD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Orca_DestroyInitInput( InitDataData%InData_Orca, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Orca_DestroyInitOutput( InitDataData%OutData_Orca, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceFloe_DestroyInitInput( InitDataData%InData_IceF, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceFloe_DestroyInitOutput( InitDataData%OutData_IceF, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceD_DestroyInitInput( InitDataData%InData_IceD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IceD_DestroyInitOutput( InitDataData%OutData_IceD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyInitData


subroutine FAST_PackInitData(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_InitData), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackInitData'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! InData_ED
   call ED_PackInitInput(Buf, InData%InData_ED) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_ED
   call ED_PackInitOutput(Buf, InData%OutData_ED) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_BD
   call BD_PackInitInput(Buf, InData%InData_BD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_BD
   call RegPack(Buf, allocated(InData%OutData_BD))
   if (allocated(InData%OutData_BD)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutData_BD), ubound(InData%OutData_BD))
      LB(1:1) = lbound(InData%OutData_BD)
      UB(1:1) = ubound(InData%OutData_BD)
      do i1 = LB(1), UB(1)
         call BD_PackInitOutput(Buf, InData%OutData_BD(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_SrvD
   call SrvD_PackInitInput(Buf, InData%InData_SrvD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_SrvD
   call SrvD_PackInitOutput(Buf, InData%OutData_SrvD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_AD14
   call AD14_PackInitInput(Buf, InData%InData_AD14) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_AD14
   call AD14_PackInitOutput(Buf, InData%OutData_AD14) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_AD
   call AD_PackInitInput(Buf, InData%InData_AD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_AD
   call AD_PackInitOutput(Buf, InData%OutData_AD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_IfW
   call InflowWind_PackInitInput(Buf, InData%InData_IfW) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_IfW
   call InflowWind_PackInitOutput(Buf, InData%OutData_IfW) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_OpFM
   call OpFM_PackInitInput(Buf, InData%InData_OpFM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_OpFM
   call OpFM_PackInitOutput(Buf, InData%OutData_OpFM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_SeaSt
   call SeaSt_PackInitInput(Buf, InData%InData_SeaSt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_SeaSt
   call SeaSt_PackInitOutput(Buf, InData%OutData_SeaSt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_HD
   call HydroDyn_PackInitInput(Buf, InData%InData_HD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_HD
   call HydroDyn_PackInitOutput(Buf, InData%OutData_HD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_SD
   call SD_PackInitInput(Buf, InData%InData_SD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_SD
   call SD_PackInitOutput(Buf, InData%OutData_SD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_ExtPtfm
   call ExtPtfm_PackInitInput(Buf, InData%InData_ExtPtfm) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_ExtPtfm
   call ExtPtfm_PackInitOutput(Buf, InData%OutData_ExtPtfm) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_MAP
   call MAP_PackInitInput(Buf, InData%InData_MAP) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_MAP
   call MAP_PackInitOutput(Buf, InData%OutData_MAP) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_FEAM
   call FEAM_PackInitInput(Buf, InData%InData_FEAM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_FEAM
   call FEAM_PackInitOutput(Buf, InData%OutData_FEAM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_MD
   call MD_PackInitInput(Buf, InData%InData_MD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_MD
   call MD_PackInitOutput(Buf, InData%OutData_MD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_Orca
   call Orca_PackInitInput(Buf, InData%InData_Orca) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_Orca
   call Orca_PackInitOutput(Buf, InData%OutData_Orca) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_IceF
   call IceFloe_PackInitInput(Buf, InData%InData_IceF) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_IceF
   call IceFloe_PackInitOutput(Buf, InData%OutData_IceF) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InData_IceD
   call IceD_PackInitInput(Buf, InData%InData_IceD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutData_IceD
   call IceD_PackInitOutput(Buf, InData%OutData_IceD) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackInitData(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_InitData), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackInitData'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InData_ED
   call ED_UnpackInitInput(Buf, OutData%InData_ED) ! InData_ED 
   ! OutData_ED
   call ED_UnpackInitOutput(Buf, OutData%OutData_ED) ! OutData_ED 
   ! InData_BD
   call BD_UnpackInitInput(Buf, OutData%InData_BD) ! InData_BD 
   ! OutData_BD
   if (allocated(OutData%OutData_BD)) deallocate(OutData%OutData_BD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutData_BD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutData_BD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call BD_UnpackInitOutput(Buf, OutData%OutData_BD(i1)) ! OutData_BD 
      end do
   end if
   ! InData_SrvD
   call SrvD_UnpackInitInput(Buf, OutData%InData_SrvD) ! InData_SrvD 
   ! OutData_SrvD
   call SrvD_UnpackInitOutput(Buf, OutData%OutData_SrvD) ! OutData_SrvD 
   ! InData_AD14
   call AD14_UnpackInitInput(Buf, OutData%InData_AD14) ! InData_AD14 
   ! OutData_AD14
   call AD14_UnpackInitOutput(Buf, OutData%OutData_AD14) ! OutData_AD14 
   ! InData_AD
   call AD_UnpackInitInput(Buf, OutData%InData_AD) ! InData_AD 
   ! OutData_AD
   call AD_UnpackInitOutput(Buf, OutData%OutData_AD) ! OutData_AD 
   ! InData_IfW
   call InflowWind_UnpackInitInput(Buf, OutData%InData_IfW) ! InData_IfW 
   ! OutData_IfW
   call InflowWind_UnpackInitOutput(Buf, OutData%OutData_IfW) ! OutData_IfW 
   ! InData_OpFM
   call OpFM_UnpackInitInput(Buf, OutData%InData_OpFM) ! InData_OpFM 
   ! OutData_OpFM
   call OpFM_UnpackInitOutput(Buf, OutData%OutData_OpFM) ! OutData_OpFM 
   ! InData_SeaSt
   call SeaSt_UnpackInitInput(Buf, OutData%InData_SeaSt) ! InData_SeaSt 
   ! OutData_SeaSt
   call SeaSt_UnpackInitOutput(Buf, OutData%OutData_SeaSt) ! OutData_SeaSt 
   ! InData_HD
   call HydroDyn_UnpackInitInput(Buf, OutData%InData_HD) ! InData_HD 
   ! OutData_HD
   call HydroDyn_UnpackInitOutput(Buf, OutData%OutData_HD) ! OutData_HD 
   ! InData_SD
   call SD_UnpackInitInput(Buf, OutData%InData_SD) ! InData_SD 
   ! OutData_SD
   call SD_UnpackInitOutput(Buf, OutData%OutData_SD) ! OutData_SD 
   ! InData_ExtPtfm
   call ExtPtfm_UnpackInitInput(Buf, OutData%InData_ExtPtfm) ! InData_ExtPtfm 
   ! OutData_ExtPtfm
   call ExtPtfm_UnpackInitOutput(Buf, OutData%OutData_ExtPtfm) ! OutData_ExtPtfm 
   ! InData_MAP
   call MAP_UnpackInitInput(Buf, OutData%InData_MAP) ! InData_MAP 
   ! OutData_MAP
   call MAP_UnpackInitOutput(Buf, OutData%OutData_MAP) ! OutData_MAP 
   ! InData_FEAM
   call FEAM_UnpackInitInput(Buf, OutData%InData_FEAM) ! InData_FEAM 
   ! OutData_FEAM
   call FEAM_UnpackInitOutput(Buf, OutData%OutData_FEAM) ! OutData_FEAM 
   ! InData_MD
   call MD_UnpackInitInput(Buf, OutData%InData_MD) ! InData_MD 
   ! OutData_MD
   call MD_UnpackInitOutput(Buf, OutData%OutData_MD) ! OutData_MD 
   ! InData_Orca
   call Orca_UnpackInitInput(Buf, OutData%InData_Orca) ! InData_Orca 
   ! OutData_Orca
   call Orca_UnpackInitOutput(Buf, OutData%OutData_Orca) ! OutData_Orca 
   ! InData_IceF
   call IceFloe_UnpackInitInput(Buf, OutData%InData_IceF) ! InData_IceF 
   ! OutData_IceF
   call IceFloe_UnpackInitOutput(Buf, OutData%OutData_IceF) ! OutData_IceF 
   ! InData_IceD
   call IceD_UnpackInitInput(Buf, OutData%InData_IceD) ! InData_IceD 
   ! OutData_IceD
   call IceD_UnpackInitOutput(Buf, OutData%OutData_IceD) ! OutData_IceD 
end subroutine
 SUBROUTINE FAST_CopyExternInitType( SrcExternInitTypeData, DstExternInitTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_ExternInitType), INTENT(IN) :: SrcExternInitTypeData
   TYPE(FAST_ExternInitType), INTENT(INOUT) :: DstExternInitTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyExternInitType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstExternInitTypeData%Tmax = SrcExternInitTypeData%Tmax
    DstExternInitTypeData%SensorType = SrcExternInitTypeData%SensorType
    DstExternInitTypeData%LidRadialVel = SrcExternInitTypeData%LidRadialVel
    DstExternInitTypeData%TurbineID = SrcExternInitTypeData%TurbineID
    DstExternInitTypeData%TurbinePos = SrcExternInitTypeData%TurbinePos
    DstExternInitTypeData%WaveFieldMod = SrcExternInitTypeData%WaveFieldMod
    DstExternInitTypeData%NumSC2CtrlGlob = SrcExternInitTypeData%NumSC2CtrlGlob
    DstExternInitTypeData%NumSC2Ctrl = SrcExternInitTypeData%NumSC2Ctrl
    DstExternInitTypeData%NumCtrl2SC = SrcExternInitTypeData%NumCtrl2SC
IF (ALLOCATED(SrcExternInitTypeData%fromSCGlob)) THEN
  i1_l = LBOUND(SrcExternInitTypeData%fromSCGlob,1)
  i1_u = UBOUND(SrcExternInitTypeData%fromSCGlob,1)
  IF (.NOT. ALLOCATED(DstExternInitTypeData%fromSCGlob)) THEN 
    ALLOCATE(DstExternInitTypeData%fromSCGlob(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstExternInitTypeData%fromSCGlob.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstExternInitTypeData%fromSCGlob = SrcExternInitTypeData%fromSCGlob
ENDIF
IF (ALLOCATED(SrcExternInitTypeData%fromSC)) THEN
  i1_l = LBOUND(SrcExternInitTypeData%fromSC,1)
  i1_u = UBOUND(SrcExternInitTypeData%fromSC,1)
  IF (.NOT. ALLOCATED(DstExternInitTypeData%fromSC)) THEN 
    ALLOCATE(DstExternInitTypeData%fromSC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstExternInitTypeData%fromSC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstExternInitTypeData%fromSC = SrcExternInitTypeData%fromSC
ENDIF
    DstExternInitTypeData%FarmIntegration = SrcExternInitTypeData%FarmIntegration
    DstExternInitTypeData%windGrid_n = SrcExternInitTypeData%windGrid_n
    DstExternInitTypeData%windGrid_delta = SrcExternInitTypeData%windGrid_delta
    DstExternInitTypeData%windGrid_pZero = SrcExternInitTypeData%windGrid_pZero
    DstExternInitTypeData%windGrid_data => SrcExternInitTypeData%windGrid_data
    DstExternInitTypeData%RootName = SrcExternInitTypeData%RootName
    DstExternInitTypeData%NumActForcePtsBlade = SrcExternInitTypeData%NumActForcePtsBlade
    DstExternInitTypeData%NumActForcePtsTower = SrcExternInitTypeData%NumActForcePtsTower
    DstExternInitTypeData%NodeClusterType = SrcExternInitTypeData%NodeClusterType
 END SUBROUTINE FAST_CopyExternInitType

 SUBROUTINE FAST_DestroyExternInitType( ExternInitTypeData, ErrStat, ErrMsg )
  TYPE(FAST_ExternInitType), INTENT(INOUT) :: ExternInitTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyExternInitType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ExternInitTypeData%fromSCGlob)) THEN
  DEALLOCATE(ExternInitTypeData%fromSCGlob)
ENDIF
IF (ALLOCATED(ExternInitTypeData%fromSC)) THEN
  DEALLOCATE(ExternInitTypeData%fromSC)
ENDIF
NULLIFY(ExternInitTypeData%windGrid_data)
 END SUBROUTINE FAST_DestroyExternInitType


subroutine FAST_PackExternInitType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_ExternInitType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackExternInitType'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! Tmax
   call RegPack(Buf, InData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegPack(Buf, InData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidRadialVel
   call RegPack(Buf, InData%LidRadialVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineID
   call RegPack(Buf, InData%TurbineID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbinePos
   call RegPack(Buf, InData%TurbinePos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegPack(Buf, InData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2CtrlGlob
   call RegPack(Buf, InData%NumSC2CtrlGlob)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2Ctrl
   call RegPack(Buf, InData%NumSC2Ctrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCtrl2SC
   call RegPack(Buf, InData%NumCtrl2SC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSCGlob
   call RegPack(Buf, allocated(InData%fromSCGlob))
   if (allocated(InData%fromSCGlob)) then
      call RegPackBounds(Buf, 1, lbound(InData%fromSCGlob), ubound(InData%fromSCGlob))
      call RegPack(Buf, InData%fromSCGlob)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSC
   call RegPack(Buf, allocated(InData%fromSC))
   if (allocated(InData%fromSC)) then
      call RegPackBounds(Buf, 1, lbound(InData%fromSC), ubound(InData%fromSC))
      call RegPack(Buf, InData%fromSC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FarmIntegration
   call RegPack(Buf, InData%FarmIntegration)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_n
   call RegPack(Buf, InData%windGrid_n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_delta
   call RegPack(Buf, InData%windGrid_delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_pZero
   call RegPack(Buf, InData%windGrid_pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_data
   call RegPack(Buf, associated(InData%windGrid_data))
   if (associated(InData%windGrid_data)) then
      call RegPackBounds(Buf, 5, lbound(InData%windGrid_data), ubound(InData%windGrid_data))
      call RegPackPointer(Buf, c_loc(InData%windGrid_data), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%windGrid_data)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumActForcePtsBlade
   call RegPack(Buf, InData%NumActForcePtsBlade)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumActForcePtsTower
   call RegPack(Buf, InData%NumActForcePtsTower)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeClusterType
   call RegPack(Buf, InData%NodeClusterType)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackExternInitType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_ExternInitType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackExternInitType'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! Tmax
   call RegUnpack(Buf, OutData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegUnpack(Buf, OutData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidRadialVel
   call RegUnpack(Buf, OutData%LidRadialVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineID
   call RegUnpack(Buf, OutData%TurbineID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbinePos
   call RegUnpack(Buf, OutData%TurbinePos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegUnpack(Buf, OutData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2CtrlGlob
   call RegUnpack(Buf, OutData%NumSC2CtrlGlob)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumSC2Ctrl
   call RegUnpack(Buf, OutData%NumSC2Ctrl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumCtrl2SC
   call RegUnpack(Buf, OutData%NumCtrl2SC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! fromSCGlob
   if (allocated(OutData%fromSCGlob)) deallocate(OutData%fromSCGlob)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%fromSCGlob(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%fromSCGlob.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%fromSCGlob)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! fromSC
   if (allocated(OutData%fromSC)) deallocate(OutData%fromSC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%fromSC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%fromSC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%fromSC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FarmIntegration
   call RegUnpack(Buf, OutData%FarmIntegration)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_n
   call RegUnpack(Buf, OutData%windGrid_n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_delta
   call RegUnpack(Buf, OutData%windGrid_delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_pZero
   call RegUnpack(Buf, OutData%windGrid_pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! windGrid_data
   if (associated(OutData%windGrid_data)) deallocate(OutData%windGrid_data)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%windGrid_data, UB(1:5)-LB(1:5))
         OutData%windGrid_data(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%windGrid_data
      else
         allocate(OutData%windGrid_data(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%windGrid_data.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%windGrid_data)
         call RegUnpack(Buf, OutData%windGrid_data)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%windGrid_data => null()
   end if
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumActForcePtsBlade
   call RegUnpack(Buf, OutData%NumActForcePtsBlade)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumActForcePtsTower
   call RegUnpack(Buf, OutData%NumActForcePtsTower)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeClusterType
   call RegUnpack(Buf, OutData%NodeClusterType)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FAST_CopyTurbineType( SrcTurbineTypeData, DstTurbineTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FAST_TurbineType), INTENT(INOUT) :: SrcTurbineTypeData
   TYPE(FAST_TurbineType), INTENT(INOUT) :: DstTurbineTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FAST_CopyTurbineType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstTurbineTypeData%TurbID = SrcTurbineTypeData%TurbID
      CALL FAST_CopyParam( SrcTurbineTypeData%p_FAST, DstTurbineTypeData%p_FAST, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyoutputfiletype( SrcTurbineTypeData%y_FAST, DstTurbineTypeData%y_FAST, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_CopyMisc( SrcTurbineTypeData%m_FAST, DstTurbineTypeData%m_FAST, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copymodulemaptype( SrcTurbineTypeData%MeshMapData, DstTurbineTypeData%MeshMapData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyelastodyn_data( SrcTurbineTypeData%ED, DstTurbineTypeData%ED, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copybeamdyn_data( SrcTurbineTypeData%BD, DstTurbineTypeData%BD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyservodyn_data( SrcTurbineTypeData%SrvD, DstTurbineTypeData%SrvD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyaerodyn_data( SrcTurbineTypeData%AD, DstTurbineTypeData%AD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyaerodyn14_data( SrcTurbineTypeData%AD14, DstTurbineTypeData%AD14, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyinflowwind_data( SrcTurbineTypeData%IfW, DstTurbineTypeData%IfW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyopenfoam_data( SrcTurbineTypeData%OpFM, DstTurbineTypeData%OpFM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyscdataex_data( SrcTurbineTypeData%SC_DX, DstTurbineTypeData%SC_DX, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyseastate_data( SrcTurbineTypeData%SeaSt, DstTurbineTypeData%SeaSt, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyhydrodyn_data( SrcTurbineTypeData%HD, DstTurbineTypeData%HD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copysubdyn_data( SrcTurbineTypeData%SD, DstTurbineTypeData%SD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copymap_data( SrcTurbineTypeData%MAP, DstTurbineTypeData%MAP, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyfeamooring_data( SrcTurbineTypeData%FEAM, DstTurbineTypeData%FEAM, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copymoordyn_data( SrcTurbineTypeData%MD, DstTurbineTypeData%MD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyorcaflex_data( SrcTurbineTypeData%Orca, DstTurbineTypeData%Orca, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyicefloe_data( SrcTurbineTypeData%IceF, DstTurbineTypeData%IceF, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyicedyn_data( SrcTurbineTypeData%IceD, DstTurbineTypeData%IceD, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FAST_Copyextptfm_data( SrcTurbineTypeData%ExtPtfm, DstTurbineTypeData%ExtPtfm, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FAST_CopyTurbineType

 SUBROUTINE FAST_DestroyTurbineType( TurbineTypeData, ErrStat, ErrMsg )
  TYPE(FAST_TurbineType), INTENT(INOUT) :: TurbineTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FAST_DestroyTurbineType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL FAST_DestroyParam( TurbineTypeData%p_FAST, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyOutputFileType( TurbineTypeData%y_FAST, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyMisc( TurbineTypeData%m_FAST, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyModuleMapType( TurbineTypeData%MeshMapData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyElastoDyn_Data( TurbineTypeData%ED, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyBeamDyn_Data( TurbineTypeData%BD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyServoDyn_Data( TurbineTypeData%SrvD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyAeroDyn_Data( TurbineTypeData%AD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyAeroDyn14_Data( TurbineTypeData%AD14, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyInflowWind_Data( TurbineTypeData%IfW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyOpenFOAM_Data( TurbineTypeData%OpFM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroySCDataEx_Data( TurbineTypeData%SC_DX, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroySeaState_Data( TurbineTypeData%SeaSt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyHydroDyn_Data( TurbineTypeData%HD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroySubDyn_Data( TurbineTypeData%SD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyMAP_Data( TurbineTypeData%MAP, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyFEAMooring_Data( TurbineTypeData%FEAM, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyMoorDyn_Data( TurbineTypeData%MD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyOrcaFlex_Data( TurbineTypeData%Orca, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyIceFloe_Data( TurbineTypeData%IceF, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyIceDyn_Data( TurbineTypeData%IceD, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FAST_DestroyExtPtfm_Data( TurbineTypeData%ExtPtfm, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FAST_DestroyTurbineType


subroutine FAST_PackTurbineType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FAST_TurbineType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FAST_PackTurbineType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TurbID
   call RegPack(Buf, InData%TurbID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_FAST
   call FAST_PackParam(Buf, InData%p_FAST) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_FAST
   call FAST_PackOutputFileType(Buf, InData%y_FAST) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! m_FAST
   call FAST_PackMisc(Buf, InData%m_FAST) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeshMapData
   call FAST_PackModuleMapType(Buf, InData%MeshMapData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ED
   call FAST_PackElastoDyn_Data(Buf, InData%ED) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BD
   call FAST_PackBeamDyn_Data(Buf, InData%BD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SrvD
   call FAST_PackServoDyn_Data(Buf, InData%SrvD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD
   call FAST_PackAeroDyn_Data(Buf, InData%AD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AD14
   call FAST_PackAeroDyn14_Data(Buf, InData%AD14) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! IfW
   call FAST_PackInflowWind_Data(Buf, InData%IfW) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OpFM
   call FAST_PackOpenFOAM_Data(Buf, InData%OpFM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SC_DX
   call FAST_PackSCDataEx_Data(Buf, InData%SC_DX) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt
   call FAST_PackSeaState_Data(Buf, InData%SeaSt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! HD
   call FAST_PackHydroDyn_Data(Buf, InData%HD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SD
   call FAST_PackSubDyn_Data(Buf, InData%SD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! MAP
   call FAST_PackMAP_Data(Buf, InData%MAP) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! FEAM
   call FAST_PackFEAMooring_Data(Buf, InData%FEAM) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! MD
   call FAST_PackMoorDyn_Data(Buf, InData%MD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Orca
   call FAST_PackOrcaFlex_Data(Buf, InData%Orca) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! IceF
   call FAST_PackIceFloe_Data(Buf, InData%IceF) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! IceD
   call FAST_PackIceDyn_Data(Buf, InData%IceD) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExtPtfm
   call FAST_PackExtPtfm_Data(Buf, InData%ExtPtfm) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FAST_UnPackTurbineType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FAST_TurbineType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FAST_UnPackTurbineType'
   if (Buf%ErrStat /= ErrID_None) return
   ! TurbID
   call RegUnpack(Buf, OutData%TurbID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_FAST
   call FAST_UnpackParam(Buf, OutData%p_FAST) ! p_FAST 
   ! y_FAST
   call FAST_UnpackOutputFileType(Buf, OutData%y_FAST) ! y_FAST 
   ! m_FAST
   call FAST_UnpackMisc(Buf, OutData%m_FAST) ! m_FAST 
   ! MeshMapData
   call FAST_UnpackModuleMapType(Buf, OutData%MeshMapData) ! MeshMapData 
   ! ED
   call FAST_UnpackElastoDyn_Data(Buf, OutData%ED) ! ED 
   ! BD
   call FAST_UnpackBeamDyn_Data(Buf, OutData%BD) ! BD 
   ! SrvD
   call FAST_UnpackServoDyn_Data(Buf, OutData%SrvD) ! SrvD 
   ! AD
   call FAST_UnpackAeroDyn_Data(Buf, OutData%AD) ! AD 
   ! AD14
   call FAST_UnpackAeroDyn14_Data(Buf, OutData%AD14) ! AD14 
   ! IfW
   call FAST_UnpackInflowWind_Data(Buf, OutData%IfW) ! IfW 
   ! OpFM
   call FAST_UnpackOpenFOAM_Data(Buf, OutData%OpFM) ! OpFM 
   ! SC_DX
   call FAST_UnpackSCDataEx_Data(Buf, OutData%SC_DX) ! SC_DX 
   ! SeaSt
   call FAST_UnpackSeaState_Data(Buf, OutData%SeaSt) ! SeaSt 
   ! HD
   call FAST_UnpackHydroDyn_Data(Buf, OutData%HD) ! HD 
   ! SD
   call FAST_UnpackSubDyn_Data(Buf, OutData%SD) ! SD 
   ! MAP
   call FAST_UnpackMAP_Data(Buf, OutData%MAP) ! MAP 
   ! FEAM
   call FAST_UnpackFEAMooring_Data(Buf, OutData%FEAM) ! FEAM 
   ! MD
   call FAST_UnpackMoorDyn_Data(Buf, OutData%MD) ! MD 
   ! Orca
   call FAST_UnpackOrcaFlex_Data(Buf, OutData%Orca) ! Orca 
   ! IceF
   call FAST_UnpackIceFloe_Data(Buf, OutData%IceF) ! IceF 
   ! IceD
   call FAST_UnpackIceDyn_Data(Buf, OutData%IceD) ! IceD 
   ! ExtPtfm
   call FAST_UnpackExtPtfm_Data(Buf, OutData%ExtPtfm) ! ExtPtfm 
end subroutine
END MODULE FAST_Types
!ENDOFREGISTRYGENERATEDFILE
