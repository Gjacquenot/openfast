!STARTOFREGISTRYGENERATEDFILE 'NWTC_Library_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! NWTC_Library_Types
!.................................................................................................................................
! This file is part of NWTC_Library.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in NWTC_Library. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE NWTC_Library_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE SysSubs
USE ModReg
IMPLICIT NONE
! =========  ProgDesc  =======
  TYPE, PUBLIC :: ProgDesc
    CHARACTER(99)  :: Name      !< Name of the program or module [-]
    CHARACTER(99)  :: Ver      !< Version number of the program or module [-]
    CHARACTER(24)  :: Date      !< String containing date module was last updated [-]
  END TYPE ProgDesc
! =======================
! =========  FASTdataType  =======
  TYPE, PUBLIC :: FASTdataType
    CHARACTER(1024)  :: File      !< Name of the FAST-style binary file [-]
    CHARACTER(1024)  :: Descr      !< String describing file [-]
    INTEGER(IntKi)  :: NumChans      !< Number of output channels in this binary file (not including the time channel) [-]
    INTEGER(IntKi)  :: NumRecs      !< Number of records (rows) of data in the file [-]
    REAL(DbKi)  :: TimeStep      !< Time step for evenly-spaced data in the output file (when NumRecs is not allo [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanNames      !< Strings describing the names of the channels from the binary file (including the time channel) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: ChanUnits      !< Strings describing the units of the channels from the binary file (including the time channel) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Data      !< numeric data (rows and columns) from the binary file, including the time channel [-]
  END TYPE FASTdataType
! =======================
! =========  OutParmType  =======
  TYPE, PUBLIC :: OutParmType
    INTEGER(IntKi)  :: Indx      !< An index into AllOuts array where this channel is computed/stored [-]
    CHARACTER(ChanLen)  :: Name      !< Name of the output channel [-]
    CHARACTER(ChanLen)  :: Units      !< Units this channel is specified in [-]
    INTEGER(IntKi)  :: SignM      !< Multiplier for output channel; usually -1 (minus) or 0 (invalid channel) [-]
  END TYPE OutParmType
! =======================
! =========  FileInfoType  =======
  TYPE, PUBLIC :: FileInfoType
    INTEGER(IntKi)  :: NumLines 
    INTEGER(IntKi)  :: NumFiles 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileLine 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FileIndx 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: FileList 
    CHARACTER(MaxFileInfoLineLen) , DIMENSION(:), ALLOCATABLE  :: Lines 
  END TYPE FileInfoType
! =======================
! =========  Quaternion  =======
  TYPE, PUBLIC :: Quaternion
    REAL(ReKi)  :: q0 
    REAL(ReKi) , DIMENSION(1:3)  :: v 
  END TYPE Quaternion
! =======================
! =========  NWTC_RandomNumber_ParameterType  =======
  TYPE, PUBLIC :: NWTC_RandomNumber_ParameterType
    INTEGER(IntKi)  :: pRNG 
    INTEGER(IntKi) , DIMENSION(1:3)  :: RandSeed 
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RandSeedAry 
    CHARACTER(6)  :: RNG_type 
  END TYPE NWTC_RandomNumber_ParameterType
! =======================
CONTAINS
 SUBROUTINE NWTC_Library_CopyProgDesc( SrcProgDescData, DstProgDescData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ProgDesc), INTENT(IN) :: SrcProgDescData
   TYPE(ProgDesc), INTENT(INOUT) :: DstProgDescData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'NWTC_Library_CopyProgDesc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstProgDescData%Name = SrcProgDescData%Name
    DstProgDescData%Ver = SrcProgDescData%Ver
    DstProgDescData%Date = SrcProgDescData%Date
 END SUBROUTINE NWTC_Library_CopyProgDesc

 SUBROUTINE NWTC_Library_DestroyProgDesc( ProgDescData, ErrStat, ErrMsg )
  TYPE(ProgDesc), INTENT(INOUT) :: ProgDescData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'NWTC_Library_DestroyProgDesc'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE NWTC_Library_DestroyProgDesc


subroutine NWTC_Library_PackProgDesc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ProgDesc), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackProgDesc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Name
   call RegPack(Buf, InData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call RegPack(Buf, InData%Ver)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Date
   call RegPack(Buf, InData%Date)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackProgDesc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ProgDesc), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackProgDesc'
   if (Buf%ErrStat /= ErrID_None) return
   ! Name
   call RegUnpack(Buf, OutData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call RegUnpack(Buf, OutData%Ver)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Date
   call RegUnpack(Buf, OutData%Date)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE NWTC_Library_CopyFASTdataType( SrcFASTdataTypeData, DstFASTdataTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FASTdataType), INTENT(IN) :: SrcFASTdataTypeData
   TYPE(FASTdataType), INTENT(INOUT) :: DstFASTdataTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'NWTC_Library_CopyFASTdataType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFASTdataTypeData%File = SrcFASTdataTypeData%File
    DstFASTdataTypeData%Descr = SrcFASTdataTypeData%Descr
    DstFASTdataTypeData%NumChans = SrcFASTdataTypeData%NumChans
    DstFASTdataTypeData%NumRecs = SrcFASTdataTypeData%NumRecs
    DstFASTdataTypeData%TimeStep = SrcFASTdataTypeData%TimeStep
IF (ALLOCATED(SrcFASTdataTypeData%ChanNames)) THEN
  i1_l = LBOUND(SrcFASTdataTypeData%ChanNames,1)
  i1_u = UBOUND(SrcFASTdataTypeData%ChanNames,1)
  IF (.NOT. ALLOCATED(DstFASTdataTypeData%ChanNames)) THEN 
    ALLOCATE(DstFASTdataTypeData%ChanNames(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanNames.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFASTdataTypeData%ChanNames = SrcFASTdataTypeData%ChanNames
ENDIF
IF (ALLOCATED(SrcFASTdataTypeData%ChanUnits)) THEN
  i1_l = LBOUND(SrcFASTdataTypeData%ChanUnits,1)
  i1_u = UBOUND(SrcFASTdataTypeData%ChanUnits,1)
  IF (.NOT. ALLOCATED(DstFASTdataTypeData%ChanUnits)) THEN 
    ALLOCATE(DstFASTdataTypeData%ChanUnits(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%ChanUnits.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFASTdataTypeData%ChanUnits = SrcFASTdataTypeData%ChanUnits
ENDIF
IF (ALLOCATED(SrcFASTdataTypeData%Data)) THEN
  i1_l = LBOUND(SrcFASTdataTypeData%Data,1)
  i1_u = UBOUND(SrcFASTdataTypeData%Data,1)
  i2_l = LBOUND(SrcFASTdataTypeData%Data,2)
  i2_u = UBOUND(SrcFASTdataTypeData%Data,2)
  IF (.NOT. ALLOCATED(DstFASTdataTypeData%Data)) THEN 
    ALLOCATE(DstFASTdataTypeData%Data(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFASTdataTypeData%Data.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFASTdataTypeData%Data = SrcFASTdataTypeData%Data
ENDIF
 END SUBROUTINE NWTC_Library_CopyFASTdataType

 SUBROUTINE NWTC_Library_DestroyFASTdataType( FASTdataTypeData, ErrStat, ErrMsg )
  TYPE(FASTdataType), INTENT(INOUT) :: FASTdataTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'NWTC_Library_DestroyFASTdataType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(FASTdataTypeData%ChanNames)) THEN
  DEALLOCATE(FASTdataTypeData%ChanNames)
ENDIF
IF (ALLOCATED(FASTdataTypeData%ChanUnits)) THEN
  DEALLOCATE(FASTdataTypeData%ChanUnits)
ENDIF
IF (ALLOCATED(FASTdataTypeData%Data)) THEN
  DEALLOCATE(FASTdataTypeData%Data)
ENDIF
 END SUBROUTINE NWTC_Library_DestroyFASTdataType


subroutine NWTC_Library_PackFASTdataType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FASTdataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFASTdataType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! File
   call RegPack(Buf, InData%File)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Descr
   call RegPack(Buf, InData%Descr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumChans
   call RegPack(Buf, InData%NumChans)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRecs
   call RegPack(Buf, InData%NumRecs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeStep
   call RegPack(Buf, InData%TimeStep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChanNames
   call RegPack(Buf, allocated(InData%ChanNames))
   if (allocated(InData%ChanNames)) then
      call RegPackBounds(Buf, 1, lbound(InData%ChanNames), ubound(InData%ChanNames))
      call RegPack(Buf, InData%ChanNames)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChanUnits
   call RegPack(Buf, allocated(InData%ChanUnits))
   if (allocated(InData%ChanUnits)) then
      call RegPackBounds(Buf, 1, lbound(InData%ChanUnits), ubound(InData%ChanUnits))
      call RegPack(Buf, InData%ChanUnits)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Data
   call RegPack(Buf, allocated(InData%Data))
   if (allocated(InData%Data)) then
      call RegPackBounds(Buf, 2, lbound(InData%Data), ubound(InData%Data))
      call RegPack(Buf, InData%Data)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFASTdataType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FASTdataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFASTdataType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! File
   call RegUnpack(Buf, OutData%File)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Descr
   call RegUnpack(Buf, OutData%Descr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumChans
   call RegUnpack(Buf, OutData%NumChans)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRecs
   call RegUnpack(Buf, OutData%NumRecs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeStep
   call RegUnpack(Buf, OutData%TimeStep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChanNames
   if (allocated(OutData%ChanNames)) deallocate(OutData%ChanNames)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ChanNames(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ChanNames.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ChanNames)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ChanUnits
   if (allocated(OutData%ChanUnits)) deallocate(OutData%ChanUnits)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ChanUnits(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ChanUnits.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ChanUnits)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Data
   if (allocated(OutData%Data)) deallocate(OutData%Data)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Data(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Data.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Data)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE NWTC_Library_CopyOutParmType( SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(OutParmType), INTENT(IN) :: SrcOutParmTypeData
   TYPE(OutParmType), INTENT(INOUT) :: DstOutParmTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'NWTC_Library_CopyOutParmType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOutParmTypeData%Indx = SrcOutParmTypeData%Indx
    DstOutParmTypeData%Name = SrcOutParmTypeData%Name
    DstOutParmTypeData%Units = SrcOutParmTypeData%Units
    DstOutParmTypeData%SignM = SrcOutParmTypeData%SignM
 END SUBROUTINE NWTC_Library_CopyOutParmType

 SUBROUTINE NWTC_Library_DestroyOutParmType( OutParmTypeData, ErrStat, ErrMsg )
  TYPE(OutParmType), INTENT(INOUT) :: OutParmTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'NWTC_Library_DestroyOutParmType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE NWTC_Library_DestroyOutParmType


subroutine NWTC_Library_PackOutParmType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackOutParmType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Indx
   call RegPack(Buf, InData%Indx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Name
   call RegPack(Buf, InData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Units
   call RegPack(Buf, InData%Units)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SignM
   call RegPack(Buf, InData%SignM)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackOutParmType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackOutParmType'
   if (Buf%ErrStat /= ErrID_None) return
   ! Indx
   call RegUnpack(Buf, OutData%Indx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Name
   call RegUnpack(Buf, OutData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Units
   call RegUnpack(Buf, OutData%Units)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SignM
   call RegUnpack(Buf, OutData%SignM)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE NWTC_Library_CopyFileInfoType( SrcFileInfoTypeData, DstFileInfoTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FileInfoType), INTENT(IN) :: SrcFileInfoTypeData
   TYPE(FileInfoType), INTENT(INOUT) :: DstFileInfoTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'NWTC_Library_CopyFileInfoType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFileInfoTypeData%NumLines = SrcFileInfoTypeData%NumLines
    DstFileInfoTypeData%NumFiles = SrcFileInfoTypeData%NumFiles
IF (ALLOCATED(SrcFileInfoTypeData%FileLine)) THEN
  i1_l = LBOUND(SrcFileInfoTypeData%FileLine,1)
  i1_u = UBOUND(SrcFileInfoTypeData%FileLine,1)
  IF (.NOT. ALLOCATED(DstFileInfoTypeData%FileLine)) THEN 
    ALLOCATE(DstFileInfoTypeData%FileLine(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileLine.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFileInfoTypeData%FileLine = SrcFileInfoTypeData%FileLine
ENDIF
IF (ALLOCATED(SrcFileInfoTypeData%FileIndx)) THEN
  i1_l = LBOUND(SrcFileInfoTypeData%FileIndx,1)
  i1_u = UBOUND(SrcFileInfoTypeData%FileIndx,1)
  IF (.NOT. ALLOCATED(DstFileInfoTypeData%FileIndx)) THEN 
    ALLOCATE(DstFileInfoTypeData%FileIndx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileIndx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFileInfoTypeData%FileIndx = SrcFileInfoTypeData%FileIndx
ENDIF
IF (ALLOCATED(SrcFileInfoTypeData%FileList)) THEN
  i1_l = LBOUND(SrcFileInfoTypeData%FileList,1)
  i1_u = UBOUND(SrcFileInfoTypeData%FileList,1)
  IF (.NOT. ALLOCATED(DstFileInfoTypeData%FileList)) THEN 
    ALLOCATE(DstFileInfoTypeData%FileList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%FileList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFileInfoTypeData%FileList = SrcFileInfoTypeData%FileList
ENDIF
IF (ALLOCATED(SrcFileInfoTypeData%Lines)) THEN
  i1_l = LBOUND(SrcFileInfoTypeData%Lines,1)
  i1_u = UBOUND(SrcFileInfoTypeData%Lines,1)
  IF (.NOT. ALLOCATED(DstFileInfoTypeData%Lines)) THEN 
    ALLOCATE(DstFileInfoTypeData%Lines(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstFileInfoTypeData%Lines.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstFileInfoTypeData%Lines = SrcFileInfoTypeData%Lines
ENDIF
 END SUBROUTINE NWTC_Library_CopyFileInfoType

 SUBROUTINE NWTC_Library_DestroyFileInfoType( FileInfoTypeData, ErrStat, ErrMsg )
  TYPE(FileInfoType), INTENT(INOUT) :: FileInfoTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'NWTC_Library_DestroyFileInfoType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(FileInfoTypeData%FileLine)) THEN
  DEALLOCATE(FileInfoTypeData%FileLine)
ENDIF
IF (ALLOCATED(FileInfoTypeData%FileIndx)) THEN
  DEALLOCATE(FileInfoTypeData%FileIndx)
ENDIF
IF (ALLOCATED(FileInfoTypeData%FileList)) THEN
  DEALLOCATE(FileInfoTypeData%FileList)
ENDIF
IF (ALLOCATED(FileInfoTypeData%Lines)) THEN
  DEALLOCATE(FileInfoTypeData%Lines)
ENDIF
 END SUBROUTINE NWTC_Library_DestroyFileInfoType


subroutine NWTC_Library_PackFileInfoType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FileInfoType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackFileInfoType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumLines
   call RegPack(Buf, InData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumFiles
   call RegPack(Buf, InData%NumFiles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileLine
   call RegPack(Buf, allocated(InData%FileLine))
   if (allocated(InData%FileLine)) then
      call RegPackBounds(Buf, 1, lbound(InData%FileLine), ubound(InData%FileLine))
      call RegPack(Buf, InData%FileLine)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileIndx
   call RegPack(Buf, allocated(InData%FileIndx))
   if (allocated(InData%FileIndx)) then
      call RegPackBounds(Buf, 1, lbound(InData%FileIndx), ubound(InData%FileIndx))
      call RegPack(Buf, InData%FileIndx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileList
   call RegPack(Buf, allocated(InData%FileList))
   if (allocated(InData%FileList)) then
      call RegPackBounds(Buf, 1, lbound(InData%FileList), ubound(InData%FileList))
      call RegPack(Buf, InData%FileList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Lines
   call RegPack(Buf, allocated(InData%Lines))
   if (allocated(InData%Lines)) then
      call RegPackBounds(Buf, 1, lbound(InData%Lines), ubound(InData%Lines))
      call RegPack(Buf, InData%Lines)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackFileInfoType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FileInfoType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackFileInfoType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NumLines
   call RegUnpack(Buf, OutData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumFiles
   call RegUnpack(Buf, OutData%NumFiles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileLine
   if (allocated(OutData%FileLine)) deallocate(OutData%FileLine)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FileLine(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FileLine.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FileLine)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FileIndx
   if (allocated(OutData%FileIndx)) deallocate(OutData%FileIndx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FileIndx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FileIndx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FileIndx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FileList
   if (allocated(OutData%FileList)) deallocate(OutData%FileList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FileList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FileList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FileList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Lines
   if (allocated(OutData%Lines)) deallocate(OutData%Lines)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Lines(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Lines.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Lines)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE NWTC_Library_CopyQuaternion( SrcQuaternionData, DstQuaternionData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Quaternion), INTENT(IN) :: SrcQuaternionData
   TYPE(Quaternion), INTENT(INOUT) :: DstQuaternionData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'NWTC_Library_CopyQuaternion'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstQuaternionData%q0 = SrcQuaternionData%q0
    DstQuaternionData%v = SrcQuaternionData%v
 END SUBROUTINE NWTC_Library_CopyQuaternion

 SUBROUTINE NWTC_Library_DestroyQuaternion( QuaternionData, ErrStat, ErrMsg )
  TYPE(Quaternion), INTENT(INOUT) :: QuaternionData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'NWTC_Library_DestroyQuaternion'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE NWTC_Library_DestroyQuaternion


subroutine NWTC_Library_PackQuaternion(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Quaternion), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackQuaternion'
   if (Buf%ErrStat >= AbortErrLev) return
   ! q0
   call RegPack(Buf, InData%q0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! v
   call RegPack(Buf, InData%v)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackQuaternion(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Quaternion), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackQuaternion'
   if (Buf%ErrStat /= ErrID_None) return
   ! q0
   call RegUnpack(Buf, OutData%q0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! v
   call RegUnpack(Buf, OutData%v)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE NWTC_Library_CopyNWTC_RandomNumber_ParameterType( SrcNWTC_RandomNumber_ParameterTypeData, DstNWTC_RandomNumber_ParameterTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(NWTC_RandomNumber_ParameterType), INTENT(IN) :: SrcNWTC_RandomNumber_ParameterTypeData
   TYPE(NWTC_RandomNumber_ParameterType), INTENT(INOUT) :: DstNWTC_RandomNumber_ParameterTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'NWTC_Library_CopyNWTC_RandomNumber_ParameterType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstNWTC_RandomNumber_ParameterTypeData%pRNG = SrcNWTC_RandomNumber_ParameterTypeData%pRNG
    DstNWTC_RandomNumber_ParameterTypeData%RandSeed = SrcNWTC_RandomNumber_ParameterTypeData%RandSeed
IF (ALLOCATED(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) THEN
  i1_l = LBOUND(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry,1)
  i1_u = UBOUND(SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry,1)
  IF (.NOT. ALLOCATED(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry)) THEN 
    ALLOCATE(DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstNWTC_RandomNumber_ParameterTypeData%RandSeedAry = SrcNWTC_RandomNumber_ParameterTypeData%RandSeedAry
ENDIF
    DstNWTC_RandomNumber_ParameterTypeData%RNG_type = SrcNWTC_RandomNumber_ParameterTypeData%RNG_type
 END SUBROUTINE NWTC_Library_CopyNWTC_RandomNumber_ParameterType

 SUBROUTINE NWTC_Library_DestroyNWTC_RandomNumber_ParameterType( NWTC_RandomNumber_ParameterTypeData, ErrStat, ErrMsg )
  TYPE(NWTC_RandomNumber_ParameterType), INTENT(INOUT) :: NWTC_RandomNumber_ParameterTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'NWTC_Library_DestroyNWTC_RandomNumber_ParameterType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)) THEN
  DEALLOCATE(NWTC_RandomNumber_ParameterTypeData%RandSeedAry)
ENDIF
 END SUBROUTINE NWTC_Library_DestroyNWTC_RandomNumber_ParameterType


subroutine NWTC_Library_PackNWTC_RandomNumber_ParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(NWTC_RandomNumber_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'NWTC_Library_PackNWTC_RandomNumber_ParameterType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! pRNG
   call RegPack(Buf, InData%pRNG)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RandSeed
   call RegPack(Buf, InData%RandSeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RandSeedAry
   call RegPack(Buf, allocated(InData%RandSeedAry))
   if (allocated(InData%RandSeedAry)) then
      call RegPackBounds(Buf, 1, lbound(InData%RandSeedAry), ubound(InData%RandSeedAry))
      call RegPack(Buf, InData%RandSeedAry)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RNG_type
   call RegPack(Buf, InData%RNG_type)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine NWTC_Library_UnPackNWTC_RandomNumber_ParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(NWTC_RandomNumber_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'NWTC_Library_UnPackNWTC_RandomNumber_ParameterType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! pRNG
   call RegUnpack(Buf, OutData%pRNG)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RandSeed
   call RegUnpack(Buf, OutData%RandSeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RandSeedAry
   if (allocated(OutData%RandSeedAry)) deallocate(OutData%RandSeedAry)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RandSeedAry(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RandSeedAry.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RandSeedAry)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RNG_type
   call RegUnpack(Buf, OutData%RNG_type)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE NWTC_Library_Types
!ENDOFREGISTRYGENERATEDFILE
