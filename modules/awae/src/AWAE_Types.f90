!STARTOFREGISTRYGENERATEDFILE 'AWAE_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AWAE_Types
!.................................................................................................................................
! This file is part of AWAE.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AWAE. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AWAE_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE InflowWind_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: XYSlice = 1      ! Extract an XY slice of data from the 3D grid [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: YZSlice = 2      ! Extract an YZ slice of data from the 3D grid [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: XZSlice = 3      ! Extract an XZ slice of data from the 3D grid [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MeanderMod_Uniform = 1      ! Spatial filter model for wake meandering: uniform [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MeanderMod_TruncJinc = 2      ! Spatial filter model for wake meandering: truncated jinc [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MeanderMod_WndwdJinc = 3      ! Spatial filter model for wake meandering: windowed jinc [-]
! =========  AWAE_HighWindGrid  =======
  TYPE, PUBLIC :: AWAE_HighWindGrid
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: data => NULL()      !< UVW components of wind data across the high-res regularly-spaced grid [m/s]
  END TYPE AWAE_HighWindGrid
! =======================
! =========  AWAE_HighWindGridPtr  =======
  TYPE, PUBLIC :: AWAE_HighWindGridPtr
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: data => NULL()      !< Pointer to UVW components of wind data across the high-res regularly-spaced grid [m/s]
  END TYPE AWAE_HighWindGridPtr
! =======================
! =========  AWAE_InputFileType  =======
  TYPE, PUBLIC :: AWAE_InputFileType
    REAL(ReKi)  :: dr      !< Radial increment of radial finite-difference grid [>0.0] [m]
    REAL(DbKi)  :: dt_low      !< Low-resolution (FAST.Farm driver/glue code) time step [s]
    INTEGER(IntKi)  :: NumTurbines      !< Number of wind turbines in the farm [>=1] [-]
    INTEGER(IntKi)  :: NumRadii      !< Number of radii in the radial finite-difference grid  [>=2] [-]
    INTEGER(IntKi)  :: NumPlanes      !< Number of wake planes downwind of the rotor where the wake is propagated [>=2] [-]
    CHARACTER(1024)  :: WindFilePath      !< Path name to the Root folder containing the wind data files from ABLSolver precursor [-]
    LOGICAL  :: WrDisWind      !< Write disturbed wind data to <WindFilePath>/Low/Dis.t<n>.vtk etc.? [-]
    INTEGER(IntKi)  :: NOutDisWindXY      !< Number of XY planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXY.<n_out>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDisWindZ      !< Z coordinates of XY planes for output of disturbed wind data across the low-resolution domain [1 to NOutDisWindXY] [meters]
    INTEGER(IntKi)  :: NOutDisWindYZ      !< Number of YZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisYZ.<n_out>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDisWindX      !< X coordinates of YZ planes for output of disturbed wind data across the low-resolution domain [1 to NOutDisWindYZ] [meters]
    INTEGER(IntKi)  :: NOutDisWindXZ      !< Number of XZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXZ.<n_out>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDisWindY      !< Y coordinates of XZ planes for output of disturbed wind data across the low-resolution domain [1 to NOutDisWindXZ] [meters]
    REAL(DbKi)  :: WrDisDT      !< The time between vtk outputs [must be a multiple of the low resolution time step] [s]
    LOGICAL  :: ChkWndFiles      !< Check all the ambient wind files for data consistency (flag) [-]
    INTEGER(IntKi)  :: Mod_Meander      !< Spatial filter model for wake meandering {1: uniform, 2: truncated jinc, 3: windowed jinc} [DEFAULT=2] [-]
    REAL(ReKi)  :: C_Meander      !< Calibrated parameter for wake meandering [>=1.0] [DEFAULT=1.9] [-]
    INTEGER(IntKi)  :: Mod_AmbWind      !< Ambient wind model {1: high-fidelity precursor in VTK format, 2: InflowWind module} [-]
    CHARACTER(1024)  :: InflowFile      !< Name of file containing InflowWind module input parameters [-]
    REAL(DbKi)  :: dt_high      !< High-resolution (FAST) time step [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X0_high      !< X-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y0_high      !< Y-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Z0_high      !< Z-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dX_high      !< X-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dY_high      !< Y-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dZ_high      !< Z-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    INTEGER(IntKi)  :: nX_high      !< Number of high-resolution spatial nodes in X direction  [-]
    INTEGER(IntKi)  :: nY_high      !< Number of high-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_high      !< Number of high-resolution spatial nodes in Z direction [-]
    REAL(ReKi)  :: dX_low      !< The spacing of the low-resolution nodes in X direction [m]
    REAL(ReKi)  :: dY_low      !< The spacing of the low-resolution nodes in Y direction [m]
    REAL(ReKi)  :: dZ_low      !< The spacing of the low-resolution nodes in Z direction [m]
    INTEGER(IntKi)  :: nX_low      !< Number of low-resolution spatial nodes in X direction [-]
    INTEGER(IntKi)  :: nY_low      !< Number of low-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_low      !< Number of low-resolution spatial nodes in Z direction [-]
    REAL(ReKi)  :: X0_low      !< X-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Y0_low      !< Y-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Z0_low      !< Z-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WT_Position      !< X-Y-Z position of each wind turbine; index 1 = XYZ; index 2 = turbine number [meters]
    INTEGER(IntKi)  :: Mod_Projection      !< Switch to select how the wake plane velocity is projected in AWAE {1: keep all components, 2: project against plane normal} or DEFAULT [DEFAULT=1: if Mod_Wake is 1 or 3, or DEFAULT=2: if Mod_Wake is 2] [-]
  END TYPE AWAE_InputFileType
! =======================
! =========  AWAE_InitInputType  =======
  TYPE, PUBLIC :: AWAE_InitInputType
    TYPE(AWAE_InputFileType)  :: InputFileData      !< FAST.Farm input-file data for AWAE module [-]
    INTEGER(IntKi)  :: n_high_low      !< Number of high-resolution time steps per low [-]
    INTEGER(IntKi)  :: NumDT      !< Number of low-resolution (FAST.Farm driver/glue code) time steps [-]
    CHARACTER(1024)  :: OutFileRoot      !< The root name derived from the primary FAST.Farm input file [-]
  END TYPE AWAE_InitInputType
! =======================
! =========  AWAE_InitOutputType  =======
  TYPE, PUBLIC :: AWAE_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X0_high      !< X-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y0_high      !< Y-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Z0_high      !< Z-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dX_high      !< X-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dY_high      !< Y-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dZ_high      !< Z-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    INTEGER(IntKi)  :: nX_high      !< Number of high-resolution spatial nodes in X direction  [-]
    INTEGER(IntKi)  :: nY_high      !< Number of high-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_high      !< Number of high-resolution spatial nodes in Z direction [-]
    REAL(ReKi)  :: dX_low      !< The spacing of the low-resolution nodes in X direction [m]
    REAL(ReKi)  :: dY_low      !< The spacing of the low-resolution nodes in Y direction [m]
    REAL(ReKi)  :: dZ_low      !< The spacing of the low-resolution nodes in Z direction [m]
    INTEGER(IntKi)  :: nX_low      !< Number of low-resolution spatial nodes in X direction [-]
    INTEGER(IntKi)  :: nY_low      !< Number of low-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_low      !< Number of low-resolution spatial nodes in Z direction [-]
    REAL(ReKi)  :: X0_low      !< X-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Y0_low      !< Y-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Z0_low      !< Z-component of the origin of the low-resolution spatial domain [m]
    TYPE(AWAE_HighWindGridPtr) , DIMENSION(:), ALLOCATABLE  :: Vdist_High      !< Pointers to Wind velocity of disturbed wind (ambient + wakes) across each high-resolution domain around a turbine for each high-resolution step within a low-resolution step [m/s]
  END TYPE AWAE_InitOutputType
! =======================
! =========  AWAE_ContinuousStateType  =======
  TYPE, PUBLIC :: AWAE_ContinuousStateType
    TYPE(InflowWind_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: IfW      !< Dummy IfW continuous states [-]
  END TYPE AWAE_ContinuousStateType
! =======================
! =========  AWAE_DiscreteStateType  =======
  TYPE, PUBLIC :: AWAE_DiscreteStateType
    TYPE(InflowWind_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: IfW      !< Dummy IfW discrete states [-]
  END TYPE AWAE_DiscreteStateType
! =======================
! =========  AWAE_ConstraintStateType  =======
  TYPE, PUBLIC :: AWAE_ConstraintStateType
    TYPE(InflowWind_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: IfW      !< Dummy IfW  constraint states [-]
  END TYPE AWAE_ConstraintStateType
! =======================
! =========  AWAE_OtherStateType  =======
  TYPE, PUBLIC :: AWAE_OtherStateType
    TYPE(InflowWind_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: IfW      !< Dummy IfW   other states [-]
  END TYPE AWAE_OtherStateType
! =======================
! =========  AWAE_MiscVarType  =======
  TYPE, PUBLIC :: AWAE_MiscVarType
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vamb_low      !< UVW components of ambient wind across the low-resolution domain throughout the farm [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vamb_lowpol      !< UVW components of disturbed wind (ambient + wakes) at points in the polar grid for each wake plane for each turbine [m/s]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vdist_low      !< UVW components of disturbed wind (ambient + deficits) across the low-resolution domain throughout the farm [m/s]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vdist_low_full      !< UVW components of disturbed wind (ambient + deficits) across the low-resolution domain throughout the farm, for outputs [m/s]
    TYPE(AWAE_HighWindGrid) , DIMENSION(:), ALLOCATABLE  :: Vamb_High      !< UVW components of ambient wind across each high-resolution domain around a turbine (one for each turbine) for each high-resolution time step within a low-resolution time step [m/s]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: parallelFlag      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r_s      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r_e      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: rhat_s      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: rhat_e      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: pvec_cs      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: pvec_ce      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: outVizXYPlane 
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: outVizYZPlane 
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: outVizXZPlane 
    TYPE(InflowWind_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: IfW      !< InflowWind module misc vars [-]
    TYPE(InflowWind_InputType)  :: u_IfW_Low      !< InflowWind module inputs for the low-resolution grid [-]
    TYPE(InflowWind_InputType)  :: u_IfW_High      !< InflowWind module inputs for the high-resolution grid [-]
    TYPE(InflowWind_OutputType)  :: y_IfW_Low      !< InflowWind module outputs for the low-resolution grid [-]
    TYPE(InflowWind_OutputType)  :: y_IfW_High      !< InflowWind module outputs for the high-resolution grid [-]
  END TYPE AWAE_MiscVarType
! =======================
! =========  AWAE_ParameterType  =======
  TYPE, PUBLIC :: AWAE_ParameterType
    CHARACTER(1024)  :: WindFilePath      !< Path name to the Root folder containing the wind data files from ABLSolver precursor [-]
    INTEGER(IntKi)  :: NumTurbines      !< Number of wind turbines in the farm [>=1] [-]
    INTEGER(IntKi)  :: NumRadii      !< Number of radii in the radial finite-difference grid  [>=2] [-]
    INTEGER(IntKi)  :: NumPlanes      !< Number of wake planes downwind of the rotor where the wake is propagated [>=2] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y      !< Horizontal discretization of the wake planes [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: z      !< Vertical discretization of the wake planes [m]
    INTEGER(IntKi)  :: Mod_AmbWind      !< Ambient wind model {1: high-fidelity precursor in VTK format, 2: InflowWind module} [-]
    INTEGER(IntKi)  :: nX_low      !< Number of low-resolution spatial nodes in X direction [-]
    INTEGER(IntKi)  :: nY_low      !< Number of low-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_low      !< Number of low-resolution spatial nodes in Z direction [-]
    INTEGER(IntKi)  :: NumGrid_low      !< Total number of low-resolution spatial nodes [-]
    INTEGER(IntKi)  :: n_rp_max      !< Maximum possible number of points in the polar grid for the wake plane at each rotor [-]
    REAL(ReKi)  :: dpol      !< Spatial resolution of the polar grid for each wake plane of each turbine [m]
    REAL(ReKi) , DIMENSION(1:3)  :: dXYZ_low      !< XYZ-components of the spatial increment of the low-resolution domain [m]
    REAL(ReKi)  :: dX_low      !< The spacing of the low-resolution nodes in X direction [m]
    REAL(ReKi)  :: dY_low      !< The spacing of the low-resolution nodes in Y direction [m]
    REAL(ReKi)  :: dZ_low      !< The spacing of the low-resolution nodes in Z direction [m]
    REAL(ReKi)  :: X0_low      !< X-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Y0_low      !< Y-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi)  :: Z0_low      !< Z-component of the origin of the low-resolution spatial domain [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X0_high      !< X-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y0_high      !< Y-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Z0_high      !< Z-component of the origin of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dX_high      !< X-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dY_high      !< Y-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dZ_high      !< Z-component of the spatial increment of the high-resolution spatial domain for each turbine [m]
    INTEGER(IntKi)  :: nX_high      !< Number of high-resolution spatial nodes in X direction  [-]
    INTEGER(IntKi)  :: nY_high      !< Number of high-resolution spatial nodes in Y direction [-]
    INTEGER(IntKi)  :: nZ_high      !< Number of high-resolution spatial nodes in Z direction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Grid_low      !< XYZ components (global positions) of the spatial discretization of the low-resolution spatial domain [m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Grid_high      !< XYZ components (global positions) of the spatial discretization of the high-resolution spatial domain for each turbine  [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WT_Position      !< X-Y-Z position of each wind turbine; index 1 = XYZ; index 2 = turbine number [meters]
    INTEGER(IntKi)  :: n_high_low      !< Number of high-resolution time steps per low [-]
    REAL(DbKi)  :: dt_low      !< Low-resolution (FAST.Farm driver/glue code) time step [s]
    REAL(DbKi)  :: dt_high      !< High-resolution (FAST) time step [s]
    INTEGER(IntKi)  :: NumDT      !< Number of low-resolution (FAST.Farm driver/glue code) time steps [-]
    INTEGER(IntKi)  :: Mod_Meander      !< Spatial filter model for wake meandering [-]
    REAL(ReKi)  :: C_Meander      !< Calibrated parameter for wake meandering [-]
    REAL(ReKi)  :: C_ScaleDiam      !< Normalized wake volume radius for wake meandering (normalized by the wake diameter) [-]
    INTEGER(IntKi)  :: Mod_Projection      !< Switch to select how the wake plane velocity is projected in AWAE {1: keep all components, 2: project against plane normal} or DEFAULT [DEFAULT=1: if Mod_Wake is 1 or 3, or DEFAULT=2: if Mod_Wake is 2] [-]
    TYPE(InflowWind_ParameterType) , DIMENSION(:), ALLOCATABLE  :: IfW      !< InflowWind module parameters [-]
    INTEGER(IntKi)  :: WrDisSkp1      !< Number of time steps to skip plus one [-]
    LOGICAL  :: WrDisWind      !< Write disturbed wind data to <WindFilePath>/Low/Dis.t<n>.vtk etc.? [-]
    INTEGER(IntKi)  :: NOutDisWindXY      !< Number of XY planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXY.<n_out>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDisWindZ      !< Z coordinates of XY planes for output of disturbed wind data across the low-resolution domain [1 to NOutDisWindXY] [meters]
    INTEGER(IntKi)  :: NOutDisWindYZ      !< Number of YZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisYZ.<n_out>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDisWindX      !< X coordinates of YZ planes for output of disturbed wind data across the low-resolution domain [1 to NOutDisWindYZ] [meters]
    INTEGER(IntKi)  :: NOutDisWindXZ      !< Number of XZ planes for output of disturbed wind data across the low-resolution domain to <WindFilePath>/Low/DisXZ.<n_out>.t<n>.vtk [0 to 9] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: OutDisWindY      !< Y coordinates of XZ planes for output of disturbed wind data across the low-resolution domain [1 to NOutDisWindXZ] [meters]
    CHARACTER(1024)  :: OutFileRoot      !< The root name derived from the primary FAST.Farm input file [-]
    CHARACTER(1024)  :: OutFileVTKRoot      !< The root name for VTK outputs [-]
    INTEGER(IntKi)  :: VTK_tWidth      !< Number of characters for VTK timestamp outputs [-]
  END TYPE AWAE_ParameterType
! =======================
! =========  AWAE_OutputType  =======
  TYPE, PUBLIC :: AWAE_OutputType
    TYPE(AWAE_HighWindGrid) , DIMENSION(:), ALLOCATABLE  :: Vdist_High      !< Wind velocity of disturbed wind (ambient + wakes) across each high-resolution domain around a turbine for each high-resolution step within a low-resolution step [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: V_plane      !< Advection, deflection, and meandering velocity of wake planes for each turbine [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TI_amb      !< Ambient turbulence intensity of wind at rotor disk for each turbine [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vx_wind_disk      !< Rotor-disk-averaged ambient wind speed, normal to disk, for each turbine [m/s]
  END TYPE AWAE_OutputType
! =======================
! =========  AWAE_InputType  =======
  TYPE, PUBLIC :: AWAE_InputType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: xhat_plane      !< Orientations of wake planes, normal to wake planes, for each turbine [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: p_plane      !< Center positions of wake planes for each turbine [m]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vx_wake      !< Axial wake velocity deficit at wake planes, distributed across the plane, for each turbine (ny,nz,np,nWT) [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vy_wake      !< Transverse horizonal wake velocity deficit at wake planes, distributed across the plane, for each turbine (ny,nz,np,nWT) [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vz_wake      !< Transverse nominally vertical wake velocity deficit at wake planes, distributed across the plane, for each turbine (ny,nz,np,nWT) [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D_wake      !< Wake diameters at wake planes for each turbine [m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WAT_k_mt      !< Scaling factor k_mt(r,x) for wake-added turbulence [-]
  END TYPE AWAE_InputType
! =======================
CONTAINS
 SUBROUTINE AWAE_CopyHighWindGrid( SrcHighWindGridData, DstHighWindGridData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_HighWindGrid), INTENT(IN) :: SrcHighWindGridData
   TYPE(AWAE_HighWindGrid), INTENT(INOUT) :: DstHighWindGridData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyHighWindGrid'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ASSOCIATED(SrcHighWindGridData%data)) THEN
  i1_l = LBOUND(SrcHighWindGridData%data,1)
  i1_u = UBOUND(SrcHighWindGridData%data,1)
  i2_l = LBOUND(SrcHighWindGridData%data,2)
  i2_u = UBOUND(SrcHighWindGridData%data,2)
  i3_l = LBOUND(SrcHighWindGridData%data,3)
  i3_u = UBOUND(SrcHighWindGridData%data,3)
  i4_l = LBOUND(SrcHighWindGridData%data,4)
  i4_u = UBOUND(SrcHighWindGridData%data,4)
  i5_l = LBOUND(SrcHighWindGridData%data,5)
  i5_u = UBOUND(SrcHighWindGridData%data,5)
  IF (.NOT. ASSOCIATED(DstHighWindGridData%data)) THEN 
    ALLOCATE(DstHighWindGridData%data(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u,i5_l:i5_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstHighWindGridData%data.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstHighWindGridData%data = SrcHighWindGridData%data
ENDIF
 END SUBROUTINE AWAE_CopyHighWindGrid

 SUBROUTINE AWAE_DestroyHighWindGrid( HighWindGridData, ErrStat, ErrMsg )
  TYPE(AWAE_HighWindGrid), INTENT(INOUT) :: HighWindGridData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyHighWindGrid'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ASSOCIATED(HighWindGridData%data)) THEN
  DEALLOCATE(HighWindGridData%data)
  HighWindGridData%data => NULL()
ENDIF
 END SUBROUTINE AWAE_DestroyHighWindGrid


subroutine AWAE_PackHighWindGrid(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_HighWindGrid), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackHighWindGrid'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! data
   call RegPack(Buf, associated(InData%data))
   if (associated(InData%data)) then
      call RegPackBounds(Buf, 5, lbound(InData%data), ubound(InData%data))
      call RegPackPointer(Buf, c_loc(InData%data), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%data)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackHighWindGrid(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_HighWindGrid), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackHighWindGrid'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! data
   if (associated(OutData%data)) deallocate(OutData%data)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%data, UB(1:5)-LB(1:5))
         OutData%data(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%data
      else
         allocate(OutData%data(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%data.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%data)
         call RegUnpack(Buf, OutData%data)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%data => null()
   end if
end subroutine
 SUBROUTINE AWAE_CopyHighWindGridPtr( SrcHighWindGridPtrData, DstHighWindGridPtrData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_HighWindGridPtr), INTENT(IN) :: SrcHighWindGridPtrData
   TYPE(AWAE_HighWindGridPtr), INTENT(INOUT) :: DstHighWindGridPtrData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyHighWindGridPtr'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstHighWindGridPtrData%data => SrcHighWindGridPtrData%data
 END SUBROUTINE AWAE_CopyHighWindGridPtr

 SUBROUTINE AWAE_DestroyHighWindGridPtr( HighWindGridPtrData, ErrStat, ErrMsg )
  TYPE(AWAE_HighWindGridPtr), INTENT(INOUT) :: HighWindGridPtrData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyHighWindGridPtr'

  ErrStat = ErrID_None
  ErrMsg  = ""

NULLIFY(HighWindGridPtrData%data)
 END SUBROUTINE AWAE_DestroyHighWindGridPtr


subroutine AWAE_PackHighWindGridPtr(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_HighWindGridPtr), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackHighWindGridPtr'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! data
   call RegPack(Buf, associated(InData%data))
   if (associated(InData%data)) then
      call RegPackBounds(Buf, 5, lbound(InData%data), ubound(InData%data))
      call RegPackPointer(Buf, c_loc(InData%data), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%data)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackHighWindGridPtr(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_HighWindGridPtr), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackHighWindGridPtr'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! data
   if (associated(OutData%data)) deallocate(OutData%data)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%data, UB(1:5)-LB(1:5))
         OutData%data(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%data
      else
         allocate(OutData%data(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%data.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%data)
         call RegUnpack(Buf, OutData%data)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%data => null()
   end if
end subroutine
 SUBROUTINE AWAE_CopyInputFileType( SrcInputFileTypeData, DstInputFileTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_InputFileType), INTENT(IN) :: SrcInputFileTypeData
   TYPE(AWAE_InputFileType), INTENT(INOUT) :: DstInputFileTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyInputFileType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileTypeData%dr = SrcInputFileTypeData%dr
    DstInputFileTypeData%dt_low = SrcInputFileTypeData%dt_low
    DstInputFileTypeData%NumTurbines = SrcInputFileTypeData%NumTurbines
    DstInputFileTypeData%NumRadii = SrcInputFileTypeData%NumRadii
    DstInputFileTypeData%NumPlanes = SrcInputFileTypeData%NumPlanes
    DstInputFileTypeData%WindFilePath = SrcInputFileTypeData%WindFilePath
    DstInputFileTypeData%WrDisWind = SrcInputFileTypeData%WrDisWind
    DstInputFileTypeData%NOutDisWindXY = SrcInputFileTypeData%NOutDisWindXY
IF (ALLOCATED(SrcInputFileTypeData%OutDisWindZ)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%OutDisWindZ,1)
  i1_u = UBOUND(SrcInputFileTypeData%OutDisWindZ,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%OutDisWindZ)) THEN 
    ALLOCATE(DstInputFileTypeData%OutDisWindZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%OutDisWindZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%OutDisWindZ = SrcInputFileTypeData%OutDisWindZ
ENDIF
    DstInputFileTypeData%NOutDisWindYZ = SrcInputFileTypeData%NOutDisWindYZ
IF (ALLOCATED(SrcInputFileTypeData%OutDisWindX)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%OutDisWindX,1)
  i1_u = UBOUND(SrcInputFileTypeData%OutDisWindX,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%OutDisWindX)) THEN 
    ALLOCATE(DstInputFileTypeData%OutDisWindX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%OutDisWindX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%OutDisWindX = SrcInputFileTypeData%OutDisWindX
ENDIF
    DstInputFileTypeData%NOutDisWindXZ = SrcInputFileTypeData%NOutDisWindXZ
IF (ALLOCATED(SrcInputFileTypeData%OutDisWindY)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%OutDisWindY,1)
  i1_u = UBOUND(SrcInputFileTypeData%OutDisWindY,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%OutDisWindY)) THEN 
    ALLOCATE(DstInputFileTypeData%OutDisWindY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%OutDisWindY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%OutDisWindY = SrcInputFileTypeData%OutDisWindY
ENDIF
    DstInputFileTypeData%WrDisDT = SrcInputFileTypeData%WrDisDT
    DstInputFileTypeData%ChkWndFiles = SrcInputFileTypeData%ChkWndFiles
    DstInputFileTypeData%Mod_Meander = SrcInputFileTypeData%Mod_Meander
    DstInputFileTypeData%C_Meander = SrcInputFileTypeData%C_Meander
    DstInputFileTypeData%Mod_AmbWind = SrcInputFileTypeData%Mod_AmbWind
    DstInputFileTypeData%InflowFile = SrcInputFileTypeData%InflowFile
    DstInputFileTypeData%dt_high = SrcInputFileTypeData%dt_high
IF (ALLOCATED(SrcInputFileTypeData%X0_high)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%X0_high,1)
  i1_u = UBOUND(SrcInputFileTypeData%X0_high,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%X0_high)) THEN 
    ALLOCATE(DstInputFileTypeData%X0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%X0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%X0_high = SrcInputFileTypeData%X0_high
ENDIF
IF (ALLOCATED(SrcInputFileTypeData%Y0_high)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%Y0_high,1)
  i1_u = UBOUND(SrcInputFileTypeData%Y0_high,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%Y0_high)) THEN 
    ALLOCATE(DstInputFileTypeData%Y0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%Y0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%Y0_high = SrcInputFileTypeData%Y0_high
ENDIF
IF (ALLOCATED(SrcInputFileTypeData%Z0_high)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%Z0_high,1)
  i1_u = UBOUND(SrcInputFileTypeData%Z0_high,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%Z0_high)) THEN 
    ALLOCATE(DstInputFileTypeData%Z0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%Z0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%Z0_high = SrcInputFileTypeData%Z0_high
ENDIF
IF (ALLOCATED(SrcInputFileTypeData%dX_high)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%dX_high,1)
  i1_u = UBOUND(SrcInputFileTypeData%dX_high,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%dX_high)) THEN 
    ALLOCATE(DstInputFileTypeData%dX_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%dX_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%dX_high = SrcInputFileTypeData%dX_high
ENDIF
IF (ALLOCATED(SrcInputFileTypeData%dY_high)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%dY_high,1)
  i1_u = UBOUND(SrcInputFileTypeData%dY_high,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%dY_high)) THEN 
    ALLOCATE(DstInputFileTypeData%dY_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%dY_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%dY_high = SrcInputFileTypeData%dY_high
ENDIF
IF (ALLOCATED(SrcInputFileTypeData%dZ_high)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%dZ_high,1)
  i1_u = UBOUND(SrcInputFileTypeData%dZ_high,1)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%dZ_high)) THEN 
    ALLOCATE(DstInputFileTypeData%dZ_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%dZ_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%dZ_high = SrcInputFileTypeData%dZ_high
ENDIF
    DstInputFileTypeData%nX_high = SrcInputFileTypeData%nX_high
    DstInputFileTypeData%nY_high = SrcInputFileTypeData%nY_high
    DstInputFileTypeData%nZ_high = SrcInputFileTypeData%nZ_high
    DstInputFileTypeData%dX_low = SrcInputFileTypeData%dX_low
    DstInputFileTypeData%dY_low = SrcInputFileTypeData%dY_low
    DstInputFileTypeData%dZ_low = SrcInputFileTypeData%dZ_low
    DstInputFileTypeData%nX_low = SrcInputFileTypeData%nX_low
    DstInputFileTypeData%nY_low = SrcInputFileTypeData%nY_low
    DstInputFileTypeData%nZ_low = SrcInputFileTypeData%nZ_low
    DstInputFileTypeData%X0_low = SrcInputFileTypeData%X0_low
    DstInputFileTypeData%Y0_low = SrcInputFileTypeData%Y0_low
    DstInputFileTypeData%Z0_low = SrcInputFileTypeData%Z0_low
IF (ALLOCATED(SrcInputFileTypeData%WT_Position)) THEN
  i1_l = LBOUND(SrcInputFileTypeData%WT_Position,1)
  i1_u = UBOUND(SrcInputFileTypeData%WT_Position,1)
  i2_l = LBOUND(SrcInputFileTypeData%WT_Position,2)
  i2_u = UBOUND(SrcInputFileTypeData%WT_Position,2)
  IF (.NOT. ALLOCATED(DstInputFileTypeData%WT_Position)) THEN 
    ALLOCATE(DstInputFileTypeData%WT_Position(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileTypeData%WT_Position.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileTypeData%WT_Position = SrcInputFileTypeData%WT_Position
ENDIF
    DstInputFileTypeData%Mod_Projection = SrcInputFileTypeData%Mod_Projection
 END SUBROUTINE AWAE_CopyInputFileType

 SUBROUTINE AWAE_DestroyInputFileType( InputFileTypeData, ErrStat, ErrMsg )
  TYPE(AWAE_InputFileType), INTENT(INOUT) :: InputFileTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyInputFileType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputFileTypeData%OutDisWindZ)) THEN
  DEALLOCATE(InputFileTypeData%OutDisWindZ)
ENDIF
IF (ALLOCATED(InputFileTypeData%OutDisWindX)) THEN
  DEALLOCATE(InputFileTypeData%OutDisWindX)
ENDIF
IF (ALLOCATED(InputFileTypeData%OutDisWindY)) THEN
  DEALLOCATE(InputFileTypeData%OutDisWindY)
ENDIF
IF (ALLOCATED(InputFileTypeData%X0_high)) THEN
  DEALLOCATE(InputFileTypeData%X0_high)
ENDIF
IF (ALLOCATED(InputFileTypeData%Y0_high)) THEN
  DEALLOCATE(InputFileTypeData%Y0_high)
ENDIF
IF (ALLOCATED(InputFileTypeData%Z0_high)) THEN
  DEALLOCATE(InputFileTypeData%Z0_high)
ENDIF
IF (ALLOCATED(InputFileTypeData%dX_high)) THEN
  DEALLOCATE(InputFileTypeData%dX_high)
ENDIF
IF (ALLOCATED(InputFileTypeData%dY_high)) THEN
  DEALLOCATE(InputFileTypeData%dY_high)
ENDIF
IF (ALLOCATED(InputFileTypeData%dZ_high)) THEN
  DEALLOCATE(InputFileTypeData%dZ_high)
ENDIF
IF (ALLOCATED(InputFileTypeData%WT_Position)) THEN
  DEALLOCATE(InputFileTypeData%WT_Position)
ENDIF
 END SUBROUTINE AWAE_DestroyInputFileType


subroutine AWAE_PackInputFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_InputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackInputFileType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dr
   call RegPack(Buf, InData%dr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_low
   call RegPack(Buf, InData%dt_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTurbines
   call RegPack(Buf, InData%NumTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegPack(Buf, InData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegPack(Buf, InData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindFilePath
   call RegPack(Buf, InData%WindFilePath)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrDisWind
   call RegPack(Buf, InData%WrDisWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindXY
   call RegPack(Buf, InData%NOutDisWindXY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindZ
   call RegPack(Buf, allocated(InData%OutDisWindZ))
   if (allocated(InData%OutDisWindZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDisWindZ), ubound(InData%OutDisWindZ))
      call RegPack(Buf, InData%OutDisWindZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindYZ
   call RegPack(Buf, InData%NOutDisWindYZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindX
   call RegPack(Buf, allocated(InData%OutDisWindX))
   if (allocated(InData%OutDisWindX)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDisWindX), ubound(InData%OutDisWindX))
      call RegPack(Buf, InData%OutDisWindX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindXZ
   call RegPack(Buf, InData%NOutDisWindXZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindY
   call RegPack(Buf, allocated(InData%OutDisWindY))
   if (allocated(InData%OutDisWindY)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDisWindY), ubound(InData%OutDisWindY))
      call RegPack(Buf, InData%OutDisWindY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrDisDT
   call RegPack(Buf, InData%WrDisDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChkWndFiles
   call RegPack(Buf, InData%ChkWndFiles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Meander
   call RegPack(Buf, InData%Mod_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Meander
   call RegPack(Buf, InData%C_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_AmbWind
   call RegPack(Buf, InData%Mod_AmbWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowFile
   call RegPack(Buf, InData%InflowFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_high
   call RegPack(Buf, InData%dt_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_high
   call RegPack(Buf, allocated(InData%X0_high))
   if (allocated(InData%X0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%X0_high), ubound(InData%X0_high))
      call RegPack(Buf, InData%X0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_high
   call RegPack(Buf, allocated(InData%Y0_high))
   if (allocated(InData%Y0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Y0_high), ubound(InData%Y0_high))
      call RegPack(Buf, InData%Y0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_high
   call RegPack(Buf, allocated(InData%Z0_high))
   if (allocated(InData%Z0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Z0_high), ubound(InData%Z0_high))
      call RegPack(Buf, InData%Z0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_high
   call RegPack(Buf, allocated(InData%dX_high))
   if (allocated(InData%dX_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dX_high), ubound(InData%dX_high))
      call RegPack(Buf, InData%dX_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_high
   call RegPack(Buf, allocated(InData%dY_high))
   if (allocated(InData%dY_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dY_high), ubound(InData%dY_high))
      call RegPack(Buf, InData%dY_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_high
   call RegPack(Buf, allocated(InData%dZ_high))
   if (allocated(InData%dZ_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dZ_high), ubound(InData%dZ_high))
      call RegPack(Buf, InData%dZ_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_high
   call RegPack(Buf, InData%nX_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_high
   call RegPack(Buf, InData%nY_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_high
   call RegPack(Buf, InData%nZ_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_low
   call RegPack(Buf, InData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_low
   call RegPack(Buf, InData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_low
   call RegPack(Buf, InData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_low
   call RegPack(Buf, InData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_low
   call RegPack(Buf, InData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_low
   call RegPack(Buf, InData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_low
   call RegPack(Buf, InData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_low
   call RegPack(Buf, InData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_low
   call RegPack(Buf, InData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WT_Position
   call RegPack(Buf, allocated(InData%WT_Position))
   if (allocated(InData%WT_Position)) then
      call RegPackBounds(Buf, 2, lbound(InData%WT_Position), ubound(InData%WT_Position))
      call RegPack(Buf, InData%WT_Position)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Projection
   call RegPack(Buf, InData%Mod_Projection)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackInputFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_InputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackInputFileType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! dr
   call RegUnpack(Buf, OutData%dr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_low
   call RegUnpack(Buf, OutData%dt_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTurbines
   call RegUnpack(Buf, OutData%NumTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegUnpack(Buf, OutData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegUnpack(Buf, OutData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindFilePath
   call RegUnpack(Buf, OutData%WindFilePath)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrDisWind
   call RegUnpack(Buf, OutData%WrDisWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindXY
   call RegUnpack(Buf, OutData%NOutDisWindXY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindZ
   if (allocated(OutData%OutDisWindZ)) deallocate(OutData%OutDisWindZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDisWindZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDisWindZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDisWindZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NOutDisWindYZ
   call RegUnpack(Buf, OutData%NOutDisWindYZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindX
   if (allocated(OutData%OutDisWindX)) deallocate(OutData%OutDisWindX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDisWindX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDisWindX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDisWindX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NOutDisWindXZ
   call RegUnpack(Buf, OutData%NOutDisWindXZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindY
   if (allocated(OutData%OutDisWindY)) deallocate(OutData%OutDisWindY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDisWindY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDisWindY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDisWindY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WrDisDT
   call RegUnpack(Buf, OutData%WrDisDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ChkWndFiles
   call RegUnpack(Buf, OutData%ChkWndFiles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Meander
   call RegUnpack(Buf, OutData%Mod_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Meander
   call RegUnpack(Buf, OutData%C_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_AmbWind
   call RegUnpack(Buf, OutData%Mod_AmbWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowFile
   call RegUnpack(Buf, OutData%InflowFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_high
   call RegUnpack(Buf, OutData%dt_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_high
   if (allocated(OutData%X0_high)) deallocate(OutData%X0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Y0_high
   if (allocated(OutData%Y0_high)) deallocate(OutData%Y0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Z0_high
   if (allocated(OutData%Z0_high)) deallocate(OutData%Z0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Z0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Z0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dX_high
   if (allocated(OutData%dX_high)) deallocate(OutData%dX_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dX_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dX_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dX_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dY_high
   if (allocated(OutData%dY_high)) deallocate(OutData%dY_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dY_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dY_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dY_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dZ_high
   if (allocated(OutData%dZ_high)) deallocate(OutData%dZ_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dZ_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dZ_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dZ_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nX_high
   call RegUnpack(Buf, OutData%nX_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_high
   call RegUnpack(Buf, OutData%nY_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_high
   call RegUnpack(Buf, OutData%nZ_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_low
   call RegUnpack(Buf, OutData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_low
   call RegUnpack(Buf, OutData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_low
   call RegUnpack(Buf, OutData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_low
   call RegUnpack(Buf, OutData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_low
   call RegUnpack(Buf, OutData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_low
   call RegUnpack(Buf, OutData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_low
   call RegUnpack(Buf, OutData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_low
   call RegUnpack(Buf, OutData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_low
   call RegUnpack(Buf, OutData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WT_Position
   if (allocated(OutData%WT_Position)) deallocate(OutData%WT_Position)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WT_Position(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WT_Position.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WT_Position)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Mod_Projection
   call RegUnpack(Buf, OutData%Mod_Projection)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AWAE_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(AWAE_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL AWAE_Copyinputfiletype( SrcInitInputData%InputFileData, DstInitInputData%InputFileData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%n_high_low = SrcInitInputData%n_high_low
    DstInitInputData%NumDT = SrcInitInputData%NumDT
    DstInitInputData%OutFileRoot = SrcInitInputData%OutFileRoot
 END SUBROUTINE AWAE_CopyInitInput

 SUBROUTINE AWAE_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(AWAE_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL AWAE_DestroyInputFileType( InitInputData%InputFileData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AWAE_DestroyInitInput


subroutine AWAE_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFileData
   call AWAE_PackInputFileType(Buf, InData%InputFileData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_high_low
   call RegPack(Buf, InData%n_high_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumDT
   call RegPack(Buf, InData%NumDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegPack(Buf, InData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackInitInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFileData
   call AWAE_UnpackInputFileType(Buf, OutData%InputFileData) ! InputFileData 
   ! n_high_low
   call RegUnpack(Buf, OutData%n_high_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumDT
   call RegUnpack(Buf, OutData%NumDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegUnpack(Buf, OutData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AWAE_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(AWAE_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%X0_high)) THEN
  i1_l = LBOUND(SrcInitOutputData%X0_high,1)
  i1_u = UBOUND(SrcInitOutputData%X0_high,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%X0_high)) THEN 
    ALLOCATE(DstInitOutputData%X0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%X0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%X0_high = SrcInitOutputData%X0_high
ENDIF
IF (ALLOCATED(SrcInitOutputData%Y0_high)) THEN
  i1_l = LBOUND(SrcInitOutputData%Y0_high,1)
  i1_u = UBOUND(SrcInitOutputData%Y0_high,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%Y0_high)) THEN 
    ALLOCATE(DstInitOutputData%Y0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%Y0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%Y0_high = SrcInitOutputData%Y0_high
ENDIF
IF (ALLOCATED(SrcInitOutputData%Z0_high)) THEN
  i1_l = LBOUND(SrcInitOutputData%Z0_high,1)
  i1_u = UBOUND(SrcInitOutputData%Z0_high,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%Z0_high)) THEN 
    ALLOCATE(DstInitOutputData%Z0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%Z0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%Z0_high = SrcInitOutputData%Z0_high
ENDIF
IF (ALLOCATED(SrcInitOutputData%dX_high)) THEN
  i1_l = LBOUND(SrcInitOutputData%dX_high,1)
  i1_u = UBOUND(SrcInitOutputData%dX_high,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%dX_high)) THEN 
    ALLOCATE(DstInitOutputData%dX_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%dX_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%dX_high = SrcInitOutputData%dX_high
ENDIF
IF (ALLOCATED(SrcInitOutputData%dY_high)) THEN
  i1_l = LBOUND(SrcInitOutputData%dY_high,1)
  i1_u = UBOUND(SrcInitOutputData%dY_high,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%dY_high)) THEN 
    ALLOCATE(DstInitOutputData%dY_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%dY_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%dY_high = SrcInitOutputData%dY_high
ENDIF
IF (ALLOCATED(SrcInitOutputData%dZ_high)) THEN
  i1_l = LBOUND(SrcInitOutputData%dZ_high,1)
  i1_u = UBOUND(SrcInitOutputData%dZ_high,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%dZ_high)) THEN 
    ALLOCATE(DstInitOutputData%dZ_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%dZ_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%dZ_high = SrcInitOutputData%dZ_high
ENDIF
    DstInitOutputData%nX_high = SrcInitOutputData%nX_high
    DstInitOutputData%nY_high = SrcInitOutputData%nY_high
    DstInitOutputData%nZ_high = SrcInitOutputData%nZ_high
    DstInitOutputData%dX_low = SrcInitOutputData%dX_low
    DstInitOutputData%dY_low = SrcInitOutputData%dY_low
    DstInitOutputData%dZ_low = SrcInitOutputData%dZ_low
    DstInitOutputData%nX_low = SrcInitOutputData%nX_low
    DstInitOutputData%nY_low = SrcInitOutputData%nY_low
    DstInitOutputData%nZ_low = SrcInitOutputData%nZ_low
    DstInitOutputData%X0_low = SrcInitOutputData%X0_low
    DstInitOutputData%Y0_low = SrcInitOutputData%Y0_low
    DstInitOutputData%Z0_low = SrcInitOutputData%Z0_low
IF (ALLOCATED(SrcInitOutputData%Vdist_High)) THEN
  i1_l = LBOUND(SrcInitOutputData%Vdist_High,1)
  i1_u = UBOUND(SrcInitOutputData%Vdist_High,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%Vdist_High)) THEN 
    ALLOCATE(DstInitOutputData%Vdist_High(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%Vdist_High.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitOutputData%Vdist_High,1), UBOUND(SrcInitOutputData%Vdist_High,1)
      CALL AWAE_Copyhighwindgridptr( SrcInitOutputData%Vdist_High(i1), DstInitOutputData%Vdist_High(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AWAE_CopyInitOutput

 SUBROUTINE AWAE_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(AWAE_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%X0_high)) THEN
  DEALLOCATE(InitOutputData%X0_high)
ENDIF
IF (ALLOCATED(InitOutputData%Y0_high)) THEN
  DEALLOCATE(InitOutputData%Y0_high)
ENDIF
IF (ALLOCATED(InitOutputData%Z0_high)) THEN
  DEALLOCATE(InitOutputData%Z0_high)
ENDIF
IF (ALLOCATED(InitOutputData%dX_high)) THEN
  DEALLOCATE(InitOutputData%dX_high)
ENDIF
IF (ALLOCATED(InitOutputData%dY_high)) THEN
  DEALLOCATE(InitOutputData%dY_high)
ENDIF
IF (ALLOCATED(InitOutputData%dZ_high)) THEN
  DEALLOCATE(InitOutputData%dZ_high)
ENDIF
IF (ALLOCATED(InitOutputData%Vdist_High)) THEN
DO i1 = LBOUND(InitOutputData%Vdist_High,1), UBOUND(InitOutputData%Vdist_High,1)
  CALL AWAE_DestroyHighWindGridPtr( InitOutputData%Vdist_High(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InitOutputData%Vdist_High)
ENDIF
 END SUBROUTINE AWAE_DestroyInitOutput


subroutine AWAE_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackInitOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_high
   call RegPack(Buf, allocated(InData%X0_high))
   if (allocated(InData%X0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%X0_high), ubound(InData%X0_high))
      call RegPack(Buf, InData%X0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_high
   call RegPack(Buf, allocated(InData%Y0_high))
   if (allocated(InData%Y0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Y0_high), ubound(InData%Y0_high))
      call RegPack(Buf, InData%Y0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_high
   call RegPack(Buf, allocated(InData%Z0_high))
   if (allocated(InData%Z0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Z0_high), ubound(InData%Z0_high))
      call RegPack(Buf, InData%Z0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_high
   call RegPack(Buf, allocated(InData%dX_high))
   if (allocated(InData%dX_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dX_high), ubound(InData%dX_high))
      call RegPack(Buf, InData%dX_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_high
   call RegPack(Buf, allocated(InData%dY_high))
   if (allocated(InData%dY_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dY_high), ubound(InData%dY_high))
      call RegPack(Buf, InData%dY_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_high
   call RegPack(Buf, allocated(InData%dZ_high))
   if (allocated(InData%dZ_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dZ_high), ubound(InData%dZ_high))
      call RegPack(Buf, InData%dZ_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_high
   call RegPack(Buf, InData%nX_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_high
   call RegPack(Buf, InData%nY_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_high
   call RegPack(Buf, InData%nZ_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_low
   call RegPack(Buf, InData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_low
   call RegPack(Buf, InData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_low
   call RegPack(Buf, InData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_low
   call RegPack(Buf, InData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_low
   call RegPack(Buf, InData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_low
   call RegPack(Buf, InData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_low
   call RegPack(Buf, InData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_low
   call RegPack(Buf, InData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_low
   call RegPack(Buf, InData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vdist_High
   call RegPack(Buf, allocated(InData%Vdist_High))
   if (allocated(InData%Vdist_High)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vdist_High), ubound(InData%Vdist_High))
      LB(1:1) = lbound(InData%Vdist_High)
      UB(1:1) = ubound(InData%Vdist_High)
      do i1 = LB(1), UB(1)
         call AWAE_PackHighWindGridPtr(Buf, InData%Vdist_High(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackInitOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! X0_high
   if (allocated(OutData%X0_high)) deallocate(OutData%X0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Y0_high
   if (allocated(OutData%Y0_high)) deallocate(OutData%Y0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Z0_high
   if (allocated(OutData%Z0_high)) deallocate(OutData%Z0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Z0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Z0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dX_high
   if (allocated(OutData%dX_high)) deallocate(OutData%dX_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dX_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dX_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dX_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dY_high
   if (allocated(OutData%dY_high)) deallocate(OutData%dY_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dY_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dY_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dY_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dZ_high
   if (allocated(OutData%dZ_high)) deallocate(OutData%dZ_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dZ_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dZ_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dZ_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nX_high
   call RegUnpack(Buf, OutData%nX_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_high
   call RegUnpack(Buf, OutData%nY_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_high
   call RegUnpack(Buf, OutData%nZ_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_low
   call RegUnpack(Buf, OutData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_low
   call RegUnpack(Buf, OutData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_low
   call RegUnpack(Buf, OutData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_low
   call RegUnpack(Buf, OutData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_low
   call RegUnpack(Buf, OutData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_low
   call RegUnpack(Buf, OutData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_low
   call RegUnpack(Buf, OutData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_low
   call RegUnpack(Buf, OutData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_low
   call RegUnpack(Buf, OutData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vdist_High
   if (allocated(OutData%Vdist_High)) deallocate(OutData%Vdist_High)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vdist_High(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vdist_High.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AWAE_UnpackHighWindGridPtr(Buf, OutData%Vdist_High(i1)) ! Vdist_High 
      end do
   end if
end subroutine
 SUBROUTINE AWAE_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(AWAE_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%IfW)) THEN
  i1_l = LBOUND(SrcContStateData%IfW,1)
  i1_u = UBOUND(SrcContStateData%IfW,1)
  IF (.NOT. ALLOCATED(DstContStateData%IfW)) THEN 
    ALLOCATE(DstContStateData%IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%IfW,1), UBOUND(SrcContStateData%IfW,1)
      CALL InflowWind_CopyContState( SrcContStateData%IfW(i1), DstContStateData%IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AWAE_CopyContState

 SUBROUTINE AWAE_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(AWAE_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%IfW)) THEN
DO i1 = LBOUND(ContStateData%IfW,1), UBOUND(ContStateData%IfW,1)
  CALL InflowWind_DestroyContState( ContStateData%IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%IfW)
ENDIF
 END SUBROUTINE AWAE_DestroyContState


subroutine AWAE_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! IfW
   call RegPack(Buf, allocated(InData%IfW))
   if (allocated(InData%IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%IfW), ubound(InData%IfW))
      LB(1:1) = lbound(InData%IfW)
      UB(1:1) = ubound(InData%IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackContState(Buf, InData%IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IfW
   if (allocated(OutData%IfW)) deallocate(OutData%IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackContState(Buf, OutData%IfW(i1)) ! IfW 
      end do
   end if
end subroutine
 SUBROUTINE AWAE_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(AWAE_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%IfW)) THEN
  i1_l = LBOUND(SrcDiscStateData%IfW,1)
  i1_u = UBOUND(SrcDiscStateData%IfW,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%IfW)) THEN 
    ALLOCATE(DstDiscStateData%IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%IfW,1), UBOUND(SrcDiscStateData%IfW,1)
      CALL InflowWind_CopyDiscState( SrcDiscStateData%IfW(i1), DstDiscStateData%IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AWAE_CopyDiscState

 SUBROUTINE AWAE_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(AWAE_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%IfW)) THEN
DO i1 = LBOUND(DiscStateData%IfW,1), UBOUND(DiscStateData%IfW,1)
  CALL InflowWind_DestroyDiscState( DiscStateData%IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%IfW)
ENDIF
 END SUBROUTINE AWAE_DestroyDiscState


subroutine AWAE_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! IfW
   call RegPack(Buf, allocated(InData%IfW))
   if (allocated(InData%IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%IfW), ubound(InData%IfW))
      LB(1:1) = lbound(InData%IfW)
      UB(1:1) = ubound(InData%IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackDiscState(Buf, InData%IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IfW
   if (allocated(OutData%IfW)) deallocate(OutData%IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackDiscState(Buf, OutData%IfW(i1)) ! IfW 
      end do
   end if
end subroutine
 SUBROUTINE AWAE_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(AWAE_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcConstrStateData%IfW)) THEN
  i1_l = LBOUND(SrcConstrStateData%IfW,1)
  i1_u = UBOUND(SrcConstrStateData%IfW,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%IfW)) THEN 
    ALLOCATE(DstConstrStateData%IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%IfW,1), UBOUND(SrcConstrStateData%IfW,1)
      CALL InflowWind_CopyConstrState( SrcConstrStateData%IfW(i1), DstConstrStateData%IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AWAE_CopyConstrState

 SUBROUTINE AWAE_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(AWAE_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ConstrStateData%IfW)) THEN
DO i1 = LBOUND(ConstrStateData%IfW,1), UBOUND(ConstrStateData%IfW,1)
  CALL InflowWind_DestroyConstrState( ConstrStateData%IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%IfW)
ENDIF
 END SUBROUTINE AWAE_DestroyConstrState


subroutine AWAE_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! IfW
   call RegPack(Buf, allocated(InData%IfW))
   if (allocated(InData%IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%IfW), ubound(InData%IfW))
      LB(1:1) = lbound(InData%IfW)
      UB(1:1) = ubound(InData%IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackConstrState(Buf, InData%IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IfW
   if (allocated(OutData%IfW)) deallocate(OutData%IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackConstrState(Buf, OutData%IfW(i1)) ! IfW 
      end do
   end if
end subroutine
 SUBROUTINE AWAE_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(AWAE_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%IfW)) THEN
  i1_l = LBOUND(SrcOtherStateData%IfW,1)
  i1_u = UBOUND(SrcOtherStateData%IfW,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%IfW)) THEN 
    ALLOCATE(DstOtherStateData%IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%IfW,1), UBOUND(SrcOtherStateData%IfW,1)
      CALL InflowWind_CopyOtherState( SrcOtherStateData%IfW(i1), DstOtherStateData%IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AWAE_CopyOtherState

 SUBROUTINE AWAE_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(AWAE_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%IfW)) THEN
DO i1 = LBOUND(OtherStateData%IfW,1), UBOUND(OtherStateData%IfW,1)
  CALL InflowWind_DestroyOtherState( OtherStateData%IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%IfW)
ENDIF
 END SUBROUTINE AWAE_DestroyOtherState


subroutine AWAE_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! IfW
   call RegPack(Buf, allocated(InData%IfW))
   if (allocated(InData%IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%IfW), ubound(InData%IfW))
      LB(1:1) = lbound(InData%IfW)
      UB(1:1) = ubound(InData%IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackOtherState(Buf, InData%IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IfW
   if (allocated(OutData%IfW)) deallocate(OutData%IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackOtherState(Buf, OutData%IfW(i1)) ! IfW 
      end do
   end if
end subroutine
 SUBROUTINE AWAE_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(AWAE_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%Vamb_low)) THEN
  i1_l = LBOUND(SrcMiscData%Vamb_low,1)
  i1_u = UBOUND(SrcMiscData%Vamb_low,1)
  i2_l = LBOUND(SrcMiscData%Vamb_low,2)
  i2_u = UBOUND(SrcMiscData%Vamb_low,2)
  i3_l = LBOUND(SrcMiscData%Vamb_low,3)
  i3_u = UBOUND(SrcMiscData%Vamb_low,3)
  i4_l = LBOUND(SrcMiscData%Vamb_low,4)
  i4_u = UBOUND(SrcMiscData%Vamb_low,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vamb_low)) THEN 
    ALLOCATE(DstMiscData%Vamb_low(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vamb_low.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vamb_low = SrcMiscData%Vamb_low
ENDIF
IF (ALLOCATED(SrcMiscData%Vamb_lowpol)) THEN
  i1_l = LBOUND(SrcMiscData%Vamb_lowpol,1)
  i1_u = UBOUND(SrcMiscData%Vamb_lowpol,1)
  i2_l = LBOUND(SrcMiscData%Vamb_lowpol,2)
  i2_u = UBOUND(SrcMiscData%Vamb_lowpol,2)
  IF (.NOT. ALLOCATED(DstMiscData%Vamb_lowpol)) THEN 
    ALLOCATE(DstMiscData%Vamb_lowpol(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vamb_lowpol.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vamb_lowpol = SrcMiscData%Vamb_lowpol
ENDIF
IF (ALLOCATED(SrcMiscData%Vdist_low)) THEN
  i1_l = LBOUND(SrcMiscData%Vdist_low,1)
  i1_u = UBOUND(SrcMiscData%Vdist_low,1)
  i2_l = LBOUND(SrcMiscData%Vdist_low,2)
  i2_u = UBOUND(SrcMiscData%Vdist_low,2)
  i3_l = LBOUND(SrcMiscData%Vdist_low,3)
  i3_u = UBOUND(SrcMiscData%Vdist_low,3)
  i4_l = LBOUND(SrcMiscData%Vdist_low,4)
  i4_u = UBOUND(SrcMiscData%Vdist_low,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vdist_low)) THEN 
    ALLOCATE(DstMiscData%Vdist_low(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vdist_low.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vdist_low = SrcMiscData%Vdist_low
ENDIF
IF (ALLOCATED(SrcMiscData%Vdist_low_full)) THEN
  i1_l = LBOUND(SrcMiscData%Vdist_low_full,1)
  i1_u = UBOUND(SrcMiscData%Vdist_low_full,1)
  i2_l = LBOUND(SrcMiscData%Vdist_low_full,2)
  i2_u = UBOUND(SrcMiscData%Vdist_low_full,2)
  i3_l = LBOUND(SrcMiscData%Vdist_low_full,3)
  i3_u = UBOUND(SrcMiscData%Vdist_low_full,3)
  i4_l = LBOUND(SrcMiscData%Vdist_low_full,4)
  i4_u = UBOUND(SrcMiscData%Vdist_low_full,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vdist_low_full)) THEN 
    ALLOCATE(DstMiscData%Vdist_low_full(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vdist_low_full.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vdist_low_full = SrcMiscData%Vdist_low_full
ENDIF
IF (ALLOCATED(SrcMiscData%Vamb_High)) THEN
  i1_l = LBOUND(SrcMiscData%Vamb_High,1)
  i1_u = UBOUND(SrcMiscData%Vamb_High,1)
  IF (.NOT. ALLOCATED(DstMiscData%Vamb_High)) THEN 
    ALLOCATE(DstMiscData%Vamb_High(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vamb_High.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%Vamb_High,1), UBOUND(SrcMiscData%Vamb_High,1)
      CALL AWAE_Copyhighwindgrid( SrcMiscData%Vamb_High(i1), DstMiscData%Vamb_High(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%parallelFlag)) THEN
  i1_l = LBOUND(SrcMiscData%parallelFlag,1)
  i1_u = UBOUND(SrcMiscData%parallelFlag,1)
  i2_l = LBOUND(SrcMiscData%parallelFlag,2)
  i2_u = UBOUND(SrcMiscData%parallelFlag,2)
  IF (.NOT. ALLOCATED(DstMiscData%parallelFlag)) THEN 
    ALLOCATE(DstMiscData%parallelFlag(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%parallelFlag.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%parallelFlag = SrcMiscData%parallelFlag
ENDIF
IF (ALLOCATED(SrcMiscData%r_s)) THEN
  i1_l = LBOUND(SrcMiscData%r_s,1)
  i1_u = UBOUND(SrcMiscData%r_s,1)
  i2_l = LBOUND(SrcMiscData%r_s,2)
  i2_u = UBOUND(SrcMiscData%r_s,2)
  IF (.NOT. ALLOCATED(DstMiscData%r_s)) THEN 
    ALLOCATE(DstMiscData%r_s(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_s.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_s = SrcMiscData%r_s
ENDIF
IF (ALLOCATED(SrcMiscData%r_e)) THEN
  i1_l = LBOUND(SrcMiscData%r_e,1)
  i1_u = UBOUND(SrcMiscData%r_e,1)
  i2_l = LBOUND(SrcMiscData%r_e,2)
  i2_u = UBOUND(SrcMiscData%r_e,2)
  IF (.NOT. ALLOCATED(DstMiscData%r_e)) THEN 
    ALLOCATE(DstMiscData%r_e(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_e.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_e = SrcMiscData%r_e
ENDIF
IF (ALLOCATED(SrcMiscData%rhat_s)) THEN
  i1_l = LBOUND(SrcMiscData%rhat_s,1)
  i1_u = UBOUND(SrcMiscData%rhat_s,1)
  i2_l = LBOUND(SrcMiscData%rhat_s,2)
  i2_u = UBOUND(SrcMiscData%rhat_s,2)
  i3_l = LBOUND(SrcMiscData%rhat_s,3)
  i3_u = UBOUND(SrcMiscData%rhat_s,3)
  IF (.NOT. ALLOCATED(DstMiscData%rhat_s)) THEN 
    ALLOCATE(DstMiscData%rhat_s(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rhat_s.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%rhat_s = SrcMiscData%rhat_s
ENDIF
IF (ALLOCATED(SrcMiscData%rhat_e)) THEN
  i1_l = LBOUND(SrcMiscData%rhat_e,1)
  i1_u = UBOUND(SrcMiscData%rhat_e,1)
  i2_l = LBOUND(SrcMiscData%rhat_e,2)
  i2_u = UBOUND(SrcMiscData%rhat_e,2)
  i3_l = LBOUND(SrcMiscData%rhat_e,3)
  i3_u = UBOUND(SrcMiscData%rhat_e,3)
  IF (.NOT. ALLOCATED(DstMiscData%rhat_e)) THEN 
    ALLOCATE(DstMiscData%rhat_e(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rhat_e.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%rhat_e = SrcMiscData%rhat_e
ENDIF
IF (ALLOCATED(SrcMiscData%pvec_cs)) THEN
  i1_l = LBOUND(SrcMiscData%pvec_cs,1)
  i1_u = UBOUND(SrcMiscData%pvec_cs,1)
  i2_l = LBOUND(SrcMiscData%pvec_cs,2)
  i2_u = UBOUND(SrcMiscData%pvec_cs,2)
  i3_l = LBOUND(SrcMiscData%pvec_cs,3)
  i3_u = UBOUND(SrcMiscData%pvec_cs,3)
  IF (.NOT. ALLOCATED(DstMiscData%pvec_cs)) THEN 
    ALLOCATE(DstMiscData%pvec_cs(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%pvec_cs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%pvec_cs = SrcMiscData%pvec_cs
ENDIF
IF (ALLOCATED(SrcMiscData%pvec_ce)) THEN
  i1_l = LBOUND(SrcMiscData%pvec_ce,1)
  i1_u = UBOUND(SrcMiscData%pvec_ce,1)
  i2_l = LBOUND(SrcMiscData%pvec_ce,2)
  i2_u = UBOUND(SrcMiscData%pvec_ce,2)
  i3_l = LBOUND(SrcMiscData%pvec_ce,3)
  i3_u = UBOUND(SrcMiscData%pvec_ce,3)
  IF (.NOT. ALLOCATED(DstMiscData%pvec_ce)) THEN 
    ALLOCATE(DstMiscData%pvec_ce(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%pvec_ce.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%pvec_ce = SrcMiscData%pvec_ce
ENDIF
IF (ALLOCATED(SrcMiscData%outVizXYPlane)) THEN
  i1_l = LBOUND(SrcMiscData%outVizXYPlane,1)
  i1_u = UBOUND(SrcMiscData%outVizXYPlane,1)
  i2_l = LBOUND(SrcMiscData%outVizXYPlane,2)
  i2_u = UBOUND(SrcMiscData%outVizXYPlane,2)
  i3_l = LBOUND(SrcMiscData%outVizXYPlane,3)
  i3_u = UBOUND(SrcMiscData%outVizXYPlane,3)
  i4_l = LBOUND(SrcMiscData%outVizXYPlane,4)
  i4_u = UBOUND(SrcMiscData%outVizXYPlane,4)
  IF (.NOT. ALLOCATED(DstMiscData%outVizXYPlane)) THEN 
    ALLOCATE(DstMiscData%outVizXYPlane(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%outVizXYPlane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%outVizXYPlane = SrcMiscData%outVizXYPlane
ENDIF
IF (ALLOCATED(SrcMiscData%outVizYZPlane)) THEN
  i1_l = LBOUND(SrcMiscData%outVizYZPlane,1)
  i1_u = UBOUND(SrcMiscData%outVizYZPlane,1)
  i2_l = LBOUND(SrcMiscData%outVizYZPlane,2)
  i2_u = UBOUND(SrcMiscData%outVizYZPlane,2)
  i3_l = LBOUND(SrcMiscData%outVizYZPlane,3)
  i3_u = UBOUND(SrcMiscData%outVizYZPlane,3)
  i4_l = LBOUND(SrcMiscData%outVizYZPlane,4)
  i4_u = UBOUND(SrcMiscData%outVizYZPlane,4)
  IF (.NOT. ALLOCATED(DstMiscData%outVizYZPlane)) THEN 
    ALLOCATE(DstMiscData%outVizYZPlane(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%outVizYZPlane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%outVizYZPlane = SrcMiscData%outVizYZPlane
ENDIF
IF (ALLOCATED(SrcMiscData%outVizXZPlane)) THEN
  i1_l = LBOUND(SrcMiscData%outVizXZPlane,1)
  i1_u = UBOUND(SrcMiscData%outVizXZPlane,1)
  i2_l = LBOUND(SrcMiscData%outVizXZPlane,2)
  i2_u = UBOUND(SrcMiscData%outVizXZPlane,2)
  i3_l = LBOUND(SrcMiscData%outVizXZPlane,3)
  i3_u = UBOUND(SrcMiscData%outVizXZPlane,3)
  i4_l = LBOUND(SrcMiscData%outVizXZPlane,4)
  i4_u = UBOUND(SrcMiscData%outVizXZPlane,4)
  IF (.NOT. ALLOCATED(DstMiscData%outVizXZPlane)) THEN 
    ALLOCATE(DstMiscData%outVizXZPlane(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%outVizXZPlane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%outVizXZPlane = SrcMiscData%outVizXZPlane
ENDIF
IF (ALLOCATED(SrcMiscData%IfW)) THEN
  i1_l = LBOUND(SrcMiscData%IfW,1)
  i1_u = UBOUND(SrcMiscData%IfW,1)
  IF (.NOT. ALLOCATED(DstMiscData%IfW)) THEN 
    ALLOCATE(DstMiscData%IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%IfW,1), UBOUND(SrcMiscData%IfW,1)
      CALL InflowWind_CopyMisc( SrcMiscData%IfW(i1), DstMiscData%IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL InflowWind_CopyInput( SrcMiscData%u_IfW_Low, DstMiscData%u_IfW_Low, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyInput( SrcMiscData%u_IfW_High, DstMiscData%u_IfW_High, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyOutput( SrcMiscData%y_IfW_Low, DstMiscData%y_IfW_Low, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL InflowWind_CopyOutput( SrcMiscData%y_IfW_High, DstMiscData%y_IfW_High, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AWAE_CopyMisc

 SUBROUTINE AWAE_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(AWAE_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%Vamb_low)) THEN
  DEALLOCATE(MiscData%Vamb_low)
ENDIF
IF (ALLOCATED(MiscData%Vamb_lowpol)) THEN
  DEALLOCATE(MiscData%Vamb_lowpol)
ENDIF
IF (ALLOCATED(MiscData%Vdist_low)) THEN
  DEALLOCATE(MiscData%Vdist_low)
ENDIF
IF (ALLOCATED(MiscData%Vdist_low_full)) THEN
  DEALLOCATE(MiscData%Vdist_low_full)
ENDIF
IF (ALLOCATED(MiscData%Vamb_High)) THEN
DO i1 = LBOUND(MiscData%Vamb_High,1), UBOUND(MiscData%Vamb_High,1)
  CALL AWAE_DestroyHighWindGrid( MiscData%Vamb_High(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%Vamb_High)
ENDIF
IF (ALLOCATED(MiscData%parallelFlag)) THEN
  DEALLOCATE(MiscData%parallelFlag)
ENDIF
IF (ALLOCATED(MiscData%r_s)) THEN
  DEALLOCATE(MiscData%r_s)
ENDIF
IF (ALLOCATED(MiscData%r_e)) THEN
  DEALLOCATE(MiscData%r_e)
ENDIF
IF (ALLOCATED(MiscData%rhat_s)) THEN
  DEALLOCATE(MiscData%rhat_s)
ENDIF
IF (ALLOCATED(MiscData%rhat_e)) THEN
  DEALLOCATE(MiscData%rhat_e)
ENDIF
IF (ALLOCATED(MiscData%pvec_cs)) THEN
  DEALLOCATE(MiscData%pvec_cs)
ENDIF
IF (ALLOCATED(MiscData%pvec_ce)) THEN
  DEALLOCATE(MiscData%pvec_ce)
ENDIF
IF (ALLOCATED(MiscData%outVizXYPlane)) THEN
  DEALLOCATE(MiscData%outVizXYPlane)
ENDIF
IF (ALLOCATED(MiscData%outVizYZPlane)) THEN
  DEALLOCATE(MiscData%outVizYZPlane)
ENDIF
IF (ALLOCATED(MiscData%outVizXZPlane)) THEN
  DEALLOCATE(MiscData%outVizXZPlane)
ENDIF
IF (ALLOCATED(MiscData%IfW)) THEN
DO i1 = LBOUND(MiscData%IfW,1), UBOUND(MiscData%IfW,1)
  CALL InflowWind_DestroyMisc( MiscData%IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%IfW)
ENDIF
  CALL InflowWind_DestroyInput( MiscData%u_IfW_Low, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyInput( MiscData%u_IfW_High, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyOutput( MiscData%y_IfW_Low, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL InflowWind_DestroyOutput( MiscData%y_IfW_High, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AWAE_DestroyMisc


subroutine AWAE_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackMisc'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Vamb_low
   call RegPack(Buf, allocated(InData%Vamb_low))
   if (allocated(InData%Vamb_low)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vamb_low), ubound(InData%Vamb_low))
      call RegPack(Buf, InData%Vamb_low)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vamb_lowpol
   call RegPack(Buf, allocated(InData%Vamb_lowpol))
   if (allocated(InData%Vamb_lowpol)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vamb_lowpol), ubound(InData%Vamb_lowpol))
      call RegPack(Buf, InData%Vamb_lowpol)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vdist_low
   call RegPack(Buf, allocated(InData%Vdist_low))
   if (allocated(InData%Vdist_low)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vdist_low), ubound(InData%Vdist_low))
      call RegPack(Buf, InData%Vdist_low)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vdist_low_full
   call RegPack(Buf, allocated(InData%Vdist_low_full))
   if (allocated(InData%Vdist_low_full)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vdist_low_full), ubound(InData%Vdist_low_full))
      call RegPack(Buf, InData%Vdist_low_full)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vamb_High
   call RegPack(Buf, allocated(InData%Vamb_High))
   if (allocated(InData%Vamb_High)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vamb_High), ubound(InData%Vamb_High))
      LB(1:1) = lbound(InData%Vamb_High)
      UB(1:1) = ubound(InData%Vamb_High)
      do i1 = LB(1), UB(1)
         call AWAE_PackHighWindGrid(Buf, InData%Vamb_High(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! parallelFlag
   call RegPack(Buf, allocated(InData%parallelFlag))
   if (allocated(InData%parallelFlag)) then
      call RegPackBounds(Buf, 2, lbound(InData%parallelFlag), ubound(InData%parallelFlag))
      call RegPack(Buf, InData%parallelFlag)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_s
   call RegPack(Buf, allocated(InData%r_s))
   if (allocated(InData%r_s)) then
      call RegPackBounds(Buf, 2, lbound(InData%r_s), ubound(InData%r_s))
      call RegPack(Buf, InData%r_s)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_e
   call RegPack(Buf, allocated(InData%r_e))
   if (allocated(InData%r_e)) then
      call RegPackBounds(Buf, 2, lbound(InData%r_e), ubound(InData%r_e))
      call RegPack(Buf, InData%r_e)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rhat_s
   call RegPack(Buf, allocated(InData%rhat_s))
   if (allocated(InData%rhat_s)) then
      call RegPackBounds(Buf, 3, lbound(InData%rhat_s), ubound(InData%rhat_s))
      call RegPack(Buf, InData%rhat_s)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rhat_e
   call RegPack(Buf, allocated(InData%rhat_e))
   if (allocated(InData%rhat_e)) then
      call RegPackBounds(Buf, 3, lbound(InData%rhat_e), ubound(InData%rhat_e))
      call RegPack(Buf, InData%rhat_e)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! pvec_cs
   call RegPack(Buf, allocated(InData%pvec_cs))
   if (allocated(InData%pvec_cs)) then
      call RegPackBounds(Buf, 3, lbound(InData%pvec_cs), ubound(InData%pvec_cs))
      call RegPack(Buf, InData%pvec_cs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! pvec_ce
   call RegPack(Buf, allocated(InData%pvec_ce))
   if (allocated(InData%pvec_ce)) then
      call RegPackBounds(Buf, 3, lbound(InData%pvec_ce), ubound(InData%pvec_ce))
      call RegPack(Buf, InData%pvec_ce)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! outVizXYPlane
   call RegPack(Buf, allocated(InData%outVizXYPlane))
   if (allocated(InData%outVizXYPlane)) then
      call RegPackBounds(Buf, 4, lbound(InData%outVizXYPlane), ubound(InData%outVizXYPlane))
      call RegPack(Buf, InData%outVizXYPlane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! outVizYZPlane
   call RegPack(Buf, allocated(InData%outVizYZPlane))
   if (allocated(InData%outVizYZPlane)) then
      call RegPackBounds(Buf, 4, lbound(InData%outVizYZPlane), ubound(InData%outVizYZPlane))
      call RegPack(Buf, InData%outVizYZPlane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! outVizXZPlane
   call RegPack(Buf, allocated(InData%outVizXZPlane))
   if (allocated(InData%outVizXZPlane)) then
      call RegPackBounds(Buf, 4, lbound(InData%outVizXZPlane), ubound(InData%outVizXZPlane))
      call RegPack(Buf, InData%outVizXZPlane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IfW
   call RegPack(Buf, allocated(InData%IfW))
   if (allocated(InData%IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%IfW), ubound(InData%IfW))
      LB(1:1) = lbound(InData%IfW)
      UB(1:1) = ubound(InData%IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackMisc(Buf, InData%IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_IfW_Low
   call InflowWind_PackInput(Buf, InData%u_IfW_Low) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_IfW_High
   call InflowWind_PackInput(Buf, InData%u_IfW_High) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_IfW_Low
   call InflowWind_PackOutput(Buf, InData%y_IfW_Low) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_IfW_High
   call InflowWind_PackOutput(Buf, InData%y_IfW_High) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackMisc'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Vamb_low
   if (allocated(OutData%Vamb_low)) deallocate(OutData%Vamb_low)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vamb_low(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vamb_low.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vamb_low)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vamb_lowpol
   if (allocated(OutData%Vamb_lowpol)) deallocate(OutData%Vamb_lowpol)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vamb_lowpol(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vamb_lowpol.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vamb_lowpol)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vdist_low
   if (allocated(OutData%Vdist_low)) deallocate(OutData%Vdist_low)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vdist_low(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vdist_low.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vdist_low)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vdist_low_full
   if (allocated(OutData%Vdist_low_full)) deallocate(OutData%Vdist_low_full)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vdist_low_full(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vdist_low_full.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vdist_low_full)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vamb_High
   if (allocated(OutData%Vamb_High)) deallocate(OutData%Vamb_High)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vamb_High(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vamb_High.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AWAE_UnpackHighWindGrid(Buf, OutData%Vamb_High(i1)) ! Vamb_High 
      end do
   end if
   ! parallelFlag
   if (allocated(OutData%parallelFlag)) deallocate(OutData%parallelFlag)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%parallelFlag(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%parallelFlag.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%parallelFlag)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! r_s
   if (allocated(OutData%r_s)) deallocate(OutData%r_s)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_s(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_s.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_s)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! r_e
   if (allocated(OutData%r_e)) deallocate(OutData%r_e)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_e(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_e.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_e)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rhat_s
   if (allocated(OutData%rhat_s)) deallocate(OutData%rhat_s)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rhat_s(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rhat_s.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rhat_s)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rhat_e
   if (allocated(OutData%rhat_e)) deallocate(OutData%rhat_e)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rhat_e(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rhat_e.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rhat_e)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! pvec_cs
   if (allocated(OutData%pvec_cs)) deallocate(OutData%pvec_cs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%pvec_cs(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%pvec_cs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%pvec_cs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! pvec_ce
   if (allocated(OutData%pvec_ce)) deallocate(OutData%pvec_ce)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%pvec_ce(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%pvec_ce.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%pvec_ce)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! outVizXYPlane
   if (allocated(OutData%outVizXYPlane)) deallocate(OutData%outVizXYPlane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%outVizXYPlane(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%outVizXYPlane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%outVizXYPlane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! outVizYZPlane
   if (allocated(OutData%outVizYZPlane)) deallocate(OutData%outVizYZPlane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%outVizYZPlane(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%outVizYZPlane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%outVizYZPlane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! outVizXZPlane
   if (allocated(OutData%outVizXZPlane)) deallocate(OutData%outVizXZPlane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%outVizXZPlane(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%outVizXZPlane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%outVizXZPlane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IfW
   if (allocated(OutData%IfW)) deallocate(OutData%IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackMisc(Buf, OutData%IfW(i1)) ! IfW 
      end do
   end if
   ! u_IfW_Low
   call InflowWind_UnpackInput(Buf, OutData%u_IfW_Low) ! u_IfW_Low 
   ! u_IfW_High
   call InflowWind_UnpackInput(Buf, OutData%u_IfW_High) ! u_IfW_High 
   ! y_IfW_Low
   call InflowWind_UnpackOutput(Buf, OutData%y_IfW_Low) ! y_IfW_Low 
   ! y_IfW_High
   call InflowWind_UnpackOutput(Buf, OutData%y_IfW_High) ! y_IfW_High 
end subroutine
 SUBROUTINE AWAE_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AWAE_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%WindFilePath = SrcParamData%WindFilePath
    DstParamData%NumTurbines = SrcParamData%NumTurbines
    DstParamData%NumRadii = SrcParamData%NumRadii
    DstParamData%NumPlanes = SrcParamData%NumPlanes
IF (ALLOCATED(SrcParamData%y)) THEN
  i1_l = LBOUND(SrcParamData%y,1)
  i1_u = UBOUND(SrcParamData%y,1)
  IF (.NOT. ALLOCATED(DstParamData%y)) THEN 
    ALLOCATE(DstParamData%y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%y = SrcParamData%y
ENDIF
IF (ALLOCATED(SrcParamData%z)) THEN
  i1_l = LBOUND(SrcParamData%z,1)
  i1_u = UBOUND(SrcParamData%z,1)
  IF (.NOT. ALLOCATED(DstParamData%z)) THEN 
    ALLOCATE(DstParamData%z(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%z = SrcParamData%z
ENDIF
    DstParamData%Mod_AmbWind = SrcParamData%Mod_AmbWind
    DstParamData%nX_low = SrcParamData%nX_low
    DstParamData%nY_low = SrcParamData%nY_low
    DstParamData%nZ_low = SrcParamData%nZ_low
    DstParamData%NumGrid_low = SrcParamData%NumGrid_low
    DstParamData%n_rp_max = SrcParamData%n_rp_max
    DstParamData%dpol = SrcParamData%dpol
    DstParamData%dXYZ_low = SrcParamData%dXYZ_low
    DstParamData%dX_low = SrcParamData%dX_low
    DstParamData%dY_low = SrcParamData%dY_low
    DstParamData%dZ_low = SrcParamData%dZ_low
    DstParamData%X0_low = SrcParamData%X0_low
    DstParamData%Y0_low = SrcParamData%Y0_low
    DstParamData%Z0_low = SrcParamData%Z0_low
IF (ALLOCATED(SrcParamData%X0_high)) THEN
  i1_l = LBOUND(SrcParamData%X0_high,1)
  i1_u = UBOUND(SrcParamData%X0_high,1)
  IF (.NOT. ALLOCATED(DstParamData%X0_high)) THEN 
    ALLOCATE(DstParamData%X0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%X0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%X0_high = SrcParamData%X0_high
ENDIF
IF (ALLOCATED(SrcParamData%Y0_high)) THEN
  i1_l = LBOUND(SrcParamData%Y0_high,1)
  i1_u = UBOUND(SrcParamData%Y0_high,1)
  IF (.NOT. ALLOCATED(DstParamData%Y0_high)) THEN 
    ALLOCATE(DstParamData%Y0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Y0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Y0_high = SrcParamData%Y0_high
ENDIF
IF (ALLOCATED(SrcParamData%Z0_high)) THEN
  i1_l = LBOUND(SrcParamData%Z0_high,1)
  i1_u = UBOUND(SrcParamData%Z0_high,1)
  IF (.NOT. ALLOCATED(DstParamData%Z0_high)) THEN 
    ALLOCATE(DstParamData%Z0_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Z0_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Z0_high = SrcParamData%Z0_high
ENDIF
IF (ALLOCATED(SrcParamData%dX_high)) THEN
  i1_l = LBOUND(SrcParamData%dX_high,1)
  i1_u = UBOUND(SrcParamData%dX_high,1)
  IF (.NOT. ALLOCATED(DstParamData%dX_high)) THEN 
    ALLOCATE(DstParamData%dX_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dX_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dX_high = SrcParamData%dX_high
ENDIF
IF (ALLOCATED(SrcParamData%dY_high)) THEN
  i1_l = LBOUND(SrcParamData%dY_high,1)
  i1_u = UBOUND(SrcParamData%dY_high,1)
  IF (.NOT. ALLOCATED(DstParamData%dY_high)) THEN 
    ALLOCATE(DstParamData%dY_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dY_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dY_high = SrcParamData%dY_high
ENDIF
IF (ALLOCATED(SrcParamData%dZ_high)) THEN
  i1_l = LBOUND(SrcParamData%dZ_high,1)
  i1_u = UBOUND(SrcParamData%dZ_high,1)
  IF (.NOT. ALLOCATED(DstParamData%dZ_high)) THEN 
    ALLOCATE(DstParamData%dZ_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dZ_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dZ_high = SrcParamData%dZ_high
ENDIF
    DstParamData%nX_high = SrcParamData%nX_high
    DstParamData%nY_high = SrcParamData%nY_high
    DstParamData%nZ_high = SrcParamData%nZ_high
IF (ALLOCATED(SrcParamData%Grid_low)) THEN
  i1_l = LBOUND(SrcParamData%Grid_low,1)
  i1_u = UBOUND(SrcParamData%Grid_low,1)
  i2_l = LBOUND(SrcParamData%Grid_low,2)
  i2_u = UBOUND(SrcParamData%Grid_low,2)
  IF (.NOT. ALLOCATED(DstParamData%Grid_low)) THEN 
    ALLOCATE(DstParamData%Grid_low(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Grid_low.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Grid_low = SrcParamData%Grid_low
ENDIF
IF (ALLOCATED(SrcParamData%Grid_high)) THEN
  i1_l = LBOUND(SrcParamData%Grid_high,1)
  i1_u = UBOUND(SrcParamData%Grid_high,1)
  i2_l = LBOUND(SrcParamData%Grid_high,2)
  i2_u = UBOUND(SrcParamData%Grid_high,2)
  i3_l = LBOUND(SrcParamData%Grid_high,3)
  i3_u = UBOUND(SrcParamData%Grid_high,3)
  IF (.NOT. ALLOCATED(DstParamData%Grid_high)) THEN 
    ALLOCATE(DstParamData%Grid_high(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Grid_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Grid_high = SrcParamData%Grid_high
ENDIF
IF (ALLOCATED(SrcParamData%WT_Position)) THEN
  i1_l = LBOUND(SrcParamData%WT_Position,1)
  i1_u = UBOUND(SrcParamData%WT_Position,1)
  i2_l = LBOUND(SrcParamData%WT_Position,2)
  i2_u = UBOUND(SrcParamData%WT_Position,2)
  IF (.NOT. ALLOCATED(DstParamData%WT_Position)) THEN 
    ALLOCATE(DstParamData%WT_Position(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WT_Position.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WT_Position = SrcParamData%WT_Position
ENDIF
    DstParamData%n_high_low = SrcParamData%n_high_low
    DstParamData%dt_low = SrcParamData%dt_low
    DstParamData%dt_high = SrcParamData%dt_high
    DstParamData%NumDT = SrcParamData%NumDT
    DstParamData%Mod_Meander = SrcParamData%Mod_Meander
    DstParamData%C_Meander = SrcParamData%C_Meander
    DstParamData%C_ScaleDiam = SrcParamData%C_ScaleDiam
    DstParamData%Mod_Projection = SrcParamData%Mod_Projection
IF (ALLOCATED(SrcParamData%IfW)) THEN
  i1_l = LBOUND(SrcParamData%IfW,1)
  i1_u = UBOUND(SrcParamData%IfW,1)
  IF (.NOT. ALLOCATED(DstParamData%IfW)) THEN 
    ALLOCATE(DstParamData%IfW(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IfW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%IfW,1), UBOUND(SrcParamData%IfW,1)
      CALL InflowWind_CopyParam( SrcParamData%IfW(i1), DstParamData%IfW(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%WrDisSkp1 = SrcParamData%WrDisSkp1
    DstParamData%WrDisWind = SrcParamData%WrDisWind
    DstParamData%NOutDisWindXY = SrcParamData%NOutDisWindXY
IF (ALLOCATED(SrcParamData%OutDisWindZ)) THEN
  i1_l = LBOUND(SrcParamData%OutDisWindZ,1)
  i1_u = UBOUND(SrcParamData%OutDisWindZ,1)
  IF (.NOT. ALLOCATED(DstParamData%OutDisWindZ)) THEN 
    ALLOCATE(DstParamData%OutDisWindZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutDisWindZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%OutDisWindZ = SrcParamData%OutDisWindZ
ENDIF
    DstParamData%NOutDisWindYZ = SrcParamData%NOutDisWindYZ
IF (ALLOCATED(SrcParamData%OutDisWindX)) THEN
  i1_l = LBOUND(SrcParamData%OutDisWindX,1)
  i1_u = UBOUND(SrcParamData%OutDisWindX,1)
  IF (.NOT. ALLOCATED(DstParamData%OutDisWindX)) THEN 
    ALLOCATE(DstParamData%OutDisWindX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutDisWindX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%OutDisWindX = SrcParamData%OutDisWindX
ENDIF
    DstParamData%NOutDisWindXZ = SrcParamData%NOutDisWindXZ
IF (ALLOCATED(SrcParamData%OutDisWindY)) THEN
  i1_l = LBOUND(SrcParamData%OutDisWindY,1)
  i1_u = UBOUND(SrcParamData%OutDisWindY,1)
  IF (.NOT. ALLOCATED(DstParamData%OutDisWindY)) THEN 
    ALLOCATE(DstParamData%OutDisWindY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutDisWindY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%OutDisWindY = SrcParamData%OutDisWindY
ENDIF
    DstParamData%OutFileRoot = SrcParamData%OutFileRoot
    DstParamData%OutFileVTKRoot = SrcParamData%OutFileVTKRoot
    DstParamData%VTK_tWidth = SrcParamData%VTK_tWidth
 END SUBROUTINE AWAE_CopyParam

 SUBROUTINE AWAE_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(AWAE_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%y)) THEN
  DEALLOCATE(ParamData%y)
ENDIF
IF (ALLOCATED(ParamData%z)) THEN
  DEALLOCATE(ParamData%z)
ENDIF
IF (ALLOCATED(ParamData%X0_high)) THEN
  DEALLOCATE(ParamData%X0_high)
ENDIF
IF (ALLOCATED(ParamData%Y0_high)) THEN
  DEALLOCATE(ParamData%Y0_high)
ENDIF
IF (ALLOCATED(ParamData%Z0_high)) THEN
  DEALLOCATE(ParamData%Z0_high)
ENDIF
IF (ALLOCATED(ParamData%dX_high)) THEN
  DEALLOCATE(ParamData%dX_high)
ENDIF
IF (ALLOCATED(ParamData%dY_high)) THEN
  DEALLOCATE(ParamData%dY_high)
ENDIF
IF (ALLOCATED(ParamData%dZ_high)) THEN
  DEALLOCATE(ParamData%dZ_high)
ENDIF
IF (ALLOCATED(ParamData%Grid_low)) THEN
  DEALLOCATE(ParamData%Grid_low)
ENDIF
IF (ALLOCATED(ParamData%Grid_high)) THEN
  DEALLOCATE(ParamData%Grid_high)
ENDIF
IF (ALLOCATED(ParamData%WT_Position)) THEN
  DEALLOCATE(ParamData%WT_Position)
ENDIF
IF (ALLOCATED(ParamData%IfW)) THEN
DO i1 = LBOUND(ParamData%IfW,1), UBOUND(ParamData%IfW,1)
  CALL InflowWind_DestroyParam( ParamData%IfW(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%IfW)
ENDIF
IF (ALLOCATED(ParamData%OutDisWindZ)) THEN
  DEALLOCATE(ParamData%OutDisWindZ)
ENDIF
IF (ALLOCATED(ParamData%OutDisWindX)) THEN
  DEALLOCATE(ParamData%OutDisWindX)
ENDIF
IF (ALLOCATED(ParamData%OutDisWindY)) THEN
  DEALLOCATE(ParamData%OutDisWindY)
ENDIF
 END SUBROUTINE AWAE_DestroyParam


subroutine AWAE_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackParam'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   if (Buf%ErrStat >= AbortErrLev) return
   ! WindFilePath
   call RegPack(Buf, InData%WindFilePath)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTurbines
   call RegPack(Buf, InData%NumTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegPack(Buf, InData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegPack(Buf, InData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call RegPack(Buf, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(Buf, 1, lbound(InData%y), ubound(InData%y))
      call RegPack(Buf, InData%y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   call RegPack(Buf, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(Buf, 1, lbound(InData%z), ubound(InData%z))
      call RegPack(Buf, InData%z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_AmbWind
   call RegPack(Buf, InData%Mod_AmbWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_low
   call RegPack(Buf, InData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_low
   call RegPack(Buf, InData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_low
   call RegPack(Buf, InData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumGrid_low
   call RegPack(Buf, InData%NumGrid_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_rp_max
   call RegPack(Buf, InData%n_rp_max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dpol
   call RegPack(Buf, InData%dpol)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dXYZ_low
   call RegPack(Buf, InData%dXYZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_low
   call RegPack(Buf, InData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_low
   call RegPack(Buf, InData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_low
   call RegPack(Buf, InData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_low
   call RegPack(Buf, InData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_low
   call RegPack(Buf, InData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_low
   call RegPack(Buf, InData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_high
   call RegPack(Buf, allocated(InData%X0_high))
   if (allocated(InData%X0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%X0_high), ubound(InData%X0_high))
      call RegPack(Buf, InData%X0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_high
   call RegPack(Buf, allocated(InData%Y0_high))
   if (allocated(InData%Y0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Y0_high), ubound(InData%Y0_high))
      call RegPack(Buf, InData%Y0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_high
   call RegPack(Buf, allocated(InData%Z0_high))
   if (allocated(InData%Z0_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Z0_high), ubound(InData%Z0_high))
      call RegPack(Buf, InData%Z0_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_high
   call RegPack(Buf, allocated(InData%dX_high))
   if (allocated(InData%dX_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dX_high), ubound(InData%dX_high))
      call RegPack(Buf, InData%dX_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_high
   call RegPack(Buf, allocated(InData%dY_high))
   if (allocated(InData%dY_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dY_high), ubound(InData%dY_high))
      call RegPack(Buf, InData%dY_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_high
   call RegPack(Buf, allocated(InData%dZ_high))
   if (allocated(InData%dZ_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%dZ_high), ubound(InData%dZ_high))
      call RegPack(Buf, InData%dZ_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_high
   call RegPack(Buf, InData%nX_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_high
   call RegPack(Buf, InData%nY_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_high
   call RegPack(Buf, InData%nZ_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Grid_low
   call RegPack(Buf, allocated(InData%Grid_low))
   if (allocated(InData%Grid_low)) then
      call RegPackBounds(Buf, 2, lbound(InData%Grid_low), ubound(InData%Grid_low))
      call RegPack(Buf, InData%Grid_low)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Grid_high
   call RegPack(Buf, allocated(InData%Grid_high))
   if (allocated(InData%Grid_high)) then
      call RegPackBounds(Buf, 3, lbound(InData%Grid_high), ubound(InData%Grid_high))
      call RegPack(Buf, InData%Grid_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WT_Position
   call RegPack(Buf, allocated(InData%WT_Position))
   if (allocated(InData%WT_Position)) then
      call RegPackBounds(Buf, 2, lbound(InData%WT_Position), ubound(InData%WT_Position))
      call RegPack(Buf, InData%WT_Position)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_high_low
   call RegPack(Buf, InData%n_high_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_low
   call RegPack(Buf, InData%dt_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_high
   call RegPack(Buf, InData%dt_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumDT
   call RegPack(Buf, InData%NumDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Meander
   call RegPack(Buf, InData%Mod_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Meander
   call RegPack(Buf, InData%C_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_ScaleDiam
   call RegPack(Buf, InData%C_ScaleDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Projection
   call RegPack(Buf, InData%Mod_Projection)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IfW
   call RegPack(Buf, allocated(InData%IfW))
   if (allocated(InData%IfW)) then
      call RegPackBounds(Buf, 1, lbound(InData%IfW), ubound(InData%IfW))
      LB(1:1) = lbound(InData%IfW)
      UB(1:1) = ubound(InData%IfW)
      do i1 = LB(1), UB(1)
         call InflowWind_PackParam(Buf, InData%IfW(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrDisSkp1
   call RegPack(Buf, InData%WrDisSkp1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrDisWind
   call RegPack(Buf, InData%WrDisWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindXY
   call RegPack(Buf, InData%NOutDisWindXY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindZ
   call RegPack(Buf, allocated(InData%OutDisWindZ))
   if (allocated(InData%OutDisWindZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDisWindZ), ubound(InData%OutDisWindZ))
      call RegPack(Buf, InData%OutDisWindZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindYZ
   call RegPack(Buf, InData%NOutDisWindYZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindX
   call RegPack(Buf, allocated(InData%OutDisWindX))
   if (allocated(InData%OutDisWindX)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDisWindX), ubound(InData%OutDisWindX))
      call RegPack(Buf, InData%OutDisWindX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindXZ
   call RegPack(Buf, InData%NOutDisWindXZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindY
   call RegPack(Buf, allocated(InData%OutDisWindY))
   if (allocated(InData%OutDisWindY)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutDisWindY), ubound(InData%OutDisWindY))
      call RegPack(Buf, InData%OutDisWindY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegPack(Buf, InData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileVTKRoot
   call RegPack(Buf, InData%OutFileVTKRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_tWidth
   call RegPack(Buf, InData%VTK_tWidth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackParam'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WindFilePath
   call RegUnpack(Buf, OutData%WindFilePath)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTurbines
   call RegUnpack(Buf, OutData%NumTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegUnpack(Buf, OutData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegUnpack(Buf, OutData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! z
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Mod_AmbWind
   call RegUnpack(Buf, OutData%Mod_AmbWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nX_low
   call RegUnpack(Buf, OutData%nX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_low
   call RegUnpack(Buf, OutData%nY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_low
   call RegUnpack(Buf, OutData%nZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumGrid_low
   call RegUnpack(Buf, OutData%NumGrid_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! n_rp_max
   call RegUnpack(Buf, OutData%n_rp_max)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dpol
   call RegUnpack(Buf, OutData%dpol)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dXYZ_low
   call RegUnpack(Buf, OutData%dXYZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dX_low
   call RegUnpack(Buf, OutData%dX_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dY_low
   call RegUnpack(Buf, OutData%dY_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dZ_low
   call RegUnpack(Buf, OutData%dZ_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_low
   call RegUnpack(Buf, OutData%X0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y0_low
   call RegUnpack(Buf, OutData%Y0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0_low
   call RegUnpack(Buf, OutData%Z0_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X0_high
   if (allocated(OutData%X0_high)) deallocate(OutData%X0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Y0_high
   if (allocated(OutData%Y0_high)) deallocate(OutData%Y0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Z0_high
   if (allocated(OutData%Z0_high)) deallocate(OutData%Z0_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Z0_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z0_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Z0_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dX_high
   if (allocated(OutData%dX_high)) deallocate(OutData%dX_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dX_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dX_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dX_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dY_high
   if (allocated(OutData%dY_high)) deallocate(OutData%dY_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dY_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dY_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dY_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dZ_high
   if (allocated(OutData%dZ_high)) deallocate(OutData%dZ_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dZ_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dZ_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dZ_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nX_high
   call RegUnpack(Buf, OutData%nX_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nY_high
   call RegUnpack(Buf, OutData%nY_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nZ_high
   call RegUnpack(Buf, OutData%nZ_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Grid_low
   if (allocated(OutData%Grid_low)) deallocate(OutData%Grid_low)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Grid_low(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Grid_low.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Grid_low)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Grid_high
   if (allocated(OutData%Grid_high)) deallocate(OutData%Grid_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Grid_high(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Grid_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Grid_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WT_Position
   if (allocated(OutData%WT_Position)) deallocate(OutData%WT_Position)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WT_Position(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WT_Position.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WT_Position)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! n_high_low
   call RegUnpack(Buf, OutData%n_high_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_low
   call RegUnpack(Buf, OutData%dt_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dt_high
   call RegUnpack(Buf, OutData%dt_high)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumDT
   call RegUnpack(Buf, OutData%NumDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Meander
   call RegUnpack(Buf, OutData%Mod_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_Meander
   call RegUnpack(Buf, OutData%C_Meander)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_ScaleDiam
   call RegUnpack(Buf, OutData%C_ScaleDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Projection
   call RegUnpack(Buf, OutData%Mod_Projection)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IfW
   if (allocated(OutData%IfW)) deallocate(OutData%IfW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IfW(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IfW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call InflowWind_UnpackParam(Buf, OutData%IfW(i1)) ! IfW 
      end do
   end if
   ! WrDisSkp1
   call RegUnpack(Buf, OutData%WrDisSkp1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrDisWind
   call RegUnpack(Buf, OutData%WrDisWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutDisWindXY
   call RegUnpack(Buf, OutData%NOutDisWindXY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindZ
   if (allocated(OutData%OutDisWindZ)) deallocate(OutData%OutDisWindZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDisWindZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDisWindZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDisWindZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NOutDisWindYZ
   call RegUnpack(Buf, OutData%NOutDisWindYZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindX
   if (allocated(OutData%OutDisWindX)) deallocate(OutData%OutDisWindX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDisWindX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDisWindX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDisWindX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NOutDisWindXZ
   call RegUnpack(Buf, OutData%NOutDisWindXZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDisWindY
   if (allocated(OutData%OutDisWindY)) deallocate(OutData%OutDisWindY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutDisWindY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutDisWindY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutDisWindY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OutFileRoot
   call RegUnpack(Buf, OutData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileVTKRoot
   call RegUnpack(Buf, OutData%OutFileVTKRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_tWidth
   call RegUnpack(Buf, OutData%VTK_tWidth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AWAE_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(AWAE_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Vdist_High)) THEN
  i1_l = LBOUND(SrcOutputData%Vdist_High,1)
  i1_u = UBOUND(SrcOutputData%Vdist_High,1)
  IF (.NOT. ALLOCATED(DstOutputData%Vdist_High)) THEN 
    ALLOCATE(DstOutputData%Vdist_High(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vdist_High.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%Vdist_High,1), UBOUND(SrcOutputData%Vdist_High,1)
      CALL AWAE_Copyhighwindgrid( SrcOutputData%Vdist_High(i1), DstOutputData%Vdist_High(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%V_plane)) THEN
  i1_l = LBOUND(SrcOutputData%V_plane,1)
  i1_u = UBOUND(SrcOutputData%V_plane,1)
  i2_l = LBOUND(SrcOutputData%V_plane,2)
  i2_u = UBOUND(SrcOutputData%V_plane,2)
  i3_l = LBOUND(SrcOutputData%V_plane,3)
  i3_u = UBOUND(SrcOutputData%V_plane,3)
  IF (.NOT. ALLOCATED(DstOutputData%V_plane)) THEN 
    ALLOCATE(DstOutputData%V_plane(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%V_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%V_plane = SrcOutputData%V_plane
ENDIF
IF (ALLOCATED(SrcOutputData%TI_amb)) THEN
  i1_l = LBOUND(SrcOutputData%TI_amb,1)
  i1_u = UBOUND(SrcOutputData%TI_amb,1)
  IF (.NOT. ALLOCATED(DstOutputData%TI_amb)) THEN 
    ALLOCATE(DstOutputData%TI_amb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%TI_amb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%TI_amb = SrcOutputData%TI_amb
ENDIF
IF (ALLOCATED(SrcOutputData%Vx_wind_disk)) THEN
  i1_l = LBOUND(SrcOutputData%Vx_wind_disk,1)
  i1_u = UBOUND(SrcOutputData%Vx_wind_disk,1)
  IF (.NOT. ALLOCATED(DstOutputData%Vx_wind_disk)) THEN 
    ALLOCATE(DstOutputData%Vx_wind_disk(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vx_wind_disk.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vx_wind_disk = SrcOutputData%Vx_wind_disk
ENDIF
 END SUBROUTINE AWAE_CopyOutput

 SUBROUTINE AWAE_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(AWAE_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%Vdist_High)) THEN
DO i1 = LBOUND(OutputData%Vdist_High,1), UBOUND(OutputData%Vdist_High,1)
  CALL AWAE_DestroyHighWindGrid( OutputData%Vdist_High(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%Vdist_High)
ENDIF
IF (ALLOCATED(OutputData%V_plane)) THEN
  DEALLOCATE(OutputData%V_plane)
ENDIF
IF (ALLOCATED(OutputData%TI_amb)) THEN
  DEALLOCATE(OutputData%TI_amb)
ENDIF
IF (ALLOCATED(OutputData%Vx_wind_disk)) THEN
  DEALLOCATE(OutputData%Vx_wind_disk)
ENDIF
 END SUBROUTINE AWAE_DestroyOutput


subroutine AWAE_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackOutput'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Vdist_High
   call RegPack(Buf, allocated(InData%Vdist_High))
   if (allocated(InData%Vdist_High)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vdist_High), ubound(InData%Vdist_High))
      LB(1:1) = lbound(InData%Vdist_High)
      UB(1:1) = ubound(InData%Vdist_High)
      do i1 = LB(1), UB(1)
         call AWAE_PackHighWindGrid(Buf, InData%Vdist_High(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_plane
   call RegPack(Buf, allocated(InData%V_plane))
   if (allocated(InData%V_plane)) then
      call RegPackBounds(Buf, 3, lbound(InData%V_plane), ubound(InData%V_plane))
      call RegPack(Buf, InData%V_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI_amb
   call RegPack(Buf, allocated(InData%TI_amb))
   if (allocated(InData%TI_amb)) then
      call RegPackBounds(Buf, 1, lbound(InData%TI_amb), ubound(InData%TI_amb))
      call RegPack(Buf, InData%TI_amb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wind_disk
   call RegPack(Buf, allocated(InData%Vx_wind_disk))
   if (allocated(InData%Vx_wind_disk)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vx_wind_disk), ubound(InData%Vx_wind_disk))
      call RegPack(Buf, InData%Vx_wind_disk)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackOutput'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Vdist_High
   if (allocated(OutData%Vdist_High)) deallocate(OutData%Vdist_High)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vdist_High(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vdist_High.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AWAE_UnpackHighWindGrid(Buf, OutData%Vdist_High(i1)) ! Vdist_High 
      end do
   end if
   ! V_plane
   if (allocated(OutData%V_plane)) deallocate(OutData%V_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%V_plane(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%V_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%V_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TI_amb
   if (allocated(OutData%TI_amb)) deallocate(OutData%TI_amb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TI_amb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TI_amb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TI_amb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wind_disk
   if (allocated(OutData%Vx_wind_disk)) deallocate(OutData%Vx_wind_disk)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wind_disk(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wind_disk.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wind_disk)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AWAE_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AWAE_InputType), INTENT(IN) :: SrcInputData
   TYPE(AWAE_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AWAE_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%xhat_plane)) THEN
  i1_l = LBOUND(SrcInputData%xhat_plane,1)
  i1_u = UBOUND(SrcInputData%xhat_plane,1)
  i2_l = LBOUND(SrcInputData%xhat_plane,2)
  i2_u = UBOUND(SrcInputData%xhat_plane,2)
  i3_l = LBOUND(SrcInputData%xhat_plane,3)
  i3_u = UBOUND(SrcInputData%xhat_plane,3)
  IF (.NOT. ALLOCATED(DstInputData%xhat_plane)) THEN 
    ALLOCATE(DstInputData%xhat_plane(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%xhat_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%xhat_plane = SrcInputData%xhat_plane
ENDIF
IF (ALLOCATED(SrcInputData%p_plane)) THEN
  i1_l = LBOUND(SrcInputData%p_plane,1)
  i1_u = UBOUND(SrcInputData%p_plane,1)
  i2_l = LBOUND(SrcInputData%p_plane,2)
  i2_u = UBOUND(SrcInputData%p_plane,2)
  i3_l = LBOUND(SrcInputData%p_plane,3)
  i3_u = UBOUND(SrcInputData%p_plane,3)
  IF (.NOT. ALLOCATED(DstInputData%p_plane)) THEN 
    ALLOCATE(DstInputData%p_plane(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%p_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%p_plane = SrcInputData%p_plane
ENDIF
IF (ALLOCATED(SrcInputData%Vx_wake)) THEN
  i1_l = LBOUND(SrcInputData%Vx_wake,1)
  i1_u = UBOUND(SrcInputData%Vx_wake,1)
  i2_l = LBOUND(SrcInputData%Vx_wake,2)
  i2_u = UBOUND(SrcInputData%Vx_wake,2)
  i3_l = LBOUND(SrcInputData%Vx_wake,3)
  i3_u = UBOUND(SrcInputData%Vx_wake,3)
  i4_l = LBOUND(SrcInputData%Vx_wake,4)
  i4_u = UBOUND(SrcInputData%Vx_wake,4)
  IF (.NOT. ALLOCATED(DstInputData%Vx_wake)) THEN 
    ALLOCATE(DstInputData%Vx_wake(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vx_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Vx_wake = SrcInputData%Vx_wake
ENDIF
IF (ALLOCATED(SrcInputData%Vy_wake)) THEN
  i1_l = LBOUND(SrcInputData%Vy_wake,1)
  i1_u = UBOUND(SrcInputData%Vy_wake,1)
  i2_l = LBOUND(SrcInputData%Vy_wake,2)
  i2_u = UBOUND(SrcInputData%Vy_wake,2)
  i3_l = LBOUND(SrcInputData%Vy_wake,3)
  i3_u = UBOUND(SrcInputData%Vy_wake,3)
  i4_l = LBOUND(SrcInputData%Vy_wake,4)
  i4_u = UBOUND(SrcInputData%Vy_wake,4)
  IF (.NOT. ALLOCATED(DstInputData%Vy_wake)) THEN 
    ALLOCATE(DstInputData%Vy_wake(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vy_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Vy_wake = SrcInputData%Vy_wake
ENDIF
IF (ALLOCATED(SrcInputData%Vz_wake)) THEN
  i1_l = LBOUND(SrcInputData%Vz_wake,1)
  i1_u = UBOUND(SrcInputData%Vz_wake,1)
  i2_l = LBOUND(SrcInputData%Vz_wake,2)
  i2_u = UBOUND(SrcInputData%Vz_wake,2)
  i3_l = LBOUND(SrcInputData%Vz_wake,3)
  i3_u = UBOUND(SrcInputData%Vz_wake,3)
  i4_l = LBOUND(SrcInputData%Vz_wake,4)
  i4_u = UBOUND(SrcInputData%Vz_wake,4)
  IF (.NOT. ALLOCATED(DstInputData%Vz_wake)) THEN 
    ALLOCATE(DstInputData%Vz_wake(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vz_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Vz_wake = SrcInputData%Vz_wake
ENDIF
IF (ALLOCATED(SrcInputData%D_wake)) THEN
  i1_l = LBOUND(SrcInputData%D_wake,1)
  i1_u = UBOUND(SrcInputData%D_wake,1)
  i2_l = LBOUND(SrcInputData%D_wake,2)
  i2_u = UBOUND(SrcInputData%D_wake,2)
  IF (.NOT. ALLOCATED(DstInputData%D_wake)) THEN 
    ALLOCATE(DstInputData%D_wake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%D_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%D_wake = SrcInputData%D_wake
ENDIF
IF (ALLOCATED(SrcInputData%WAT_k_mt)) THEN
  i1_l = LBOUND(SrcInputData%WAT_k_mt,1)
  i1_u = UBOUND(SrcInputData%WAT_k_mt,1)
  i2_l = LBOUND(SrcInputData%WAT_k_mt,2)
  i2_u = UBOUND(SrcInputData%WAT_k_mt,2)
  i3_l = LBOUND(SrcInputData%WAT_k_mt,3)
  i3_u = UBOUND(SrcInputData%WAT_k_mt,3)
  IF (.NOT. ALLOCATED(DstInputData%WAT_k_mt)) THEN 
    ALLOCATE(DstInputData%WAT_k_mt(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%WAT_k_mt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%WAT_k_mt = SrcInputData%WAT_k_mt
ENDIF
 END SUBROUTINE AWAE_CopyInput

 SUBROUTINE AWAE_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(AWAE_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AWAE_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%xhat_plane)) THEN
  DEALLOCATE(InputData%xhat_plane)
ENDIF
IF (ALLOCATED(InputData%p_plane)) THEN
  DEALLOCATE(InputData%p_plane)
ENDIF
IF (ALLOCATED(InputData%Vx_wake)) THEN
  DEALLOCATE(InputData%Vx_wake)
ENDIF
IF (ALLOCATED(InputData%Vy_wake)) THEN
  DEALLOCATE(InputData%Vy_wake)
ENDIF
IF (ALLOCATED(InputData%Vz_wake)) THEN
  DEALLOCATE(InputData%Vz_wake)
ENDIF
IF (ALLOCATED(InputData%D_wake)) THEN
  DEALLOCATE(InputData%D_wake)
ENDIF
IF (ALLOCATED(InputData%WAT_k_mt)) THEN
  DEALLOCATE(InputData%WAT_k_mt)
ENDIF
 END SUBROUTINE AWAE_DestroyInput


subroutine AWAE_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AWAE_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AWAE_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! xhat_plane
   call RegPack(Buf, allocated(InData%xhat_plane))
   if (allocated(InData%xhat_plane)) then
      call RegPackBounds(Buf, 3, lbound(InData%xhat_plane), ubound(InData%xhat_plane))
      call RegPack(Buf, InData%xhat_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_plane
   call RegPack(Buf, allocated(InData%p_plane))
   if (allocated(InData%p_plane)) then
      call RegPackBounds(Buf, 3, lbound(InData%p_plane), ubound(InData%p_plane))
      call RegPack(Buf, InData%p_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wake
   call RegPack(Buf, allocated(InData%Vx_wake))
   if (allocated(InData%Vx_wake)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vx_wake), ubound(InData%Vx_wake))
      call RegPack(Buf, InData%Vx_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vy_wake
   call RegPack(Buf, allocated(InData%Vy_wake))
   if (allocated(InData%Vy_wake)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vy_wake), ubound(InData%Vy_wake))
      call RegPack(Buf, InData%Vy_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vz_wake
   call RegPack(Buf, allocated(InData%Vz_wake))
   if (allocated(InData%Vz_wake)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vz_wake), ubound(InData%Vz_wake))
      call RegPack(Buf, InData%Vz_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D_wake
   call RegPack(Buf, allocated(InData%D_wake))
   if (allocated(InData%D_wake)) then
      call RegPackBounds(Buf, 2, lbound(InData%D_wake), ubound(InData%D_wake))
      call RegPack(Buf, InData%D_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_mt
   call RegPack(Buf, allocated(InData%WAT_k_mt))
   if (allocated(InData%WAT_k_mt)) then
      call RegPackBounds(Buf, 3, lbound(InData%WAT_k_mt), ubound(InData%WAT_k_mt))
      call RegPack(Buf, InData%WAT_k_mt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AWAE_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AWAE_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AWAE_UnPackInput'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! xhat_plane
   if (allocated(OutData%xhat_plane)) deallocate(OutData%xhat_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xhat_plane(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xhat_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%xhat_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! p_plane
   if (allocated(OutData%p_plane)) deallocate(OutData%p_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%p_plane(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%p_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wake
   if (allocated(OutData%Vx_wake)) deallocate(OutData%Vx_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wake(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vy_wake
   if (allocated(OutData%Vy_wake)) deallocate(OutData%Vy_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vy_wake(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vy_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vy_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vz_wake
   if (allocated(OutData%Vz_wake)) deallocate(OutData%Vz_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vz_wake(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vz_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vz_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D_wake
   if (allocated(OutData%D_wake)) deallocate(OutData%D_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D_wake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WAT_k_mt
   if (allocated(OutData%WAT_k_mt)) deallocate(OutData%WAT_k_mt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAT_k_mt(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAT_k_mt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WAT_k_mt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
END MODULE AWAE_Types
!ENDOFREGISTRYGENERATEDFILE
