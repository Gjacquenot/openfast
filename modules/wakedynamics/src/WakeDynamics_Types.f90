!STARTOFREGISTRYGENERATEDFILE 'WakeDynamics_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! WakeDynamics_Types
!.................................................................................................................................
! This file is part of WakeDynamics.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in WakeDynamics. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE WakeDynamics_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeDiamMod_RotDiam = 1      ! Wake diameter calculation model: rotor diameter [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeDiamMod_Velocity = 2      ! Wake diameter calculation model: velocity-based [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeDiamMod_MassFlux = 3      ! Wake diameter calculation model: mass-flux based [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeDiamMod_MtmFlux = 4      ! Wake diameter calculation model: momentum-flux based [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Mod_Wake_Polar = 1      ! Wake model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Mod_Wake_Curl = 2      ! Wake model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Mod_Wake_Cartesian = 3      ! Wake model [-]
! =========  WD_InputFileType  =======
  TYPE, PUBLIC :: WD_InputFileType
    REAL(ReKi)  :: dr      !< Radial increment of radial finite-difference grid [>0.0] [m]
    INTEGER(IntKi)  :: NumRadii      !< Number of radii in the radial finite-difference grid [>=2] [-]
    INTEGER(IntKi)  :: NumPlanes      !< Number of wake planes [>=2] [-]
    INTEGER(IntKi)  :: Mod_Wake      !< Switch between wake formulations 1=Polar, 2=Cartesian, 3=Curl [-]
    REAL(ReKi)  :: f_c      !< Cut-off frequency of the low-pass time-filter for the wake advection, deflection, and meandering model [>0.0] [Hz]
    REAL(ReKi)  :: C_HWkDfl_O      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor [m]
    REAL(ReKi)  :: C_HWkDfl_OY      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor scaled with yaw error [m/rad]
    REAL(ReKi)  :: C_HWkDfl_x      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance [-]
    REAL(ReKi)  :: C_HWkDfl_xY      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance and yaw error [1/rad]
    REAL(ReKi)  :: C_NearWake      !< Calibrated parameter for the near-wake correction [>-1.0] [-]
    REAL(ReKi)  :: k_vAmb      !< Calibrated parameter for the influence of ambient turbulence in the eddy viscosity [>=0.0] [-]
    REAL(ReKi)  :: k_vShr      !< Calibrated parameter for the influence of the shear layer in the eddy viscosity [>=0.0] [-]
    REAL(ReKi)  :: C_vAmb_DMin      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the minimum and exponential regions [>=0.0 ] [-]
    REAL(ReKi)  :: C_vAmb_DMax      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the exponential and maximum regions [> C_vAmb_DMin] [-]
    REAL(ReKi)  :: C_vAmb_FMin      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the value in the minimum region [>=0.0 and <=1.0] [-]
    REAL(ReKi)  :: C_vAmb_Exp      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the exponent in the exponential region [> 0.0] [-]
    REAL(ReKi)  :: C_vShr_DMin      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the minimum and exponential regions [>=0.0] [-]
    REAL(ReKi)  :: C_vShr_DMax      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the exponential and maximum regions [> C_vShr_DMin] [-]
    REAL(ReKi)  :: C_vShr_FMin      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the value in the minimum region [>=0.0 and <=1.0] [-]
    REAL(ReKi)  :: C_vShr_Exp      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the exponent in the exponential region [> 0.0] [-]
    INTEGER(IntKi)  :: Mod_WakeDiam      !< Wake diameter calculation model {1: rotor diameter, 2: velocity-based, 3: mass-flux based, 4: momentum-flux based} [DEFAULT=1] [-]
    REAL(ReKi)  :: C_WakeDiam      !< Calibrated parameter for wake diameter calculation [>0.0 and <1.0] [unused for Mod_WakeDiam=1] [-]
    LOGICAL  :: Swirl      !< Switch to add swirl [only used if Mod_Wake=2 or 2] [-]
    REAL(ReKi)  :: k_VortexDecay      !< Vortex decay constant for curl [-]
    REAL(ReKi)  :: sigma_D      !< The width of the Gaussian vortices used for the curled wake model divided by diameter [-]
    INTEGER(IntKi)  :: NumVortices      !< The number of vortices used for the curled wake model [-]
    INTEGER(IntKi)  :: FilterInit      !< Switch to filter the initial wake plane deficit and select the number of grid points for the filter {0: no filter, 1: filter of size 1} or DEFAULT [DEFAULT=0: if Mod_Wake is 1 or 3, or DEFAULT=2: if Mod_Wwake is 2] (switch) [-]
    REAL(ReKi)  :: k_vCurl      !< Calibrated parameter for the eddy viscosity in curled-wake model [>=0.0] [-]
    LOGICAL  :: OutAllPlanes      !< Output all planes [-]
    LOGICAL  :: WAT      !< Switch for turning on and off wake-added turbulence [-]
    REAL(ReKi)  :: WAT_k_Def      !< Calibrated parameter for the influence of the wake deficit in the wake-added Turbulence (-) [>=0.0] or DEFAULT [DEFAULT=0.6] [-]
    REAL(ReKi)  :: WAT_k_Grad      !< Calibrated parameter for the influence of the radial velocity gradient of the wake deficit in the wake-added Turbulence (-) [>=0.0] or DEFAULT [DEFAULT=0.35] [-]
  END TYPE WD_InputFileType
! =======================
! =========  WD_InitInputType  =======
  TYPE, PUBLIC :: WD_InitInputType
    TYPE(WD_InputFileType)  :: InputFileData      !< FAST.Farm input-file data for wake dynamics [-]
    INTEGER(IntKi)  :: TurbNum = 0      !< Turbine ID number (start with 1; end with number of turbines) [-]
    CHARACTER(1024)  :: OutFileRoot      !< The root name derived from the primary FAST.Farm input file [-]
  END TYPE WD_InitInputType
! =======================
! =========  WD_InitOutputType  =======
  TYPE, PUBLIC :: WD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
  END TYPE WD_InitOutputType
! =======================
! =========  WD_ContinuousStateType  =======
  TYPE, PUBLIC :: WD_ContinuousStateType
    REAL(ReKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
  END TYPE WD_ContinuousStateType
! =======================
! =========  WD_DiscreteStateType  =======
  TYPE, PUBLIC :: WD_DiscreteStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: xhat_plane      !< Orientations of wake planes, normal to wake planes [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: YawErr_filt      !< Time-filtered nacelle-yaw error at the wake planes [rad]
    REAL(ReKi)  :: psi_skew_filt      !< Time-filtered azimuth angle from skew vertical axis [rad]
    REAL(ReKi)  :: chi_skew_filt      !< Time-filtered inflow skew angle [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: V_plane_filt      !< Time-filtered advection, deflection, and meandering velocity of wake planes [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: p_plane      !< Center positions of wake planes [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: x_plane      !< Downwind distance from rotor to each wake plane [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vx_wake      !< Axial wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vr_wake      !< Radial wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vx_wake2      !< Axial wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vy_wake2      !< Longitudinal wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vz_wake2      !< Vertical wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vx_wind_disk_filt      !< Time-filtered rotor-disk-averaged ambient wind speed of wake planes, normal to planes [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TI_amb_filt      !< Time-filtered ambient turbulence intensity of wind at wake planes [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_rotor_filt      !< Time-filtered rotor diameter associated with each wake plane [m]
    REAL(ReKi)  :: Vx_rel_disk_filt      !< Time-filtered rotor-disk-averaged relative wind speed (ambient + deficits + motion), normal to disk [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Ct_azavg_filt      !< Time-filtered azimuthally averaged thrust force coefficient (normal to disk), distributed radially [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cq_azavg_filt      !< Time-filtered azimuthally averaged torque coefficient (normal to disk), distributed radially [-]
  END TYPE WD_DiscreteStateType
! =======================
! =========  WD_ConstraintStateType  =======
  TYPE, PUBLIC :: WD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE WD_ConstraintStateType
! =======================
! =========  WD_OtherStateType  =======
  TYPE, PUBLIC :: WD_OtherStateType
    LOGICAL  :: firstPass      !< Flag indicating whether or not the states have been initialized with proper inputs [-]
  END TYPE WD_OtherStateType
! =======================
! =========  WD_MiscVarType  =======
  TYPE, PUBLIC :: WD_MiscVarType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dvtdr      !< Radial gradient of total eddy viscosity (nr) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: vt_tot      !< Polar total   eddy viscosity (nr,np) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: vt_amb      !< Polar ambient eddy viscosity (nr,np) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: vt_shr      !< Polar shear   eddy viscosity (nr,np) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: vt_tot2      !< Cartesian total   eddy viscosity (ny,nz,np) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: vt_amb2      !< Cartesian ambient eddy viscosity (ny,nz,np) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: vt_shr2      !< Cartesian shear   eddy viscosity (ny,nz,np) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: dvx_dy      !< Cartesian velocity gradient dVx/dy [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: dvx_dz      !< Cartesian velocity gradient dVx/dz [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: nu_dvx_dy      !< Product of total eddy viscosity and gradient [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: nu_dvx_dz      !< Product of total eddy viscosity and gradient [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: dnuvx_dy      !< Gradient of nu_dvx_dy wrt y [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: dnuvx_dz      !< Gradient of nu_dvx_dz wrt z [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: a      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: b      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: c      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: d      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: r_wake      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vx_high      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vx_polar      !< Vx as function of r for Cartesian implementation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vt_wake      !< Vr as function of r for Cartesian implementation [-]
    REAL(ReKi)  :: GammaCurl      !< Circulation used in Curled wake model [-]
    REAL(ReKi)  :: Ct_avg      !< Circulation used in Curled wake model [-]
  END TYPE WD_MiscVarType
! =======================
! =========  WD_ParameterType  =======
  TYPE, PUBLIC :: WD_ParameterType
    REAL(DbKi)  :: dt_low      !< Time interval for wake dynamics calculations {or default} [s]
    INTEGER(IntKi)  :: NumPlanes      !< Number of wake planes [-]
    INTEGER(IntKi)  :: NumRadii      !< Number of radii in the radial finite-difference grid [-]
    REAL(ReKi)  :: dr      !< Radial increment of radial finite-difference grid [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: r      !< Discretization of radial finite-difference grid [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y      !< Horizontal discretization of each wake plane (size ny=2nr-1) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: z      !< Nomically-vertical discretization of each wake plane (size nz=2nr-1) [m]
    INTEGER(IntKi)  :: Mod_Wake      !< Switch between wake formulations 1=Polar, 2=Curl, 3=Cartesian [-]
    LOGICAL  :: Swirl      !< Switch to add swirl [only used if Mod_Wake=2 or 2] [-]
    REAL(ReKi)  :: k_VortexDecay      !< Vortex decay constant for curl [-]
    REAL(ReKi)  :: sigma_D      !< The width of the Gaussian vortices used for the curled wake model divided by diameter [-]
    INTEGER(IntKi)  :: NumVortices      !< The number of vortices used for the curled wake model [-]
    REAL(ReKi)  :: filtParam      !< Low-pass time-filter parameter, with a value between 0 (minimum filtering) and 1 (maximum filtering) (exclusive) [-]
    REAL(ReKi)  :: oneMinusFiltParam      !< 1.0 - filtParam [-]
    REAL(ReKi)  :: C_HWkDfl_O      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor [m]
    REAL(ReKi)  :: C_HWkDfl_OY      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset at the rotor scaled with yaw error [m/rad]
    REAL(ReKi)  :: C_HWkDfl_x      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance [-]
    REAL(ReKi)  :: C_HWkDfl_xY      !< Calibrated parameter in the correction for wake deflection defining the horizontal offset scaled with downstream distance and yaw error [1/rad]
    REAL(ReKi)  :: C_NearWake      !< Calibrated parameter for near-wake correction [-]
    REAL(ReKi)  :: C_vAmb_DMin      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the minimum and exponential regions [-]
    REAL(ReKi)  :: C_vAmb_DMax      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the transitional diameter fraction between the exponential and maximum regions [-]
    REAL(ReKi)  :: C_vAmb_FMin      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the functional value in the minimum region [-]
    REAL(ReKi)  :: C_vAmb_Exp      !< Calibrated parameter in the eddy viscosity filter function for ambient turbulence defining the exponent in the exponential region [-]
    REAL(ReKi)  :: C_vShr_DMin      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the minimum and exponential regions [-]
    REAL(ReKi)  :: C_vShr_DMax      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the transitional diameter fraction between the exponential and maximum regions [-]
    REAL(ReKi)  :: C_vShr_FMin      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the functional value in the minimum region [-]
    REAL(ReKi)  :: C_vShr_Exp      !< Calibrated parameter in the eddy viscosity filter function for the shear layer defining the exponent in the exponential region [-]
    REAL(ReKi)  :: k_vAmb      !< Calibrated parameter for the influence of ambient turbulence in the eddy viscosity [-]
    REAL(ReKi)  :: k_vShr      !< Calibrated parameter for the influence of the shear layer in the eddy viscosity [-]
    INTEGER(IntKi)  :: Mod_WakeDiam      !< Wake diameter calculation model [-]
    REAL(ReKi)  :: C_WakeDiam      !< Calibrated parameter for wake diameter calculation [-]
    INTEGER(IntKi)  :: FilterInit      !< Switch to filter the initial wake plane deficit and select the number of grid points for the filter {0: no filter, 1: filter of size 1} or DEFAULT [DEFAULT=0: if Mod_Wake is 1 or 3, or DEFAULT=2: if Mod_Wwake is 2] (switch) [-]
    REAL(ReKi)  :: k_vCurl      !< Calibrated parameter for the eddy viscosity in curled-wake model [>=0.0] [-]
    LOGICAL  :: OutAllPlanes      !< Output all planes [-]
    CHARACTER(1024)  :: OutFileRoot      !< The root name derived from the primary FAST.Farm input file [-]
    CHARACTER(1024)  :: OutFileVTKDir      !< The parent directory for all VTK files written by WD [-]
    INTEGER(IntKi)  :: TurbNum = 0      !< Turbine ID number (start with 1; end with number of turbines) [-]
    LOGICAL  :: WAT      !< Switch for turning on and off wake-added turbulence [-]
    REAL(ReKi)  :: WAT_k_Def      !< Calibrated parameter for the influence of the wake deficit in the wake-added Turbulence (-) [>=0.0] or DEFAULT [DEFAULT=0.6] [-]
    REAL(ReKi)  :: WAT_k_Grad      !< Calibrated parameter for the influence of the radial velocity gradient of the wake deficit in the wake-added Turbulence (-) [>=0.0] or DEFAULT [DEFAULT=0.35] [-]
  END TYPE WD_ParameterType
! =======================
! =========  WD_InputType  =======
  TYPE, PUBLIC :: WD_InputType
    REAL(ReKi) , DIMENSION(1:3)  :: xhat_disk      !< Orientation of rotor centerline, normal to disk [-]
    REAL(ReKi)  :: YawErr      !< Nacelle-yaw error at the wake planes [rad]
    REAL(ReKi)  :: psi_skew      !< Azimuth angle from the nominally vertical axis in the disk plane to the vector about which the inflow skew angle is defined [rad]
    REAL(ReKi)  :: chi_skew      !< Inflow skew angle [rad]
    REAL(ReKi) , DIMENSION(1:3)  :: p_hub      !< Center position of hub [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: V_plane      !< Advection, deflection, and meandering velocity of wake planes [m/s]
    REAL(ReKi)  :: Vx_wind_disk      !< Rotor-disk-averaged ambient wind speed, normal to planes [m/s]
    REAL(ReKi)  :: TI_amb      !< Ambient turbulence intensity of wind at rotor disk [-]
    REAL(ReKi)  :: D_rotor      !< Rotor diameter [m]
    REAL(ReKi)  :: Vx_rel_disk      !< Rotor-disk-averaged relative wind speed (ambient + deficits + motion), normal to disk [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Ct_azavg      !< Azimuthally averaged thrust force coefficient (normal to disk), distributed radially [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Cq_azavg      !< Azimuthally averaged torque coefficient (normal to disk), distributed radially [-]
  END TYPE WD_InputType
! =======================
! =========  WD_OutputType  =======
  TYPE, PUBLIC :: WD_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: xhat_plane      !< Orientations of wake planes, normal to wake planes [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: p_plane      !< Center positions of wake planes [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vx_wake      !< Axial wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vr_wake      !< Radial wake velocity deficit at wake planes, distributed radially [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vx_wake2      !< Axial wake velocity deficit at wake planes, distributed across the plane [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vy_wake2      !< Transverse horizontal wake velocity deficit at wake planes, distributed across the plane [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vz_wake2      !< Transverse nominally vertical wake velocity deficit at wake planes, distributed across the plane [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: D_wake      !< Wake diameters at wake planes [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: x_plane      !< Downwind distance from rotor to each wake plane [m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WAT_k_mt      !< Scaling factor k_mt(iP,y,z) for wake-added turbulence [-]
  END TYPE WD_OutputType
! =======================
CONTAINS
 SUBROUTINE WD_CopyInputFileType( SrcInputFileTypeData, DstInputFileTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_InputFileType), INTENT(IN) :: SrcInputFileTypeData
   TYPE(WD_InputFileType), INTENT(INOUT) :: DstInputFileTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyInputFileType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileTypeData%dr = SrcInputFileTypeData%dr
    DstInputFileTypeData%NumRadii = SrcInputFileTypeData%NumRadii
    DstInputFileTypeData%NumPlanes = SrcInputFileTypeData%NumPlanes
    DstInputFileTypeData%Mod_Wake = SrcInputFileTypeData%Mod_Wake
    DstInputFileTypeData%f_c = SrcInputFileTypeData%f_c
    DstInputFileTypeData%C_HWkDfl_O = SrcInputFileTypeData%C_HWkDfl_O
    DstInputFileTypeData%C_HWkDfl_OY = SrcInputFileTypeData%C_HWkDfl_OY
    DstInputFileTypeData%C_HWkDfl_x = SrcInputFileTypeData%C_HWkDfl_x
    DstInputFileTypeData%C_HWkDfl_xY = SrcInputFileTypeData%C_HWkDfl_xY
    DstInputFileTypeData%C_NearWake = SrcInputFileTypeData%C_NearWake
    DstInputFileTypeData%k_vAmb = SrcInputFileTypeData%k_vAmb
    DstInputFileTypeData%k_vShr = SrcInputFileTypeData%k_vShr
    DstInputFileTypeData%C_vAmb_DMin = SrcInputFileTypeData%C_vAmb_DMin
    DstInputFileTypeData%C_vAmb_DMax = SrcInputFileTypeData%C_vAmb_DMax
    DstInputFileTypeData%C_vAmb_FMin = SrcInputFileTypeData%C_vAmb_FMin
    DstInputFileTypeData%C_vAmb_Exp = SrcInputFileTypeData%C_vAmb_Exp
    DstInputFileTypeData%C_vShr_DMin = SrcInputFileTypeData%C_vShr_DMin
    DstInputFileTypeData%C_vShr_DMax = SrcInputFileTypeData%C_vShr_DMax
    DstInputFileTypeData%C_vShr_FMin = SrcInputFileTypeData%C_vShr_FMin
    DstInputFileTypeData%C_vShr_Exp = SrcInputFileTypeData%C_vShr_Exp
    DstInputFileTypeData%Mod_WakeDiam = SrcInputFileTypeData%Mod_WakeDiam
    DstInputFileTypeData%C_WakeDiam = SrcInputFileTypeData%C_WakeDiam
    DstInputFileTypeData%Swirl = SrcInputFileTypeData%Swirl
    DstInputFileTypeData%k_VortexDecay = SrcInputFileTypeData%k_VortexDecay
    DstInputFileTypeData%sigma_D = SrcInputFileTypeData%sigma_D
    DstInputFileTypeData%NumVortices = SrcInputFileTypeData%NumVortices
    DstInputFileTypeData%FilterInit = SrcInputFileTypeData%FilterInit
    DstInputFileTypeData%k_vCurl = SrcInputFileTypeData%k_vCurl
    DstInputFileTypeData%OutAllPlanes = SrcInputFileTypeData%OutAllPlanes
    DstInputFileTypeData%WAT = SrcInputFileTypeData%WAT
    DstInputFileTypeData%WAT_k_Def = SrcInputFileTypeData%WAT_k_Def
    DstInputFileTypeData%WAT_k_Grad = SrcInputFileTypeData%WAT_k_Grad
 END SUBROUTINE WD_CopyInputFileType

 SUBROUTINE WD_DestroyInputFileType( InputFileTypeData, ErrStat, ErrMsg )
  TYPE(WD_InputFileType), INTENT(INOUT) :: InputFileTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyInputFileType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE WD_DestroyInputFileType


subroutine WD_PackInputFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_InputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackInputFileType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dr
   call RegPack(Buf, InData%dr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegPack(Buf, InData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegPack(Buf, InData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Wake
   call RegPack(Buf, InData%Mod_Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! f_c
   call RegPack(Buf, InData%f_c)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_O
   call RegPack(Buf, InData%C_HWkDfl_O)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_OY
   call RegPack(Buf, InData%C_HWkDfl_OY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_x
   call RegPack(Buf, InData%C_HWkDfl_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_xY
   call RegPack(Buf, InData%C_HWkDfl_xY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_NearWake
   call RegPack(Buf, InData%C_NearWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vAmb
   call RegPack(Buf, InData%k_vAmb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vShr
   call RegPack(Buf, InData%k_vShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMin
   call RegPack(Buf, InData%C_vAmb_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMax
   call RegPack(Buf, InData%C_vAmb_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_FMin
   call RegPack(Buf, InData%C_vAmb_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_Exp
   call RegPack(Buf, InData%C_vAmb_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMin
   call RegPack(Buf, InData%C_vShr_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMax
   call RegPack(Buf, InData%C_vShr_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_FMin
   call RegPack(Buf, InData%C_vShr_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_Exp
   call RegPack(Buf, InData%C_vShr_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_WakeDiam
   call RegPack(Buf, InData%Mod_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_WakeDiam
   call RegPack(Buf, InData%C_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Swirl
   call RegPack(Buf, InData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_VortexDecay
   call RegPack(Buf, InData%k_VortexDecay)
   if (RegCheckErr(Buf, RoutineName)) return
   ! sigma_D
   call RegPack(Buf, InData%sigma_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumVortices
   call RegPack(Buf, InData%NumVortices)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FilterInit
   call RegPack(Buf, InData%FilterInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vCurl
   call RegPack(Buf, InData%k_vCurl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllPlanes
   call RegPack(Buf, InData%OutAllPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT
   call RegPack(Buf, InData%WAT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Def
   call RegPack(Buf, InData%WAT_k_Def)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Grad
   call RegPack(Buf, InData%WAT_k_Grad)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackInputFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_InputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackInputFileType'
   if (Buf%ErrStat /= ErrID_None) return
   ! dr
   call RegUnpack(Buf, OutData%dr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegUnpack(Buf, OutData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegUnpack(Buf, OutData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Wake
   call RegUnpack(Buf, OutData%Mod_Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! f_c
   call RegUnpack(Buf, OutData%f_c)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_O
   call RegUnpack(Buf, OutData%C_HWkDfl_O)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_OY
   call RegUnpack(Buf, OutData%C_HWkDfl_OY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_x
   call RegUnpack(Buf, OutData%C_HWkDfl_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_xY
   call RegUnpack(Buf, OutData%C_HWkDfl_xY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_NearWake
   call RegUnpack(Buf, OutData%C_NearWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vAmb
   call RegUnpack(Buf, OutData%k_vAmb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vShr
   call RegUnpack(Buf, OutData%k_vShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMin
   call RegUnpack(Buf, OutData%C_vAmb_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMax
   call RegUnpack(Buf, OutData%C_vAmb_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_FMin
   call RegUnpack(Buf, OutData%C_vAmb_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_Exp
   call RegUnpack(Buf, OutData%C_vAmb_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMin
   call RegUnpack(Buf, OutData%C_vShr_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMax
   call RegUnpack(Buf, OutData%C_vShr_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_FMin
   call RegUnpack(Buf, OutData%C_vShr_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_Exp
   call RegUnpack(Buf, OutData%C_vShr_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_WakeDiam
   call RegUnpack(Buf, OutData%Mod_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_WakeDiam
   call RegUnpack(Buf, OutData%C_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Swirl
   call RegUnpack(Buf, OutData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_VortexDecay
   call RegUnpack(Buf, OutData%k_VortexDecay)
   if (RegCheckErr(Buf, RoutineName)) return
   ! sigma_D
   call RegUnpack(Buf, OutData%sigma_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumVortices
   call RegUnpack(Buf, OutData%NumVortices)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FilterInit
   call RegUnpack(Buf, OutData%FilterInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vCurl
   call RegUnpack(Buf, OutData%k_vCurl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllPlanes
   call RegUnpack(Buf, OutData%OutAllPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT
   call RegUnpack(Buf, OutData%WAT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Def
   call RegUnpack(Buf, OutData%WAT_k_Def)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Grad
   call RegUnpack(Buf, OutData%WAT_k_Grad)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(WD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL WD_Copyinputfiletype( SrcInitInputData%InputFileData, DstInitInputData%InputFileData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%TurbNum = SrcInitInputData%TurbNum
    DstInitInputData%OutFileRoot = SrcInitInputData%OutFileRoot
 END SUBROUTINE WD_CopyInitInput

 SUBROUTINE WD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(WD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL WD_DestroyInputFileType( InitInputData%InputFileData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WD_DestroyInitInput


subroutine WD_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFileData
   call WD_PackInputFileType(Buf, InData%InputFileData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbNum
   call RegPack(Buf, InData%TurbNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegPack(Buf, InData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackInitInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFileData
   call WD_UnpackInputFileType(Buf, OutData%InputFileData) ! InputFileData 
   ! TurbNum
   call RegUnpack(Buf, OutData%TurbNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegUnpack(Buf, OutData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(WD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WD_CopyInitOutput

 SUBROUTINE WD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(WD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WD_DestroyInitOutput


subroutine WD_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
end subroutine
 SUBROUTINE WD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(WD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE WD_CopyContState

 SUBROUTINE WD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(WD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE WD_DestroyContState


subroutine WD_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyContState
   call RegPack(Buf, InData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyContState
   call RegUnpack(Buf, OutData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(WD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%xhat_plane)) THEN
  i1_l = LBOUND(SrcDiscStateData%xhat_plane,1)
  i1_u = UBOUND(SrcDiscStateData%xhat_plane,1)
  i2_l = LBOUND(SrcDiscStateData%xhat_plane,2)
  i2_u = UBOUND(SrcDiscStateData%xhat_plane,2)
  IF (.NOT. ALLOCATED(DstDiscStateData%xhat_plane)) THEN 
    ALLOCATE(DstDiscStateData%xhat_plane(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%xhat_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%xhat_plane = SrcDiscStateData%xhat_plane
ENDIF
IF (ALLOCATED(SrcDiscStateData%YawErr_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%YawErr_filt,1)
  i1_u = UBOUND(SrcDiscStateData%YawErr_filt,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%YawErr_filt)) THEN 
    ALLOCATE(DstDiscStateData%YawErr_filt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%YawErr_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%YawErr_filt = SrcDiscStateData%YawErr_filt
ENDIF
    DstDiscStateData%psi_skew_filt = SrcDiscStateData%psi_skew_filt
    DstDiscStateData%chi_skew_filt = SrcDiscStateData%chi_skew_filt
IF (ALLOCATED(SrcDiscStateData%V_plane_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%V_plane_filt,1)
  i1_u = UBOUND(SrcDiscStateData%V_plane_filt,1)
  i2_l = LBOUND(SrcDiscStateData%V_plane_filt,2)
  i2_u = UBOUND(SrcDiscStateData%V_plane_filt,2)
  IF (.NOT. ALLOCATED(DstDiscStateData%V_plane_filt)) THEN 
    ALLOCATE(DstDiscStateData%V_plane_filt(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%V_plane_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%V_plane_filt = SrcDiscStateData%V_plane_filt
ENDIF
IF (ALLOCATED(SrcDiscStateData%p_plane)) THEN
  i1_l = LBOUND(SrcDiscStateData%p_plane,1)
  i1_u = UBOUND(SrcDiscStateData%p_plane,1)
  i2_l = LBOUND(SrcDiscStateData%p_plane,2)
  i2_u = UBOUND(SrcDiscStateData%p_plane,2)
  IF (.NOT. ALLOCATED(DstDiscStateData%p_plane)) THEN 
    ALLOCATE(DstDiscStateData%p_plane(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%p_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%p_plane = SrcDiscStateData%p_plane
ENDIF
IF (ALLOCATED(SrcDiscStateData%x_plane)) THEN
  i1_l = LBOUND(SrcDiscStateData%x_plane,1)
  i1_u = UBOUND(SrcDiscStateData%x_plane,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%x_plane)) THEN 
    ALLOCATE(DstDiscStateData%x_plane(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%x_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%x_plane = SrcDiscStateData%x_plane
ENDIF
IF (ALLOCATED(SrcDiscStateData%Vx_wake)) THEN
  i1_l = LBOUND(SrcDiscStateData%Vx_wake,1)
  i1_u = UBOUND(SrcDiscStateData%Vx_wake,1)
  i2_l = LBOUND(SrcDiscStateData%Vx_wake,2)
  i2_u = UBOUND(SrcDiscStateData%Vx_wake,2)
  IF (.NOT. ALLOCATED(DstDiscStateData%Vx_wake)) THEN 
    ALLOCATE(DstDiscStateData%Vx_wake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Vx_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Vx_wake = SrcDiscStateData%Vx_wake
ENDIF
IF (ALLOCATED(SrcDiscStateData%Vr_wake)) THEN
  i1_l = LBOUND(SrcDiscStateData%Vr_wake,1)
  i1_u = UBOUND(SrcDiscStateData%Vr_wake,1)
  i2_l = LBOUND(SrcDiscStateData%Vr_wake,2)
  i2_u = UBOUND(SrcDiscStateData%Vr_wake,2)
  IF (.NOT. ALLOCATED(DstDiscStateData%Vr_wake)) THEN 
    ALLOCATE(DstDiscStateData%Vr_wake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Vr_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Vr_wake = SrcDiscStateData%Vr_wake
ENDIF
IF (ALLOCATED(SrcDiscStateData%Vx_wake2)) THEN
  i1_l = LBOUND(SrcDiscStateData%Vx_wake2,1)
  i1_u = UBOUND(SrcDiscStateData%Vx_wake2,1)
  i2_l = LBOUND(SrcDiscStateData%Vx_wake2,2)
  i2_u = UBOUND(SrcDiscStateData%Vx_wake2,2)
  i3_l = LBOUND(SrcDiscStateData%Vx_wake2,3)
  i3_u = UBOUND(SrcDiscStateData%Vx_wake2,3)
  IF (.NOT. ALLOCATED(DstDiscStateData%Vx_wake2)) THEN 
    ALLOCATE(DstDiscStateData%Vx_wake2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Vx_wake2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Vx_wake2 = SrcDiscStateData%Vx_wake2
ENDIF
IF (ALLOCATED(SrcDiscStateData%Vy_wake2)) THEN
  i1_l = LBOUND(SrcDiscStateData%Vy_wake2,1)
  i1_u = UBOUND(SrcDiscStateData%Vy_wake2,1)
  i2_l = LBOUND(SrcDiscStateData%Vy_wake2,2)
  i2_u = UBOUND(SrcDiscStateData%Vy_wake2,2)
  i3_l = LBOUND(SrcDiscStateData%Vy_wake2,3)
  i3_u = UBOUND(SrcDiscStateData%Vy_wake2,3)
  IF (.NOT. ALLOCATED(DstDiscStateData%Vy_wake2)) THEN 
    ALLOCATE(DstDiscStateData%Vy_wake2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Vy_wake2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Vy_wake2 = SrcDiscStateData%Vy_wake2
ENDIF
IF (ALLOCATED(SrcDiscStateData%Vz_wake2)) THEN
  i1_l = LBOUND(SrcDiscStateData%Vz_wake2,1)
  i1_u = UBOUND(SrcDiscStateData%Vz_wake2,1)
  i2_l = LBOUND(SrcDiscStateData%Vz_wake2,2)
  i2_u = UBOUND(SrcDiscStateData%Vz_wake2,2)
  i3_l = LBOUND(SrcDiscStateData%Vz_wake2,3)
  i3_u = UBOUND(SrcDiscStateData%Vz_wake2,3)
  IF (.NOT. ALLOCATED(DstDiscStateData%Vz_wake2)) THEN 
    ALLOCATE(DstDiscStateData%Vz_wake2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Vz_wake2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Vz_wake2 = SrcDiscStateData%Vz_wake2
ENDIF
IF (ALLOCATED(SrcDiscStateData%Vx_wind_disk_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%Vx_wind_disk_filt,1)
  i1_u = UBOUND(SrcDiscStateData%Vx_wind_disk_filt,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%Vx_wind_disk_filt)) THEN 
    ALLOCATE(DstDiscStateData%Vx_wind_disk_filt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Vx_wind_disk_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Vx_wind_disk_filt = SrcDiscStateData%Vx_wind_disk_filt
ENDIF
IF (ALLOCATED(SrcDiscStateData%TI_amb_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%TI_amb_filt,1)
  i1_u = UBOUND(SrcDiscStateData%TI_amb_filt,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%TI_amb_filt)) THEN 
    ALLOCATE(DstDiscStateData%TI_amb_filt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%TI_amb_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%TI_amb_filt = SrcDiscStateData%TI_amb_filt
ENDIF
IF (ALLOCATED(SrcDiscStateData%D_rotor_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%D_rotor_filt,1)
  i1_u = UBOUND(SrcDiscStateData%D_rotor_filt,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%D_rotor_filt)) THEN 
    ALLOCATE(DstDiscStateData%D_rotor_filt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%D_rotor_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%D_rotor_filt = SrcDiscStateData%D_rotor_filt
ENDIF
    DstDiscStateData%Vx_rel_disk_filt = SrcDiscStateData%Vx_rel_disk_filt
IF (ALLOCATED(SrcDiscStateData%Ct_azavg_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%Ct_azavg_filt,1)
  i1_u = UBOUND(SrcDiscStateData%Ct_azavg_filt,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%Ct_azavg_filt)) THEN 
    ALLOCATE(DstDiscStateData%Ct_azavg_filt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Ct_azavg_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Ct_azavg_filt = SrcDiscStateData%Ct_azavg_filt
ENDIF
IF (ALLOCATED(SrcDiscStateData%Cq_azavg_filt)) THEN
  i1_l = LBOUND(SrcDiscStateData%Cq_azavg_filt,1)
  i1_u = UBOUND(SrcDiscStateData%Cq_azavg_filt,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%Cq_azavg_filt)) THEN 
    ALLOCATE(DstDiscStateData%Cq_azavg_filt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%Cq_azavg_filt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%Cq_azavg_filt = SrcDiscStateData%Cq_azavg_filt
ENDIF
 END SUBROUTINE WD_CopyDiscState

 SUBROUTINE WD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(WD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%xhat_plane)) THEN
  DEALLOCATE(DiscStateData%xhat_plane)
ENDIF
IF (ALLOCATED(DiscStateData%YawErr_filt)) THEN
  DEALLOCATE(DiscStateData%YawErr_filt)
ENDIF
IF (ALLOCATED(DiscStateData%V_plane_filt)) THEN
  DEALLOCATE(DiscStateData%V_plane_filt)
ENDIF
IF (ALLOCATED(DiscStateData%p_plane)) THEN
  DEALLOCATE(DiscStateData%p_plane)
ENDIF
IF (ALLOCATED(DiscStateData%x_plane)) THEN
  DEALLOCATE(DiscStateData%x_plane)
ENDIF
IF (ALLOCATED(DiscStateData%Vx_wake)) THEN
  DEALLOCATE(DiscStateData%Vx_wake)
ENDIF
IF (ALLOCATED(DiscStateData%Vr_wake)) THEN
  DEALLOCATE(DiscStateData%Vr_wake)
ENDIF
IF (ALLOCATED(DiscStateData%Vx_wake2)) THEN
  DEALLOCATE(DiscStateData%Vx_wake2)
ENDIF
IF (ALLOCATED(DiscStateData%Vy_wake2)) THEN
  DEALLOCATE(DiscStateData%Vy_wake2)
ENDIF
IF (ALLOCATED(DiscStateData%Vz_wake2)) THEN
  DEALLOCATE(DiscStateData%Vz_wake2)
ENDIF
IF (ALLOCATED(DiscStateData%Vx_wind_disk_filt)) THEN
  DEALLOCATE(DiscStateData%Vx_wind_disk_filt)
ENDIF
IF (ALLOCATED(DiscStateData%TI_amb_filt)) THEN
  DEALLOCATE(DiscStateData%TI_amb_filt)
ENDIF
IF (ALLOCATED(DiscStateData%D_rotor_filt)) THEN
  DEALLOCATE(DiscStateData%D_rotor_filt)
ENDIF
IF (ALLOCATED(DiscStateData%Ct_azavg_filt)) THEN
  DEALLOCATE(DiscStateData%Ct_azavg_filt)
ENDIF
IF (ALLOCATED(DiscStateData%Cq_azavg_filt)) THEN
  DEALLOCATE(DiscStateData%Cq_azavg_filt)
ENDIF
 END SUBROUTINE WD_DestroyDiscState


subroutine WD_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! xhat_plane
   call RegPack(Buf, allocated(InData%xhat_plane))
   if (allocated(InData%xhat_plane)) then
      call RegPackBounds(Buf, 2, lbound(InData%xhat_plane), ubound(InData%xhat_plane))
      call RegPack(Buf, InData%xhat_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr_filt
   call RegPack(Buf, allocated(InData%YawErr_filt))
   if (allocated(InData%YawErr_filt)) then
      call RegPackBounds(Buf, 1, lbound(InData%YawErr_filt), ubound(InData%YawErr_filt))
      call RegPack(Buf, InData%YawErr_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! psi_skew_filt
   call RegPack(Buf, InData%psi_skew_filt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! chi_skew_filt
   call RegPack(Buf, InData%chi_skew_filt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_plane_filt
   call RegPack(Buf, allocated(InData%V_plane_filt))
   if (allocated(InData%V_plane_filt)) then
      call RegPackBounds(Buf, 2, lbound(InData%V_plane_filt), ubound(InData%V_plane_filt))
      call RegPack(Buf, InData%V_plane_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_plane
   call RegPack(Buf, allocated(InData%p_plane))
   if (allocated(InData%p_plane)) then
      call RegPackBounds(Buf, 2, lbound(InData%p_plane), ubound(InData%p_plane))
      call RegPack(Buf, InData%p_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_plane
   call RegPack(Buf, allocated(InData%x_plane))
   if (allocated(InData%x_plane)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_plane), ubound(InData%x_plane))
      call RegPack(Buf, InData%x_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wake
   call RegPack(Buf, allocated(InData%Vx_wake))
   if (allocated(InData%Vx_wake)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vx_wake), ubound(InData%Vx_wake))
      call RegPack(Buf, InData%Vx_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vr_wake
   call RegPack(Buf, allocated(InData%Vr_wake))
   if (allocated(InData%Vr_wake)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vr_wake), ubound(InData%Vr_wake))
      call RegPack(Buf, InData%Vr_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wake2
   call RegPack(Buf, allocated(InData%Vx_wake2))
   if (allocated(InData%Vx_wake2)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vx_wake2), ubound(InData%Vx_wake2))
      call RegPack(Buf, InData%Vx_wake2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vy_wake2
   call RegPack(Buf, allocated(InData%Vy_wake2))
   if (allocated(InData%Vy_wake2)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vy_wake2), ubound(InData%Vy_wake2))
      call RegPack(Buf, InData%Vy_wake2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vz_wake2
   call RegPack(Buf, allocated(InData%Vz_wake2))
   if (allocated(InData%Vz_wake2)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vz_wake2), ubound(InData%Vz_wake2))
      call RegPack(Buf, InData%Vz_wake2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wind_disk_filt
   call RegPack(Buf, allocated(InData%Vx_wind_disk_filt))
   if (allocated(InData%Vx_wind_disk_filt)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vx_wind_disk_filt), ubound(InData%Vx_wind_disk_filt))
      call RegPack(Buf, InData%Vx_wind_disk_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI_amb_filt
   call RegPack(Buf, allocated(InData%TI_amb_filt))
   if (allocated(InData%TI_amb_filt)) then
      call RegPackBounds(Buf, 1, lbound(InData%TI_amb_filt), ubound(InData%TI_amb_filt))
      call RegPack(Buf, InData%TI_amb_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D_rotor_filt
   call RegPack(Buf, allocated(InData%D_rotor_filt))
   if (allocated(InData%D_rotor_filt)) then
      call RegPackBounds(Buf, 1, lbound(InData%D_rotor_filt), ubound(InData%D_rotor_filt))
      call RegPack(Buf, InData%D_rotor_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_rel_disk_filt
   call RegPack(Buf, InData%Vx_rel_disk_filt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ct_azavg_filt
   call RegPack(Buf, allocated(InData%Ct_azavg_filt))
   if (allocated(InData%Ct_azavg_filt)) then
      call RegPackBounds(Buf, 1, lbound(InData%Ct_azavg_filt), ubound(InData%Ct_azavg_filt))
      call RegPack(Buf, InData%Ct_azavg_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cq_azavg_filt
   call RegPack(Buf, allocated(InData%Cq_azavg_filt))
   if (allocated(InData%Cq_azavg_filt)) then
      call RegPackBounds(Buf, 1, lbound(InData%Cq_azavg_filt), ubound(InData%Cq_azavg_filt))
      call RegPack(Buf, InData%Cq_azavg_filt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackDiscState'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! xhat_plane
   if (allocated(OutData%xhat_plane)) deallocate(OutData%xhat_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xhat_plane(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xhat_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%xhat_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! YawErr_filt
   if (allocated(OutData%YawErr_filt)) deallocate(OutData%YawErr_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%YawErr_filt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%YawErr_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%YawErr_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! psi_skew_filt
   call RegUnpack(Buf, OutData%psi_skew_filt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! chi_skew_filt
   call RegUnpack(Buf, OutData%chi_skew_filt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_plane_filt
   if (allocated(OutData%V_plane_filt)) deallocate(OutData%V_plane_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%V_plane_filt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%V_plane_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%V_plane_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! p_plane
   if (allocated(OutData%p_plane)) deallocate(OutData%p_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%p_plane(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%p_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! x_plane
   if (allocated(OutData%x_plane)) deallocate(OutData%x_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_plane(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%x_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wake
   if (allocated(OutData%Vx_wake)) deallocate(OutData%Vx_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vr_wake
   if (allocated(OutData%Vr_wake)) deallocate(OutData%Vr_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vr_wake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vr_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vr_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wake2
   if (allocated(OutData%Vx_wake2)) deallocate(OutData%Vx_wake2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wake2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wake2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wake2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vy_wake2
   if (allocated(OutData%Vy_wake2)) deallocate(OutData%Vy_wake2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vy_wake2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vy_wake2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vy_wake2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vz_wake2
   if (allocated(OutData%Vz_wake2)) deallocate(OutData%Vz_wake2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vz_wake2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vz_wake2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vz_wake2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wind_disk_filt
   if (allocated(OutData%Vx_wind_disk_filt)) deallocate(OutData%Vx_wind_disk_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wind_disk_filt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wind_disk_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wind_disk_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TI_amb_filt
   if (allocated(OutData%TI_amb_filt)) deallocate(OutData%TI_amb_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TI_amb_filt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TI_amb_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TI_amb_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D_rotor_filt
   if (allocated(OutData%D_rotor_filt)) deallocate(OutData%D_rotor_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D_rotor_filt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_rotor_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D_rotor_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_rel_disk_filt
   call RegUnpack(Buf, OutData%Vx_rel_disk_filt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ct_azavg_filt
   if (allocated(OutData%Ct_azavg_filt)) deallocate(OutData%Ct_azavg_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ct_azavg_filt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ct_azavg_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ct_azavg_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Cq_azavg_filt
   if (allocated(OutData%Cq_azavg_filt)) deallocate(OutData%Cq_azavg_filt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cq_azavg_filt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cq_azavg_filt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cq_azavg_filt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE WD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(WD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE WD_CopyConstrState

 SUBROUTINE WD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(WD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE WD_DestroyConstrState


subroutine WD_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(WD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%firstPass = SrcOtherStateData%firstPass
 END SUBROUTINE WD_CopyOtherState

 SUBROUTINE WD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(WD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE WD_DestroyOtherState


subroutine WD_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! firstPass
   call RegPack(Buf, InData%firstPass)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! firstPass
   call RegUnpack(Buf, OutData%firstPass)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(WD_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%dvtdr)) THEN
  i1_l = LBOUND(SrcMiscData%dvtdr,1)
  i1_u = UBOUND(SrcMiscData%dvtdr,1)
  IF (.NOT. ALLOCATED(DstMiscData%dvtdr)) THEN 
    ALLOCATE(DstMiscData%dvtdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dvtdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dvtdr = SrcMiscData%dvtdr
ENDIF
IF (ALLOCATED(SrcMiscData%vt_tot)) THEN
  i1_l = LBOUND(SrcMiscData%vt_tot,1)
  i1_u = UBOUND(SrcMiscData%vt_tot,1)
  i2_l = LBOUND(SrcMiscData%vt_tot,2)
  i2_u = UBOUND(SrcMiscData%vt_tot,2)
  IF (.NOT. ALLOCATED(DstMiscData%vt_tot)) THEN 
    ALLOCATE(DstMiscData%vt_tot(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vt_tot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%vt_tot = SrcMiscData%vt_tot
ENDIF
IF (ALLOCATED(SrcMiscData%vt_amb)) THEN
  i1_l = LBOUND(SrcMiscData%vt_amb,1)
  i1_u = UBOUND(SrcMiscData%vt_amb,1)
  i2_l = LBOUND(SrcMiscData%vt_amb,2)
  i2_u = UBOUND(SrcMiscData%vt_amb,2)
  IF (.NOT. ALLOCATED(DstMiscData%vt_amb)) THEN 
    ALLOCATE(DstMiscData%vt_amb(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vt_amb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%vt_amb = SrcMiscData%vt_amb
ENDIF
IF (ALLOCATED(SrcMiscData%vt_shr)) THEN
  i1_l = LBOUND(SrcMiscData%vt_shr,1)
  i1_u = UBOUND(SrcMiscData%vt_shr,1)
  i2_l = LBOUND(SrcMiscData%vt_shr,2)
  i2_u = UBOUND(SrcMiscData%vt_shr,2)
  IF (.NOT. ALLOCATED(DstMiscData%vt_shr)) THEN 
    ALLOCATE(DstMiscData%vt_shr(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vt_shr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%vt_shr = SrcMiscData%vt_shr
ENDIF
IF (ALLOCATED(SrcMiscData%vt_tot2)) THEN
  i1_l = LBOUND(SrcMiscData%vt_tot2,1)
  i1_u = UBOUND(SrcMiscData%vt_tot2,1)
  i2_l = LBOUND(SrcMiscData%vt_tot2,2)
  i2_u = UBOUND(SrcMiscData%vt_tot2,2)
  i3_l = LBOUND(SrcMiscData%vt_tot2,3)
  i3_u = UBOUND(SrcMiscData%vt_tot2,3)
  IF (.NOT. ALLOCATED(DstMiscData%vt_tot2)) THEN 
    ALLOCATE(DstMiscData%vt_tot2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vt_tot2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%vt_tot2 = SrcMiscData%vt_tot2
ENDIF
IF (ALLOCATED(SrcMiscData%vt_amb2)) THEN
  i1_l = LBOUND(SrcMiscData%vt_amb2,1)
  i1_u = UBOUND(SrcMiscData%vt_amb2,1)
  i2_l = LBOUND(SrcMiscData%vt_amb2,2)
  i2_u = UBOUND(SrcMiscData%vt_amb2,2)
  i3_l = LBOUND(SrcMiscData%vt_amb2,3)
  i3_u = UBOUND(SrcMiscData%vt_amb2,3)
  IF (.NOT. ALLOCATED(DstMiscData%vt_amb2)) THEN 
    ALLOCATE(DstMiscData%vt_amb2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vt_amb2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%vt_amb2 = SrcMiscData%vt_amb2
ENDIF
IF (ALLOCATED(SrcMiscData%vt_shr2)) THEN
  i1_l = LBOUND(SrcMiscData%vt_shr2,1)
  i1_u = UBOUND(SrcMiscData%vt_shr2,1)
  i2_l = LBOUND(SrcMiscData%vt_shr2,2)
  i2_u = UBOUND(SrcMiscData%vt_shr2,2)
  i3_l = LBOUND(SrcMiscData%vt_shr2,3)
  i3_u = UBOUND(SrcMiscData%vt_shr2,3)
  IF (.NOT. ALLOCATED(DstMiscData%vt_shr2)) THEN 
    ALLOCATE(DstMiscData%vt_shr2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%vt_shr2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%vt_shr2 = SrcMiscData%vt_shr2
ENDIF
IF (ALLOCATED(SrcMiscData%dvx_dy)) THEN
  i1_l = LBOUND(SrcMiscData%dvx_dy,1)
  i1_u = UBOUND(SrcMiscData%dvx_dy,1)
  i2_l = LBOUND(SrcMiscData%dvx_dy,2)
  i2_u = UBOUND(SrcMiscData%dvx_dy,2)
  i3_l = LBOUND(SrcMiscData%dvx_dy,3)
  i3_u = UBOUND(SrcMiscData%dvx_dy,3)
  IF (.NOT. ALLOCATED(DstMiscData%dvx_dy)) THEN 
    ALLOCATE(DstMiscData%dvx_dy(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dvx_dy.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dvx_dy = SrcMiscData%dvx_dy
ENDIF
IF (ALLOCATED(SrcMiscData%dvx_dz)) THEN
  i1_l = LBOUND(SrcMiscData%dvx_dz,1)
  i1_u = UBOUND(SrcMiscData%dvx_dz,1)
  i2_l = LBOUND(SrcMiscData%dvx_dz,2)
  i2_u = UBOUND(SrcMiscData%dvx_dz,2)
  i3_l = LBOUND(SrcMiscData%dvx_dz,3)
  i3_u = UBOUND(SrcMiscData%dvx_dz,3)
  IF (.NOT. ALLOCATED(DstMiscData%dvx_dz)) THEN 
    ALLOCATE(DstMiscData%dvx_dz(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dvx_dz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dvx_dz = SrcMiscData%dvx_dz
ENDIF
IF (ALLOCATED(SrcMiscData%nu_dvx_dy)) THEN
  i1_l = LBOUND(SrcMiscData%nu_dvx_dy,1)
  i1_u = UBOUND(SrcMiscData%nu_dvx_dy,1)
  i2_l = LBOUND(SrcMiscData%nu_dvx_dy,2)
  i2_u = UBOUND(SrcMiscData%nu_dvx_dy,2)
  IF (.NOT. ALLOCATED(DstMiscData%nu_dvx_dy)) THEN 
    ALLOCATE(DstMiscData%nu_dvx_dy(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%nu_dvx_dy.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%nu_dvx_dy = SrcMiscData%nu_dvx_dy
ENDIF
IF (ALLOCATED(SrcMiscData%nu_dvx_dz)) THEN
  i1_l = LBOUND(SrcMiscData%nu_dvx_dz,1)
  i1_u = UBOUND(SrcMiscData%nu_dvx_dz,1)
  i2_l = LBOUND(SrcMiscData%nu_dvx_dz,2)
  i2_u = UBOUND(SrcMiscData%nu_dvx_dz,2)
  IF (.NOT. ALLOCATED(DstMiscData%nu_dvx_dz)) THEN 
    ALLOCATE(DstMiscData%nu_dvx_dz(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%nu_dvx_dz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%nu_dvx_dz = SrcMiscData%nu_dvx_dz
ENDIF
IF (ALLOCATED(SrcMiscData%dnuvx_dy)) THEN
  i1_l = LBOUND(SrcMiscData%dnuvx_dy,1)
  i1_u = UBOUND(SrcMiscData%dnuvx_dy,1)
  i2_l = LBOUND(SrcMiscData%dnuvx_dy,2)
  i2_u = UBOUND(SrcMiscData%dnuvx_dy,2)
  IF (.NOT. ALLOCATED(DstMiscData%dnuvx_dy)) THEN 
    ALLOCATE(DstMiscData%dnuvx_dy(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dnuvx_dy.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dnuvx_dy = SrcMiscData%dnuvx_dy
ENDIF
IF (ALLOCATED(SrcMiscData%dnuvx_dz)) THEN
  i1_l = LBOUND(SrcMiscData%dnuvx_dz,1)
  i1_u = UBOUND(SrcMiscData%dnuvx_dz,1)
  i2_l = LBOUND(SrcMiscData%dnuvx_dz,2)
  i2_u = UBOUND(SrcMiscData%dnuvx_dz,2)
  IF (.NOT. ALLOCATED(DstMiscData%dnuvx_dz)) THEN 
    ALLOCATE(DstMiscData%dnuvx_dz(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dnuvx_dz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dnuvx_dz = SrcMiscData%dnuvx_dz
ENDIF
IF (ALLOCATED(SrcMiscData%a)) THEN
  i1_l = LBOUND(SrcMiscData%a,1)
  i1_u = UBOUND(SrcMiscData%a,1)
  IF (.NOT. ALLOCATED(DstMiscData%a)) THEN 
    ALLOCATE(DstMiscData%a(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%a.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%a = SrcMiscData%a
ENDIF
IF (ALLOCATED(SrcMiscData%b)) THEN
  i1_l = LBOUND(SrcMiscData%b,1)
  i1_u = UBOUND(SrcMiscData%b,1)
  IF (.NOT. ALLOCATED(DstMiscData%b)) THEN 
    ALLOCATE(DstMiscData%b(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%b.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%b = SrcMiscData%b
ENDIF
IF (ALLOCATED(SrcMiscData%c)) THEN
  i1_l = LBOUND(SrcMiscData%c,1)
  i1_u = UBOUND(SrcMiscData%c,1)
  IF (.NOT. ALLOCATED(DstMiscData%c)) THEN 
    ALLOCATE(DstMiscData%c(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%c.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%c = SrcMiscData%c
ENDIF
IF (ALLOCATED(SrcMiscData%d)) THEN
  i1_l = LBOUND(SrcMiscData%d,1)
  i1_u = UBOUND(SrcMiscData%d,1)
  IF (.NOT. ALLOCATED(DstMiscData%d)) THEN 
    ALLOCATE(DstMiscData%d(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%d.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%d = SrcMiscData%d
ENDIF
IF (ALLOCATED(SrcMiscData%r_wake)) THEN
  i1_l = LBOUND(SrcMiscData%r_wake,1)
  i1_u = UBOUND(SrcMiscData%r_wake,1)
  IF (.NOT. ALLOCATED(DstMiscData%r_wake)) THEN 
    ALLOCATE(DstMiscData%r_wake(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_wake = SrcMiscData%r_wake
ENDIF
IF (ALLOCATED(SrcMiscData%Vx_high)) THEN
  i1_l = LBOUND(SrcMiscData%Vx_high,1)
  i1_u = UBOUND(SrcMiscData%Vx_high,1)
  IF (.NOT. ALLOCATED(DstMiscData%Vx_high)) THEN 
    ALLOCATE(DstMiscData%Vx_high(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vx_high.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vx_high = SrcMiscData%Vx_high
ENDIF
IF (ALLOCATED(SrcMiscData%Vx_polar)) THEN
  i1_l = LBOUND(SrcMiscData%Vx_polar,1)
  i1_u = UBOUND(SrcMiscData%Vx_polar,1)
  IF (.NOT. ALLOCATED(DstMiscData%Vx_polar)) THEN 
    ALLOCATE(DstMiscData%Vx_polar(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vx_polar.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vx_polar = SrcMiscData%Vx_polar
ENDIF
IF (ALLOCATED(SrcMiscData%Vt_wake)) THEN
  i1_l = LBOUND(SrcMiscData%Vt_wake,1)
  i1_u = UBOUND(SrcMiscData%Vt_wake,1)
  IF (.NOT. ALLOCATED(DstMiscData%Vt_wake)) THEN 
    ALLOCATE(DstMiscData%Vt_wake(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vt_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vt_wake = SrcMiscData%Vt_wake
ENDIF
    DstMiscData%GammaCurl = SrcMiscData%GammaCurl
    DstMiscData%Ct_avg = SrcMiscData%Ct_avg
 END SUBROUTINE WD_CopyMisc

 SUBROUTINE WD_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(WD_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%dvtdr)) THEN
  DEALLOCATE(MiscData%dvtdr)
ENDIF
IF (ALLOCATED(MiscData%vt_tot)) THEN
  DEALLOCATE(MiscData%vt_tot)
ENDIF
IF (ALLOCATED(MiscData%vt_amb)) THEN
  DEALLOCATE(MiscData%vt_amb)
ENDIF
IF (ALLOCATED(MiscData%vt_shr)) THEN
  DEALLOCATE(MiscData%vt_shr)
ENDIF
IF (ALLOCATED(MiscData%vt_tot2)) THEN
  DEALLOCATE(MiscData%vt_tot2)
ENDIF
IF (ALLOCATED(MiscData%vt_amb2)) THEN
  DEALLOCATE(MiscData%vt_amb2)
ENDIF
IF (ALLOCATED(MiscData%vt_shr2)) THEN
  DEALLOCATE(MiscData%vt_shr2)
ENDIF
IF (ALLOCATED(MiscData%dvx_dy)) THEN
  DEALLOCATE(MiscData%dvx_dy)
ENDIF
IF (ALLOCATED(MiscData%dvx_dz)) THEN
  DEALLOCATE(MiscData%dvx_dz)
ENDIF
IF (ALLOCATED(MiscData%nu_dvx_dy)) THEN
  DEALLOCATE(MiscData%nu_dvx_dy)
ENDIF
IF (ALLOCATED(MiscData%nu_dvx_dz)) THEN
  DEALLOCATE(MiscData%nu_dvx_dz)
ENDIF
IF (ALLOCATED(MiscData%dnuvx_dy)) THEN
  DEALLOCATE(MiscData%dnuvx_dy)
ENDIF
IF (ALLOCATED(MiscData%dnuvx_dz)) THEN
  DEALLOCATE(MiscData%dnuvx_dz)
ENDIF
IF (ALLOCATED(MiscData%a)) THEN
  DEALLOCATE(MiscData%a)
ENDIF
IF (ALLOCATED(MiscData%b)) THEN
  DEALLOCATE(MiscData%b)
ENDIF
IF (ALLOCATED(MiscData%c)) THEN
  DEALLOCATE(MiscData%c)
ENDIF
IF (ALLOCATED(MiscData%d)) THEN
  DEALLOCATE(MiscData%d)
ENDIF
IF (ALLOCATED(MiscData%r_wake)) THEN
  DEALLOCATE(MiscData%r_wake)
ENDIF
IF (ALLOCATED(MiscData%Vx_high)) THEN
  DEALLOCATE(MiscData%Vx_high)
ENDIF
IF (ALLOCATED(MiscData%Vx_polar)) THEN
  DEALLOCATE(MiscData%Vx_polar)
ENDIF
IF (ALLOCATED(MiscData%Vt_wake)) THEN
  DEALLOCATE(MiscData%Vt_wake)
ENDIF
 END SUBROUTINE WD_DestroyMisc


subroutine WD_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dvtdr
   call RegPack(Buf, allocated(InData%dvtdr))
   if (allocated(InData%dvtdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%dvtdr), ubound(InData%dvtdr))
      call RegPack(Buf, InData%dvtdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! vt_tot
   call RegPack(Buf, allocated(InData%vt_tot))
   if (allocated(InData%vt_tot)) then
      call RegPackBounds(Buf, 2, lbound(InData%vt_tot), ubound(InData%vt_tot))
      call RegPack(Buf, InData%vt_tot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! vt_amb
   call RegPack(Buf, allocated(InData%vt_amb))
   if (allocated(InData%vt_amb)) then
      call RegPackBounds(Buf, 2, lbound(InData%vt_amb), ubound(InData%vt_amb))
      call RegPack(Buf, InData%vt_amb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! vt_shr
   call RegPack(Buf, allocated(InData%vt_shr))
   if (allocated(InData%vt_shr)) then
      call RegPackBounds(Buf, 2, lbound(InData%vt_shr), ubound(InData%vt_shr))
      call RegPack(Buf, InData%vt_shr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! vt_tot2
   call RegPack(Buf, allocated(InData%vt_tot2))
   if (allocated(InData%vt_tot2)) then
      call RegPackBounds(Buf, 3, lbound(InData%vt_tot2), ubound(InData%vt_tot2))
      call RegPack(Buf, InData%vt_tot2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! vt_amb2
   call RegPack(Buf, allocated(InData%vt_amb2))
   if (allocated(InData%vt_amb2)) then
      call RegPackBounds(Buf, 3, lbound(InData%vt_amb2), ubound(InData%vt_amb2))
      call RegPack(Buf, InData%vt_amb2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! vt_shr2
   call RegPack(Buf, allocated(InData%vt_shr2))
   if (allocated(InData%vt_shr2)) then
      call RegPackBounds(Buf, 3, lbound(InData%vt_shr2), ubound(InData%vt_shr2))
      call RegPack(Buf, InData%vt_shr2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dvx_dy
   call RegPack(Buf, allocated(InData%dvx_dy))
   if (allocated(InData%dvx_dy)) then
      call RegPackBounds(Buf, 3, lbound(InData%dvx_dy), ubound(InData%dvx_dy))
      call RegPack(Buf, InData%dvx_dy)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dvx_dz
   call RegPack(Buf, allocated(InData%dvx_dz))
   if (allocated(InData%dvx_dz)) then
      call RegPackBounds(Buf, 3, lbound(InData%dvx_dz), ubound(InData%dvx_dz))
      call RegPack(Buf, InData%dvx_dz)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nu_dvx_dy
   call RegPack(Buf, allocated(InData%nu_dvx_dy))
   if (allocated(InData%nu_dvx_dy)) then
      call RegPackBounds(Buf, 2, lbound(InData%nu_dvx_dy), ubound(InData%nu_dvx_dy))
      call RegPack(Buf, InData%nu_dvx_dy)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nu_dvx_dz
   call RegPack(Buf, allocated(InData%nu_dvx_dz))
   if (allocated(InData%nu_dvx_dz)) then
      call RegPackBounds(Buf, 2, lbound(InData%nu_dvx_dz), ubound(InData%nu_dvx_dz))
      call RegPack(Buf, InData%nu_dvx_dz)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dnuvx_dy
   call RegPack(Buf, allocated(InData%dnuvx_dy))
   if (allocated(InData%dnuvx_dy)) then
      call RegPackBounds(Buf, 2, lbound(InData%dnuvx_dy), ubound(InData%dnuvx_dy))
      call RegPack(Buf, InData%dnuvx_dy)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dnuvx_dz
   call RegPack(Buf, allocated(InData%dnuvx_dz))
   if (allocated(InData%dnuvx_dz)) then
      call RegPackBounds(Buf, 2, lbound(InData%dnuvx_dz), ubound(InData%dnuvx_dz))
      call RegPack(Buf, InData%dnuvx_dz)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! a
   call RegPack(Buf, allocated(InData%a))
   if (allocated(InData%a)) then
      call RegPackBounds(Buf, 1, lbound(InData%a), ubound(InData%a))
      call RegPack(Buf, InData%a)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! b
   call RegPack(Buf, allocated(InData%b))
   if (allocated(InData%b)) then
      call RegPackBounds(Buf, 1, lbound(InData%b), ubound(InData%b))
      call RegPack(Buf, InData%b)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! c
   call RegPack(Buf, allocated(InData%c))
   if (allocated(InData%c)) then
      call RegPackBounds(Buf, 1, lbound(InData%c), ubound(InData%c))
      call RegPack(Buf, InData%c)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegPack(Buf, allocated(InData%d))
   if (allocated(InData%d)) then
      call RegPackBounds(Buf, 1, lbound(InData%d), ubound(InData%d))
      call RegPack(Buf, InData%d)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_wake
   call RegPack(Buf, allocated(InData%r_wake))
   if (allocated(InData%r_wake)) then
      call RegPackBounds(Buf, 1, lbound(InData%r_wake), ubound(InData%r_wake))
      call RegPack(Buf, InData%r_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_high
   call RegPack(Buf, allocated(InData%Vx_high))
   if (allocated(InData%Vx_high)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vx_high), ubound(InData%Vx_high))
      call RegPack(Buf, InData%Vx_high)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_polar
   call RegPack(Buf, allocated(InData%Vx_polar))
   if (allocated(InData%Vx_polar)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vx_polar), ubound(InData%Vx_polar))
      call RegPack(Buf, InData%Vx_polar)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vt_wake
   call RegPack(Buf, allocated(InData%Vt_wake))
   if (allocated(InData%Vt_wake)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vt_wake), ubound(InData%Vt_wake))
      call RegPack(Buf, InData%Vt_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GammaCurl
   call RegPack(Buf, InData%GammaCurl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ct_avg
   call RegPack(Buf, InData%Ct_avg)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackMisc'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! dvtdr
   if (allocated(OutData%dvtdr)) deallocate(OutData%dvtdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dvtdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dvtdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dvtdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! vt_tot
   if (allocated(OutData%vt_tot)) deallocate(OutData%vt_tot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%vt_tot(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%vt_tot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%vt_tot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! vt_amb
   if (allocated(OutData%vt_amb)) deallocate(OutData%vt_amb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%vt_amb(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%vt_amb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%vt_amb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! vt_shr
   if (allocated(OutData%vt_shr)) deallocate(OutData%vt_shr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%vt_shr(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%vt_shr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%vt_shr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! vt_tot2
   if (allocated(OutData%vt_tot2)) deallocate(OutData%vt_tot2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%vt_tot2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%vt_tot2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%vt_tot2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! vt_amb2
   if (allocated(OutData%vt_amb2)) deallocate(OutData%vt_amb2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%vt_amb2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%vt_amb2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%vt_amb2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! vt_shr2
   if (allocated(OutData%vt_shr2)) deallocate(OutData%vt_shr2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%vt_shr2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%vt_shr2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%vt_shr2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dvx_dy
   if (allocated(OutData%dvx_dy)) deallocate(OutData%dvx_dy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dvx_dy(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dvx_dy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dvx_dy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dvx_dz
   if (allocated(OutData%dvx_dz)) deallocate(OutData%dvx_dz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dvx_dz(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dvx_dz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dvx_dz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nu_dvx_dy
   if (allocated(OutData%nu_dvx_dy)) deallocate(OutData%nu_dvx_dy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%nu_dvx_dy(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%nu_dvx_dy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%nu_dvx_dy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nu_dvx_dz
   if (allocated(OutData%nu_dvx_dz)) deallocate(OutData%nu_dvx_dz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%nu_dvx_dz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%nu_dvx_dz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%nu_dvx_dz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dnuvx_dy
   if (allocated(OutData%dnuvx_dy)) deallocate(OutData%dnuvx_dy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dnuvx_dy(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dnuvx_dy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dnuvx_dy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dnuvx_dz
   if (allocated(OutData%dnuvx_dz)) deallocate(OutData%dnuvx_dz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dnuvx_dz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dnuvx_dz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dnuvx_dz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! a
   if (allocated(OutData%a)) deallocate(OutData%a)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%a(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%a.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%a)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! b
   if (allocated(OutData%b)) deallocate(OutData%b)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%b(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%b.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%b)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! c
   if (allocated(OutData%c)) deallocate(OutData%c)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%c(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%c.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%c)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! d
   if (allocated(OutData%d)) deallocate(OutData%d)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%d(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%d.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%d)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! r_wake
   if (allocated(OutData%r_wake)) deallocate(OutData%r_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_wake(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_high
   if (allocated(OutData%Vx_high)) deallocate(OutData%Vx_high)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_high(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_high.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_high)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_polar
   if (allocated(OutData%Vx_polar)) deallocate(OutData%Vx_polar)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_polar(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_polar.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_polar)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vt_wake
   if (allocated(OutData%Vt_wake)) deallocate(OutData%Vt_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vt_wake(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vt_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vt_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GammaCurl
   call RegUnpack(Buf, OutData%GammaCurl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ct_avg
   call RegUnpack(Buf, OutData%Ct_avg)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(WD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%dt_low = SrcParamData%dt_low
    DstParamData%NumPlanes = SrcParamData%NumPlanes
    DstParamData%NumRadii = SrcParamData%NumRadii
    DstParamData%dr = SrcParamData%dr
IF (ALLOCATED(SrcParamData%r)) THEN
  i1_l = LBOUND(SrcParamData%r,1)
  i1_u = UBOUND(SrcParamData%r,1)
  IF (.NOT. ALLOCATED(DstParamData%r)) THEN 
    ALLOCATE(DstParamData%r(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%r.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%r = SrcParamData%r
ENDIF
IF (ALLOCATED(SrcParamData%y)) THEN
  i1_l = LBOUND(SrcParamData%y,1)
  i1_u = UBOUND(SrcParamData%y,1)
  IF (.NOT. ALLOCATED(DstParamData%y)) THEN 
    ALLOCATE(DstParamData%y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%y = SrcParamData%y
ENDIF
IF (ALLOCATED(SrcParamData%z)) THEN
  i1_l = LBOUND(SrcParamData%z,1)
  i1_u = UBOUND(SrcParamData%z,1)
  IF (.NOT. ALLOCATED(DstParamData%z)) THEN 
    ALLOCATE(DstParamData%z(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%z = SrcParamData%z
ENDIF
    DstParamData%Mod_Wake = SrcParamData%Mod_Wake
    DstParamData%Swirl = SrcParamData%Swirl
    DstParamData%k_VortexDecay = SrcParamData%k_VortexDecay
    DstParamData%sigma_D = SrcParamData%sigma_D
    DstParamData%NumVortices = SrcParamData%NumVortices
    DstParamData%filtParam = SrcParamData%filtParam
    DstParamData%oneMinusFiltParam = SrcParamData%oneMinusFiltParam
    DstParamData%C_HWkDfl_O = SrcParamData%C_HWkDfl_O
    DstParamData%C_HWkDfl_OY = SrcParamData%C_HWkDfl_OY
    DstParamData%C_HWkDfl_x = SrcParamData%C_HWkDfl_x
    DstParamData%C_HWkDfl_xY = SrcParamData%C_HWkDfl_xY
    DstParamData%C_NearWake = SrcParamData%C_NearWake
    DstParamData%C_vAmb_DMin = SrcParamData%C_vAmb_DMin
    DstParamData%C_vAmb_DMax = SrcParamData%C_vAmb_DMax
    DstParamData%C_vAmb_FMin = SrcParamData%C_vAmb_FMin
    DstParamData%C_vAmb_Exp = SrcParamData%C_vAmb_Exp
    DstParamData%C_vShr_DMin = SrcParamData%C_vShr_DMin
    DstParamData%C_vShr_DMax = SrcParamData%C_vShr_DMax
    DstParamData%C_vShr_FMin = SrcParamData%C_vShr_FMin
    DstParamData%C_vShr_Exp = SrcParamData%C_vShr_Exp
    DstParamData%k_vAmb = SrcParamData%k_vAmb
    DstParamData%k_vShr = SrcParamData%k_vShr
    DstParamData%Mod_WakeDiam = SrcParamData%Mod_WakeDiam
    DstParamData%C_WakeDiam = SrcParamData%C_WakeDiam
    DstParamData%FilterInit = SrcParamData%FilterInit
    DstParamData%k_vCurl = SrcParamData%k_vCurl
    DstParamData%OutAllPlanes = SrcParamData%OutAllPlanes
    DstParamData%OutFileRoot = SrcParamData%OutFileRoot
    DstParamData%OutFileVTKDir = SrcParamData%OutFileVTKDir
    DstParamData%TurbNum = SrcParamData%TurbNum
    DstParamData%WAT = SrcParamData%WAT
    DstParamData%WAT_k_Def = SrcParamData%WAT_k_Def
    DstParamData%WAT_k_Grad = SrcParamData%WAT_k_Grad
 END SUBROUTINE WD_CopyParam

 SUBROUTINE WD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(WD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%r)) THEN
  DEALLOCATE(ParamData%r)
ENDIF
IF (ALLOCATED(ParamData%y)) THEN
  DEALLOCATE(ParamData%y)
ENDIF
IF (ALLOCATED(ParamData%z)) THEN
  DEALLOCATE(ParamData%z)
ENDIF
 END SUBROUTINE WD_DestroyParam


subroutine WD_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dt_low
   call RegPack(Buf, InData%dt_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegPack(Buf, InData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegPack(Buf, InData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dr
   call RegPack(Buf, InData%dr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   call RegPack(Buf, allocated(InData%r))
   if (allocated(InData%r)) then
      call RegPackBounds(Buf, 1, lbound(InData%r), ubound(InData%r))
      call RegPack(Buf, InData%r)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! y
   call RegPack(Buf, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(Buf, 1, lbound(InData%y), ubound(InData%y))
      call RegPack(Buf, InData%y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! z
   call RegPack(Buf, allocated(InData%z))
   if (allocated(InData%z)) then
      call RegPackBounds(Buf, 1, lbound(InData%z), ubound(InData%z))
      call RegPack(Buf, InData%z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_Wake
   call RegPack(Buf, InData%Mod_Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Swirl
   call RegPack(Buf, InData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_VortexDecay
   call RegPack(Buf, InData%k_VortexDecay)
   if (RegCheckErr(Buf, RoutineName)) return
   ! sigma_D
   call RegPack(Buf, InData%sigma_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumVortices
   call RegPack(Buf, InData%NumVortices)
   if (RegCheckErr(Buf, RoutineName)) return
   ! filtParam
   call RegPack(Buf, InData%filtParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! oneMinusFiltParam
   call RegPack(Buf, InData%oneMinusFiltParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_O
   call RegPack(Buf, InData%C_HWkDfl_O)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_OY
   call RegPack(Buf, InData%C_HWkDfl_OY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_x
   call RegPack(Buf, InData%C_HWkDfl_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_xY
   call RegPack(Buf, InData%C_HWkDfl_xY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_NearWake
   call RegPack(Buf, InData%C_NearWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMin
   call RegPack(Buf, InData%C_vAmb_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMax
   call RegPack(Buf, InData%C_vAmb_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_FMin
   call RegPack(Buf, InData%C_vAmb_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_Exp
   call RegPack(Buf, InData%C_vAmb_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMin
   call RegPack(Buf, InData%C_vShr_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMax
   call RegPack(Buf, InData%C_vShr_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_FMin
   call RegPack(Buf, InData%C_vShr_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_Exp
   call RegPack(Buf, InData%C_vShr_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vAmb
   call RegPack(Buf, InData%k_vAmb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vShr
   call RegPack(Buf, InData%k_vShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_WakeDiam
   call RegPack(Buf, InData%Mod_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_WakeDiam
   call RegPack(Buf, InData%C_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FilterInit
   call RegPack(Buf, InData%FilterInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vCurl
   call RegPack(Buf, InData%k_vCurl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllPlanes
   call RegPack(Buf, InData%OutAllPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegPack(Buf, InData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileVTKDir
   call RegPack(Buf, InData%OutFileVTKDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbNum
   call RegPack(Buf, InData%TurbNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT
   call RegPack(Buf, InData%WAT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Def
   call RegPack(Buf, InData%WAT_k_Def)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Grad
   call RegPack(Buf, InData%WAT_k_Grad)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackParam'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! dt_low
   call RegUnpack(Buf, OutData%dt_low)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPlanes
   call RegUnpack(Buf, OutData%NumPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumRadii
   call RegUnpack(Buf, OutData%NumRadii)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dr
   call RegUnpack(Buf, OutData%dr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   if (allocated(OutData%r)) deallocate(OutData%r)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! y
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! z
   if (allocated(OutData%z)) deallocate(OutData%z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Mod_Wake
   call RegUnpack(Buf, OutData%Mod_Wake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Swirl
   call RegUnpack(Buf, OutData%Swirl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_VortexDecay
   call RegUnpack(Buf, OutData%k_VortexDecay)
   if (RegCheckErr(Buf, RoutineName)) return
   ! sigma_D
   call RegUnpack(Buf, OutData%sigma_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumVortices
   call RegUnpack(Buf, OutData%NumVortices)
   if (RegCheckErr(Buf, RoutineName)) return
   ! filtParam
   call RegUnpack(Buf, OutData%filtParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! oneMinusFiltParam
   call RegUnpack(Buf, OutData%oneMinusFiltParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_O
   call RegUnpack(Buf, OutData%C_HWkDfl_O)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_OY
   call RegUnpack(Buf, OutData%C_HWkDfl_OY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_x
   call RegUnpack(Buf, OutData%C_HWkDfl_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_HWkDfl_xY
   call RegUnpack(Buf, OutData%C_HWkDfl_xY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_NearWake
   call RegUnpack(Buf, OutData%C_NearWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMin
   call RegUnpack(Buf, OutData%C_vAmb_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_DMax
   call RegUnpack(Buf, OutData%C_vAmb_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_FMin
   call RegUnpack(Buf, OutData%C_vAmb_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vAmb_Exp
   call RegUnpack(Buf, OutData%C_vAmb_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMin
   call RegUnpack(Buf, OutData%C_vShr_DMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_DMax
   call RegUnpack(Buf, OutData%C_vShr_DMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_FMin
   call RegUnpack(Buf, OutData%C_vShr_FMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_vShr_Exp
   call RegUnpack(Buf, OutData%C_vShr_Exp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vAmb
   call RegUnpack(Buf, OutData%k_vAmb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vShr
   call RegUnpack(Buf, OutData%k_vShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mod_WakeDiam
   call RegUnpack(Buf, OutData%Mod_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! C_WakeDiam
   call RegUnpack(Buf, OutData%C_WakeDiam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FilterInit
   call RegUnpack(Buf, OutData%FilterInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! k_vCurl
   call RegUnpack(Buf, OutData%k_vCurl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllPlanes
   call RegUnpack(Buf, OutData%OutAllPlanes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileRoot
   call RegUnpack(Buf, OutData%OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFileVTKDir
   call RegUnpack(Buf, OutData%OutFileVTKDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbNum
   call RegUnpack(Buf, OutData%TurbNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT
   call RegUnpack(Buf, OutData%WAT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Def
   call RegUnpack(Buf, OutData%WAT_k_Def)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_Grad
   call RegUnpack(Buf, OutData%WAT_k_Grad)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_InputType), INTENT(IN) :: SrcInputData
   TYPE(WD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputData%xhat_disk = SrcInputData%xhat_disk
    DstInputData%YawErr = SrcInputData%YawErr
    DstInputData%psi_skew = SrcInputData%psi_skew
    DstInputData%chi_skew = SrcInputData%chi_skew
    DstInputData%p_hub = SrcInputData%p_hub
IF (ALLOCATED(SrcInputData%V_plane)) THEN
  i1_l = LBOUND(SrcInputData%V_plane,1)
  i1_u = UBOUND(SrcInputData%V_plane,1)
  i2_l = LBOUND(SrcInputData%V_plane,2)
  i2_u = UBOUND(SrcInputData%V_plane,2)
  IF (.NOT. ALLOCATED(DstInputData%V_plane)) THEN 
    ALLOCATE(DstInputData%V_plane(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%V_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%V_plane = SrcInputData%V_plane
ENDIF
    DstInputData%Vx_wind_disk = SrcInputData%Vx_wind_disk
    DstInputData%TI_amb = SrcInputData%TI_amb
    DstInputData%D_rotor = SrcInputData%D_rotor
    DstInputData%Vx_rel_disk = SrcInputData%Vx_rel_disk
IF (ALLOCATED(SrcInputData%Ct_azavg)) THEN
  i1_l = LBOUND(SrcInputData%Ct_azavg,1)
  i1_u = UBOUND(SrcInputData%Ct_azavg,1)
  IF (.NOT. ALLOCATED(DstInputData%Ct_azavg)) THEN 
    ALLOCATE(DstInputData%Ct_azavg(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Ct_azavg.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Ct_azavg = SrcInputData%Ct_azavg
ENDIF
IF (ALLOCATED(SrcInputData%Cq_azavg)) THEN
  i1_l = LBOUND(SrcInputData%Cq_azavg,1)
  i1_u = UBOUND(SrcInputData%Cq_azavg,1)
  IF (.NOT. ALLOCATED(DstInputData%Cq_azavg)) THEN 
    ALLOCATE(DstInputData%Cq_azavg(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Cq_azavg.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Cq_azavg = SrcInputData%Cq_azavg
ENDIF
 END SUBROUTINE WD_CopyInput

 SUBROUTINE WD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(WD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%V_plane)) THEN
  DEALLOCATE(InputData%V_plane)
ENDIF
IF (ALLOCATED(InputData%Ct_azavg)) THEN
  DEALLOCATE(InputData%Ct_azavg)
ENDIF
IF (ALLOCATED(InputData%Cq_azavg)) THEN
  DEALLOCATE(InputData%Cq_azavg)
ENDIF
 END SUBROUTINE WD_DestroyInput


subroutine WD_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! xhat_disk
   call RegPack(Buf, InData%xhat_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr
   call RegPack(Buf, InData%YawErr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! psi_skew
   call RegPack(Buf, InData%psi_skew)
   if (RegCheckErr(Buf, RoutineName)) return
   ! chi_skew
   call RegPack(Buf, InData%chi_skew)
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_hub
   call RegPack(Buf, InData%p_hub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_plane
   call RegPack(Buf, allocated(InData%V_plane))
   if (allocated(InData%V_plane)) then
      call RegPackBounds(Buf, 2, lbound(InData%V_plane), ubound(InData%V_plane))
      call RegPack(Buf, InData%V_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wind_disk
   call RegPack(Buf, InData%Vx_wind_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI_amb
   call RegPack(Buf, InData%TI_amb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! D_rotor
   call RegPack(Buf, InData%D_rotor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_rel_disk
   call RegPack(Buf, InData%Vx_rel_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ct_azavg
   call RegPack(Buf, allocated(InData%Ct_azavg))
   if (allocated(InData%Ct_azavg)) then
      call RegPackBounds(Buf, 1, lbound(InData%Ct_azavg), ubound(InData%Ct_azavg))
      call RegPack(Buf, InData%Ct_azavg)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cq_azavg
   call RegPack(Buf, allocated(InData%Cq_azavg))
   if (allocated(InData%Cq_azavg)) then
      call RegPackBounds(Buf, 1, lbound(InData%Cq_azavg), ubound(InData%Cq_azavg))
      call RegPack(Buf, InData%Cq_azavg)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! xhat_disk
   call RegUnpack(Buf, OutData%xhat_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YawErr
   call RegUnpack(Buf, OutData%YawErr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! psi_skew
   call RegUnpack(Buf, OutData%psi_skew)
   if (RegCheckErr(Buf, RoutineName)) return
   ! chi_skew
   call RegUnpack(Buf, OutData%chi_skew)
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_hub
   call RegUnpack(Buf, OutData%p_hub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_plane
   if (allocated(OutData%V_plane)) deallocate(OutData%V_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%V_plane(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%V_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%V_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wind_disk
   call RegUnpack(Buf, OutData%Vx_wind_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI_amb
   call RegUnpack(Buf, OutData%TI_amb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! D_rotor
   call RegUnpack(Buf, OutData%D_rotor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_rel_disk
   call RegUnpack(Buf, OutData%Vx_rel_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ct_azavg
   if (allocated(OutData%Ct_azavg)) deallocate(OutData%Ct_azavg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ct_azavg(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ct_azavg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ct_azavg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Cq_azavg
   if (allocated(OutData%Cq_azavg)) deallocate(OutData%Cq_azavg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cq_azavg(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cq_azavg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cq_azavg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE WD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WD_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(WD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WD_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%xhat_plane)) THEN
  i1_l = LBOUND(SrcOutputData%xhat_plane,1)
  i1_u = UBOUND(SrcOutputData%xhat_plane,1)
  i2_l = LBOUND(SrcOutputData%xhat_plane,2)
  i2_u = UBOUND(SrcOutputData%xhat_plane,2)
  IF (.NOT. ALLOCATED(DstOutputData%xhat_plane)) THEN 
    ALLOCATE(DstOutputData%xhat_plane(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%xhat_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%xhat_plane = SrcOutputData%xhat_plane
ENDIF
IF (ALLOCATED(SrcOutputData%p_plane)) THEN
  i1_l = LBOUND(SrcOutputData%p_plane,1)
  i1_u = UBOUND(SrcOutputData%p_plane,1)
  i2_l = LBOUND(SrcOutputData%p_plane,2)
  i2_u = UBOUND(SrcOutputData%p_plane,2)
  IF (.NOT. ALLOCATED(DstOutputData%p_plane)) THEN 
    ALLOCATE(DstOutputData%p_plane(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%p_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%p_plane = SrcOutputData%p_plane
ENDIF
IF (ALLOCATED(SrcOutputData%Vx_wake)) THEN
  i1_l = LBOUND(SrcOutputData%Vx_wake,1)
  i1_u = UBOUND(SrcOutputData%Vx_wake,1)
  i2_l = LBOUND(SrcOutputData%Vx_wake,2)
  i2_u = UBOUND(SrcOutputData%Vx_wake,2)
  IF (.NOT. ALLOCATED(DstOutputData%Vx_wake)) THEN 
    ALLOCATE(DstOutputData%Vx_wake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vx_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vx_wake = SrcOutputData%Vx_wake
ENDIF
IF (ALLOCATED(SrcOutputData%Vr_wake)) THEN
  i1_l = LBOUND(SrcOutputData%Vr_wake,1)
  i1_u = UBOUND(SrcOutputData%Vr_wake,1)
  i2_l = LBOUND(SrcOutputData%Vr_wake,2)
  i2_u = UBOUND(SrcOutputData%Vr_wake,2)
  IF (.NOT. ALLOCATED(DstOutputData%Vr_wake)) THEN 
    ALLOCATE(DstOutputData%Vr_wake(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vr_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vr_wake = SrcOutputData%Vr_wake
ENDIF
IF (ALLOCATED(SrcOutputData%Vx_wake2)) THEN
  i1_l = LBOUND(SrcOutputData%Vx_wake2,1)
  i1_u = UBOUND(SrcOutputData%Vx_wake2,1)
  i2_l = LBOUND(SrcOutputData%Vx_wake2,2)
  i2_u = UBOUND(SrcOutputData%Vx_wake2,2)
  i3_l = LBOUND(SrcOutputData%Vx_wake2,3)
  i3_u = UBOUND(SrcOutputData%Vx_wake2,3)
  IF (.NOT. ALLOCATED(DstOutputData%Vx_wake2)) THEN 
    ALLOCATE(DstOutputData%Vx_wake2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vx_wake2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vx_wake2 = SrcOutputData%Vx_wake2
ENDIF
IF (ALLOCATED(SrcOutputData%Vy_wake2)) THEN
  i1_l = LBOUND(SrcOutputData%Vy_wake2,1)
  i1_u = UBOUND(SrcOutputData%Vy_wake2,1)
  i2_l = LBOUND(SrcOutputData%Vy_wake2,2)
  i2_u = UBOUND(SrcOutputData%Vy_wake2,2)
  i3_l = LBOUND(SrcOutputData%Vy_wake2,3)
  i3_u = UBOUND(SrcOutputData%Vy_wake2,3)
  IF (.NOT. ALLOCATED(DstOutputData%Vy_wake2)) THEN 
    ALLOCATE(DstOutputData%Vy_wake2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vy_wake2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vy_wake2 = SrcOutputData%Vy_wake2
ENDIF
IF (ALLOCATED(SrcOutputData%Vz_wake2)) THEN
  i1_l = LBOUND(SrcOutputData%Vz_wake2,1)
  i1_u = UBOUND(SrcOutputData%Vz_wake2,1)
  i2_l = LBOUND(SrcOutputData%Vz_wake2,2)
  i2_u = UBOUND(SrcOutputData%Vz_wake2,2)
  i3_l = LBOUND(SrcOutputData%Vz_wake2,3)
  i3_u = UBOUND(SrcOutputData%Vz_wake2,3)
  IF (.NOT. ALLOCATED(DstOutputData%Vz_wake2)) THEN 
    ALLOCATE(DstOutputData%Vz_wake2(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vz_wake2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vz_wake2 = SrcOutputData%Vz_wake2
ENDIF
IF (ALLOCATED(SrcOutputData%D_wake)) THEN
  i1_l = LBOUND(SrcOutputData%D_wake,1)
  i1_u = UBOUND(SrcOutputData%D_wake,1)
  IF (.NOT. ALLOCATED(DstOutputData%D_wake)) THEN 
    ALLOCATE(DstOutputData%D_wake(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%D_wake.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%D_wake = SrcOutputData%D_wake
ENDIF
IF (ALLOCATED(SrcOutputData%x_plane)) THEN
  i1_l = LBOUND(SrcOutputData%x_plane,1)
  i1_u = UBOUND(SrcOutputData%x_plane,1)
  IF (.NOT. ALLOCATED(DstOutputData%x_plane)) THEN 
    ALLOCATE(DstOutputData%x_plane(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%x_plane.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%x_plane = SrcOutputData%x_plane
ENDIF
IF (ALLOCATED(SrcOutputData%WAT_k_mt)) THEN
  i1_l = LBOUND(SrcOutputData%WAT_k_mt,1)
  i1_u = UBOUND(SrcOutputData%WAT_k_mt,1)
  i2_l = LBOUND(SrcOutputData%WAT_k_mt,2)
  i2_u = UBOUND(SrcOutputData%WAT_k_mt,2)
  i3_l = LBOUND(SrcOutputData%WAT_k_mt,3)
  i3_u = UBOUND(SrcOutputData%WAT_k_mt,3)
  IF (.NOT. ALLOCATED(DstOutputData%WAT_k_mt)) THEN 
    ALLOCATE(DstOutputData%WAT_k_mt(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WAT_k_mt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WAT_k_mt = SrcOutputData%WAT_k_mt
ENDIF
 END SUBROUTINE WD_CopyOutput

 SUBROUTINE WD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(WD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WD_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%xhat_plane)) THEN
  DEALLOCATE(OutputData%xhat_plane)
ENDIF
IF (ALLOCATED(OutputData%p_plane)) THEN
  DEALLOCATE(OutputData%p_plane)
ENDIF
IF (ALLOCATED(OutputData%Vx_wake)) THEN
  DEALLOCATE(OutputData%Vx_wake)
ENDIF
IF (ALLOCATED(OutputData%Vr_wake)) THEN
  DEALLOCATE(OutputData%Vr_wake)
ENDIF
IF (ALLOCATED(OutputData%Vx_wake2)) THEN
  DEALLOCATE(OutputData%Vx_wake2)
ENDIF
IF (ALLOCATED(OutputData%Vy_wake2)) THEN
  DEALLOCATE(OutputData%Vy_wake2)
ENDIF
IF (ALLOCATED(OutputData%Vz_wake2)) THEN
  DEALLOCATE(OutputData%Vz_wake2)
ENDIF
IF (ALLOCATED(OutputData%D_wake)) THEN
  DEALLOCATE(OutputData%D_wake)
ENDIF
IF (ALLOCATED(OutputData%x_plane)) THEN
  DEALLOCATE(OutputData%x_plane)
ENDIF
IF (ALLOCATED(OutputData%WAT_k_mt)) THEN
  DEALLOCATE(OutputData%WAT_k_mt)
ENDIF
 END SUBROUTINE WD_DestroyOutput


subroutine WD_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WD_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! xhat_plane
   call RegPack(Buf, allocated(InData%xhat_plane))
   if (allocated(InData%xhat_plane)) then
      call RegPackBounds(Buf, 2, lbound(InData%xhat_plane), ubound(InData%xhat_plane))
      call RegPack(Buf, InData%xhat_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_plane
   call RegPack(Buf, allocated(InData%p_plane))
   if (allocated(InData%p_plane)) then
      call RegPackBounds(Buf, 2, lbound(InData%p_plane), ubound(InData%p_plane))
      call RegPack(Buf, InData%p_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wake
   call RegPack(Buf, allocated(InData%Vx_wake))
   if (allocated(InData%Vx_wake)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vx_wake), ubound(InData%Vx_wake))
      call RegPack(Buf, InData%Vx_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vr_wake
   call RegPack(Buf, allocated(InData%Vr_wake))
   if (allocated(InData%Vr_wake)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vr_wake), ubound(InData%Vr_wake))
      call RegPack(Buf, InData%Vr_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vx_wake2
   call RegPack(Buf, allocated(InData%Vx_wake2))
   if (allocated(InData%Vx_wake2)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vx_wake2), ubound(InData%Vx_wake2))
      call RegPack(Buf, InData%Vx_wake2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vy_wake2
   call RegPack(Buf, allocated(InData%Vy_wake2))
   if (allocated(InData%Vy_wake2)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vy_wake2), ubound(InData%Vy_wake2))
      call RegPack(Buf, InData%Vy_wake2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vz_wake2
   call RegPack(Buf, allocated(InData%Vz_wake2))
   if (allocated(InData%Vz_wake2)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vz_wake2), ubound(InData%Vz_wake2))
      call RegPack(Buf, InData%Vz_wake2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D_wake
   call RegPack(Buf, allocated(InData%D_wake))
   if (allocated(InData%D_wake)) then
      call RegPackBounds(Buf, 1, lbound(InData%D_wake), ubound(InData%D_wake))
      call RegPack(Buf, InData%D_wake)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! x_plane
   call RegPack(Buf, allocated(InData%x_plane))
   if (allocated(InData%x_plane)) then
      call RegPackBounds(Buf, 1, lbound(InData%x_plane), ubound(InData%x_plane))
      call RegPack(Buf, InData%x_plane)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAT_k_mt
   call RegPack(Buf, allocated(InData%WAT_k_mt))
   if (allocated(InData%WAT_k_mt)) then
      call RegPackBounds(Buf, 3, lbound(InData%WAT_k_mt), ubound(InData%WAT_k_mt))
      call RegPack(Buf, InData%WAT_k_mt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WD_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WD_UnPackOutput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! xhat_plane
   if (allocated(OutData%xhat_plane)) deallocate(OutData%xhat_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xhat_plane(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xhat_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%xhat_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! p_plane
   if (allocated(OutData%p_plane)) deallocate(OutData%p_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%p_plane(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%p_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%p_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wake
   if (allocated(OutData%Vx_wake)) deallocate(OutData%Vx_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vr_wake
   if (allocated(OutData%Vr_wake)) deallocate(OutData%Vr_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vr_wake(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vr_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vr_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vx_wake2
   if (allocated(OutData%Vx_wake2)) deallocate(OutData%Vx_wake2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx_wake2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx_wake2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx_wake2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vy_wake2
   if (allocated(OutData%Vy_wake2)) deallocate(OutData%Vy_wake2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vy_wake2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vy_wake2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vy_wake2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vz_wake2
   if (allocated(OutData%Vz_wake2)) deallocate(OutData%Vz_wake2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vz_wake2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vz_wake2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vz_wake2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D_wake
   if (allocated(OutData%D_wake)) deallocate(OutData%D_wake)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D_wake(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D_wake.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D_wake)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! x_plane
   if (allocated(OutData%x_plane)) deallocate(OutData%x_plane)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x_plane(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x_plane.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%x_plane)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WAT_k_mt
   if (allocated(OutData%WAT_k_mt)) deallocate(OutData%WAT_k_mt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAT_k_mt(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAT_k_mt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WAT_k_mt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
END MODULE WakeDynamics_Types
!ENDOFREGISTRYGENERATEDFILE
