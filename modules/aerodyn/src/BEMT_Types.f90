!STARTOFREGISTRYGENERATEDFILE 'BEMT_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! BEMT_Types
!.................................................................................................................................
! This file is part of BEMT.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in BEMT. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE BEMT_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE UnsteadyAero_Types
USE DBEMT_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SkewMod_Orthogonal = 0      ! Inflow orthogonal to rotor [-] [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SkewMod_Uncoupled = 1      ! Uncoupled (no correction) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SkewMod_PittPeters = 2      ! Pitt/Peters [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SkewMod_Coupled = 3      ! Coupled [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SkewMod_PittPeters_Cont = 4      ! Pitt/Peters continuous formulation [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: BEMMod_2D = 0      ! 2D BEM assuming Cx, Cy, phi, L, D are in the same plane [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: BEMMod_3D = 2      ! 3D BEM assuming a momentum balance system, and an airfoil system [-]
! =========  BEMT_InitInputType  =======
  TYPE, PUBLIC :: BEMT_InitInputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      !< Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      !< Number of blades [-]
    REAL(ReKi)  :: airDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: skewWakeMod      !< Type of skewed-wake correction model [switch] {1=uncoupled, 2=Pitt/Peters, 3=coupled} [-]
    REAL(ReKi)  :: aTol      !< Tolerance for the induction solution [-]
    LOGICAL  :: useTipLoss      !< Use the Prandtl tip-loss model?  [flag] [-]
    LOGICAL  :: useHubLoss      !< Use the Prandtl hub-loss model?  [flag] [-]
    LOGICAL  :: useInduction      !< Include induction in BEMT calculations [flag] { If FALSE then useTanInd will be set to FALSE} [-]
    LOGICAL  :: useTanInd      !< Include tangential induction in BEMT calculations [flag] [-]
    LOGICAL  :: useAIDrag      !< Include the drag term in the axial-induction calculation?  [flag] [-]
    LOGICAL  :: useTIDrag      !< Include the drag term in the tangential-induction calculation?  Ignored if TanInd is False.  [flag] [-]
    LOGICAL  :: MomentumCorr      !< Momentum Correction {0=Axial Theory, 1 = Glauert Momentum Theory} [-]
    INTEGER(IntKi)  :: numBladeNodes      !< Number of blade nodes used in the analysis [-]
    INTEGER(IntKi)  :: numReIterations      !< Number of iterations for finding the Reynolds number [-]
    INTEGER(IntKi)  :: maxIndIterations      !< Maximum number of iterations of induction factor solve [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zHub      !< Distance to hub for each blade [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: zLocal      !< Distance to blade node, measured along the blade [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zTip      !< Distance to blade tip, measured along the blade [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rLocal      !< Radial distance to blade node from the center of rotation, measured in the rotor plane, needed for DBEMT [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: rTipFix      !< Nominally the coned rotor diameter (without prebend), used to align with Bladed calculations [m]
    INTEGER(IntKi)  :: UAMod      !< Model for the dynamic stall equations [1 = Leishman/Beddoes, 2 = Gonzalez, 3 = Minnema] [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    LOGICAL  :: Flookup      !< Use table lookup for f' and f''  [-]
    REAL(ReKi)  :: a_s      !< speed of sound [m/s]
    INTEGER(IntKi)  :: DBEMT_Mod      !< DBEMT model.  1 = constant tau1, 2 = time dependent tau1 [-]
    REAL(ReKi)  :: tau1_const      !< DBEMT time constant (when DBEMT_Mod=1) [s]
    REAL(ReKi)  :: yawCorrFactor      !< constant used in Pitt/Peters skewed wake model (default is 15*pi/32) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: UAOff_innerNode      !< Last node on each blade where UA should be turned off based on span location from blade root (0 if always on) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: UAOff_outerNode      !< First node on each blade where UA should be turned off based on span location from blade tip (>nNodesPerBlade if always on) [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    LOGICAL  :: SumPrint      !< logical flag indicating whether to use UnsteadyAero [-]
    INTEGER(IntKi)  :: BEM_Mod      !< BEM Model 0=OpenFAST 2=Envision  [-]
  END TYPE BEMT_InitInputType
! =======================
! =========  BEMT_InitOutputType  =======
  TYPE, PUBLIC :: BEMT_InitOutputType
    TYPE(ProgDesc)  :: Version      !<  [-]
  END TYPE BEMT_InitOutputType
! =======================
! =========  BEMT_SkewWake_InputType  =======
  TYPE, PUBLIC :: BEMT_SkewWake_InputType
    REAL(ReKi) , DIMENSION(1:3)  :: v_qsw      !< quasi-steady instantaneous wake velocity (value to be filtered in Skewed Wake model) [m/s]
    REAL(ReKi)  :: V0      !< magnitude of disk-averaged velocity (for input to SkewWake) [m/s]
    REAL(ReKi)  :: R      !< rotor radius (for input to SkewWake) [m]
  END TYPE BEMT_SkewWake_InputType
! =======================
! =========  BEMT_ContinuousStateType  =======
  TYPE, PUBLIC :: BEMT_ContinuousStateType
    TYPE(UA_ContinuousStateType)  :: UA      !< UA module continuous states [-]
    TYPE(DBEMT_ContinuousStateType)  :: DBEMT      !< DBEMT module continuous states [-]
    REAL(R8Ki) , DIMENSION(1:3)  :: V_w      !< continuous state for filtering  wake velocity [-]
  END TYPE BEMT_ContinuousStateType
! =======================
! =========  BEMT_DiscreteStateType  =======
  TYPE, PUBLIC :: BEMT_DiscreteStateType
    TYPE(UA_DiscreteStateType)  :: UA      !< states for UnsteadyAero [-]
  END TYPE BEMT_DiscreteStateType
! =======================
! =========  BEMT_ConstraintStateType  =======
  TYPE, PUBLIC :: BEMT_ConstraintStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: phi      !< angle between the plane of rotation and the direction of the local wind [rad]
  END TYPE BEMT_ConstraintStateType
! =======================
! =========  BEMT_OtherStateType  =======
  TYPE, PUBLIC :: BEMT_OtherStateType
    TYPE(UA_OtherStateType)  :: UA      !< other states for UnsteadyAero [-]
    TYPE(DBEMT_OtherStateType)  :: DBEMT      !< other states for DBEMT [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: ValidPhi      !< set to indicate when there is no valid Phi for this node at this time (temporarially turn off induction when this is false) [-]
    LOGICAL  :: nodesInitialized      !< the node states have been initialized properly [-]
    TYPE(BEMT_ContinuousStateType) , DIMENSION(1:4)  :: xdot      !< history states for continuous state integration [-]
    INTEGER(IntKi)  :: n      !< time step # value used for continuous state integrator [-]
  END TYPE BEMT_OtherStateType
! =======================
! =========  BEMT_MiscVarType  =======
  TYPE, PUBLIC :: BEMT_MiscVarType
    LOGICAL  :: FirstWarn_Skew      !< flag so invalid skew warning doesn't get repeated forever [-]
    LOGICAL  :: FirstWarn_Phi      !< flag so Invalid Phi warning doesn't get repeated forever [-]
    LOGICAL  :: FirstWarn_BEMoff      !< flag to warn the BEM was turned off [-]
    TYPE(UA_MiscVarType)  :: UA      !< misc vars for UnsteadyAero [-]
    TYPE(DBEMT_MiscVarType)  :: DBEMT      !< misc vars for DBEMT [-]
    TYPE(UA_OutputType)  :: y_UA      !< outputs from UnsteadyAero [-]
    TYPE(UA_InputType) , DIMENSION(:,:,:), ALLOCATABLE  :: u_UA      !< inputs to UnsteadyAero at t and t+dt [-]
    TYPE(DBEMT_InputType) , DIMENSION(1:2)  :: u_DBEMT      !< inputs to DBEMT at t and t+dt [-]
    TYPE(BEMT_SkewWake_InputType) , DIMENSION(1:2)  :: u_SkewWake      !< inputs to SkewedWake at t and t+dt [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TnInd_op      !< tangential induction at the operating point (for linearization with frozen wake assumption) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AxInd_op      !< axial induction at the operating point (for linearization) with frozen wake assumption [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AxInduction      !< axial induction used for code run-time optimization [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TanInduction      !< tangential induction used for code run-time optimization [-]
    LOGICAL  :: UseFrozenWake      !< flag set to determine if frozen values of TnInd_op and AxInd_op should be used for this calculation in the linearization process [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Rtip      !< maximum rlocal value for each blade (typically the value at the tip) [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: phi      !< temp variable used in update states for returning phi (to allow computing inputs and states at multiple times) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chi      !< temp variable used in update states for returning chi (to allow calling same routine from CalcOutput and UpdateStates) [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: ValidPhi      !< temp variable used in calcOutput for ValidPhi (to allow calling same routine from CalcOutput and UpdateStates) [-]
    REAL(ReKi)  :: BEM_weight 
  END TYPE BEMT_MiscVarType
! =======================
! =========  BEMT_ParameterType  =======
  TYPE, PUBLIC :: BEMT_ParameterType
    REAL(DbKi)  :: DT      !< time step [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord      !< Chord length at node [m]
    INTEGER(IntKi)  :: numBlades      !< Number of blades [-]
    REAL(ReKi)  :: airDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: kinVisc      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: skewWakeMod      !< Type of skewed-wake correction model [switch] {1=uncoupled, 2=Pitt/Peters, 3=coupled} [-]
    REAL(ReKi)  :: aTol      !< Tolerance for the induction solution [-]
    LOGICAL  :: useTipLoss      !< Use the Prandtl tip-loss model?  [flag] [-]
    LOGICAL  :: useHubLoss      !< Use the Prandtl hub-loss model?  [flag] [-]
    LOGICAL  :: useInduction      !< Include induction in BEMT calculations [flag] { If FALSE then useTanInd will be set to FALSE} [-]
    LOGICAL  :: useTanInd      !< Include tangential induction in BEMT calculations [flag] [-]
    LOGICAL  :: useAIDrag      !< Include the drag term in the axial-induction calculation?  [flag] [-]
    LOGICAL  :: useTIDrag      !< Include the drag term in the tangential-induction calculation?  Ignored if TanInd is False.  [flag] [-]
    INTEGER(IntKi)  :: numBladeNodes      !< Number of blade nodes used in the analysis [-]
    INTEGER(IntKi)  :: numReIterations      !< Number of iterations for finding the Reynolds number [-]
    INTEGER(IntKi)  :: maxIndIterations      !< Maximum number of iterations of induction factor solve [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index of airfoil data file for blade node location [array of numBladeNodes] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: tipLossConst      !< A constant computed during initialization based on B*(zTip-zLocal)/(2*zLocal) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: hubLossConst      !< A constant computed during initialization based on B*(zLocal-zHub)/(2*zHub) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zHub      !< Distance to hub for each blade [m]
    TYPE(UA_ParameterType)  :: UA      !< parameters for UnsteadyAero [-]
    TYPE(DBEMT_ParameterType)  :: DBEMT      !< parameters for DBEMT [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    INTEGER(IntKi)  :: DBEMT_Mod      !< DBEMT Model.  0 = constant tau1, 1 = time dependent tau1 [-]
    REAL(ReKi)  :: yawCorrFactor      !< constant used in Pitt/Peters skewed wake model (default is 15*pi/32) [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: FixedInductions      !< flag to determine if BEM inductions should be fixed and not modified by dbemt or skewed wake [-]
    LOGICAL  :: MomentumCorr      !< Momentum Correction {0=Axial Theory, 1 = Glauert Momentum Theory} [-]
    REAL(ReKi)  :: rTipFixMax      !< Nominally the coned rotor diameter (without prebend), used to align with Bladed calculations [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: IntegrateWeight      !< A weighting factor for calculating rotor-averaged values (e.g., AxInd) [-]
    INTEGER(IntKi)  :: lin_nx = 0      !< Number of continuous states for linearization [-]
    INTEGER(IntKi)  :: BEM_Mod      !< BEM Model 0=OpenFAST 2=Envision  [-]
  END TYPE BEMT_ParameterType
! =======================
! =========  BEMT_InputType  =======
  TYPE, PUBLIC :: BEMT_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: theta      !< Twist angle (includes all sources of twist)  [Array of size (NumBlNds,numBlades)] [rad]
    REAL(ReKi)  :: chi0      !< Angle between the vector normal to the rotor plane and the wind vector (e.g., the yaw angle in the case of no tilt) [rad]
    REAL(ReKi)  :: psiSkewOffset      !< Azimuth angle offset (relative to 90 deg) of the most downwind blade when chi0 is non-zero [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: psi      !< Azimuth angle [rad]
    REAL(ReKi)  :: omega      !< Angular velocity of rotor [rad/s]
    REAL(ReKi)  :: TSR      !< Tip-speed ratio (to check if BEM should be turned off) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vx      !< Local axial velocity at node [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vy      !< Local tangential velocity at node [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vz      !< Local radial velocity at node [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: omega_z      !< rotation of no-sweep-pitch-twist coordinate system around z (for CDBEMT and CUA) [rad/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: xVelCorr      !< projection of velocity when yawed + prebend [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: rLocal      !< Radial distance from center-of-rotation to node [m]
    REAL(ReKi)  :: Un_disk      !< disk-averaged velocity normal to the rotor disk (for input to DBEMT) [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: V0      !< disk-averaged velocity (for input to SkewWake) [m/s]
    REAL(R8Ki) , DIMENSION(1:3)  :: x_hat_disk      !< Hub Orientation vector: normal to rotor disk [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: UserProp      !< Optional user property for interpolating airfoils (per element per blade) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CantAngle      !< Cant angle [Array of size (NumBlNds,numBlades)] [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: drdz      !< dr/dz geometric parameter [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: toeAngle      !< Toe angle [Array of size (NumBlNds,numBlades)] [rad]
  END TYPE BEMT_InputType
! =======================
! =========  BEMT_OutputType  =======
  TYPE, PUBLIC :: BEMT_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vrel      !< Total local relative velocity [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: phi      !< angle between the plane of rotation and the direction of the local wind [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: axInduction      !< axial induction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: tanInduction      !< tangential induction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Re      !< Reynold's number [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AOA      !< angle of attack [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cx      !< normal force coefficient (normal to the plane, not chord) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cy      !< tangential force coefficient (tangential to the plane, not chord) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cz      !< axial force coefficient (tangential to the plane, not chord) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cmx      !< pitching moment coefficient (x-component) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cmy      !< pitching moment coefficient (y-component) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cmz      !< pitching moment coefficient (z-component) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cm      !< pitching moment coefficient of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cl      !< lift coefficient [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cd      !< drag coefficient [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chi      !< wake skew angle [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cpmin      !< min Cpressure [-]
  END TYPE BEMT_OutputType
! =======================
CONTAINS

subroutine BEMT_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_InitInputType), intent(in) :: SrcInitInputData
   type(BEMT_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'BEMT_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitInputData%chord)) then
      LB(1:2) = lbound(SrcInitInputData%chord)
      UB(1:2) = ubound(SrcInitInputData%chord)
      if (.not. allocated(DstInitInputData%chord)) then
         allocate(DstInitInputData%chord(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%chord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%chord = SrcInitInputData%chord
   else if (allocated(DstInitInputData%chord)) then
      deallocate(DstInitInputData%chord)
   end if
   DstInitInputData%numBlades = SrcInitInputData%numBlades
   DstInitInputData%airDens = SrcInitInputData%airDens
   DstInitInputData%kinVisc = SrcInitInputData%kinVisc
   DstInitInputData%skewWakeMod = SrcInitInputData%skewWakeMod
   DstInitInputData%aTol = SrcInitInputData%aTol
   DstInitInputData%useTipLoss = SrcInitInputData%useTipLoss
   DstInitInputData%useHubLoss = SrcInitInputData%useHubLoss
   DstInitInputData%useInduction = SrcInitInputData%useInduction
   DstInitInputData%useTanInd = SrcInitInputData%useTanInd
   DstInitInputData%useAIDrag = SrcInitInputData%useAIDrag
   DstInitInputData%useTIDrag = SrcInitInputData%useTIDrag
   DstInitInputData%MomentumCorr = SrcInitInputData%MomentumCorr
   DstInitInputData%numBladeNodes = SrcInitInputData%numBladeNodes
   DstInitInputData%numReIterations = SrcInitInputData%numReIterations
   DstInitInputData%maxIndIterations = SrcInitInputData%maxIndIterations
   if (allocated(SrcInitInputData%AFindx)) then
      LB(1:2) = lbound(SrcInitInputData%AFindx)
      UB(1:2) = ubound(SrcInitInputData%AFindx)
      if (.not. allocated(DstInitInputData%AFindx)) then
         allocate(DstInitInputData%AFindx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%AFindx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%AFindx = SrcInitInputData%AFindx
   else if (allocated(DstInitInputData%AFindx)) then
      deallocate(DstInitInputData%AFindx)
   end if
   if (allocated(SrcInitInputData%zHub)) then
      LB(1:1) = lbound(SrcInitInputData%zHub)
      UB(1:1) = ubound(SrcInitInputData%zHub)
      if (.not. allocated(DstInitInputData%zHub)) then
         allocate(DstInitInputData%zHub(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zHub.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%zHub = SrcInitInputData%zHub
   else if (allocated(DstInitInputData%zHub)) then
      deallocate(DstInitInputData%zHub)
   end if
   if (allocated(SrcInitInputData%zLocal)) then
      LB(1:2) = lbound(SrcInitInputData%zLocal)
      UB(1:2) = ubound(SrcInitInputData%zLocal)
      if (.not. allocated(DstInitInputData%zLocal)) then
         allocate(DstInitInputData%zLocal(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zLocal.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%zLocal = SrcInitInputData%zLocal
   else if (allocated(DstInitInputData%zLocal)) then
      deallocate(DstInitInputData%zLocal)
   end if
   if (allocated(SrcInitInputData%zTip)) then
      LB(1:1) = lbound(SrcInitInputData%zTip)
      UB(1:1) = ubound(SrcInitInputData%zTip)
      if (.not. allocated(DstInitInputData%zTip)) then
         allocate(DstInitInputData%zTip(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%zTip.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%zTip = SrcInitInputData%zTip
   else if (allocated(DstInitInputData%zTip)) then
      deallocate(DstInitInputData%zTip)
   end if
   if (allocated(SrcInitInputData%rLocal)) then
      LB(1:2) = lbound(SrcInitInputData%rLocal)
      UB(1:2) = ubound(SrcInitInputData%rLocal)
      if (.not. allocated(DstInitInputData%rLocal)) then
         allocate(DstInitInputData%rLocal(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%rLocal.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%rLocal = SrcInitInputData%rLocal
   else if (allocated(DstInitInputData%rLocal)) then
      deallocate(DstInitInputData%rLocal)
   end if
   if (allocated(SrcInitInputData%rTipFix)) then
      LB(1:1) = lbound(SrcInitInputData%rTipFix)
      UB(1:1) = ubound(SrcInitInputData%rTipFix)
      if (.not. allocated(DstInitInputData%rTipFix)) then
         allocate(DstInitInputData%rTipFix(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%rTipFix.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%rTipFix = SrcInitInputData%rTipFix
   else if (allocated(DstInitInputData%rTipFix)) then
      deallocate(DstInitInputData%rTipFix)
   end if
   DstInitInputData%UAMod = SrcInitInputData%UAMod
   DstInitInputData%UA_Flag = SrcInitInputData%UA_Flag
   DstInitInputData%Flookup = SrcInitInputData%Flookup
   DstInitInputData%a_s = SrcInitInputData%a_s
   DstInitInputData%DBEMT_Mod = SrcInitInputData%DBEMT_Mod
   DstInitInputData%tau1_const = SrcInitInputData%tau1_const
   DstInitInputData%yawCorrFactor = SrcInitInputData%yawCorrFactor
   if (allocated(SrcInitInputData%UAOff_innerNode)) then
      LB(1:1) = lbound(SrcInitInputData%UAOff_innerNode)
      UB(1:1) = ubound(SrcInitInputData%UAOff_innerNode)
      if (.not. allocated(DstInitInputData%UAOff_innerNode)) then
         allocate(DstInitInputData%UAOff_innerNode(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%UAOff_innerNode.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%UAOff_innerNode = SrcInitInputData%UAOff_innerNode
   else if (allocated(DstInitInputData%UAOff_innerNode)) then
      deallocate(DstInitInputData%UAOff_innerNode)
   end if
   if (allocated(SrcInitInputData%UAOff_outerNode)) then
      LB(1:1) = lbound(SrcInitInputData%UAOff_outerNode)
      UB(1:1) = ubound(SrcInitInputData%UAOff_outerNode)
      if (.not. allocated(DstInitInputData%UAOff_outerNode)) then
         allocate(DstInitInputData%UAOff_outerNode(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%UAOff_outerNode.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%UAOff_outerNode = SrcInitInputData%UAOff_outerNode
   else if (allocated(DstInitInputData%UAOff_outerNode)) then
      deallocate(DstInitInputData%UAOff_outerNode)
   end if
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%SumPrint = SrcInitInputData%SumPrint
   DstInitInputData%BEM_Mod = SrcInitInputData%BEM_Mod
end subroutine

subroutine BEMT_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(BEMT_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'BEMT_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%chord)) then
      deallocate(InitInputData%chord)
   end if
   if (allocated(InitInputData%AFindx)) then
      deallocate(InitInputData%AFindx)
   end if
   if (allocated(InitInputData%zHub)) then
      deallocate(InitInputData%zHub)
   end if
   if (allocated(InitInputData%zLocal)) then
      deallocate(InitInputData%zLocal)
   end if
   if (allocated(InitInputData%zTip)) then
      deallocate(InitInputData%zTip)
   end if
   if (allocated(InitInputData%rLocal)) then
      deallocate(InitInputData%rLocal)
   end if
   if (allocated(InitInputData%rTipFix)) then
      deallocate(InitInputData%rTipFix)
   end if
   if (allocated(InitInputData%UAOff_innerNode)) then
      deallocate(InitInputData%UAOff_innerNode)
   end if
   if (allocated(InitInputData%UAOff_outerNode)) then
      deallocate(InitInputData%UAOff_outerNode)
   end if
end subroutine

subroutine BEMT_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%chord))
   if (allocated(InData%chord)) then
      call RegPackBounds(Buf, 2, lbound(InData%chord), ubound(InData%chord))
      call RegPack(Buf, InData%chord)
   end if
   call RegPack(Buf, InData%numBlades)
   call RegPack(Buf, InData%airDens)
   call RegPack(Buf, InData%kinVisc)
   call RegPack(Buf, InData%skewWakeMod)
   call RegPack(Buf, InData%aTol)
   call RegPack(Buf, InData%useTipLoss)
   call RegPack(Buf, InData%useHubLoss)
   call RegPack(Buf, InData%useInduction)
   call RegPack(Buf, InData%useTanInd)
   call RegPack(Buf, InData%useAIDrag)
   call RegPack(Buf, InData%useTIDrag)
   call RegPack(Buf, InData%MomentumCorr)
   call RegPack(Buf, InData%numBladeNodes)
   call RegPack(Buf, InData%numReIterations)
   call RegPack(Buf, InData%maxIndIterations)
   call RegPack(Buf, allocated(InData%AFindx))
   if (allocated(InData%AFindx)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFindx), ubound(InData%AFindx))
      call RegPack(Buf, InData%AFindx)
   end if
   call RegPack(Buf, allocated(InData%zHub))
   if (allocated(InData%zHub)) then
      call RegPackBounds(Buf, 1, lbound(InData%zHub), ubound(InData%zHub))
      call RegPack(Buf, InData%zHub)
   end if
   call RegPack(Buf, allocated(InData%zLocal))
   if (allocated(InData%zLocal)) then
      call RegPackBounds(Buf, 2, lbound(InData%zLocal), ubound(InData%zLocal))
      call RegPack(Buf, InData%zLocal)
   end if
   call RegPack(Buf, allocated(InData%zTip))
   if (allocated(InData%zTip)) then
      call RegPackBounds(Buf, 1, lbound(InData%zTip), ubound(InData%zTip))
      call RegPack(Buf, InData%zTip)
   end if
   call RegPack(Buf, allocated(InData%rLocal))
   if (allocated(InData%rLocal)) then
      call RegPackBounds(Buf, 2, lbound(InData%rLocal), ubound(InData%rLocal))
      call RegPack(Buf, InData%rLocal)
   end if
   call RegPack(Buf, allocated(InData%rTipFix))
   if (allocated(InData%rTipFix)) then
      call RegPackBounds(Buf, 1, lbound(InData%rTipFix), ubound(InData%rTipFix))
      call RegPack(Buf, InData%rTipFix)
   end if
   call RegPack(Buf, InData%UAMod)
   call RegPack(Buf, InData%UA_Flag)
   call RegPack(Buf, InData%Flookup)
   call RegPack(Buf, InData%a_s)
   call RegPack(Buf, InData%DBEMT_Mod)
   call RegPack(Buf, InData%tau1_const)
   call RegPack(Buf, InData%yawCorrFactor)
   call RegPack(Buf, allocated(InData%UAOff_innerNode))
   if (allocated(InData%UAOff_innerNode)) then
      call RegPackBounds(Buf, 1, lbound(InData%UAOff_innerNode), ubound(InData%UAOff_innerNode))
      call RegPack(Buf, InData%UAOff_innerNode)
   end if
   call RegPack(Buf, allocated(InData%UAOff_outerNode))
   if (allocated(InData%UAOff_outerNode)) then
      call RegPackBounds(Buf, 1, lbound(InData%UAOff_outerNode), ubound(InData%UAOff_outerNode))
      call RegPack(Buf, InData%UAOff_outerNode)
   end if
   call RegPack(Buf, InData%RootName)
   call RegPack(Buf, InData%SumPrint)
   call RegPack(Buf, InData%BEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackInitInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%chord)) deallocate(OutData%chord)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chord(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chord)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%numBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%airDens)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%kinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%skewWakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%aTol)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useTipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useHubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useInduction)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useTanInd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useAIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useTIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%MomentumCorr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%numBladeNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%numReIterations)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%maxIndIterations)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%AFindx)) deallocate(OutData%AFindx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFindx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFindx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFindx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%zHub)) deallocate(OutData%zHub)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zHub(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zHub.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zHub)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%zLocal)) deallocate(OutData%zLocal)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zLocal(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zLocal.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zLocal)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%zTip)) deallocate(OutData%zTip)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zTip(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zTip.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zTip)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%rLocal)) deallocate(OutData%rLocal)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rLocal(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rLocal.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rLocal)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%rTipFix)) deallocate(OutData%rTipFix)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rTipFix(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rTipFix.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rTipFix)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%UAMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%Flookup)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%a_s)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DBEMT_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%tau1_const)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%yawCorrFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%UAOff_innerNode)) deallocate(OutData%UAOff_innerNode)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UAOff_innerNode(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UAOff_innerNode.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UAOff_innerNode)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%UAOff_outerNode)) deallocate(OutData%UAOff_outerNode)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UAOff_outerNode(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UAOff_outerNode.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UAOff_outerNode)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_InitOutputType), intent(in) :: SrcInitOutputData
   type(BEMT_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Version, DstInitOutputData%Version, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine BEMT_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(BEMT_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call NWTC_Library_DestroyProgDesc(InitOutputData%Version, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine BEMT_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   call NWTC_Library_PackProgDesc(Buf, InData%Version) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Version) ! Version 
end subroutine

subroutine BEMT_CopySkewWake_InputType(SrcSkewWake_InputTypeData, DstSkewWake_InputTypeData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_SkewWake_InputType), intent(in) :: SrcSkewWake_InputTypeData
   type(BEMT_SkewWake_InputType), intent(inout) :: DstSkewWake_InputTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'BEMT_CopySkewWake_InputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstSkewWake_InputTypeData%v_qsw = SrcSkewWake_InputTypeData%v_qsw
   DstSkewWake_InputTypeData%V0 = SrcSkewWake_InputTypeData%V0
   DstSkewWake_InputTypeData%R = SrcSkewWake_InputTypeData%R
end subroutine

subroutine BEMT_DestroySkewWake_InputType(SkewWake_InputTypeData, ErrStat, ErrMsg)
   type(BEMT_SkewWake_InputType), intent(inout) :: SkewWake_InputTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'BEMT_DestroySkewWake_InputType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine BEMT_PackSkewWake_InputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_SkewWake_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackSkewWake_InputType'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%v_qsw)
   call RegPack(Buf, InData%V0)
   call RegPack(Buf, InData%R)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackSkewWake_InputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_SkewWake_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackSkewWake_InputType'
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%v_qsw)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%V0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%R)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_ContinuousStateType), intent(in) :: SrcContStateData
   type(BEMT_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_CopyContState(SrcContStateData%UA, DstContStateData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DBEMT_CopyContState(SrcContStateData%DBEMT, DstContStateData%DBEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstContStateData%V_w = SrcContStateData%V_w
end subroutine

subroutine BEMT_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(BEMT_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyContState(ContStateData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DBEMT_DestroyContState(ContStateData%DBEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine BEMT_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   call UA_PackContState(Buf, InData%UA) 
   call DBEMT_PackContState(Buf, InData%DBEMT) 
   call RegPack(Buf, InData%V_w)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   call UA_UnpackContState(Buf, OutData%UA) ! UA 
   call DBEMT_UnpackContState(Buf, OutData%DBEMT) ! DBEMT 
   call RegUnpack(Buf, OutData%V_w)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(BEMT_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_CopyDiscState(SrcDiscStateData%UA, DstDiscStateData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
end subroutine

subroutine BEMT_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(BEMT_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyDiscState(DiscStateData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
end subroutine

subroutine BEMT_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   call UA_PackDiscState(Buf, InData%UA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   call UA_UnpackDiscState(Buf, OutData%UA) ! UA 
end subroutine

subroutine BEMT_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(BEMT_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'BEMT_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcConstrStateData%phi)) then
      LB(1:2) = lbound(SrcConstrStateData%phi)
      UB(1:2) = ubound(SrcConstrStateData%phi)
      if (.not. allocated(DstConstrStateData%phi)) then
         allocate(DstConstrStateData%phi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%phi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstConstrStateData%phi = SrcConstrStateData%phi
   else if (allocated(DstConstrStateData%phi)) then
      deallocate(DstConstrStateData%phi)
   end if
end subroutine

subroutine BEMT_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(BEMT_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'BEMT_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ConstrStateData%phi)) then
      deallocate(ConstrStateData%phi)
   end if
end subroutine

subroutine BEMT_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%phi))
   if (allocated(InData%phi)) then
      call RegPackBounds(Buf, 2, lbound(InData%phi), ubound(InData%phi))
      call RegPack(Buf, InData%phi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackConstrState'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%phi)) deallocate(OutData%phi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%phi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%phi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%phi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine BEMT_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_OtherStateType), intent(in) :: SrcOtherStateData
   type(BEMT_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_CopyOtherState(SrcOtherStateData%UA, DstOtherStateData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DBEMT_CopyOtherState(SrcOtherStateData%DBEMT, DstOtherStateData%DBEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcOtherStateData%ValidPhi)) then
      LB(1:2) = lbound(SrcOtherStateData%ValidPhi)
      UB(1:2) = ubound(SrcOtherStateData%ValidPhi)
      if (.not. allocated(DstOtherStateData%ValidPhi)) then
         allocate(DstOtherStateData%ValidPhi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%ValidPhi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOtherStateData%ValidPhi = SrcOtherStateData%ValidPhi
   else if (allocated(DstOtherStateData%ValidPhi)) then
      deallocate(DstOtherStateData%ValidPhi)
   end if
   DstOtherStateData%nodesInitialized = SrcOtherStateData%nodesInitialized
   LB(1:1) = lbound(SrcOtherStateData%xdot)
   UB(1:1) = ubound(SrcOtherStateData%xdot)
   do i1 = LB(1), UB(1)
      call BEMT_CopyContState(SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   DstOtherStateData%n = SrcOtherStateData%n
end subroutine

subroutine BEMT_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(BEMT_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyOtherState(OtherStateData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DBEMT_DestroyOtherState(OtherStateData%DBEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(OtherStateData%ValidPhi)) then
      deallocate(OtherStateData%ValidPhi)
   end if
   LB(1:1) = lbound(OtherStateData%xdot)
   UB(1:1) = ubound(OtherStateData%xdot)
   do i1 = LB(1), UB(1)
      call BEMT_DestroyContState(OtherStateData%xdot(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
end subroutine

subroutine BEMT_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackOtherState'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   call UA_PackOtherState(Buf, InData%UA) 
   call DBEMT_PackOtherState(Buf, InData%DBEMT) 
   call RegPack(Buf, allocated(InData%ValidPhi))
   if (allocated(InData%ValidPhi)) then
      call RegPackBounds(Buf, 2, lbound(InData%ValidPhi), ubound(InData%ValidPhi))
      call RegPack(Buf, InData%ValidPhi)
   end if
   call RegPack(Buf, InData%nodesInitialized)
   LB(1:1) = lbound(InData%xdot)
   UB(1:1) = ubound(InData%xdot)
   do i1 = LB(1), UB(1)
      call BEMT_PackContState(Buf, InData%xdot(i1)) 
   end do
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackOtherState'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call UA_UnpackOtherState(Buf, OutData%UA) ! UA 
   call DBEMT_UnpackOtherState(Buf, OutData%DBEMT) ! DBEMT 
   if (allocated(OutData%ValidPhi)) deallocate(OutData%ValidPhi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ValidPhi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ValidPhi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ValidPhi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%nodesInitialized)
   if (RegCheckErr(Buf, RoutineName)) return
   LB(1:1) = lbound(OutData%xdot)
   UB(1:1) = ubound(OutData%xdot)
   do i1 = LB(1), UB(1)
      call BEMT_UnpackContState(Buf, OutData%xdot(i1)) ! xdot 
   end do
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_MiscVarType), intent(in) :: SrcMiscData
   type(BEMT_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)                 :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstMiscData%FirstWarn_Skew = SrcMiscData%FirstWarn_Skew
   DstMiscData%FirstWarn_Phi = SrcMiscData%FirstWarn_Phi
   DstMiscData%FirstWarn_BEMoff = SrcMiscData%FirstWarn_BEMoff
   call UA_CopyMisc(SrcMiscData%UA, DstMiscData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DBEMT_CopyMisc(SrcMiscData%DBEMT, DstMiscData%DBEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call UA_CopyOutput(SrcMiscData%y_UA, DstMiscData%y_UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMiscData%u_UA)) then
      LB(1:3) = lbound(SrcMiscData%u_UA)
      UB(1:3) = ubound(SrcMiscData%u_UA)
      if (.not. allocated(DstMiscData%u_UA)) then
         allocate(DstMiscData%u_UA(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_UA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_CopyInput(SrcMiscData%u_UA(i1,i2,i3), DstMiscData%u_UA(i1,i2,i3), CtrlCode, ErrStat2, ErrMsg2)
               call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
               if (ErrStat >= AbortErrLev) return
            end do
         end do
      end do
   else if (allocated(DstMiscData%u_UA)) then
      deallocate(DstMiscData%u_UA)
   end if
   LB(1:1) = lbound(SrcMiscData%u_DBEMT)
   UB(1:1) = ubound(SrcMiscData%u_DBEMT)
   do i1 = LB(1), UB(1)
      call DBEMT_CopyInput(SrcMiscData%u_DBEMT(i1), DstMiscData%u_DBEMT(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   LB(1:1) = lbound(SrcMiscData%u_SkewWake)
   UB(1:1) = ubound(SrcMiscData%u_SkewWake)
   do i1 = LB(1), UB(1)
      call BEMT_CopySkewWake_InputType(SrcMiscData%u_SkewWake(i1), DstMiscData%u_SkewWake(i1), CtrlCode, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if (ErrStat >= AbortErrLev) return
   end do
   if (allocated(SrcMiscData%TnInd_op)) then
      LB(1:2) = lbound(SrcMiscData%TnInd_op)
      UB(1:2) = ubound(SrcMiscData%TnInd_op)
      if (.not. allocated(DstMiscData%TnInd_op)) then
         allocate(DstMiscData%TnInd_op(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%TnInd_op.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%TnInd_op = SrcMiscData%TnInd_op
   else if (allocated(DstMiscData%TnInd_op)) then
      deallocate(DstMiscData%TnInd_op)
   end if
   if (allocated(SrcMiscData%AxInd_op)) then
      LB(1:2) = lbound(SrcMiscData%AxInd_op)
      UB(1:2) = ubound(SrcMiscData%AxInd_op)
      if (.not. allocated(DstMiscData%AxInd_op)) then
         allocate(DstMiscData%AxInd_op(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%AxInd_op.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%AxInd_op = SrcMiscData%AxInd_op
   else if (allocated(DstMiscData%AxInd_op)) then
      deallocate(DstMiscData%AxInd_op)
   end if
   if (allocated(SrcMiscData%AxInduction)) then
      LB(1:2) = lbound(SrcMiscData%AxInduction)
      UB(1:2) = ubound(SrcMiscData%AxInduction)
      if (.not. allocated(DstMiscData%AxInduction)) then
         allocate(DstMiscData%AxInduction(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%AxInduction.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%AxInduction = SrcMiscData%AxInduction
   else if (allocated(DstMiscData%AxInduction)) then
      deallocate(DstMiscData%AxInduction)
   end if
   if (allocated(SrcMiscData%TanInduction)) then
      LB(1:2) = lbound(SrcMiscData%TanInduction)
      UB(1:2) = ubound(SrcMiscData%TanInduction)
      if (.not. allocated(DstMiscData%TanInduction)) then
         allocate(DstMiscData%TanInduction(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%TanInduction.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%TanInduction = SrcMiscData%TanInduction
   else if (allocated(DstMiscData%TanInduction)) then
      deallocate(DstMiscData%TanInduction)
   end if
   DstMiscData%UseFrozenWake = SrcMiscData%UseFrozenWake
   if (allocated(SrcMiscData%Rtip)) then
      LB(1:1) = lbound(SrcMiscData%Rtip)
      UB(1:1) = ubound(SrcMiscData%Rtip)
      if (.not. allocated(DstMiscData%Rtip)) then
         allocate(DstMiscData%Rtip(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Rtip.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%Rtip = SrcMiscData%Rtip
   else if (allocated(DstMiscData%Rtip)) then
      deallocate(DstMiscData%Rtip)
   end if
   if (allocated(SrcMiscData%phi)) then
      LB(1:2) = lbound(SrcMiscData%phi)
      UB(1:2) = ubound(SrcMiscData%phi)
      if (.not. allocated(DstMiscData%phi)) then
         allocate(DstMiscData%phi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%phi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%phi = SrcMiscData%phi
   else if (allocated(DstMiscData%phi)) then
      deallocate(DstMiscData%phi)
   end if
   if (allocated(SrcMiscData%chi)) then
      LB(1:2) = lbound(SrcMiscData%chi)
      UB(1:2) = ubound(SrcMiscData%chi)
      if (.not. allocated(DstMiscData%chi)) then
         allocate(DstMiscData%chi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%chi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%chi = SrcMiscData%chi
   else if (allocated(DstMiscData%chi)) then
      deallocate(DstMiscData%chi)
   end if
   if (allocated(SrcMiscData%ValidPhi)) then
      LB(1:2) = lbound(SrcMiscData%ValidPhi)
      UB(1:2) = ubound(SrcMiscData%ValidPhi)
      if (.not. allocated(DstMiscData%ValidPhi)) then
         allocate(DstMiscData%ValidPhi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ValidPhi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%ValidPhi = SrcMiscData%ValidPhi
   else if (allocated(DstMiscData%ValidPhi)) then
      deallocate(DstMiscData%ValidPhi)
   end if
   DstMiscData%BEM_weight = SrcMiscData%BEM_weight
end subroutine

subroutine BEMT_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(BEMT_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   call UA_DestroyMisc(MiscData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DBEMT_DestroyMisc(MiscData%DBEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call UA_DestroyOutput(MiscData%y_UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%u_UA)) then
      LB(1:3) = lbound(MiscData%u_UA)
      UB(1:3) = ubound(MiscData%u_UA)
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_DestroyInput(MiscData%u_UA(i1,i2,i3), ErrStat2, ErrMsg2)
               call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
            end do
         end do
      end do
      deallocate(MiscData%u_UA)
   end if
   LB(1:1) = lbound(MiscData%u_DBEMT)
   UB(1:1) = ubound(MiscData%u_DBEMT)
   do i1 = LB(1), UB(1)
      call DBEMT_DestroyInput(MiscData%u_DBEMT(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   LB(1:1) = lbound(MiscData%u_SkewWake)
   UB(1:1) = ubound(MiscData%u_SkewWake)
   do i1 = LB(1), UB(1)
      call BEMT_DestroySkewWake_InputType(MiscData%u_SkewWake(i1), ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   end do
   if (allocated(MiscData%TnInd_op)) then
      deallocate(MiscData%TnInd_op)
   end if
   if (allocated(MiscData%AxInd_op)) then
      deallocate(MiscData%AxInd_op)
   end if
   if (allocated(MiscData%AxInduction)) then
      deallocate(MiscData%AxInduction)
   end if
   if (allocated(MiscData%TanInduction)) then
      deallocate(MiscData%TanInduction)
   end if
   if (allocated(MiscData%Rtip)) then
      deallocate(MiscData%Rtip)
   end if
   if (allocated(MiscData%phi)) then
      deallocate(MiscData%phi)
   end if
   if (allocated(MiscData%chi)) then
      deallocate(MiscData%chi)
   end if
   if (allocated(MiscData%ValidPhi)) then
      deallocate(MiscData%ValidPhi)
   end if
end subroutine

subroutine BEMT_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackMisc'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%FirstWarn_Skew)
   call RegPack(Buf, InData%FirstWarn_Phi)
   call RegPack(Buf, InData%FirstWarn_BEMoff)
   call UA_PackMisc(Buf, InData%UA) 
   call DBEMT_PackMisc(Buf, InData%DBEMT) 
   call UA_PackOutput(Buf, InData%y_UA) 
   call RegPack(Buf, allocated(InData%u_UA))
   if (allocated(InData%u_UA)) then
      call RegPackBounds(Buf, 3, lbound(InData%u_UA), ubound(InData%u_UA))
      LB(1:3) = lbound(InData%u_UA)
      UB(1:3) = ubound(InData%u_UA)
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_PackInput(Buf, InData%u_UA(i1,i2,i3)) 
            end do
         end do
      end do
   end if
   LB(1:1) = lbound(InData%u_DBEMT)
   UB(1:1) = ubound(InData%u_DBEMT)
   do i1 = LB(1), UB(1)
      call DBEMT_PackInput(Buf, InData%u_DBEMT(i1)) 
   end do
   LB(1:1) = lbound(InData%u_SkewWake)
   UB(1:1) = ubound(InData%u_SkewWake)
   do i1 = LB(1), UB(1)
      call BEMT_PackSkewWake_InputType(Buf, InData%u_SkewWake(i1)) 
   end do
   call RegPack(Buf, allocated(InData%TnInd_op))
   if (allocated(InData%TnInd_op)) then
      call RegPackBounds(Buf, 2, lbound(InData%TnInd_op), ubound(InData%TnInd_op))
      call RegPack(Buf, InData%TnInd_op)
   end if
   call RegPack(Buf, allocated(InData%AxInd_op))
   if (allocated(InData%AxInd_op)) then
      call RegPackBounds(Buf, 2, lbound(InData%AxInd_op), ubound(InData%AxInd_op))
      call RegPack(Buf, InData%AxInd_op)
   end if
   call RegPack(Buf, allocated(InData%AxInduction))
   if (allocated(InData%AxInduction)) then
      call RegPackBounds(Buf, 2, lbound(InData%AxInduction), ubound(InData%AxInduction))
      call RegPack(Buf, InData%AxInduction)
   end if
   call RegPack(Buf, allocated(InData%TanInduction))
   if (allocated(InData%TanInduction)) then
      call RegPackBounds(Buf, 2, lbound(InData%TanInduction), ubound(InData%TanInduction))
      call RegPack(Buf, InData%TanInduction)
   end if
   call RegPack(Buf, InData%UseFrozenWake)
   call RegPack(Buf, allocated(InData%Rtip))
   if (allocated(InData%Rtip)) then
      call RegPackBounds(Buf, 1, lbound(InData%Rtip), ubound(InData%Rtip))
      call RegPack(Buf, InData%Rtip)
   end if
   call RegPack(Buf, allocated(InData%phi))
   if (allocated(InData%phi)) then
      call RegPackBounds(Buf, 2, lbound(InData%phi), ubound(InData%phi))
      call RegPack(Buf, InData%phi)
   end if
   call RegPack(Buf, allocated(InData%chi))
   if (allocated(InData%chi)) then
      call RegPackBounds(Buf, 2, lbound(InData%chi), ubound(InData%chi))
      call RegPack(Buf, InData%chi)
   end if
   call RegPack(Buf, allocated(InData%ValidPhi))
   if (allocated(InData%ValidPhi)) then
      call RegPackBounds(Buf, 2, lbound(InData%ValidPhi), ubound(InData%ValidPhi))
      call RegPack(Buf, InData%ValidPhi)
   end if
   call RegPack(Buf, InData%BEM_weight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackMisc'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%FirstWarn_Skew)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FirstWarn_Phi)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%FirstWarn_BEMoff)
   if (RegCheckErr(Buf, RoutineName)) return
   call UA_UnpackMisc(Buf, OutData%UA) ! UA 
   call DBEMT_UnpackMisc(Buf, OutData%DBEMT) ! DBEMT 
   call UA_UnpackOutput(Buf, OutData%y_UA) ! y_UA 
   if (allocated(OutData%u_UA)) deallocate(OutData%u_UA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_UA(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_UA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i3 = LB(3), UB(3)
         do i2 = LB(2), UB(2)
            do i1 = LB(1), UB(1)
               call UA_UnpackInput(Buf, OutData%u_UA(i1,i2,i3)) ! u_UA 
            end do
         end do
      end do
   end if
   LB(1:1) = lbound(OutData%u_DBEMT)
   UB(1:1) = ubound(OutData%u_DBEMT)
   do i1 = LB(1), UB(1)
      call DBEMT_UnpackInput(Buf, OutData%u_DBEMT(i1)) ! u_DBEMT 
   end do
   LB(1:1) = lbound(OutData%u_SkewWake)
   UB(1:1) = ubound(OutData%u_SkewWake)
   do i1 = LB(1), UB(1)
      call BEMT_UnpackSkewWake_InputType(Buf, OutData%u_SkewWake(i1)) ! u_SkewWake 
   end do
   if (allocated(OutData%TnInd_op)) deallocate(OutData%TnInd_op)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TnInd_op(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TnInd_op.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TnInd_op)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AxInd_op)) deallocate(OutData%AxInd_op)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AxInd_op(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AxInd_op.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AxInd_op)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AxInduction)) deallocate(OutData%AxInduction)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AxInduction(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AxInduction.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AxInduction)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%TanInduction)) deallocate(OutData%TanInduction)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TanInduction(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TanInduction.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TanInduction)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%UseFrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%Rtip)) deallocate(OutData%Rtip)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Rtip(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Rtip.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Rtip)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%phi)) deallocate(OutData%phi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%phi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%phi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%phi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%chi)) deallocate(OutData%chi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%ValidPhi)) deallocate(OutData%ValidPhi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ValidPhi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ValidPhi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ValidPhi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%BEM_weight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_ParameterType), intent(in) :: SrcParamData
   type(BEMT_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%DT = SrcParamData%DT
   if (allocated(SrcParamData%chord)) then
      LB(1:2) = lbound(SrcParamData%chord)
      UB(1:2) = ubound(SrcParamData%chord)
      if (.not. allocated(DstParamData%chord)) then
         allocate(DstParamData%chord(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%chord.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%chord = SrcParamData%chord
   else if (allocated(DstParamData%chord)) then
      deallocate(DstParamData%chord)
   end if
   DstParamData%numBlades = SrcParamData%numBlades
   DstParamData%airDens = SrcParamData%airDens
   DstParamData%kinVisc = SrcParamData%kinVisc
   DstParamData%skewWakeMod = SrcParamData%skewWakeMod
   DstParamData%aTol = SrcParamData%aTol
   DstParamData%useTipLoss = SrcParamData%useTipLoss
   DstParamData%useHubLoss = SrcParamData%useHubLoss
   DstParamData%useInduction = SrcParamData%useInduction
   DstParamData%useTanInd = SrcParamData%useTanInd
   DstParamData%useAIDrag = SrcParamData%useAIDrag
   DstParamData%useTIDrag = SrcParamData%useTIDrag
   DstParamData%numBladeNodes = SrcParamData%numBladeNodes
   DstParamData%numReIterations = SrcParamData%numReIterations
   DstParamData%maxIndIterations = SrcParamData%maxIndIterations
   if (allocated(SrcParamData%AFindx)) then
      LB(1:2) = lbound(SrcParamData%AFindx)
      UB(1:2) = ubound(SrcParamData%AFindx)
      if (.not. allocated(DstParamData%AFindx)) then
         allocate(DstParamData%AFindx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFindx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%AFindx = SrcParamData%AFindx
   else if (allocated(DstParamData%AFindx)) then
      deallocate(DstParamData%AFindx)
   end if
   if (allocated(SrcParamData%tipLossConst)) then
      LB(1:2) = lbound(SrcParamData%tipLossConst)
      UB(1:2) = ubound(SrcParamData%tipLossConst)
      if (.not. allocated(DstParamData%tipLossConst)) then
         allocate(DstParamData%tipLossConst(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%tipLossConst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%tipLossConst = SrcParamData%tipLossConst
   else if (allocated(DstParamData%tipLossConst)) then
      deallocate(DstParamData%tipLossConst)
   end if
   if (allocated(SrcParamData%hubLossConst)) then
      LB(1:2) = lbound(SrcParamData%hubLossConst)
      UB(1:2) = ubound(SrcParamData%hubLossConst)
      if (.not. allocated(DstParamData%hubLossConst)) then
         allocate(DstParamData%hubLossConst(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%hubLossConst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%hubLossConst = SrcParamData%hubLossConst
   else if (allocated(DstParamData%hubLossConst)) then
      deallocate(DstParamData%hubLossConst)
   end if
   if (allocated(SrcParamData%zHub)) then
      LB(1:1) = lbound(SrcParamData%zHub)
      UB(1:1) = ubound(SrcParamData%zHub)
      if (.not. allocated(DstParamData%zHub)) then
         allocate(DstParamData%zHub(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%zHub.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%zHub = SrcParamData%zHub
   else if (allocated(DstParamData%zHub)) then
      deallocate(DstParamData%zHub)
   end if
   call UA_CopyParam(SrcParamData%UA, DstParamData%UA, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call DBEMT_CopyParam(SrcParamData%DBEMT, DstParamData%DBEMT, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstParamData%UA_Flag = SrcParamData%UA_Flag
   DstParamData%DBEMT_Mod = SrcParamData%DBEMT_Mod
   DstParamData%yawCorrFactor = SrcParamData%yawCorrFactor
   if (allocated(SrcParamData%FixedInductions)) then
      LB(1:2) = lbound(SrcParamData%FixedInductions)
      UB(1:2) = ubound(SrcParamData%FixedInductions)
      if (.not. allocated(DstParamData%FixedInductions)) then
         allocate(DstParamData%FixedInductions(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FixedInductions.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%FixedInductions = SrcParamData%FixedInductions
   else if (allocated(DstParamData%FixedInductions)) then
      deallocate(DstParamData%FixedInductions)
   end if
   DstParamData%MomentumCorr = SrcParamData%MomentumCorr
   DstParamData%rTipFixMax = SrcParamData%rTipFixMax
   if (allocated(SrcParamData%IntegrateWeight)) then
      LB(1:2) = lbound(SrcParamData%IntegrateWeight)
      UB(1:2) = ubound(SrcParamData%IntegrateWeight)
      if (.not. allocated(DstParamData%IntegrateWeight)) then
         allocate(DstParamData%IntegrateWeight(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IntegrateWeight.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%IntegrateWeight = SrcParamData%IntegrateWeight
   else if (allocated(DstParamData%IntegrateWeight)) then
      deallocate(DstParamData%IntegrateWeight)
   end if
   DstParamData%lin_nx = SrcParamData%lin_nx
   DstParamData%BEM_Mod = SrcParamData%BEM_Mod
end subroutine

subroutine BEMT_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(BEMT_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'BEMT_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%chord)) then
      deallocate(ParamData%chord)
   end if
   if (allocated(ParamData%AFindx)) then
      deallocate(ParamData%AFindx)
   end if
   if (allocated(ParamData%tipLossConst)) then
      deallocate(ParamData%tipLossConst)
   end if
   if (allocated(ParamData%hubLossConst)) then
      deallocate(ParamData%hubLossConst)
   end if
   if (allocated(ParamData%zHub)) then
      deallocate(ParamData%zHub)
   end if
   call UA_DestroyParam(ParamData%UA, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call DBEMT_DestroyParam(ParamData%DBEMT, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(ParamData%FixedInductions)) then
      deallocate(ParamData%FixedInductions)
   end if
   if (allocated(ParamData%IntegrateWeight)) then
      deallocate(ParamData%IntegrateWeight)
   end if
end subroutine

subroutine BEMT_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, InData%DT)
   call RegPack(Buf, allocated(InData%chord))
   if (allocated(InData%chord)) then
      call RegPackBounds(Buf, 2, lbound(InData%chord), ubound(InData%chord))
      call RegPack(Buf, InData%chord)
   end if
   call RegPack(Buf, InData%numBlades)
   call RegPack(Buf, InData%airDens)
   call RegPack(Buf, InData%kinVisc)
   call RegPack(Buf, InData%skewWakeMod)
   call RegPack(Buf, InData%aTol)
   call RegPack(Buf, InData%useTipLoss)
   call RegPack(Buf, InData%useHubLoss)
   call RegPack(Buf, InData%useInduction)
   call RegPack(Buf, InData%useTanInd)
   call RegPack(Buf, InData%useAIDrag)
   call RegPack(Buf, InData%useTIDrag)
   call RegPack(Buf, InData%numBladeNodes)
   call RegPack(Buf, InData%numReIterations)
   call RegPack(Buf, InData%maxIndIterations)
   call RegPack(Buf, allocated(InData%AFindx))
   if (allocated(InData%AFindx)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFindx), ubound(InData%AFindx))
      call RegPack(Buf, InData%AFindx)
   end if
   call RegPack(Buf, allocated(InData%tipLossConst))
   if (allocated(InData%tipLossConst)) then
      call RegPackBounds(Buf, 2, lbound(InData%tipLossConst), ubound(InData%tipLossConst))
      call RegPack(Buf, InData%tipLossConst)
   end if
   call RegPack(Buf, allocated(InData%hubLossConst))
   if (allocated(InData%hubLossConst)) then
      call RegPackBounds(Buf, 2, lbound(InData%hubLossConst), ubound(InData%hubLossConst))
      call RegPack(Buf, InData%hubLossConst)
   end if
   call RegPack(Buf, allocated(InData%zHub))
   if (allocated(InData%zHub)) then
      call RegPackBounds(Buf, 1, lbound(InData%zHub), ubound(InData%zHub))
      call RegPack(Buf, InData%zHub)
   end if
   call UA_PackParam(Buf, InData%UA) 
   call DBEMT_PackParam(Buf, InData%DBEMT) 
   call RegPack(Buf, InData%UA_Flag)
   call RegPack(Buf, InData%DBEMT_Mod)
   call RegPack(Buf, InData%yawCorrFactor)
   call RegPack(Buf, allocated(InData%FixedInductions))
   if (allocated(InData%FixedInductions)) then
      call RegPackBounds(Buf, 2, lbound(InData%FixedInductions), ubound(InData%FixedInductions))
      call RegPack(Buf, InData%FixedInductions)
   end if
   call RegPack(Buf, InData%MomentumCorr)
   call RegPack(Buf, InData%rTipFixMax)
   call RegPack(Buf, allocated(InData%IntegrateWeight))
   if (allocated(InData%IntegrateWeight)) then
      call RegPackBounds(Buf, 2, lbound(InData%IntegrateWeight), ubound(InData%IntegrateWeight))
      call RegPack(Buf, InData%IntegrateWeight)
   end if
   call RegPack(Buf, InData%lin_nx)
   call RegPack(Buf, InData%BEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackParam'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%chord)) deallocate(OutData%chord)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chord(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chord)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%numBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%airDens)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%kinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%skewWakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%aTol)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useTipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useHubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useInduction)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useTanInd)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useAIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%useTIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%numBladeNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%numReIterations)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%maxIndIterations)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%AFindx)) deallocate(OutData%AFindx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFindx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFindx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFindx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%tipLossConst)) deallocate(OutData%tipLossConst)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%tipLossConst(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%tipLossConst.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%tipLossConst)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%hubLossConst)) deallocate(OutData%hubLossConst)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%hubLossConst(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%hubLossConst.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%hubLossConst)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%zHub)) deallocate(OutData%zHub)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zHub(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zHub.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zHub)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call UA_UnpackParam(Buf, OutData%UA) ! UA 
   call DBEMT_UnpackParam(Buf, OutData%DBEMT) ! DBEMT 
   call RegUnpack(Buf, OutData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%DBEMT_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%yawCorrFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%FixedInductions)) deallocate(OutData%FixedInductions)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FixedInductions(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FixedInductions.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FixedInductions)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%MomentumCorr)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%rTipFixMax)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%IntegrateWeight)) deallocate(OutData%IntegrateWeight)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IntegrateWeight(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IntegrateWeight.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IntegrateWeight)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%lin_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%BEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_InputType), intent(in) :: SrcInputData
   type(BEMT_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'BEMT_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInputData%theta)) then
      LB(1:2) = lbound(SrcInputData%theta)
      UB(1:2) = ubound(SrcInputData%theta)
      if (.not. allocated(DstInputData%theta)) then
         allocate(DstInputData%theta(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%theta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%theta = SrcInputData%theta
   else if (allocated(DstInputData%theta)) then
      deallocate(DstInputData%theta)
   end if
   DstInputData%chi0 = SrcInputData%chi0
   DstInputData%psiSkewOffset = SrcInputData%psiSkewOffset
   if (allocated(SrcInputData%psi)) then
      LB(1:1) = lbound(SrcInputData%psi)
      UB(1:1) = ubound(SrcInputData%psi)
      if (.not. allocated(DstInputData%psi)) then
         allocate(DstInputData%psi(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%psi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%psi = SrcInputData%psi
   else if (allocated(DstInputData%psi)) then
      deallocate(DstInputData%psi)
   end if
   DstInputData%omega = SrcInputData%omega
   DstInputData%TSR = SrcInputData%TSR
   if (allocated(SrcInputData%Vx)) then
      LB(1:2) = lbound(SrcInputData%Vx)
      UB(1:2) = ubound(SrcInputData%Vx)
      if (.not. allocated(DstInputData%Vx)) then
         allocate(DstInputData%Vx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vx = SrcInputData%Vx
   else if (allocated(DstInputData%Vx)) then
      deallocate(DstInputData%Vx)
   end if
   if (allocated(SrcInputData%Vy)) then
      LB(1:2) = lbound(SrcInputData%Vy)
      UB(1:2) = ubound(SrcInputData%Vy)
      if (.not. allocated(DstInputData%Vy)) then
         allocate(DstInputData%Vy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vy = SrcInputData%Vy
   else if (allocated(DstInputData%Vy)) then
      deallocate(DstInputData%Vy)
   end if
   if (allocated(SrcInputData%Vz)) then
      LB(1:2) = lbound(SrcInputData%Vz)
      UB(1:2) = ubound(SrcInputData%Vz)
      if (.not. allocated(DstInputData%Vz)) then
         allocate(DstInputData%Vz(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Vz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%Vz = SrcInputData%Vz
   else if (allocated(DstInputData%Vz)) then
      deallocate(DstInputData%Vz)
   end if
   if (allocated(SrcInputData%omega_z)) then
      LB(1:2) = lbound(SrcInputData%omega_z)
      UB(1:2) = ubound(SrcInputData%omega_z)
      if (.not. allocated(DstInputData%omega_z)) then
         allocate(DstInputData%omega_z(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%omega_z.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%omega_z = SrcInputData%omega_z
   else if (allocated(DstInputData%omega_z)) then
      deallocate(DstInputData%omega_z)
   end if
   if (allocated(SrcInputData%xVelCorr)) then
      LB(1:2) = lbound(SrcInputData%xVelCorr)
      UB(1:2) = ubound(SrcInputData%xVelCorr)
      if (.not. allocated(DstInputData%xVelCorr)) then
         allocate(DstInputData%xVelCorr(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%xVelCorr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%xVelCorr = SrcInputData%xVelCorr
   else if (allocated(DstInputData%xVelCorr)) then
      deallocate(DstInputData%xVelCorr)
   end if
   if (allocated(SrcInputData%rLocal)) then
      LB(1:2) = lbound(SrcInputData%rLocal)
      UB(1:2) = ubound(SrcInputData%rLocal)
      if (.not. allocated(DstInputData%rLocal)) then
         allocate(DstInputData%rLocal(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%rLocal.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%rLocal = SrcInputData%rLocal
   else if (allocated(DstInputData%rLocal)) then
      deallocate(DstInputData%rLocal)
   end if
   DstInputData%Un_disk = SrcInputData%Un_disk
   DstInputData%V0 = SrcInputData%V0
   DstInputData%x_hat_disk = SrcInputData%x_hat_disk
   if (allocated(SrcInputData%UserProp)) then
      LB(1:2) = lbound(SrcInputData%UserProp)
      UB(1:2) = ubound(SrcInputData%UserProp)
      if (.not. allocated(DstInputData%UserProp)) then
         allocate(DstInputData%UserProp(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%UserProp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%UserProp = SrcInputData%UserProp
   else if (allocated(DstInputData%UserProp)) then
      deallocate(DstInputData%UserProp)
   end if
   if (allocated(SrcInputData%CantAngle)) then
      LB(1:2) = lbound(SrcInputData%CantAngle)
      UB(1:2) = ubound(SrcInputData%CantAngle)
      if (.not. allocated(DstInputData%CantAngle)) then
         allocate(DstInputData%CantAngle(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CantAngle.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%CantAngle = SrcInputData%CantAngle
   else if (allocated(DstInputData%CantAngle)) then
      deallocate(DstInputData%CantAngle)
   end if
   if (allocated(SrcInputData%drdz)) then
      LB(1:2) = lbound(SrcInputData%drdz)
      UB(1:2) = ubound(SrcInputData%drdz)
      if (.not. allocated(DstInputData%drdz)) then
         allocate(DstInputData%drdz(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%drdz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%drdz = SrcInputData%drdz
   else if (allocated(DstInputData%drdz)) then
      deallocate(DstInputData%drdz)
   end if
   if (allocated(SrcInputData%toeAngle)) then
      LB(1:2) = lbound(SrcInputData%toeAngle)
      UB(1:2) = ubound(SrcInputData%toeAngle)
      if (.not. allocated(DstInputData%toeAngle)) then
         allocate(DstInputData%toeAngle(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%toeAngle.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%toeAngle = SrcInputData%toeAngle
   else if (allocated(DstInputData%toeAngle)) then
      deallocate(DstInputData%toeAngle)
   end if
end subroutine

subroutine BEMT_DestroyInput(InputData, ErrStat, ErrMsg)
   type(BEMT_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'BEMT_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%theta)) then
      deallocate(InputData%theta)
   end if
   if (allocated(InputData%psi)) then
      deallocate(InputData%psi)
   end if
   if (allocated(InputData%Vx)) then
      deallocate(InputData%Vx)
   end if
   if (allocated(InputData%Vy)) then
      deallocate(InputData%Vy)
   end if
   if (allocated(InputData%Vz)) then
      deallocate(InputData%Vz)
   end if
   if (allocated(InputData%omega_z)) then
      deallocate(InputData%omega_z)
   end if
   if (allocated(InputData%xVelCorr)) then
      deallocate(InputData%xVelCorr)
   end if
   if (allocated(InputData%rLocal)) then
      deallocate(InputData%rLocal)
   end if
   if (allocated(InputData%UserProp)) then
      deallocate(InputData%UserProp)
   end if
   if (allocated(InputData%CantAngle)) then
      deallocate(InputData%CantAngle)
   end if
   if (allocated(InputData%drdz)) then
      deallocate(InputData%drdz)
   end if
   if (allocated(InputData%toeAngle)) then
      deallocate(InputData%toeAngle)
   end if
end subroutine

subroutine BEMT_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%theta))
   if (allocated(InData%theta)) then
      call RegPackBounds(Buf, 2, lbound(InData%theta), ubound(InData%theta))
      call RegPack(Buf, InData%theta)
   end if
   call RegPack(Buf, InData%chi0)
   call RegPack(Buf, InData%psiSkewOffset)
   call RegPack(Buf, allocated(InData%psi))
   if (allocated(InData%psi)) then
      call RegPackBounds(Buf, 1, lbound(InData%psi), ubound(InData%psi))
      call RegPack(Buf, InData%psi)
   end if
   call RegPack(Buf, InData%omega)
   call RegPack(Buf, InData%TSR)
   call RegPack(Buf, allocated(InData%Vx))
   if (allocated(InData%Vx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vx), ubound(InData%Vx))
      call RegPack(Buf, InData%Vx)
   end if
   call RegPack(Buf, allocated(InData%Vy))
   if (allocated(InData%Vy)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vy), ubound(InData%Vy))
      call RegPack(Buf, InData%Vy)
   end if
   call RegPack(Buf, allocated(InData%Vz))
   if (allocated(InData%Vz)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vz), ubound(InData%Vz))
      call RegPack(Buf, InData%Vz)
   end if
   call RegPack(Buf, allocated(InData%omega_z))
   if (allocated(InData%omega_z)) then
      call RegPackBounds(Buf, 2, lbound(InData%omega_z), ubound(InData%omega_z))
      call RegPack(Buf, InData%omega_z)
   end if
   call RegPack(Buf, allocated(InData%xVelCorr))
   if (allocated(InData%xVelCorr)) then
      call RegPackBounds(Buf, 2, lbound(InData%xVelCorr), ubound(InData%xVelCorr))
      call RegPack(Buf, InData%xVelCorr)
   end if
   call RegPack(Buf, allocated(InData%rLocal))
   if (allocated(InData%rLocal)) then
      call RegPackBounds(Buf, 2, lbound(InData%rLocal), ubound(InData%rLocal))
      call RegPack(Buf, InData%rLocal)
   end if
   call RegPack(Buf, InData%Un_disk)
   call RegPack(Buf, InData%V0)
   call RegPack(Buf, InData%x_hat_disk)
   call RegPack(Buf, allocated(InData%UserProp))
   if (allocated(InData%UserProp)) then
      call RegPackBounds(Buf, 2, lbound(InData%UserProp), ubound(InData%UserProp))
      call RegPack(Buf, InData%UserProp)
   end if
   call RegPack(Buf, allocated(InData%CantAngle))
   if (allocated(InData%CantAngle)) then
      call RegPackBounds(Buf, 2, lbound(InData%CantAngle), ubound(InData%CantAngle))
      call RegPack(Buf, InData%CantAngle)
   end if
   call RegPack(Buf, allocated(InData%drdz))
   if (allocated(InData%drdz)) then
      call RegPackBounds(Buf, 2, lbound(InData%drdz), ubound(InData%drdz))
      call RegPack(Buf, InData%drdz)
   end if
   call RegPack(Buf, allocated(InData%toeAngle))
   if (allocated(InData%toeAngle)) then
      call RegPackBounds(Buf, 2, lbound(InData%toeAngle), ubound(InData%toeAngle))
      call RegPack(Buf, InData%toeAngle)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%theta)) deallocate(OutData%theta)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%theta(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%theta.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%theta)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%chi0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%psiSkewOffset)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%psi)) deallocate(OutData%psi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%psi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%psi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%psi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%omega)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%TSR)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%Vx)) deallocate(OutData%Vx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Vy)) deallocate(OutData%Vy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vy(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Vz)) deallocate(OutData%Vz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%omega_z)) deallocate(OutData%omega_z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%omega_z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%omega_z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%omega_z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%xVelCorr)) deallocate(OutData%xVelCorr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xVelCorr(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xVelCorr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%xVelCorr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%rLocal)) deallocate(OutData%rLocal)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rLocal(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rLocal.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rLocal)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   call RegUnpack(Buf, OutData%Un_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%V0)
   if (RegCheckErr(Buf, RoutineName)) return
   call RegUnpack(Buf, OutData%x_hat_disk)
   if (RegCheckErr(Buf, RoutineName)) return
   if (allocated(OutData%UserProp)) deallocate(OutData%UserProp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UserProp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UserProp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UserProp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%CantAngle)) deallocate(OutData%CantAngle)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CantAngle(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CantAngle.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CantAngle)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%drdz)) deallocate(OutData%drdz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%drdz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%drdz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%drdz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%toeAngle)) deallocate(OutData%toeAngle)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%toeAngle(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%toeAngle.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%toeAngle)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

subroutine BEMT_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(BEMT_OutputType), intent(in) :: SrcOutputData
   type(BEMT_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'BEMT_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%Vrel)) then
      LB(1:2) = lbound(SrcOutputData%Vrel)
      UB(1:2) = ubound(SrcOutputData%Vrel)
      if (.not. allocated(DstOutputData%Vrel)) then
         allocate(DstOutputData%Vrel(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vrel.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Vrel = SrcOutputData%Vrel
   else if (allocated(DstOutputData%Vrel)) then
      deallocate(DstOutputData%Vrel)
   end if
   if (allocated(SrcOutputData%phi)) then
      LB(1:2) = lbound(SrcOutputData%phi)
      UB(1:2) = ubound(SrcOutputData%phi)
      if (.not. allocated(DstOutputData%phi)) then
         allocate(DstOutputData%phi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%phi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%phi = SrcOutputData%phi
   else if (allocated(DstOutputData%phi)) then
      deallocate(DstOutputData%phi)
   end if
   if (allocated(SrcOutputData%axInduction)) then
      LB(1:2) = lbound(SrcOutputData%axInduction)
      UB(1:2) = ubound(SrcOutputData%axInduction)
      if (.not. allocated(DstOutputData%axInduction)) then
         allocate(DstOutputData%axInduction(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%axInduction.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%axInduction = SrcOutputData%axInduction
   else if (allocated(DstOutputData%axInduction)) then
      deallocate(DstOutputData%axInduction)
   end if
   if (allocated(SrcOutputData%tanInduction)) then
      LB(1:2) = lbound(SrcOutputData%tanInduction)
      UB(1:2) = ubound(SrcOutputData%tanInduction)
      if (.not. allocated(DstOutputData%tanInduction)) then
         allocate(DstOutputData%tanInduction(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%tanInduction.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%tanInduction = SrcOutputData%tanInduction
   else if (allocated(DstOutputData%tanInduction)) then
      deallocate(DstOutputData%tanInduction)
   end if
   if (allocated(SrcOutputData%Re)) then
      LB(1:2) = lbound(SrcOutputData%Re)
      UB(1:2) = ubound(SrcOutputData%Re)
      if (.not. allocated(DstOutputData%Re)) then
         allocate(DstOutputData%Re(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Re.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Re = SrcOutputData%Re
   else if (allocated(DstOutputData%Re)) then
      deallocate(DstOutputData%Re)
   end if
   if (allocated(SrcOutputData%AOA)) then
      LB(1:2) = lbound(SrcOutputData%AOA)
      UB(1:2) = ubound(SrcOutputData%AOA)
      if (.not. allocated(DstOutputData%AOA)) then
         allocate(DstOutputData%AOA(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%AOA.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%AOA = SrcOutputData%AOA
   else if (allocated(DstOutputData%AOA)) then
      deallocate(DstOutputData%AOA)
   end if
   if (allocated(SrcOutputData%Cx)) then
      LB(1:2) = lbound(SrcOutputData%Cx)
      UB(1:2) = ubound(SrcOutputData%Cx)
      if (.not. allocated(DstOutputData%Cx)) then
         allocate(DstOutputData%Cx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cx = SrcOutputData%Cx
   else if (allocated(DstOutputData%Cx)) then
      deallocate(DstOutputData%Cx)
   end if
   if (allocated(SrcOutputData%Cy)) then
      LB(1:2) = lbound(SrcOutputData%Cy)
      UB(1:2) = ubound(SrcOutputData%Cy)
      if (.not. allocated(DstOutputData%Cy)) then
         allocate(DstOutputData%Cy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cy = SrcOutputData%Cy
   else if (allocated(DstOutputData%Cy)) then
      deallocate(DstOutputData%Cy)
   end if
   if (allocated(SrcOutputData%Cz)) then
      LB(1:2) = lbound(SrcOutputData%Cz)
      UB(1:2) = ubound(SrcOutputData%Cz)
      if (.not. allocated(DstOutputData%Cz)) then
         allocate(DstOutputData%Cz(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cz = SrcOutputData%Cz
   else if (allocated(DstOutputData%Cz)) then
      deallocate(DstOutputData%Cz)
   end if
   if (allocated(SrcOutputData%Cmx)) then
      LB(1:2) = lbound(SrcOutputData%Cmx)
      UB(1:2) = ubound(SrcOutputData%Cmx)
      if (.not. allocated(DstOutputData%Cmx)) then
         allocate(DstOutputData%Cmx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cmx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cmx = SrcOutputData%Cmx
   else if (allocated(DstOutputData%Cmx)) then
      deallocate(DstOutputData%Cmx)
   end if
   if (allocated(SrcOutputData%Cmy)) then
      LB(1:2) = lbound(SrcOutputData%Cmy)
      UB(1:2) = ubound(SrcOutputData%Cmy)
      if (.not. allocated(DstOutputData%Cmy)) then
         allocate(DstOutputData%Cmy(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cmy.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cmy = SrcOutputData%Cmy
   else if (allocated(DstOutputData%Cmy)) then
      deallocate(DstOutputData%Cmy)
   end if
   if (allocated(SrcOutputData%Cmz)) then
      LB(1:2) = lbound(SrcOutputData%Cmz)
      UB(1:2) = ubound(SrcOutputData%Cmz)
      if (.not. allocated(DstOutputData%Cmz)) then
         allocate(DstOutputData%Cmz(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cmz.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cmz = SrcOutputData%Cmz
   else if (allocated(DstOutputData%Cmz)) then
      deallocate(DstOutputData%Cmz)
   end if
   if (allocated(SrcOutputData%Cm)) then
      LB(1:2) = lbound(SrcOutputData%Cm)
      UB(1:2) = ubound(SrcOutputData%Cm)
      if (.not. allocated(DstOutputData%Cm)) then
         allocate(DstOutputData%Cm(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cm.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cm = SrcOutputData%Cm
   else if (allocated(DstOutputData%Cm)) then
      deallocate(DstOutputData%Cm)
   end if
   if (allocated(SrcOutputData%Cl)) then
      LB(1:2) = lbound(SrcOutputData%Cl)
      UB(1:2) = ubound(SrcOutputData%Cl)
      if (.not. allocated(DstOutputData%Cl)) then
         allocate(DstOutputData%Cl(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cl.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cl = SrcOutputData%Cl
   else if (allocated(DstOutputData%Cl)) then
      deallocate(DstOutputData%Cl)
   end if
   if (allocated(SrcOutputData%Cd)) then
      LB(1:2) = lbound(SrcOutputData%Cd)
      UB(1:2) = ubound(SrcOutputData%Cd)
      if (.not. allocated(DstOutputData%Cd)) then
         allocate(DstOutputData%Cd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cd = SrcOutputData%Cd
   else if (allocated(DstOutputData%Cd)) then
      deallocate(DstOutputData%Cd)
   end if
   if (allocated(SrcOutputData%chi)) then
      LB(1:2) = lbound(SrcOutputData%chi)
      UB(1:2) = ubound(SrcOutputData%chi)
      if (.not. allocated(DstOutputData%chi)) then
         allocate(DstOutputData%chi(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%chi.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%chi = SrcOutputData%chi
   else if (allocated(DstOutputData%chi)) then
      deallocate(DstOutputData%chi)
   end if
   if (allocated(SrcOutputData%Cpmin)) then
      LB(1:2) = lbound(SrcOutputData%Cpmin)
      UB(1:2) = ubound(SrcOutputData%Cpmin)
      if (.not. allocated(DstOutputData%Cpmin)) then
         allocate(DstOutputData%Cpmin(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cpmin.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%Cpmin = SrcOutputData%Cpmin
   else if (allocated(DstOutputData%Cpmin)) then
      deallocate(DstOutputData%Cpmin)
   end if
end subroutine

subroutine BEMT_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(BEMT_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'BEMT_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%Vrel)) then
      deallocate(OutputData%Vrel)
   end if
   if (allocated(OutputData%phi)) then
      deallocate(OutputData%phi)
   end if
   if (allocated(OutputData%axInduction)) then
      deallocate(OutputData%axInduction)
   end if
   if (allocated(OutputData%tanInduction)) then
      deallocate(OutputData%tanInduction)
   end if
   if (allocated(OutputData%Re)) then
      deallocate(OutputData%Re)
   end if
   if (allocated(OutputData%AOA)) then
      deallocate(OutputData%AOA)
   end if
   if (allocated(OutputData%Cx)) then
      deallocate(OutputData%Cx)
   end if
   if (allocated(OutputData%Cy)) then
      deallocate(OutputData%Cy)
   end if
   if (allocated(OutputData%Cz)) then
      deallocate(OutputData%Cz)
   end if
   if (allocated(OutputData%Cmx)) then
      deallocate(OutputData%Cmx)
   end if
   if (allocated(OutputData%Cmy)) then
      deallocate(OutputData%Cmy)
   end if
   if (allocated(OutputData%Cmz)) then
      deallocate(OutputData%Cmz)
   end if
   if (allocated(OutputData%Cm)) then
      deallocate(OutputData%Cm)
   end if
   if (allocated(OutputData%Cl)) then
      deallocate(OutputData%Cl)
   end if
   if (allocated(OutputData%Cd)) then
      deallocate(OutputData%Cd)
   end if
   if (allocated(OutputData%chi)) then
      deallocate(OutputData%chi)
   end if
   if (allocated(OutputData%Cpmin)) then
      deallocate(OutputData%Cpmin)
   end if
end subroutine

subroutine BEMT_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(BEMT_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'BEMT_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   call RegPack(Buf, allocated(InData%Vrel))
   if (allocated(InData%Vrel)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vrel), ubound(InData%Vrel))
      call RegPack(Buf, InData%Vrel)
   end if
   call RegPack(Buf, allocated(InData%phi))
   if (allocated(InData%phi)) then
      call RegPackBounds(Buf, 2, lbound(InData%phi), ubound(InData%phi))
      call RegPack(Buf, InData%phi)
   end if
   call RegPack(Buf, allocated(InData%axInduction))
   if (allocated(InData%axInduction)) then
      call RegPackBounds(Buf, 2, lbound(InData%axInduction), ubound(InData%axInduction))
      call RegPack(Buf, InData%axInduction)
   end if
   call RegPack(Buf, allocated(InData%tanInduction))
   if (allocated(InData%tanInduction)) then
      call RegPackBounds(Buf, 2, lbound(InData%tanInduction), ubound(InData%tanInduction))
      call RegPack(Buf, InData%tanInduction)
   end if
   call RegPack(Buf, allocated(InData%Re))
   if (allocated(InData%Re)) then
      call RegPackBounds(Buf, 2, lbound(InData%Re), ubound(InData%Re))
      call RegPack(Buf, InData%Re)
   end if
   call RegPack(Buf, allocated(InData%AOA))
   if (allocated(InData%AOA)) then
      call RegPackBounds(Buf, 2, lbound(InData%AOA), ubound(InData%AOA))
      call RegPack(Buf, InData%AOA)
   end if
   call RegPack(Buf, allocated(InData%Cx))
   if (allocated(InData%Cx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cx), ubound(InData%Cx))
      call RegPack(Buf, InData%Cx)
   end if
   call RegPack(Buf, allocated(InData%Cy))
   if (allocated(InData%Cy)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cy), ubound(InData%Cy))
      call RegPack(Buf, InData%Cy)
   end if
   call RegPack(Buf, allocated(InData%Cz))
   if (allocated(InData%Cz)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cz), ubound(InData%Cz))
      call RegPack(Buf, InData%Cz)
   end if
   call RegPack(Buf, allocated(InData%Cmx))
   if (allocated(InData%Cmx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cmx), ubound(InData%Cmx))
      call RegPack(Buf, InData%Cmx)
   end if
   call RegPack(Buf, allocated(InData%Cmy))
   if (allocated(InData%Cmy)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cmy), ubound(InData%Cmy))
      call RegPack(Buf, InData%Cmy)
   end if
   call RegPack(Buf, allocated(InData%Cmz))
   if (allocated(InData%Cmz)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cmz), ubound(InData%Cmz))
      call RegPack(Buf, InData%Cmz)
   end if
   call RegPack(Buf, allocated(InData%Cm))
   if (allocated(InData%Cm)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cm), ubound(InData%Cm))
      call RegPack(Buf, InData%Cm)
   end if
   call RegPack(Buf, allocated(InData%Cl))
   if (allocated(InData%Cl)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cl), ubound(InData%Cl))
      call RegPack(Buf, InData%Cl)
   end if
   call RegPack(Buf, allocated(InData%Cd))
   if (allocated(InData%Cd)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cd), ubound(InData%Cd))
      call RegPack(Buf, InData%Cd)
   end if
   call RegPack(Buf, allocated(InData%chi))
   if (allocated(InData%chi)) then
      call RegPackBounds(Buf, 2, lbound(InData%chi), ubound(InData%chi))
      call RegPack(Buf, InData%chi)
   end if
   call RegPack(Buf, allocated(InData%Cpmin))
   if (allocated(InData%Cpmin)) then
      call RegPackBounds(Buf, 2, lbound(InData%Cpmin), ubound(InData%Cpmin))
      call RegPack(Buf, InData%Cpmin)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine BEMT_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(BEMT_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'BEMT_UnPackOutput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   if (allocated(OutData%Vrel)) deallocate(OutData%Vrel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vrel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vrel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vrel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%phi)) deallocate(OutData%phi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%phi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%phi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%phi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%axInduction)) deallocate(OutData%axInduction)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%axInduction(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%axInduction.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%axInduction)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%tanInduction)) deallocate(OutData%tanInduction)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%tanInduction(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%tanInduction.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%tanInduction)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Re)) deallocate(OutData%Re)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Re(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Re.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Re)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%AOA)) deallocate(OutData%AOA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AOA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AOA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AOA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cx)) deallocate(OutData%Cx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cy)) deallocate(OutData%Cy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cy(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cz)) deallocate(OutData%Cz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cmx)) deallocate(OutData%Cmx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cmx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cmx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cmx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cmy)) deallocate(OutData%Cmy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cmy(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cmy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cmy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cmz)) deallocate(OutData%Cmz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cmz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cmz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cmz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cm)) deallocate(OutData%Cm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cm(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cl)) deallocate(OutData%Cl)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cl(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cl.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cl)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cd)) deallocate(OutData%Cd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%chi)) deallocate(OutData%chi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chi(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   if (allocated(OutData%Cpmin)) deallocate(OutData%Cpmin)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Cpmin(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cpmin.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Cpmin)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE BEMT_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(BEMT_InputType), INTENT(IN)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(BEMT_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'BEMT_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL BEMT_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL BEMT_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL BEMT_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE BEMT_Input_ExtrapInterp


 SUBROUTINE BEMT_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(BEMT_InputType), INTENT(IN)  :: u1    ! Input at t1 > t2
 TYPE(BEMT_InputType), INTENT(IN)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(BEMT_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'BEMT_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u1%theta)) THEN
  DO i2 = LBOUND(u_out%theta,2),UBOUND(u_out%theta,2)
    DO i1 = LBOUND(u_out%theta,1),UBOUND(u_out%theta,1)
      b = -(u1%theta(i1,i2) - u2%theta(i1,i2))
      u_out%theta(i1,i2) = u1%theta(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  b = -(u1%chi0 - u2%chi0)
  u_out%chi0 = u1%chi0 + b * ScaleFactor
  b = -(u1%psiSkewOffset - u2%psiSkewOffset)
  u_out%psiSkewOffset = u1%psiSkewOffset + b * ScaleFactor
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u1%psi)) THEN
  DO i1 = LBOUND(u_out%psi,1),UBOUND(u_out%psi,1)
    b = -(u1%psi(i1) - u2%psi(i1))
    u_out%psi(i1) = u1%psi(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
  b = -(u1%omega - u2%omega)
  u_out%omega = u1%omega + b * ScaleFactor
  b = -(u1%TSR - u2%TSR)
  u_out%TSR = u1%TSR + b * ScaleFactor
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u1%Vx)) THEN
  DO i2 = LBOUND(u_out%Vx,2),UBOUND(u_out%Vx,2)
    DO i1 = LBOUND(u_out%Vx,1),UBOUND(u_out%Vx,1)
      b = -(u1%Vx(i1,i2) - u2%Vx(i1,i2))
      u_out%Vx(i1,i2) = u1%Vx(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u1%Vy)) THEN
  DO i2 = LBOUND(u_out%Vy,2),UBOUND(u_out%Vy,2)
    DO i1 = LBOUND(u_out%Vy,1),UBOUND(u_out%Vy,1)
      b = -(u1%Vy(i1,i2) - u2%Vy(i1,i2))
      u_out%Vy(i1,i2) = u1%Vy(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%Vz) .AND. ALLOCATED(u1%Vz)) THEN
  DO i2 = LBOUND(u_out%Vz,2),UBOUND(u_out%Vz,2)
    DO i1 = LBOUND(u_out%Vz,1),UBOUND(u_out%Vz,1)
      b = -(u1%Vz(i1,i2) - u2%Vz(i1,i2))
      u_out%Vz(i1,i2) = u1%Vz(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%omega_z) .AND. ALLOCATED(u1%omega_z)) THEN
  DO i2 = LBOUND(u_out%omega_z,2),UBOUND(u_out%omega_z,2)
    DO i1 = LBOUND(u_out%omega_z,1),UBOUND(u_out%omega_z,1)
      b = -(u1%omega_z(i1,i2) - u2%omega_z(i1,i2))
      u_out%omega_z(i1,i2) = u1%omega_z(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%xVelCorr) .AND. ALLOCATED(u1%xVelCorr)) THEN
  DO i2 = LBOUND(u_out%xVelCorr,2),UBOUND(u_out%xVelCorr,2)
    DO i1 = LBOUND(u_out%xVelCorr,1),UBOUND(u_out%xVelCorr,1)
      b = -(u1%xVelCorr(i1,i2) - u2%xVelCorr(i1,i2))
      u_out%xVelCorr(i1,i2) = u1%xVelCorr(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u1%rLocal)) THEN
  DO i2 = LBOUND(u_out%rLocal,2),UBOUND(u_out%rLocal,2)
    DO i1 = LBOUND(u_out%rLocal,1),UBOUND(u_out%rLocal,1)
      b = -(u1%rLocal(i1,i2) - u2%rLocal(i1,i2))
      u_out%rLocal(i1,i2) = u1%rLocal(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  b = -(u1%Un_disk - u2%Un_disk)
  u_out%Un_disk = u1%Un_disk + b * ScaleFactor
  DO i1 = LBOUND(u_out%V0,1),UBOUND(u_out%V0,1)
    b = -(u1%V0(i1) - u2%V0(i1))
    u_out%V0(i1) = u1%V0(i1) + b * ScaleFactor
  END DO
  DO i1 = LBOUND(u_out%x_hat_disk,1),UBOUND(u_out%x_hat_disk,1)
    b = -(u1%x_hat_disk(i1) - u2%x_hat_disk(i1))
    u_out%x_hat_disk(i1) = u1%x_hat_disk(i1) + b * ScaleFactor
  END DO
IF (ALLOCATED(u_out%UserProp) .AND. ALLOCATED(u1%UserProp)) THEN
  DO i2 = LBOUND(u_out%UserProp,2),UBOUND(u_out%UserProp,2)
    DO i1 = LBOUND(u_out%UserProp,1),UBOUND(u_out%UserProp,1)
      b = -(u1%UserProp(i1,i2) - u2%UserProp(i1,i2))
      u_out%UserProp(i1,i2) = u1%UserProp(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CantAngle) .AND. ALLOCATED(u1%CantAngle)) THEN
  DO i2 = LBOUND(u_out%CantAngle,2),UBOUND(u_out%CantAngle,2)
    DO i1 = LBOUND(u_out%CantAngle,1),UBOUND(u_out%CantAngle,1)
      b = -(u1%CantAngle(i1,i2) - u2%CantAngle(i1,i2))
      u_out%CantAngle(i1,i2) = u1%CantAngle(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%drdz) .AND. ALLOCATED(u1%drdz)) THEN
  DO i2 = LBOUND(u_out%drdz,2),UBOUND(u_out%drdz,2)
    DO i1 = LBOUND(u_out%drdz,1),UBOUND(u_out%drdz,1)
      b = -(u1%drdz(i1,i2) - u2%drdz(i1,i2))
      u_out%drdz(i1,i2) = u1%drdz(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%toeAngle) .AND. ALLOCATED(u1%toeAngle)) THEN
  DO i2 = LBOUND(u_out%toeAngle,2),UBOUND(u_out%toeAngle,2)
    DO i1 = LBOUND(u_out%toeAngle,1),UBOUND(u_out%toeAngle,1)
      b = -(u1%toeAngle(i1,i2) - u2%toeAngle(i1,i2))
      u_out%toeAngle(i1,i2) = u1%toeAngle(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE BEMT_Input_ExtrapInterp1


 SUBROUTINE BEMT_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(BEMT_InputType), INTENT(IN)  :: u1      ! Input at t1 > t2 > t3
 TYPE(BEMT_InputType), INTENT(IN)  :: u2      ! Input at t2 > t3
 TYPE(BEMT_InputType), INTENT(IN)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(BEMT_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'BEMT_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%theta) .AND. ALLOCATED(u1%theta)) THEN
  DO i2 = LBOUND(u_out%theta,2),UBOUND(u_out%theta,2)
    DO i1 = LBOUND(u_out%theta,1),UBOUND(u_out%theta,1)
      b = (t(3)**2*(u1%theta(i1,i2) - u2%theta(i1,i2)) + t(2)**2*(-u1%theta(i1,i2) + u3%theta(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%theta(i1,i2) + t(3)*u2%theta(i1,i2) - t(2)*u3%theta(i1,i2) ) * scaleFactor
      u_out%theta(i1,i2) = u1%theta(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  b = (t(3)**2*(u1%chi0 - u2%chi0) + t(2)**2*(-u1%chi0 + u3%chi0))* scaleFactor
  c = ( (t(2)-t(3))*u1%chi0 + t(3)*u2%chi0 - t(2)*u3%chi0 ) * scaleFactor
  u_out%chi0 = u1%chi0 + b  + c * t_out
  b = (t(3)**2*(u1%psiSkewOffset - u2%psiSkewOffset) + t(2)**2*(-u1%psiSkewOffset + u3%psiSkewOffset))* scaleFactor
  c = ( (t(2)-t(3))*u1%psiSkewOffset + t(3)*u2%psiSkewOffset - t(2)*u3%psiSkewOffset ) * scaleFactor
  u_out%psiSkewOffset = u1%psiSkewOffset + b  + c * t_out
IF (ALLOCATED(u_out%psi) .AND. ALLOCATED(u1%psi)) THEN
  DO i1 = LBOUND(u_out%psi,1),UBOUND(u_out%psi,1)
    b = (t(3)**2*(u1%psi(i1) - u2%psi(i1)) + t(2)**2*(-u1%psi(i1) + u3%psi(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%psi(i1) + t(3)*u2%psi(i1) - t(2)*u3%psi(i1) ) * scaleFactor
    u_out%psi(i1) = u1%psi(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
  b = (t(3)**2*(u1%omega - u2%omega) + t(2)**2*(-u1%omega + u3%omega))* scaleFactor
  c = ( (t(2)-t(3))*u1%omega + t(3)*u2%omega - t(2)*u3%omega ) * scaleFactor
  u_out%omega = u1%omega + b  + c * t_out
  b = (t(3)**2*(u1%TSR - u2%TSR) + t(2)**2*(-u1%TSR + u3%TSR))* scaleFactor
  c = ( (t(2)-t(3))*u1%TSR + t(3)*u2%TSR - t(2)*u3%TSR ) * scaleFactor
  u_out%TSR = u1%TSR + b  + c * t_out
IF (ALLOCATED(u_out%Vx) .AND. ALLOCATED(u1%Vx)) THEN
  DO i2 = LBOUND(u_out%Vx,2),UBOUND(u_out%Vx,2)
    DO i1 = LBOUND(u_out%Vx,1),UBOUND(u_out%Vx,1)
      b = (t(3)**2*(u1%Vx(i1,i2) - u2%Vx(i1,i2)) + t(2)**2*(-u1%Vx(i1,i2) + u3%Vx(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%Vx(i1,i2) + t(3)*u2%Vx(i1,i2) - t(2)*u3%Vx(i1,i2) ) * scaleFactor
      u_out%Vx(i1,i2) = u1%Vx(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%Vy) .AND. ALLOCATED(u1%Vy)) THEN
  DO i2 = LBOUND(u_out%Vy,2),UBOUND(u_out%Vy,2)
    DO i1 = LBOUND(u_out%Vy,1),UBOUND(u_out%Vy,1)
      b = (t(3)**2*(u1%Vy(i1,i2) - u2%Vy(i1,i2)) + t(2)**2*(-u1%Vy(i1,i2) + u3%Vy(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%Vy(i1,i2) + t(3)*u2%Vy(i1,i2) - t(2)*u3%Vy(i1,i2) ) * scaleFactor
      u_out%Vy(i1,i2) = u1%Vy(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%Vz) .AND. ALLOCATED(u1%Vz)) THEN
  DO i2 = LBOUND(u_out%Vz,2),UBOUND(u_out%Vz,2)
    DO i1 = LBOUND(u_out%Vz,1),UBOUND(u_out%Vz,1)
      b = (t(3)**2*(u1%Vz(i1,i2) - u2%Vz(i1,i2)) + t(2)**2*(-u1%Vz(i1,i2) + u3%Vz(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%Vz(i1,i2) + t(3)*u2%Vz(i1,i2) - t(2)*u3%Vz(i1,i2) ) * scaleFactor
      u_out%Vz(i1,i2) = u1%Vz(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%omega_z) .AND. ALLOCATED(u1%omega_z)) THEN
  DO i2 = LBOUND(u_out%omega_z,2),UBOUND(u_out%omega_z,2)
    DO i1 = LBOUND(u_out%omega_z,1),UBOUND(u_out%omega_z,1)
      b = (t(3)**2*(u1%omega_z(i1,i2) - u2%omega_z(i1,i2)) + t(2)**2*(-u1%omega_z(i1,i2) + u3%omega_z(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%omega_z(i1,i2) + t(3)*u2%omega_z(i1,i2) - t(2)*u3%omega_z(i1,i2) ) * scaleFactor
      u_out%omega_z(i1,i2) = u1%omega_z(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%xVelCorr) .AND. ALLOCATED(u1%xVelCorr)) THEN
  DO i2 = LBOUND(u_out%xVelCorr,2),UBOUND(u_out%xVelCorr,2)
    DO i1 = LBOUND(u_out%xVelCorr,1),UBOUND(u_out%xVelCorr,1)
      b = (t(3)**2*(u1%xVelCorr(i1,i2) - u2%xVelCorr(i1,i2)) + t(2)**2*(-u1%xVelCorr(i1,i2) + u3%xVelCorr(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%xVelCorr(i1,i2) + t(3)*u2%xVelCorr(i1,i2) - t(2)*u3%xVelCorr(i1,i2) ) * scaleFactor
      u_out%xVelCorr(i1,i2) = u1%xVelCorr(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%rLocal) .AND. ALLOCATED(u1%rLocal)) THEN
  DO i2 = LBOUND(u_out%rLocal,2),UBOUND(u_out%rLocal,2)
    DO i1 = LBOUND(u_out%rLocal,1),UBOUND(u_out%rLocal,1)
      b = (t(3)**2*(u1%rLocal(i1,i2) - u2%rLocal(i1,i2)) + t(2)**2*(-u1%rLocal(i1,i2) + u3%rLocal(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rLocal(i1,i2) + t(3)*u2%rLocal(i1,i2) - t(2)*u3%rLocal(i1,i2) ) * scaleFactor
      u_out%rLocal(i1,i2) = u1%rLocal(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  b = (t(3)**2*(u1%Un_disk - u2%Un_disk) + t(2)**2*(-u1%Un_disk + u3%Un_disk))* scaleFactor
  c = ( (t(2)-t(3))*u1%Un_disk + t(3)*u2%Un_disk - t(2)*u3%Un_disk ) * scaleFactor
  u_out%Un_disk = u1%Un_disk + b  + c * t_out
  DO i1 = LBOUND(u_out%V0,1),UBOUND(u_out%V0,1)
    b = (t(3)**2*(u1%V0(i1) - u2%V0(i1)) + t(2)**2*(-u1%V0(i1) + u3%V0(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%V0(i1) + t(3)*u2%V0(i1) - t(2)*u3%V0(i1) ) * scaleFactor
    u_out%V0(i1) = u1%V0(i1) + b  + c * t_out
  END DO
  DO i1 = LBOUND(u_out%x_hat_disk,1),UBOUND(u_out%x_hat_disk,1)
    b = (t(3)**2*(u1%x_hat_disk(i1) - u2%x_hat_disk(i1)) + t(2)**2*(-u1%x_hat_disk(i1) + u3%x_hat_disk(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%x_hat_disk(i1) + t(3)*u2%x_hat_disk(i1) - t(2)*u3%x_hat_disk(i1) ) * scaleFactor
    u_out%x_hat_disk(i1) = u1%x_hat_disk(i1) + b  + c * t_out
  END DO
IF (ALLOCATED(u_out%UserProp) .AND. ALLOCATED(u1%UserProp)) THEN
  DO i2 = LBOUND(u_out%UserProp,2),UBOUND(u_out%UserProp,2)
    DO i1 = LBOUND(u_out%UserProp,1),UBOUND(u_out%UserProp,1)
      b = (t(3)**2*(u1%UserProp(i1,i2) - u2%UserProp(i1,i2)) + t(2)**2*(-u1%UserProp(i1,i2) + u3%UserProp(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%UserProp(i1,i2) + t(3)*u2%UserProp(i1,i2) - t(2)*u3%UserProp(i1,i2) ) * scaleFactor
      u_out%UserProp(i1,i2) = u1%UserProp(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%CantAngle) .AND. ALLOCATED(u1%CantAngle)) THEN
  DO i2 = LBOUND(u_out%CantAngle,2),UBOUND(u_out%CantAngle,2)
    DO i1 = LBOUND(u_out%CantAngle,1),UBOUND(u_out%CantAngle,1)
      b = (t(3)**2*(u1%CantAngle(i1,i2) - u2%CantAngle(i1,i2)) + t(2)**2*(-u1%CantAngle(i1,i2) + u3%CantAngle(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%CantAngle(i1,i2) + t(3)*u2%CantAngle(i1,i2) - t(2)*u3%CantAngle(i1,i2) ) * scaleFactor
      u_out%CantAngle(i1,i2) = u1%CantAngle(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%drdz) .AND. ALLOCATED(u1%drdz)) THEN
  DO i2 = LBOUND(u_out%drdz,2),UBOUND(u_out%drdz,2)
    DO i1 = LBOUND(u_out%drdz,1),UBOUND(u_out%drdz,1)
      b = (t(3)**2*(u1%drdz(i1,i2) - u2%drdz(i1,i2)) + t(2)**2*(-u1%drdz(i1,i2) + u3%drdz(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%drdz(i1,i2) + t(3)*u2%drdz(i1,i2) - t(2)*u3%drdz(i1,i2) ) * scaleFactor
      u_out%drdz(i1,i2) = u1%drdz(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%toeAngle) .AND. ALLOCATED(u1%toeAngle)) THEN
  DO i2 = LBOUND(u_out%toeAngle,2),UBOUND(u_out%toeAngle,2)
    DO i1 = LBOUND(u_out%toeAngle,1),UBOUND(u_out%toeAngle,1)
      b = (t(3)**2*(u1%toeAngle(i1,i2) - u2%toeAngle(i1,i2)) + t(2)**2*(-u1%toeAngle(i1,i2) + u3%toeAngle(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%toeAngle(i1,i2) + t(3)*u2%toeAngle(i1,i2) - t(2)*u3%toeAngle(i1,i2) ) * scaleFactor
      u_out%toeAngle(i1,i2) = u1%toeAngle(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE BEMT_Input_ExtrapInterp2


 SUBROUTINE BEMT_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(BEMT_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(BEMT_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'BEMT_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL BEMT_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL BEMT_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL BEMT_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE BEMT_Output_ExtrapInterp


 SUBROUTINE BEMT_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(BEMT_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(BEMT_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(BEMT_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'BEMT_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%Vrel) .AND. ALLOCATED(y1%Vrel)) THEN
  DO i2 = LBOUND(y_out%Vrel,2),UBOUND(y_out%Vrel,2)
    DO i1 = LBOUND(y_out%Vrel,1),UBOUND(y_out%Vrel,1)
      b = -(y1%Vrel(i1,i2) - y2%Vrel(i1,i2))
      y_out%Vrel(i1,i2) = y1%Vrel(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%phi) .AND. ALLOCATED(y1%phi)) THEN
  DO i2 = LBOUND(y_out%phi,2),UBOUND(y_out%phi,2)
    DO i1 = LBOUND(y_out%phi,1),UBOUND(y_out%phi,1)
      b = -(y1%phi(i1,i2) - y2%phi(i1,i2))
      y_out%phi(i1,i2) = y1%phi(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%axInduction) .AND. ALLOCATED(y1%axInduction)) THEN
  DO i2 = LBOUND(y_out%axInduction,2),UBOUND(y_out%axInduction,2)
    DO i1 = LBOUND(y_out%axInduction,1),UBOUND(y_out%axInduction,1)
      b = -(y1%axInduction(i1,i2) - y2%axInduction(i1,i2))
      y_out%axInduction(i1,i2) = y1%axInduction(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%tanInduction) .AND. ALLOCATED(y1%tanInduction)) THEN
  DO i2 = LBOUND(y_out%tanInduction,2),UBOUND(y_out%tanInduction,2)
    DO i1 = LBOUND(y_out%tanInduction,1),UBOUND(y_out%tanInduction,1)
      b = -(y1%tanInduction(i1,i2) - y2%tanInduction(i1,i2))
      y_out%tanInduction(i1,i2) = y1%tanInduction(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Re) .AND. ALLOCATED(y1%Re)) THEN
  DO i2 = LBOUND(y_out%Re,2),UBOUND(y_out%Re,2)
    DO i1 = LBOUND(y_out%Re,1),UBOUND(y_out%Re,1)
      b = -(y1%Re(i1,i2) - y2%Re(i1,i2))
      y_out%Re(i1,i2) = y1%Re(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%AOA) .AND. ALLOCATED(y1%AOA)) THEN
  DO i2 = LBOUND(y_out%AOA,2),UBOUND(y_out%AOA,2)
    DO i1 = LBOUND(y_out%AOA,1),UBOUND(y_out%AOA,1)
      b = -(y1%AOA(i1,i2) - y2%AOA(i1,i2))
      y_out%AOA(i1,i2) = y1%AOA(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cx) .AND. ALLOCATED(y1%Cx)) THEN
  DO i2 = LBOUND(y_out%Cx,2),UBOUND(y_out%Cx,2)
    DO i1 = LBOUND(y_out%Cx,1),UBOUND(y_out%Cx,1)
      b = -(y1%Cx(i1,i2) - y2%Cx(i1,i2))
      y_out%Cx(i1,i2) = y1%Cx(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cy) .AND. ALLOCATED(y1%Cy)) THEN
  DO i2 = LBOUND(y_out%Cy,2),UBOUND(y_out%Cy,2)
    DO i1 = LBOUND(y_out%Cy,1),UBOUND(y_out%Cy,1)
      b = -(y1%Cy(i1,i2) - y2%Cy(i1,i2))
      y_out%Cy(i1,i2) = y1%Cy(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cz) .AND. ALLOCATED(y1%Cz)) THEN
  DO i2 = LBOUND(y_out%Cz,2),UBOUND(y_out%Cz,2)
    DO i1 = LBOUND(y_out%Cz,1),UBOUND(y_out%Cz,1)
      b = -(y1%Cz(i1,i2) - y2%Cz(i1,i2))
      y_out%Cz(i1,i2) = y1%Cz(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cmx) .AND. ALLOCATED(y1%Cmx)) THEN
  DO i2 = LBOUND(y_out%Cmx,2),UBOUND(y_out%Cmx,2)
    DO i1 = LBOUND(y_out%Cmx,1),UBOUND(y_out%Cmx,1)
      b = -(y1%Cmx(i1,i2) - y2%Cmx(i1,i2))
      y_out%Cmx(i1,i2) = y1%Cmx(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cmy) .AND. ALLOCATED(y1%Cmy)) THEN
  DO i2 = LBOUND(y_out%Cmy,2),UBOUND(y_out%Cmy,2)
    DO i1 = LBOUND(y_out%Cmy,1),UBOUND(y_out%Cmy,1)
      b = -(y1%Cmy(i1,i2) - y2%Cmy(i1,i2))
      y_out%Cmy(i1,i2) = y1%Cmy(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cmz) .AND. ALLOCATED(y1%Cmz)) THEN
  DO i2 = LBOUND(y_out%Cmz,2),UBOUND(y_out%Cmz,2)
    DO i1 = LBOUND(y_out%Cmz,1),UBOUND(y_out%Cmz,1)
      b = -(y1%Cmz(i1,i2) - y2%Cmz(i1,i2))
      y_out%Cmz(i1,i2) = y1%Cmz(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cm) .AND. ALLOCATED(y1%Cm)) THEN
  DO i2 = LBOUND(y_out%Cm,2),UBOUND(y_out%Cm,2)
    DO i1 = LBOUND(y_out%Cm,1),UBOUND(y_out%Cm,1)
      b = -(y1%Cm(i1,i2) - y2%Cm(i1,i2))
      y_out%Cm(i1,i2) = y1%Cm(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cl) .AND. ALLOCATED(y1%Cl)) THEN
  DO i2 = LBOUND(y_out%Cl,2),UBOUND(y_out%Cl,2)
    DO i1 = LBOUND(y_out%Cl,1),UBOUND(y_out%Cl,1)
      b = -(y1%Cl(i1,i2) - y2%Cl(i1,i2))
      y_out%Cl(i1,i2) = y1%Cl(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cd) .AND. ALLOCATED(y1%Cd)) THEN
  DO i2 = LBOUND(y_out%Cd,2),UBOUND(y_out%Cd,2)
    DO i1 = LBOUND(y_out%Cd,1),UBOUND(y_out%Cd,1)
      b = -(y1%Cd(i1,i2) - y2%Cd(i1,i2))
      y_out%Cd(i1,i2) = y1%Cd(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%chi) .AND. ALLOCATED(y1%chi)) THEN
  DO i2 = LBOUND(y_out%chi,2),UBOUND(y_out%chi,2)
    DO i1 = LBOUND(y_out%chi,1),UBOUND(y_out%chi,1)
      b = -(y1%chi(i1,i2) - y2%chi(i1,i2))
      y_out%chi(i1,i2) = y1%chi(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cpmin) .AND. ALLOCATED(y1%Cpmin)) THEN
  DO i2 = LBOUND(y_out%Cpmin,2),UBOUND(y_out%Cpmin,2)
    DO i1 = LBOUND(y_out%Cpmin,1),UBOUND(y_out%Cpmin,1)
      b = -(y1%Cpmin(i1,i2) - y2%Cpmin(i1,i2))
      y_out%Cpmin(i1,i2) = y1%Cpmin(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE BEMT_Output_ExtrapInterp1


 SUBROUTINE BEMT_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(BEMT_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(BEMT_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(BEMT_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(BEMT_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'BEMT_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%Vrel) .AND. ALLOCATED(y1%Vrel)) THEN
  DO i2 = LBOUND(y_out%Vrel,2),UBOUND(y_out%Vrel,2)
    DO i1 = LBOUND(y_out%Vrel,1),UBOUND(y_out%Vrel,1)
      b = (t(3)**2*(y1%Vrel(i1,i2) - y2%Vrel(i1,i2)) + t(2)**2*(-y1%Vrel(i1,i2) + y3%Vrel(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Vrel(i1,i2) + t(3)*y2%Vrel(i1,i2) - t(2)*y3%Vrel(i1,i2) ) * scaleFactor
      y_out%Vrel(i1,i2) = y1%Vrel(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%phi) .AND. ALLOCATED(y1%phi)) THEN
  DO i2 = LBOUND(y_out%phi,2),UBOUND(y_out%phi,2)
    DO i1 = LBOUND(y_out%phi,1),UBOUND(y_out%phi,1)
      b = (t(3)**2*(y1%phi(i1,i2) - y2%phi(i1,i2)) + t(2)**2*(-y1%phi(i1,i2) + y3%phi(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%phi(i1,i2) + t(3)*y2%phi(i1,i2) - t(2)*y3%phi(i1,i2) ) * scaleFactor
      y_out%phi(i1,i2) = y1%phi(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%axInduction) .AND. ALLOCATED(y1%axInduction)) THEN
  DO i2 = LBOUND(y_out%axInduction,2),UBOUND(y_out%axInduction,2)
    DO i1 = LBOUND(y_out%axInduction,1),UBOUND(y_out%axInduction,1)
      b = (t(3)**2*(y1%axInduction(i1,i2) - y2%axInduction(i1,i2)) + t(2)**2*(-y1%axInduction(i1,i2) + y3%axInduction(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%axInduction(i1,i2) + t(3)*y2%axInduction(i1,i2) - t(2)*y3%axInduction(i1,i2) ) * scaleFactor
      y_out%axInduction(i1,i2) = y1%axInduction(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%tanInduction) .AND. ALLOCATED(y1%tanInduction)) THEN
  DO i2 = LBOUND(y_out%tanInduction,2),UBOUND(y_out%tanInduction,2)
    DO i1 = LBOUND(y_out%tanInduction,1),UBOUND(y_out%tanInduction,1)
      b = (t(3)**2*(y1%tanInduction(i1,i2) - y2%tanInduction(i1,i2)) + t(2)**2*(-y1%tanInduction(i1,i2) + y3%tanInduction(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%tanInduction(i1,i2) + t(3)*y2%tanInduction(i1,i2) - t(2)*y3%tanInduction(i1,i2) ) * scaleFactor
      y_out%tanInduction(i1,i2) = y1%tanInduction(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Re) .AND. ALLOCATED(y1%Re)) THEN
  DO i2 = LBOUND(y_out%Re,2),UBOUND(y_out%Re,2)
    DO i1 = LBOUND(y_out%Re,1),UBOUND(y_out%Re,1)
      b = (t(3)**2*(y1%Re(i1,i2) - y2%Re(i1,i2)) + t(2)**2*(-y1%Re(i1,i2) + y3%Re(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Re(i1,i2) + t(3)*y2%Re(i1,i2) - t(2)*y3%Re(i1,i2) ) * scaleFactor
      y_out%Re(i1,i2) = y1%Re(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%AOA) .AND. ALLOCATED(y1%AOA)) THEN
  DO i2 = LBOUND(y_out%AOA,2),UBOUND(y_out%AOA,2)
    DO i1 = LBOUND(y_out%AOA,1),UBOUND(y_out%AOA,1)
      b = (t(3)**2*(y1%AOA(i1,i2) - y2%AOA(i1,i2)) + t(2)**2*(-y1%AOA(i1,i2) + y3%AOA(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%AOA(i1,i2) + t(3)*y2%AOA(i1,i2) - t(2)*y3%AOA(i1,i2) ) * scaleFactor
      y_out%AOA(i1,i2) = y1%AOA(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cx) .AND. ALLOCATED(y1%Cx)) THEN
  DO i2 = LBOUND(y_out%Cx,2),UBOUND(y_out%Cx,2)
    DO i1 = LBOUND(y_out%Cx,1),UBOUND(y_out%Cx,1)
      b = (t(3)**2*(y1%Cx(i1,i2) - y2%Cx(i1,i2)) + t(2)**2*(-y1%Cx(i1,i2) + y3%Cx(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cx(i1,i2) + t(3)*y2%Cx(i1,i2) - t(2)*y3%Cx(i1,i2) ) * scaleFactor
      y_out%Cx(i1,i2) = y1%Cx(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cy) .AND. ALLOCATED(y1%Cy)) THEN
  DO i2 = LBOUND(y_out%Cy,2),UBOUND(y_out%Cy,2)
    DO i1 = LBOUND(y_out%Cy,1),UBOUND(y_out%Cy,1)
      b = (t(3)**2*(y1%Cy(i1,i2) - y2%Cy(i1,i2)) + t(2)**2*(-y1%Cy(i1,i2) + y3%Cy(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cy(i1,i2) + t(3)*y2%Cy(i1,i2) - t(2)*y3%Cy(i1,i2) ) * scaleFactor
      y_out%Cy(i1,i2) = y1%Cy(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cz) .AND. ALLOCATED(y1%Cz)) THEN
  DO i2 = LBOUND(y_out%Cz,2),UBOUND(y_out%Cz,2)
    DO i1 = LBOUND(y_out%Cz,1),UBOUND(y_out%Cz,1)
      b = (t(3)**2*(y1%Cz(i1,i2) - y2%Cz(i1,i2)) + t(2)**2*(-y1%Cz(i1,i2) + y3%Cz(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cz(i1,i2) + t(3)*y2%Cz(i1,i2) - t(2)*y3%Cz(i1,i2) ) * scaleFactor
      y_out%Cz(i1,i2) = y1%Cz(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cmx) .AND. ALLOCATED(y1%Cmx)) THEN
  DO i2 = LBOUND(y_out%Cmx,2),UBOUND(y_out%Cmx,2)
    DO i1 = LBOUND(y_out%Cmx,1),UBOUND(y_out%Cmx,1)
      b = (t(3)**2*(y1%Cmx(i1,i2) - y2%Cmx(i1,i2)) + t(2)**2*(-y1%Cmx(i1,i2) + y3%Cmx(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cmx(i1,i2) + t(3)*y2%Cmx(i1,i2) - t(2)*y3%Cmx(i1,i2) ) * scaleFactor
      y_out%Cmx(i1,i2) = y1%Cmx(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cmy) .AND. ALLOCATED(y1%Cmy)) THEN
  DO i2 = LBOUND(y_out%Cmy,2),UBOUND(y_out%Cmy,2)
    DO i1 = LBOUND(y_out%Cmy,1),UBOUND(y_out%Cmy,1)
      b = (t(3)**2*(y1%Cmy(i1,i2) - y2%Cmy(i1,i2)) + t(2)**2*(-y1%Cmy(i1,i2) + y3%Cmy(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cmy(i1,i2) + t(3)*y2%Cmy(i1,i2) - t(2)*y3%Cmy(i1,i2) ) * scaleFactor
      y_out%Cmy(i1,i2) = y1%Cmy(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cmz) .AND. ALLOCATED(y1%Cmz)) THEN
  DO i2 = LBOUND(y_out%Cmz,2),UBOUND(y_out%Cmz,2)
    DO i1 = LBOUND(y_out%Cmz,1),UBOUND(y_out%Cmz,1)
      b = (t(3)**2*(y1%Cmz(i1,i2) - y2%Cmz(i1,i2)) + t(2)**2*(-y1%Cmz(i1,i2) + y3%Cmz(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cmz(i1,i2) + t(3)*y2%Cmz(i1,i2) - t(2)*y3%Cmz(i1,i2) ) * scaleFactor
      y_out%Cmz(i1,i2) = y1%Cmz(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cm) .AND. ALLOCATED(y1%Cm)) THEN
  DO i2 = LBOUND(y_out%Cm,2),UBOUND(y_out%Cm,2)
    DO i1 = LBOUND(y_out%Cm,1),UBOUND(y_out%Cm,1)
      b = (t(3)**2*(y1%Cm(i1,i2) - y2%Cm(i1,i2)) + t(2)**2*(-y1%Cm(i1,i2) + y3%Cm(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cm(i1,i2) + t(3)*y2%Cm(i1,i2) - t(2)*y3%Cm(i1,i2) ) * scaleFactor
      y_out%Cm(i1,i2) = y1%Cm(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cl) .AND. ALLOCATED(y1%Cl)) THEN
  DO i2 = LBOUND(y_out%Cl,2),UBOUND(y_out%Cl,2)
    DO i1 = LBOUND(y_out%Cl,1),UBOUND(y_out%Cl,1)
      b = (t(3)**2*(y1%Cl(i1,i2) - y2%Cl(i1,i2)) + t(2)**2*(-y1%Cl(i1,i2) + y3%Cl(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cl(i1,i2) + t(3)*y2%Cl(i1,i2) - t(2)*y3%Cl(i1,i2) ) * scaleFactor
      y_out%Cl(i1,i2) = y1%Cl(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cd) .AND. ALLOCATED(y1%Cd)) THEN
  DO i2 = LBOUND(y_out%Cd,2),UBOUND(y_out%Cd,2)
    DO i1 = LBOUND(y_out%Cd,1),UBOUND(y_out%Cd,1)
      b = (t(3)**2*(y1%Cd(i1,i2) - y2%Cd(i1,i2)) + t(2)**2*(-y1%Cd(i1,i2) + y3%Cd(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cd(i1,i2) + t(3)*y2%Cd(i1,i2) - t(2)*y3%Cd(i1,i2) ) * scaleFactor
      y_out%Cd(i1,i2) = y1%Cd(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%chi) .AND. ALLOCATED(y1%chi)) THEN
  DO i2 = LBOUND(y_out%chi,2),UBOUND(y_out%chi,2)
    DO i1 = LBOUND(y_out%chi,1),UBOUND(y_out%chi,1)
      b = (t(3)**2*(y1%chi(i1,i2) - y2%chi(i1,i2)) + t(2)**2*(-y1%chi(i1,i2) + y3%chi(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%chi(i1,i2) + t(3)*y2%chi(i1,i2) - t(2)*y3%chi(i1,i2) ) * scaleFactor
      y_out%chi(i1,i2) = y1%chi(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%Cpmin) .AND. ALLOCATED(y1%Cpmin)) THEN
  DO i2 = LBOUND(y_out%Cpmin,2),UBOUND(y_out%Cpmin,2)
    DO i1 = LBOUND(y_out%Cpmin,1),UBOUND(y_out%Cpmin,1)
      b = (t(3)**2*(y1%Cpmin(i1,i2) - y2%Cpmin(i1,i2)) + t(2)**2*(-y1%Cpmin(i1,i2) + y3%Cpmin(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%Cpmin(i1,i2) + t(3)*y2%Cpmin(i1,i2) - t(2)*y3%Cpmin(i1,i2) ) * scaleFactor
      y_out%Cpmin(i1,i2) = y1%Cpmin(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE BEMT_Output_ExtrapInterp2

END MODULE BEMT_Types
!ENDOFREGISTRYGENERATEDFILE
