!STARTOFREGISTRYGENERATEDFILE 'FVW_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FVW_Types
!.................................................................................................................................
! This file is part of FVW.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FVW. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FVW_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE UnsteadyAero_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: idGridVelocity = 1      ! Grid stores velocity field [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: idGridVelVorticity = 2      ! Grid stores velocity and vorticity [-]
! =========  GridOutType  =======
  TYPE, PUBLIC :: GridOutType
    CHARACTER(100)  :: name      !< Grid name [-]
    INTEGER(IntKi)  :: type      !< Grid type [-]
    REAL(ReKi)  :: tStart      !< Time at which outputs starts [-]
    REAL(ReKi)  :: tEnd      !< Time at which outputs ends [-]
    REAL(ReKi)  :: DTout      !< Output frequency of grid [-]
    REAL(ReKi)  :: xStart      !< xStart [-]
    REAL(ReKi)  :: yStart      !< yStart [-]
    REAL(ReKi)  :: zStart      !< zStart [-]
    REAL(ReKi)  :: xEnd      !< xEnd [-]
    REAL(ReKi)  :: yEnd      !< yEnd [-]
    REAL(ReKi)  :: zEnd      !< zEnd [-]
    INTEGER(IntKi)  :: nx      !< nx [-]
    INTEGER(IntKi)  :: ny      !< ny [-]
    INTEGER(IntKi)  :: nz      !< nz [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uGrid      !< Grid velocity 3 x nz x ny x nx [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: omGrid      !< Grid vorticity 3 x nz x ny x nx [-]
    REAL(DbKi)  :: tLastOutput      !< Last output time [-]
  END TYPE GridOutType
! =======================
! =========  T_Sgmt  =======
  TYPE, PUBLIC :: T_Sgmt
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Points      !< Points delimiting the segments [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Connct      !< Connectivity of segments [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Gamma      !< Segment circulations [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Epsilon      !< Segment regularization parameter [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: nAct      !< Number of active segments [-]
    INTEGER(IntKi)  :: nActP      !< Number of active segment points [-]
  END TYPE T_Sgmt
! =======================
! =========  T_Part  =======
  TYPE, PUBLIC :: T_Part
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: P      !< Particle Points [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Alpha      !< Particle intensity 3 x nP [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RegParam      !< Particle regularization parameter [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: nAct      !< Number of active particles <=nP [-]
  END TYPE T_Part
! =======================
! =========  Wng_ParameterType  =======
  TYPE, PUBLIC :: Wng_ParameterType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: chord_LL      !< Chord of each blade element from input file [idx1=BladeNode, idx2=Blade number] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: chord_CP      !< Chord on LL cp  [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: s_LL      !< Spanwise coordinate of LL elements [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: s_CP      !< Spanwise coordinate of LL CP [m]
    INTEGER(IntKi)  :: iRotor      !< Index of rotor the wing belong to [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index to the airfoils from AD15 [BladeNode,BladeIndex=1] [-]
    INTEGER(IntKi)  :: nSpan      !< TODO, should be defined per wing. Number of spanwise element [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PrescribedCirculation      !< Prescribed circulation on all lifting lines [m/s]
  END TYPE Wng_ParameterType
! =======================
! =========  FVW_ParameterType  =======
  TYPE, PUBLIC :: FVW_ParameterType
    INTEGER(IntKi)  :: nRotors      !< Number of Wings [-]
    INTEGER(IntKi)  :: nWings      !< Number of Wings [-]
    TYPE(Wng_ParameterType) , DIMENSION(:), ALLOCATABLE  :: W      !< Wings parameters [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Bld2Wings      !< Index mapping from blades to wings [-]
    INTEGER(IntKi)  :: iNWStart      !< Index where NW start in r_NW. (iNWStart=2, the first panel contains the lifting line panel, otherwise, start at 1) [-]
    INTEGER(IntKi)  :: nNWMax      !< Maximum number of nw panels, per wing [-]
    INTEGER(IntKi)  :: nNWFree      !< Number of nw panels that are free, per wing [-]
    INTEGER(IntKi)  :: nFWMax      !< Maximum number of fw panels, per wing [-]
    INTEGER(IntKi)  :: nFWFree      !< Number of fw panels that are free, per wing [-]
    LOGICAL  :: FWShedVorticity      !< Include shed vorticity in the far wake [-]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1=RK4, 2=AB4, 3=ABM4, 5=Euler1) [-]
    REAL(ReKi)  :: FreeWakeStart      !< Time when wake starts convecting (rolling up) [s]
    REAL(ReKi)  :: FullCircStart      !< Time when the circulation is full [s]
    INTEGER(IntKi)  :: CircSolvMethod      !< Method to determine the circulation [-]
    INTEGER(IntKi)  :: CircSolvMaxIter      !< Maximum number of iterations for circulation solving [-]
    REAL(ReKi)  :: CircSolvConvCrit      !< Convergence criterion for circulation solving [-]
    REAL(ReKi)  :: CircSolvRelaxation      !< Relaxation factor for circulation solving [-]
    INTEGER(IntKi)  :: CircSolvPolar      !< (0=Use AD polars, 1=2PiAlpha, 2=sin(2pialpha) [-]
    INTEGER(IntKi)  :: DiffusionMethod      !< Diffusion method (None, CoreSpreading, PSE) [-]
    REAL(ReKi)  :: CoreSpreadEddyVisc      !< Eddy viscosity used in the core spreading method [-]
    INTEGER(IntKi)  :: RegDeterMethod      !< Regularization determinatino method (manual, automatic) [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: WakeRegMethod      !< Method for regularization (constant, stretching, age, etc.) [-]
    REAL(ReKi)  :: WakeRegParam      !< Initial value of the regularization parameter [-]
    REAL(ReKi)  :: WingRegParam      !< Regularization parameter of the wing [-]
    INTEGER(IntKi)  :: ShearModel      !< Option for shear modelling [-]
    LOGICAL  :: TwrShadowOnWake      !< Include tower shadow effects on wake [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: VelocityMethod      !< Velocity calculation method for Full Wake and for LiftingLine [-]
    REAL(ReKi) , DIMENSION(1:2)  :: TreeBranchFactor      !< Factor used to determine if a point is far enough, for full wake and lifting line [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: PartPerSegment      !< Number of particles per segment, e.g. for tree method, for full wake and lifting line [-]
    REAL(DbKi)  :: DTaero      !< Time interval for calls calculations [s]
    REAL(DbKi)  :: DTfvw      !< Time interval for calculating wake induced velocities [s]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: MHK      !< MHK flag [-]
    REAL(ReKi)  :: WtrDpth      !< Water depth [m]
    INTEGER(IntKi)  :: WrVTK      !< Outputs VTK at each calcoutput call, even if main fst doesnt do it [-]
    INTEGER(IntKi)  :: VTKBlades      !< Outputs VTk for each blade 0=no blade, 1=Bld 1 [-]
    REAL(DbKi)  :: DTvtk      !< DT between vtk writes [s]
    INTEGER(IntKi)  :: VTKCoord      !< Switch for VTK outputs coordinate  system [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    CHARACTER(1024)  :: VTK_OutFileRoot      !< Rootdirectory for writing VTK files [-]
    CHARACTER(1024)  :: VTK_OutFileBase      !< Basename for writing VTK files [-]
    INTEGER(IntKi)  :: nGridOut      !< Number of VTK grid to output [-]
    LOGICAL  :: InductionAtCP = .true.      !< Compute induced velocities at nodes or CP [-]
    LOGICAL  :: WakeAtTE = .true.      !< Start the wake at the trailing edge, or at the LL [-]
    LOGICAL  :: DStallOnWake = .false.      !< Dynamic stall has influence on wake [-]
    LOGICAL  :: Induction = .true.      !< Compute induction [-]
    REAL(ReKi)  :: kFrozenNWStart = 0.75      !< Fraction of wake induced velocity at start of frozen wake. 1 seems too strong. [-]
    REAL(ReKi)  :: kFrozenNWEnd = 0.5      !< Fraction of wake induced velocity at end of frozen wake [-]
  END TYPE FVW_ParameterType
! =======================
! =========  Wng_ContinuousStateType  =======
  TYPE, PUBLIC :: Wng_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Gamma_NW      !< Circulation of the near wake panels (    nSpan     x nNW  ) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Gamma_FW      !< Circulation of the far  wake panels (    nFWSpan   x nFW  ) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Eps_NW      !< Reg param   of the near wake panels (3 x nSpan     x nNW  ) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Eps_FW      !< Reg param   of the far  wake panels (3 x nFWSpan   x nFW  ) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: r_NW      !< Position    of the near wake panels (3 x nSpan+1   x nNW+1)  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: r_FW      !< Position    of the far  wake panels (3 x nFWSpan+1 x nFW+1) [-]
  END TYPE Wng_ContinuousStateType
! =======================
! =========  FVW_ContinuousStateType  =======
  TYPE, PUBLIC :: FVW_ContinuousStateType
    TYPE(Wng_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: W      !< Circulation of the near wake panels (    nSpan     x nNW ) [-]
    TYPE(UA_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: UA      !< states for UnsteadyAero [-]
  END TYPE FVW_ContinuousStateType
! =======================
! =========  Wng_OutputType  =======
  TYPE, PUBLIC :: Wng_OutputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vind      !< TODO mesh  - Induced velocity vector at AeroDyn nodes.  [-]
  END TYPE Wng_OutputType
! =======================
! =========  FVW_OutputType  =======
  TYPE, PUBLIC :: FVW_OutputType
    TYPE(Wng_OutputType) , DIMENSION(:), ALLOCATABLE  :: W      !< Induced velocity vector at AeroDyn nodes for all wings.  [-]
  END TYPE FVW_OutputType
! =======================
! =========  Wng_MiscVarType  =======
  TYPE, PUBLIC :: Wng_MiscVarType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: LE      !< Leading edge points [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TE      !< Trailing edge points [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: r_LL      !< Position    of the Lifting line panels [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CP      !< Coordinates of LL CP [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Tang      !< Unit Tangential vector on LL CP [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Norm      !< Unit Normal vector on LL CP     [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Orth      !< Unit Orthogonal vector on LL CP [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: dl      !< Vector of elementary length along the LL [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Area      !< Area of each LL panel [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: diag_LL      !< Diagonal length of each LL panel [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vind_CP      !< Induced velocity on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vtot_CP      !< Total velocity on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vstr_CP      !< Structural velocity on LL CP [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vwnd_CP      !< Wind on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vwnd_NW      !< Wind on near wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vwnd_FW      !< Wind on far  wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind_NW      !< Induced velocity on near wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind_FW      !< Induced velocity on far  wake panels [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PitchAndTwist      !< Twist angle (includes all sources of twist)  [Array of size (NumBlNds,numBlades)] [rad]
    INTEGER(IntKi)  :: iTip      !< Index where tip vorticity will be placed. TODO, per blade [-]
    INTEGER(IntKi)  :: iRoot      !< Index where root vorticity will be placed [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: alpha_LL      !< Angle of attack at lifting line CP, only computed with CircPolarData method [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vreln_LL      !< Norm of Vrel on the lifting line [-]
    TYPE(UA_InputType) , DIMENSION(:,:), ALLOCATABLE  :: u_UA      !< inputs to UnsteadyAero  numNode x 2 (t and t+dt) [-]
    TYPE(UA_MiscVarType)  :: m_UA      !< misc vars for UnsteadyAero [-]
    TYPE(UA_OutputType)  :: y_UA      !< outputs from UnsteadyAero [-]
    TYPE(UA_ParameterType)  :: p_UA      !< parameters for UnsteadyAero [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vind_LL      !< Induced velocity on lifting line nodes [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_AxInd      !< Axial induction [size (NumBlNds,numBlades)] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_TanInd      !< Tangential induction [size (NumBlNds,numBlades)] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Vrel      !< Relative velocity [size (NumBlNds,numBlades)] [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_alpha      !< Angle of attack [size (NumBlNds,numBlades)] [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_phi      !< angle between the plane of rotation and the direction of the local wind [size (NumBlNds,numBlades)] [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Re      !< Reynolds number [size (NumBlNds,numBlades)] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BN_URelWind_s      !< Relative wind velocity in section coordinates [size (3,NumBlNds,numBlades)] [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cl_Static      !< Coefficient lift,   excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cd_Static      !< Coefficient drag.   excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cm_Static      !< Coefficient moment, excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cpmin      !< Coefficient minimum pressure, excluding unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cl      !< Coefficient lift,   including unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cd      !< Coefficient drag,   including unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cm      !< Coefficient moment, including unsteady aero effects [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cx      !< normal force coefficient (normal to the plane, not chord) of the jth node in the kth blade [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BN_Cy      !< tangential force coefficient (tangential to the plane, not chord) of the jth node in the kth blade [-]
  END TYPE Wng_MiscVarType
! =======================
! =========  FVW_MiscVarType  =======
  TYPE, PUBLIC :: FVW_MiscVarType
    TYPE(Wng_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: W      !< Misc for all wings [-]
    LOGICAL  :: FirstCall      !< True if this is the first call to update state (used in CalcOutput) [-]
    INTEGER(IntKi)  :: nNW      !< Number of active near wake panels [-]
    INTEGER(IntKi)  :: nFW      !< Number of active far  wake panels [-]
    INTEGER(IntKi)  :: iStep      !< Current step number used for update state [-]
    INTEGER(IntKi)  :: VTKstep      !< Current vtk output step number [-]
    REAL(DbKi)  :: VTKlastTime      !< Time the last VTK file set was written out [s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r_wind      !< List of points where wind is requested for next time step [-]
    LOGICAL  :: ComputeWakeInduced      !< Compute induced velocities on this timestep [-]
    REAL(DbKi)  :: OldWakeTime      !< Time the wake induction velocities were last calculated [s]
    TYPE(FVW_ContinuousStateType)  :: dxdt      !< State time derivatie, stored for overcycling and convenience [-]
    TYPE(FVW_ContinuousStateType)  :: x1      !< States at t (for overcycling)  [-]
    TYPE(FVW_ContinuousStateType)  :: x2      !< States at t+DTFVW (for overcycling) [-]
    REAL(DbKi)  :: t1      !< Time of x1 (for overcycling)  [-]
    REAL(DbKi)  :: t2      !< Time of x2 t+DTFVW (for overcycling) [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    TYPE(T_Sgmt)  :: Sgmt      !< Segments storage [-]
    TYPE(T_Part)  :: Part      !< Particle storage [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CPs      !< Control points used for wake rollup computation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Uind      !< Induced velocities obtained at control points [-]
    TYPE(GridOutType) , DIMENSION(:), ALLOCATABLE  :: GridOutputs      !< Number of VTK grid to output [-]
  END TYPE FVW_MiscVarType
! =======================
! =========  Rot_InputType  =======
  TYPE, PUBLIC :: Rot_InputType
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: HubOrientation      !< Orientation of hub coordinate system (for output only) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: HubPosition      !< Origin of hub (for output only) [-]
  END TYPE Rot_InputType
! =======================
! =========  Wng_InputType  =======
  TYPE, PUBLIC :: Wng_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vwnd_LL      !< Disturbed wind at LL mesh points (not CP), for UA only [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: omega_z      !< rotation of no-sweep-pitch-twist coordinate system around z (for CDBEMT and CUA) [rad/s]
  END TYPE Wng_InputType
! =======================
! =========  FVW_InputType  =======
  TYPE, PUBLIC :: FVW_InputType
    TYPE(Rot_InputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Rotors inputs [-]
    TYPE(Wng_InputType) , DIMENSION(:), ALLOCATABLE  :: W      !< Wings inputs [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: WingsMesh      !< Input Mesh defining position and orientation of wings (nSpan+1)  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: V_wind      !< Wind at requested points (r_wind) [-]
  END TYPE FVW_InputType
! =======================
! =========  FVW_DiscreteStateType  =======
  TYPE, PUBLIC :: FVW_DiscreteStateType
    REAL(ReKi)  :: Dummy      !< Empty to satisfy framework [-]
    TYPE(UA_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: UA      !< states for UnsteadyAero for each Wing [-]
  END TYPE FVW_DiscreteStateType
! =======================
! =========  Wng_ConstraintStateType  =======
  TYPE, PUBLIC :: Wng_ConstraintStateType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Gamma_LL      !< Circulation on the wing lifting line [-]
  END TYPE Wng_ConstraintStateType
! =======================
! =========  FVW_ConstraintStateType  =======
  TYPE, PUBLIC :: FVW_ConstraintStateType
    TYPE(Wng_ConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: W      !< rotors constr. states [-]
    REAL(ReKi)  :: residual      !< Residual [-]
  END TYPE FVW_ConstraintStateType
! =======================
! =========  FVW_OtherStateType  =======
  TYPE, PUBLIC :: FVW_OtherStateType
    INTEGER(IntKi)  :: Dummy      !< Empty to satisfy framework [-]
    TYPE(UA_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: UA      !< other states for UnsteadyAero for each wing [-]
  END TYPE FVW_OtherStateType
! =======================
! =========  Wng_InitInputType  =======
  TYPE, PUBLIC :: Wng_InitInputType
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: AFindx      !< Index to the airfoils from AD15 [idx1=BladeNode, idx2=Blade number=1] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: chord      !< Chord of each blade element from input file [idx1=BladeNode, idx2=Blade number] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RElm      !< radius of center of each element [-]
    INTEGER(IntKi)  :: iRotor      !< Index of rotor the wing belong to [-]
    INTEGER(IntKi)  :: UAOff_innerNode      !< Last node on each blade where UA should be turned off based on span location from blade root (0 if always on) [-]
    INTEGER(IntKi)  :: UAOff_outerNode      !< First node on each blade where UA should be turned off based on span location from blade tip (>nNodesPerBlade if always on) [-]
  END TYPE Wng_InitInputType
! =======================
! =========  FVW_InitInputType  =======
  TYPE, PUBLIC :: FVW_InitInputType
    CHARACTER(1024)  :: FVWFileName      !< Main FVW input file name [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(Wng_InitInputType) , DIMENSION(:), ALLOCATABLE  :: W      !< Number of blades [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: WingsMesh      !< Input Mesh defining position and orientation of wings (nSpan+1)  [-]
    INTEGER(IntKi)  :: numBladeNodes      !< Number of nodes on each blade [-]
    REAL(DbKi)  :: DTaero      !< Time interval for calls (from AD15) [s]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    INTEGER(IntKi)  :: MHK      !< MHK flag [-]
    REAL(ReKi)  :: WtrDpth      !< Water depth [m]
    INTEGER(IntKi)  :: UAMod      !< Model for the dynamic stall equations [1 = Leishman/Beddoes, 2 = Gonzalez, 3 = Minnema] [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    LOGICAL  :: Flookup      !< Use table lookup for f' and f''  [-]
    REAL(ReKi)  :: a_s      !< speed of sound [m/s]
    LOGICAL  :: SumPrint      !< Whether to print summary file (primarially in in UA) [-]
  END TYPE FVW_InitInputType
! =======================
! =========  FVW_InputFile  =======
  TYPE, PUBLIC :: FVW_InputFile
    INTEGER(IntKi)  :: CircSolvMethod      !< Method to determine the circulation [-]
    CHARACTER(1024)  :: CirculationFile      !< Prescribed circulation file [-]
    INTEGER(IntKi)  :: CircSolvMaxIter      !< Maximum number of iterations for circulation solving [-]
    REAL(ReKi)  :: CircSolvConvCrit      !< Convergence criterion for circulation solving [-]
    REAL(ReKi)  :: CircSolvRelaxation      !< Relaxation factor for circulation solving [-]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1=RK4, 2=AB4, 3=ABM4, 5=Euler1, 7=Corrector/Predictor) [-]
    LOGICAL  :: FreeWake      !< Disable roll up, wake convects with wind only (flag) [-]
    REAL(ReKi)  :: FreeWakeStart      !< Time when wake starts convecting (rolling up) [s]
    REAL(ReKi)  :: FullCircStart      !< Time when the circulation is full [s]
    REAL(DbKi)  :: DTfvw      !< Time interval for calculating wake induced velocities [s]
    INTEGER(IntKi)  :: CircSolvPolar      !< (0=Use AD polars, 1=2PiAlpha, 2=sin(2pialpha) [-]
    INTEGER(IntKi)  :: nNWPanels      !< Number of nw panels [-]
    INTEGER(IntKi)  :: nNWPanelsFree      !< Number of nw panels [-]
    INTEGER(IntKi)  :: nFWPanels      !< Number of fw panels [-]
    INTEGER(IntKi)  :: nFWPanelsFree      !< Number of fw panels that are free [-]
    LOGICAL  :: FWShedVorticity      !< Include shed vorticity in the far wake [-]
    INTEGER(IntKi)  :: DiffusionMethod      !< Diffusion method (None, CoreSpreading, PSE) [-]
    REAL(ReKi)  :: CoreSpreadEddyVisc      !< Eddy viscosity used in the core spreading method [-]
    INTEGER(IntKi)  :: RegDeterMethod      !< Regularization determinatino method (manual, automatic) [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: WakeRegMethod      !< Method for regularization (constant, stretching, age, etc.) [-]
    REAL(ReKi)  :: WakeRegParam      !< Factor used in the regularization  [-]
    REAL(ReKi)  :: WingRegParam      !< Factor used in the regularization  [-]
    INTEGER(IntKi)  :: ShearModel      !< Option for shear modelling [-]
    LOGICAL  :: TwrShadowOnWake      !< Include tower shadow effects on wake [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: VelocityMethod      !< Velocity calculation method for Full Wake and for LiftingLine [-]
    REAL(ReKi) , DIMENSION(1:2)  :: TreeBranchFactor      !< Factor used to determine if a point is far enough, for full wake and lifting line [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: PartPerSegment      !< Number of particles per segment, e.g. for tree method, for full wake and lifting line [-]
    INTEGER(IntKi)  :: WrVTK      !< Outputs VTK at each calcoutput call, even if main fst doesnt do it [-]
    INTEGER(IntKi)  :: VTKBlades      !< Outputs VTk for each blade 0=no blade, 1=Bld 1 [-]
    REAL(DbKi)  :: DTvtk      !< Requested timestep between VTK outputs (calculated from the VTK_fps read in) [s]
    INTEGER(IntKi)  :: VTKCoord      !< Switch for VTK outputs coordinate  system [-]
  END TYPE FVW_InputFile
! =======================
! =========  FVW_InitOutputType  =======
  TYPE, PUBLIC :: FVW_InitOutputType
    INTEGER(IntKi)  :: Dummy      !< Empty parameter to satisfy framework [-]
  END TYPE FVW_InitOutputType
! =======================
CONTAINS
 SUBROUTINE FVW_CopyGridOutType( SrcGridOutTypeData, DstGridOutTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(GridOutType), INTENT(IN) :: SrcGridOutTypeData
   TYPE(GridOutType), INTENT(INOUT) :: DstGridOutTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyGridOutType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstGridOutTypeData%name = SrcGridOutTypeData%name
    DstGridOutTypeData%type = SrcGridOutTypeData%type
    DstGridOutTypeData%tStart = SrcGridOutTypeData%tStart
    DstGridOutTypeData%tEnd = SrcGridOutTypeData%tEnd
    DstGridOutTypeData%DTout = SrcGridOutTypeData%DTout
    DstGridOutTypeData%xStart = SrcGridOutTypeData%xStart
    DstGridOutTypeData%yStart = SrcGridOutTypeData%yStart
    DstGridOutTypeData%zStart = SrcGridOutTypeData%zStart
    DstGridOutTypeData%xEnd = SrcGridOutTypeData%xEnd
    DstGridOutTypeData%yEnd = SrcGridOutTypeData%yEnd
    DstGridOutTypeData%zEnd = SrcGridOutTypeData%zEnd
    DstGridOutTypeData%nx = SrcGridOutTypeData%nx
    DstGridOutTypeData%ny = SrcGridOutTypeData%ny
    DstGridOutTypeData%nz = SrcGridOutTypeData%nz
IF (ALLOCATED(SrcGridOutTypeData%uGrid)) THEN
  i1_l = LBOUND(SrcGridOutTypeData%uGrid,1)
  i1_u = UBOUND(SrcGridOutTypeData%uGrid,1)
  i2_l = LBOUND(SrcGridOutTypeData%uGrid,2)
  i2_u = UBOUND(SrcGridOutTypeData%uGrid,2)
  i3_l = LBOUND(SrcGridOutTypeData%uGrid,3)
  i3_u = UBOUND(SrcGridOutTypeData%uGrid,3)
  i4_l = LBOUND(SrcGridOutTypeData%uGrid,4)
  i4_u = UBOUND(SrcGridOutTypeData%uGrid,4)
  IF (.NOT. ALLOCATED(DstGridOutTypeData%uGrid)) THEN 
    ALLOCATE(DstGridOutTypeData%uGrid(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGridOutTypeData%uGrid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGridOutTypeData%uGrid = SrcGridOutTypeData%uGrid
ENDIF
IF (ALLOCATED(SrcGridOutTypeData%omGrid)) THEN
  i1_l = LBOUND(SrcGridOutTypeData%omGrid,1)
  i1_u = UBOUND(SrcGridOutTypeData%omGrid,1)
  i2_l = LBOUND(SrcGridOutTypeData%omGrid,2)
  i2_u = UBOUND(SrcGridOutTypeData%omGrid,2)
  i3_l = LBOUND(SrcGridOutTypeData%omGrid,3)
  i3_u = UBOUND(SrcGridOutTypeData%omGrid,3)
  i4_l = LBOUND(SrcGridOutTypeData%omGrid,4)
  i4_u = UBOUND(SrcGridOutTypeData%omGrid,4)
  IF (.NOT. ALLOCATED(DstGridOutTypeData%omGrid)) THEN 
    ALLOCATE(DstGridOutTypeData%omGrid(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGridOutTypeData%omGrid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGridOutTypeData%omGrid = SrcGridOutTypeData%omGrid
ENDIF
    DstGridOutTypeData%tLastOutput = SrcGridOutTypeData%tLastOutput
 END SUBROUTINE FVW_CopyGridOutType

 SUBROUTINE FVW_DestroyGridOutType( GridOutTypeData, ErrStat, ErrMsg )
  TYPE(GridOutType), INTENT(INOUT) :: GridOutTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyGridOutType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(GridOutTypeData%uGrid)) THEN
  DEALLOCATE(GridOutTypeData%uGrid)
ENDIF
IF (ALLOCATED(GridOutTypeData%omGrid)) THEN
  DEALLOCATE(GridOutTypeData%omGrid)
ENDIF
 END SUBROUTINE FVW_DestroyGridOutType


subroutine FVW_PackGridOutType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(GridOutType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackGridOutType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! name
   call RegPack(Buf, InData%name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! type
   call RegPack(Buf, InData%type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! tStart
   call RegPack(Buf, InData%tStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! tEnd
   call RegPack(Buf, InData%tEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTout
   call RegPack(Buf, InData%DTout)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xStart
   call RegPack(Buf, InData%xStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! yStart
   call RegPack(Buf, InData%yStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zStart
   call RegPack(Buf, InData%zStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xEnd
   call RegPack(Buf, InData%xEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! yEnd
   call RegPack(Buf, InData%yEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zEnd
   call RegPack(Buf, InData%zEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nx
   call RegPack(Buf, InData%nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ny
   call RegPack(Buf, InData%ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nz
   call RegPack(Buf, InData%nz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! uGrid
   call RegPack(Buf, allocated(InData%uGrid))
   if (allocated(InData%uGrid)) then
      call RegPackBounds(Buf, 4, lbound(InData%uGrid), ubound(InData%uGrid))
      call RegPack(Buf, InData%uGrid)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! omGrid
   call RegPack(Buf, allocated(InData%omGrid))
   if (allocated(InData%omGrid)) then
      call RegPackBounds(Buf, 4, lbound(InData%omGrid), ubound(InData%omGrid))
      call RegPack(Buf, InData%omGrid)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! tLastOutput
   call RegPack(Buf, InData%tLastOutput)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackGridOutType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(GridOutType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackGridOutType'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! name
   call RegUnpack(Buf, OutData%name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! type
   call RegUnpack(Buf, OutData%type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! tStart
   call RegUnpack(Buf, OutData%tStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! tEnd
   call RegUnpack(Buf, OutData%tEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTout
   call RegUnpack(Buf, OutData%DTout)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xStart
   call RegUnpack(Buf, OutData%xStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! yStart
   call RegUnpack(Buf, OutData%yStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zStart
   call RegUnpack(Buf, OutData%zStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xEnd
   call RegUnpack(Buf, OutData%xEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! yEnd
   call RegUnpack(Buf, OutData%yEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zEnd
   call RegUnpack(Buf, OutData%zEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nx
   call RegUnpack(Buf, OutData%nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ny
   call RegUnpack(Buf, OutData%ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nz
   call RegUnpack(Buf, OutData%nz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! uGrid
   if (allocated(OutData%uGrid)) deallocate(OutData%uGrid)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%uGrid(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%uGrid.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%uGrid)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! omGrid
   if (allocated(OutData%omGrid)) deallocate(OutData%omGrid)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%omGrid(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%omGrid.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%omGrid)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! tLastOutput
   call RegUnpack(Buf, OutData%tLastOutput)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyT_Sgmt( SrcT_SgmtData, DstT_SgmtData, CtrlCode, ErrStat, ErrMsg )
   TYPE(T_Sgmt), INTENT(IN) :: SrcT_SgmtData
   TYPE(T_Sgmt), INTENT(INOUT) :: DstT_SgmtData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyT_Sgmt'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcT_SgmtData%Points)) THEN
  i1_l = LBOUND(SrcT_SgmtData%Points,1)
  i1_u = UBOUND(SrcT_SgmtData%Points,1)
  i2_l = LBOUND(SrcT_SgmtData%Points,2)
  i2_u = UBOUND(SrcT_SgmtData%Points,2)
  IF (.NOT. ALLOCATED(DstT_SgmtData%Points)) THEN 
    ALLOCATE(DstT_SgmtData%Points(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_SgmtData%Points.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_SgmtData%Points = SrcT_SgmtData%Points
ENDIF
IF (ALLOCATED(SrcT_SgmtData%Connct)) THEN
  i1_l = LBOUND(SrcT_SgmtData%Connct,1)
  i1_u = UBOUND(SrcT_SgmtData%Connct,1)
  i2_l = LBOUND(SrcT_SgmtData%Connct,2)
  i2_u = UBOUND(SrcT_SgmtData%Connct,2)
  IF (.NOT. ALLOCATED(DstT_SgmtData%Connct)) THEN 
    ALLOCATE(DstT_SgmtData%Connct(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_SgmtData%Connct.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_SgmtData%Connct = SrcT_SgmtData%Connct
ENDIF
IF (ALLOCATED(SrcT_SgmtData%Gamma)) THEN
  i1_l = LBOUND(SrcT_SgmtData%Gamma,1)
  i1_u = UBOUND(SrcT_SgmtData%Gamma,1)
  IF (.NOT. ALLOCATED(DstT_SgmtData%Gamma)) THEN 
    ALLOCATE(DstT_SgmtData%Gamma(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_SgmtData%Gamma.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_SgmtData%Gamma = SrcT_SgmtData%Gamma
ENDIF
IF (ALLOCATED(SrcT_SgmtData%Epsilon)) THEN
  i1_l = LBOUND(SrcT_SgmtData%Epsilon,1)
  i1_u = UBOUND(SrcT_SgmtData%Epsilon,1)
  IF (.NOT. ALLOCATED(DstT_SgmtData%Epsilon)) THEN 
    ALLOCATE(DstT_SgmtData%Epsilon(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_SgmtData%Epsilon.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_SgmtData%Epsilon = SrcT_SgmtData%Epsilon
ENDIF
    DstT_SgmtData%RegFunction = SrcT_SgmtData%RegFunction
    DstT_SgmtData%nAct = SrcT_SgmtData%nAct
    DstT_SgmtData%nActP = SrcT_SgmtData%nActP
 END SUBROUTINE FVW_CopyT_Sgmt

 SUBROUTINE FVW_DestroyT_Sgmt( T_SgmtData, ErrStat, ErrMsg )
  TYPE(T_Sgmt), INTENT(INOUT) :: T_SgmtData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyT_Sgmt'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(T_SgmtData%Points)) THEN
  DEALLOCATE(T_SgmtData%Points)
ENDIF
IF (ALLOCATED(T_SgmtData%Connct)) THEN
  DEALLOCATE(T_SgmtData%Connct)
ENDIF
IF (ALLOCATED(T_SgmtData%Gamma)) THEN
  DEALLOCATE(T_SgmtData%Gamma)
ENDIF
IF (ALLOCATED(T_SgmtData%Epsilon)) THEN
  DEALLOCATE(T_SgmtData%Epsilon)
ENDIF
 END SUBROUTINE FVW_DestroyT_Sgmt


subroutine FVW_PackT_Sgmt(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(T_Sgmt), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackT_Sgmt'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Points
   call RegPack(Buf, allocated(InData%Points))
   if (allocated(InData%Points)) then
      call RegPackBounds(Buf, 2, lbound(InData%Points), ubound(InData%Points))
      call RegPack(Buf, InData%Points)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Connct
   call RegPack(Buf, allocated(InData%Connct))
   if (allocated(InData%Connct)) then
      call RegPackBounds(Buf, 2, lbound(InData%Connct), ubound(InData%Connct))
      call RegPack(Buf, InData%Connct)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gamma
   call RegPack(Buf, allocated(InData%Gamma))
   if (allocated(InData%Gamma)) then
      call RegPackBounds(Buf, 1, lbound(InData%Gamma), ubound(InData%Gamma))
      call RegPack(Buf, InData%Gamma)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Epsilon
   call RegPack(Buf, allocated(InData%Epsilon))
   if (allocated(InData%Epsilon)) then
      call RegPackBounds(Buf, 1, lbound(InData%Epsilon), ubound(InData%Epsilon))
      call RegPack(Buf, InData%Epsilon)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegFunction
   call RegPack(Buf, InData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAct
   call RegPack(Buf, InData%nAct)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nActP
   call RegPack(Buf, InData%nActP)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackT_Sgmt(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(T_Sgmt), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackT_Sgmt'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Points
   if (allocated(OutData%Points)) deallocate(OutData%Points)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Points(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Points.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Points)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Connct
   if (allocated(OutData%Connct)) deallocate(OutData%Connct)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Connct(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Connct.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Connct)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Gamma
   if (allocated(OutData%Gamma)) deallocate(OutData%Gamma)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Gamma(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Gamma)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Epsilon
   if (allocated(OutData%Epsilon)) deallocate(OutData%Epsilon)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Epsilon(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Epsilon.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Epsilon)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RegFunction
   call RegUnpack(Buf, OutData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAct
   call RegUnpack(Buf, OutData%nAct)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nActP
   call RegUnpack(Buf, OutData%nActP)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyT_Part( SrcT_PartData, DstT_PartData, CtrlCode, ErrStat, ErrMsg )
   TYPE(T_Part), INTENT(IN) :: SrcT_PartData
   TYPE(T_Part), INTENT(INOUT) :: DstT_PartData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyT_Part'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcT_PartData%P)) THEN
  i1_l = LBOUND(SrcT_PartData%P,1)
  i1_u = UBOUND(SrcT_PartData%P,1)
  i2_l = LBOUND(SrcT_PartData%P,2)
  i2_u = UBOUND(SrcT_PartData%P,2)
  IF (.NOT. ALLOCATED(DstT_PartData%P)) THEN 
    ALLOCATE(DstT_PartData%P(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_PartData%P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_PartData%P = SrcT_PartData%P
ENDIF
IF (ALLOCATED(SrcT_PartData%Alpha)) THEN
  i1_l = LBOUND(SrcT_PartData%Alpha,1)
  i1_u = UBOUND(SrcT_PartData%Alpha,1)
  i2_l = LBOUND(SrcT_PartData%Alpha,2)
  i2_u = UBOUND(SrcT_PartData%Alpha,2)
  IF (.NOT. ALLOCATED(DstT_PartData%Alpha)) THEN 
    ALLOCATE(DstT_PartData%Alpha(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_PartData%Alpha.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_PartData%Alpha = SrcT_PartData%Alpha
ENDIF
IF (ALLOCATED(SrcT_PartData%RegParam)) THEN
  i1_l = LBOUND(SrcT_PartData%RegParam,1)
  i1_u = UBOUND(SrcT_PartData%RegParam,1)
  IF (.NOT. ALLOCATED(DstT_PartData%RegParam)) THEN 
    ALLOCATE(DstT_PartData%RegParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstT_PartData%RegParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstT_PartData%RegParam = SrcT_PartData%RegParam
ENDIF
    DstT_PartData%RegFunction = SrcT_PartData%RegFunction
    DstT_PartData%nAct = SrcT_PartData%nAct
 END SUBROUTINE FVW_CopyT_Part

 SUBROUTINE FVW_DestroyT_Part( T_PartData, ErrStat, ErrMsg )
  TYPE(T_Part), INTENT(INOUT) :: T_PartData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyT_Part'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(T_PartData%P)) THEN
  DEALLOCATE(T_PartData%P)
ENDIF
IF (ALLOCATED(T_PartData%Alpha)) THEN
  DEALLOCATE(T_PartData%Alpha)
ENDIF
IF (ALLOCATED(T_PartData%RegParam)) THEN
  DEALLOCATE(T_PartData%RegParam)
ENDIF
 END SUBROUTINE FVW_DestroyT_Part


subroutine FVW_PackT_Part(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(T_Part), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackT_Part'
   if (Buf%ErrStat >= AbortErrLev) return
   ! P
   call RegPack(Buf, allocated(InData%P))
   if (allocated(InData%P)) then
      call RegPackBounds(Buf, 2, lbound(InData%P), ubound(InData%P))
      call RegPack(Buf, InData%P)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Alpha
   call RegPack(Buf, allocated(InData%Alpha))
   if (allocated(InData%Alpha)) then
      call RegPackBounds(Buf, 2, lbound(InData%Alpha), ubound(InData%Alpha))
      call RegPack(Buf, InData%Alpha)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegParam
   call RegPack(Buf, allocated(InData%RegParam))
   if (allocated(InData%RegParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%RegParam), ubound(InData%RegParam))
      call RegPack(Buf, InData%RegParam)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegFunction
   call RegPack(Buf, InData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAct
   call RegPack(Buf, InData%nAct)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackT_Part(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(T_Part), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackT_Part'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! P
   if (allocated(OutData%P)) deallocate(OutData%P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%P(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%P)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Alpha
   if (allocated(OutData%Alpha)) deallocate(OutData%Alpha)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Alpha(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Alpha.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Alpha)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RegParam
   if (allocated(OutData%RegParam)) deallocate(OutData%RegParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RegParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RegParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RegParam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RegFunction
   call RegUnpack(Buf, OutData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAct
   call RegUnpack(Buf, OutData%nAct)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyWng_ParameterType( SrcWng_ParameterTypeData, DstWng_ParameterTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_ParameterType), INTENT(IN) :: SrcWng_ParameterTypeData
   TYPE(Wng_ParameterType), INTENT(INOUT) :: DstWng_ParameterTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_ParameterType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_ParameterTypeData%chord_LL)) THEN
  i1_l = LBOUND(SrcWng_ParameterTypeData%chord_LL,1)
  i1_u = UBOUND(SrcWng_ParameterTypeData%chord_LL,1)
  IF (.NOT. ALLOCATED(DstWng_ParameterTypeData%chord_LL)) THEN 
    ALLOCATE(DstWng_ParameterTypeData%chord_LL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ParameterTypeData%chord_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ParameterTypeData%chord_LL = SrcWng_ParameterTypeData%chord_LL
ENDIF
IF (ALLOCATED(SrcWng_ParameterTypeData%chord_CP)) THEN
  i1_l = LBOUND(SrcWng_ParameterTypeData%chord_CP,1)
  i1_u = UBOUND(SrcWng_ParameterTypeData%chord_CP,1)
  IF (.NOT. ALLOCATED(DstWng_ParameterTypeData%chord_CP)) THEN 
    ALLOCATE(DstWng_ParameterTypeData%chord_CP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ParameterTypeData%chord_CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ParameterTypeData%chord_CP = SrcWng_ParameterTypeData%chord_CP
ENDIF
IF (ALLOCATED(SrcWng_ParameterTypeData%s_LL)) THEN
  i1_l = LBOUND(SrcWng_ParameterTypeData%s_LL,1)
  i1_u = UBOUND(SrcWng_ParameterTypeData%s_LL,1)
  IF (.NOT. ALLOCATED(DstWng_ParameterTypeData%s_LL)) THEN 
    ALLOCATE(DstWng_ParameterTypeData%s_LL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ParameterTypeData%s_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ParameterTypeData%s_LL = SrcWng_ParameterTypeData%s_LL
ENDIF
IF (ALLOCATED(SrcWng_ParameterTypeData%s_CP)) THEN
  i1_l = LBOUND(SrcWng_ParameterTypeData%s_CP,1)
  i1_u = UBOUND(SrcWng_ParameterTypeData%s_CP,1)
  IF (.NOT. ALLOCATED(DstWng_ParameterTypeData%s_CP)) THEN 
    ALLOCATE(DstWng_ParameterTypeData%s_CP(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ParameterTypeData%s_CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ParameterTypeData%s_CP = SrcWng_ParameterTypeData%s_CP
ENDIF
    DstWng_ParameterTypeData%iRotor = SrcWng_ParameterTypeData%iRotor
IF (ALLOCATED(SrcWng_ParameterTypeData%AFindx)) THEN
  i1_l = LBOUND(SrcWng_ParameterTypeData%AFindx,1)
  i1_u = UBOUND(SrcWng_ParameterTypeData%AFindx,1)
  i2_l = LBOUND(SrcWng_ParameterTypeData%AFindx,2)
  i2_u = UBOUND(SrcWng_ParameterTypeData%AFindx,2)
  IF (.NOT. ALLOCATED(DstWng_ParameterTypeData%AFindx)) THEN 
    ALLOCATE(DstWng_ParameterTypeData%AFindx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ParameterTypeData%AFindx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ParameterTypeData%AFindx = SrcWng_ParameterTypeData%AFindx
ENDIF
    DstWng_ParameterTypeData%nSpan = SrcWng_ParameterTypeData%nSpan
IF (ALLOCATED(SrcWng_ParameterTypeData%PrescribedCirculation)) THEN
  i1_l = LBOUND(SrcWng_ParameterTypeData%PrescribedCirculation,1)
  i1_u = UBOUND(SrcWng_ParameterTypeData%PrescribedCirculation,1)
  IF (.NOT. ALLOCATED(DstWng_ParameterTypeData%PrescribedCirculation)) THEN 
    ALLOCATE(DstWng_ParameterTypeData%PrescribedCirculation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ParameterTypeData%PrescribedCirculation.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ParameterTypeData%PrescribedCirculation = SrcWng_ParameterTypeData%PrescribedCirculation
ENDIF
 END SUBROUTINE FVW_CopyWng_ParameterType

 SUBROUTINE FVW_DestroyWng_ParameterType( Wng_ParameterTypeData, ErrStat, ErrMsg )
  TYPE(Wng_ParameterType), INTENT(INOUT) :: Wng_ParameterTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_ParameterType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_ParameterTypeData%chord_LL)) THEN
  DEALLOCATE(Wng_ParameterTypeData%chord_LL)
ENDIF
IF (ALLOCATED(Wng_ParameterTypeData%chord_CP)) THEN
  DEALLOCATE(Wng_ParameterTypeData%chord_CP)
ENDIF
IF (ALLOCATED(Wng_ParameterTypeData%s_LL)) THEN
  DEALLOCATE(Wng_ParameterTypeData%s_LL)
ENDIF
IF (ALLOCATED(Wng_ParameterTypeData%s_CP)) THEN
  DEALLOCATE(Wng_ParameterTypeData%s_CP)
ENDIF
IF (ALLOCATED(Wng_ParameterTypeData%AFindx)) THEN
  DEALLOCATE(Wng_ParameterTypeData%AFindx)
ENDIF
IF (ALLOCATED(Wng_ParameterTypeData%PrescribedCirculation)) THEN
  DEALLOCATE(Wng_ParameterTypeData%PrescribedCirculation)
ENDIF
 END SUBROUTINE FVW_DestroyWng_ParameterType


subroutine FVW_PackWng_ParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_ParameterType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! chord_LL
   call RegPack(Buf, allocated(InData%chord_LL))
   if (allocated(InData%chord_LL)) then
      call RegPackBounds(Buf, 1, lbound(InData%chord_LL), ubound(InData%chord_LL))
      call RegPack(Buf, InData%chord_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! chord_CP
   call RegPack(Buf, allocated(InData%chord_CP))
   if (allocated(InData%chord_CP)) then
      call RegPackBounds(Buf, 1, lbound(InData%chord_CP), ubound(InData%chord_CP))
      call RegPack(Buf, InData%chord_CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! s_LL
   call RegPack(Buf, allocated(InData%s_LL))
   if (allocated(InData%s_LL)) then
      call RegPackBounds(Buf, 1, lbound(InData%s_LL), ubound(InData%s_LL))
      call RegPack(Buf, InData%s_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! s_CP
   call RegPack(Buf, allocated(InData%s_CP))
   if (allocated(InData%s_CP)) then
      call RegPackBounds(Buf, 1, lbound(InData%s_CP), ubound(InData%s_CP))
      call RegPack(Buf, InData%s_CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! iRotor
   call RegPack(Buf, InData%iRotor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFindx
   call RegPack(Buf, allocated(InData%AFindx))
   if (allocated(InData%AFindx)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFindx), ubound(InData%AFindx))
      call RegPack(Buf, InData%AFindx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nSpan
   call RegPack(Buf, InData%nSpan)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedCirculation
   call RegPack(Buf, allocated(InData%PrescribedCirculation))
   if (allocated(InData%PrescribedCirculation)) then
      call RegPackBounds(Buf, 1, lbound(InData%PrescribedCirculation), ubound(InData%PrescribedCirculation))
      call RegPack(Buf, InData%PrescribedCirculation)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_ParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_ParameterType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! chord_LL
   if (allocated(OutData%chord_LL)) deallocate(OutData%chord_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chord_LL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chord_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! chord_CP
   if (allocated(OutData%chord_CP)) deallocate(OutData%chord_CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chord_CP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord_CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chord_CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! s_LL
   if (allocated(OutData%s_LL)) deallocate(OutData%s_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%s_LL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%s_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%s_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! s_CP
   if (allocated(OutData%s_CP)) deallocate(OutData%s_CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%s_CP(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%s_CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%s_CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! iRotor
   call RegUnpack(Buf, OutData%iRotor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFindx
   if (allocated(OutData%AFindx)) deallocate(OutData%AFindx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFindx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFindx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFindx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nSpan
   call RegUnpack(Buf, OutData%nSpan)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PrescribedCirculation
   if (allocated(OutData%PrescribedCirculation)) deallocate(OutData%PrescribedCirculation)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PrescribedCirculation(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrescribedCirculation.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PrescribedCirculation)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(FVW_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%nRotors = SrcParamData%nRotors
    DstParamData%nWings = SrcParamData%nWings
IF (ALLOCATED(SrcParamData%W)) THEN
  i1_l = LBOUND(SrcParamData%W,1)
  i1_u = UBOUND(SrcParamData%W,1)
  IF (.NOT. ALLOCATED(DstParamData%W)) THEN 
    ALLOCATE(DstParamData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%W,1), UBOUND(SrcParamData%W,1)
      CALL FVW_Copywng_parametertype( SrcParamData%W(i1), DstParamData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%Bld2Wings)) THEN
  i1_l = LBOUND(SrcParamData%Bld2Wings,1)
  i1_u = UBOUND(SrcParamData%Bld2Wings,1)
  i2_l = LBOUND(SrcParamData%Bld2Wings,2)
  i2_u = UBOUND(SrcParamData%Bld2Wings,2)
  IF (.NOT. ALLOCATED(DstParamData%Bld2Wings)) THEN 
    ALLOCATE(DstParamData%Bld2Wings(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Bld2Wings.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Bld2Wings = SrcParamData%Bld2Wings
ENDIF
    DstParamData%iNWStart = SrcParamData%iNWStart
    DstParamData%nNWMax = SrcParamData%nNWMax
    DstParamData%nNWFree = SrcParamData%nNWFree
    DstParamData%nFWMax = SrcParamData%nFWMax
    DstParamData%nFWFree = SrcParamData%nFWFree
    DstParamData%FWShedVorticity = SrcParamData%FWShedVorticity
    DstParamData%IntMethod = SrcParamData%IntMethod
    DstParamData%FreeWakeStart = SrcParamData%FreeWakeStart
    DstParamData%FullCircStart = SrcParamData%FullCircStart
    DstParamData%CircSolvMethod = SrcParamData%CircSolvMethod
    DstParamData%CircSolvMaxIter = SrcParamData%CircSolvMaxIter
    DstParamData%CircSolvConvCrit = SrcParamData%CircSolvConvCrit
    DstParamData%CircSolvRelaxation = SrcParamData%CircSolvRelaxation
    DstParamData%CircSolvPolar = SrcParamData%CircSolvPolar
    DstParamData%DiffusionMethod = SrcParamData%DiffusionMethod
    DstParamData%CoreSpreadEddyVisc = SrcParamData%CoreSpreadEddyVisc
    DstParamData%RegDeterMethod = SrcParamData%RegDeterMethod
    DstParamData%RegFunction = SrcParamData%RegFunction
    DstParamData%WakeRegMethod = SrcParamData%WakeRegMethod
    DstParamData%WakeRegParam = SrcParamData%WakeRegParam
    DstParamData%WingRegParam = SrcParamData%WingRegParam
    DstParamData%ShearModel = SrcParamData%ShearModel
    DstParamData%TwrShadowOnWake = SrcParamData%TwrShadowOnWake
    DstParamData%VelocityMethod = SrcParamData%VelocityMethod
    DstParamData%TreeBranchFactor = SrcParamData%TreeBranchFactor
    DstParamData%PartPerSegment = SrcParamData%PartPerSegment
    DstParamData%DTaero = SrcParamData%DTaero
    DstParamData%DTfvw = SrcParamData%DTfvw
    DstParamData%KinVisc = SrcParamData%KinVisc
    DstParamData%MHK = SrcParamData%MHK
    DstParamData%WtrDpth = SrcParamData%WtrDpth
    DstParamData%WrVTK = SrcParamData%WrVTK
    DstParamData%VTKBlades = SrcParamData%VTKBlades
    DstParamData%DTvtk = SrcParamData%DTvtk
    DstParamData%VTKCoord = SrcParamData%VTKCoord
    DstParamData%RootName = SrcParamData%RootName
    DstParamData%VTK_OutFileRoot = SrcParamData%VTK_OutFileRoot
    DstParamData%VTK_OutFileBase = SrcParamData%VTK_OutFileBase
    DstParamData%nGridOut = SrcParamData%nGridOut
    DstParamData%InductionAtCP = SrcParamData%InductionAtCP
    DstParamData%WakeAtTE = SrcParamData%WakeAtTE
    DstParamData%DStallOnWake = SrcParamData%DStallOnWake
    DstParamData%Induction = SrcParamData%Induction
    DstParamData%kFrozenNWStart = SrcParamData%kFrozenNWStart
    DstParamData%kFrozenNWEnd = SrcParamData%kFrozenNWEnd
 END SUBROUTINE FVW_CopyParam

 SUBROUTINE FVW_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FVW_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%W)) THEN
DO i1 = LBOUND(ParamData%W,1), UBOUND(ParamData%W,1)
  CALL FVW_DestroyWng_ParameterType( ParamData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%W)
ENDIF
IF (ALLOCATED(ParamData%Bld2Wings)) THEN
  DEALLOCATE(ParamData%Bld2Wings)
ENDIF
 END SUBROUTINE FVW_DestroyParam


subroutine FVW_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackParam'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! nRotors
   call RegPack(Buf, InData%nRotors)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nWings
   call RegPack(Buf, InData%nWings)
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_ParameterType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Bld2Wings
   call RegPack(Buf, allocated(InData%Bld2Wings))
   if (allocated(InData%Bld2Wings)) then
      call RegPackBounds(Buf, 2, lbound(InData%Bld2Wings), ubound(InData%Bld2Wings))
      call RegPack(Buf, InData%Bld2Wings)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! iNWStart
   call RegPack(Buf, InData%iNWStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWMax
   call RegPack(Buf, InData%nNWMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWFree
   call RegPack(Buf, InData%nNWFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWMax
   call RegPack(Buf, InData%nFWMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWFree
   call RegPack(Buf, InData%nFWFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FWShedVorticity
   call RegPack(Buf, InData%FWShedVorticity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IntMethod
   call RegPack(Buf, InData%IntMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeWakeStart
   call RegPack(Buf, InData%FreeWakeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FullCircStart
   call RegPack(Buf, InData%FullCircStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvMethod
   call RegPack(Buf, InData%CircSolvMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvMaxIter
   call RegPack(Buf, InData%CircSolvMaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvConvCrit
   call RegPack(Buf, InData%CircSolvConvCrit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvRelaxation
   call RegPack(Buf, InData%CircSolvRelaxation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvPolar
   call RegPack(Buf, InData%CircSolvPolar)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffusionMethod
   call RegPack(Buf, InData%DiffusionMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CoreSpreadEddyVisc
   call RegPack(Buf, InData%CoreSpreadEddyVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegDeterMethod
   call RegPack(Buf, InData%RegDeterMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegFunction
   call RegPack(Buf, InData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegMethod
   call RegPack(Buf, InData%WakeRegMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegParam
   call RegPack(Buf, InData%WakeRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WingRegParam
   call RegPack(Buf, InData%WingRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShearModel
   call RegPack(Buf, InData%ShearModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadowOnWake
   call RegPack(Buf, InData%TwrShadowOnWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelocityMethod
   call RegPack(Buf, InData%VelocityMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TreeBranchFactor
   call RegPack(Buf, InData%TreeBranchFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PartPerSegment
   call RegPack(Buf, InData%PartPerSegment)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTaero
   call RegPack(Buf, InData%DTaero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTfvw
   call RegPack(Buf, InData%DTfvw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegPack(Buf, InData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrVTK
   call RegPack(Buf, InData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKBlades
   call RegPack(Buf, InData%VTKBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTvtk
   call RegPack(Buf, InData%DTvtk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKCoord
   call RegPack(Buf, InData%VTKCoord)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_OutFileRoot
   call RegPack(Buf, InData%VTK_OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_OutFileBase
   call RegPack(Buf, InData%VTK_OutFileBase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nGridOut
   call RegPack(Buf, InData%nGridOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InductionAtCP
   call RegPack(Buf, InData%InductionAtCP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeAtTE
   call RegPack(Buf, InData%WakeAtTE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DStallOnWake
   call RegPack(Buf, InData%DStallOnWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Induction
   call RegPack(Buf, InData%Induction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! kFrozenNWStart
   call RegPack(Buf, InData%kFrozenNWStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! kFrozenNWEnd
   call RegPack(Buf, InData%kFrozenNWEnd)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackParam'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! nRotors
   call RegUnpack(Buf, OutData%nRotors)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nWings
   call RegUnpack(Buf, OutData%nWings)
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_ParameterType(Buf, OutData%W(i1)) ! W 
      end do
   end if
   ! Bld2Wings
   if (allocated(OutData%Bld2Wings)) deallocate(OutData%Bld2Wings)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Bld2Wings(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bld2Wings.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Bld2Wings)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! iNWStart
   call RegUnpack(Buf, OutData%iNWStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWMax
   call RegUnpack(Buf, OutData%nNWMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWFree
   call RegUnpack(Buf, OutData%nNWFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWMax
   call RegUnpack(Buf, OutData%nFWMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWFree
   call RegUnpack(Buf, OutData%nFWFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FWShedVorticity
   call RegUnpack(Buf, OutData%FWShedVorticity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IntMethod
   call RegUnpack(Buf, OutData%IntMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeWakeStart
   call RegUnpack(Buf, OutData%FreeWakeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FullCircStart
   call RegUnpack(Buf, OutData%FullCircStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvMethod
   call RegUnpack(Buf, OutData%CircSolvMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvMaxIter
   call RegUnpack(Buf, OutData%CircSolvMaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvConvCrit
   call RegUnpack(Buf, OutData%CircSolvConvCrit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvRelaxation
   call RegUnpack(Buf, OutData%CircSolvRelaxation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvPolar
   call RegUnpack(Buf, OutData%CircSolvPolar)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffusionMethod
   call RegUnpack(Buf, OutData%DiffusionMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CoreSpreadEddyVisc
   call RegUnpack(Buf, OutData%CoreSpreadEddyVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegDeterMethod
   call RegUnpack(Buf, OutData%RegDeterMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegFunction
   call RegUnpack(Buf, OutData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegMethod
   call RegUnpack(Buf, OutData%WakeRegMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegParam
   call RegUnpack(Buf, OutData%WakeRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WingRegParam
   call RegUnpack(Buf, OutData%WingRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShearModel
   call RegUnpack(Buf, OutData%ShearModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadowOnWake
   call RegUnpack(Buf, OutData%TwrShadowOnWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelocityMethod
   call RegUnpack(Buf, OutData%VelocityMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TreeBranchFactor
   call RegUnpack(Buf, OutData%TreeBranchFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PartPerSegment
   call RegUnpack(Buf, OutData%PartPerSegment)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTaero
   call RegUnpack(Buf, OutData%DTaero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTfvw
   call RegUnpack(Buf, OutData%DTfvw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrVTK
   call RegUnpack(Buf, OutData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKBlades
   call RegUnpack(Buf, OutData%VTKBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTvtk
   call RegUnpack(Buf, OutData%DTvtk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKCoord
   call RegUnpack(Buf, OutData%VTKCoord)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_OutFileRoot
   call RegUnpack(Buf, OutData%VTK_OutFileRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTK_OutFileBase
   call RegUnpack(Buf, OutData%VTK_OutFileBase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nGridOut
   call RegUnpack(Buf, OutData%nGridOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InductionAtCP
   call RegUnpack(Buf, OutData%InductionAtCP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeAtTE
   call RegUnpack(Buf, OutData%WakeAtTE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DStallOnWake
   call RegUnpack(Buf, OutData%DStallOnWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Induction
   call RegUnpack(Buf, OutData%Induction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! kFrozenNWStart
   call RegUnpack(Buf, OutData%kFrozenNWStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! kFrozenNWEnd
   call RegUnpack(Buf, OutData%kFrozenNWEnd)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyWng_ContinuousStateType( SrcWng_ContinuousStateTypeData, DstWng_ContinuousStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_ContinuousStateType), INTENT(IN) :: SrcWng_ContinuousStateTypeData
   TYPE(Wng_ContinuousStateType), INTENT(INOUT) :: DstWng_ContinuousStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_ContinuousStateType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_ContinuousStateTypeData%Gamma_NW)) THEN
  i1_l = LBOUND(SrcWng_ContinuousStateTypeData%Gamma_NW,1)
  i1_u = UBOUND(SrcWng_ContinuousStateTypeData%Gamma_NW,1)
  i2_l = LBOUND(SrcWng_ContinuousStateTypeData%Gamma_NW,2)
  i2_u = UBOUND(SrcWng_ContinuousStateTypeData%Gamma_NW,2)
  IF (.NOT. ALLOCATED(DstWng_ContinuousStateTypeData%Gamma_NW)) THEN 
    ALLOCATE(DstWng_ContinuousStateTypeData%Gamma_NW(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ContinuousStateTypeData%Gamma_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ContinuousStateTypeData%Gamma_NW = SrcWng_ContinuousStateTypeData%Gamma_NW
ENDIF
IF (ALLOCATED(SrcWng_ContinuousStateTypeData%Gamma_FW)) THEN
  i1_l = LBOUND(SrcWng_ContinuousStateTypeData%Gamma_FW,1)
  i1_u = UBOUND(SrcWng_ContinuousStateTypeData%Gamma_FW,1)
  i2_l = LBOUND(SrcWng_ContinuousStateTypeData%Gamma_FW,2)
  i2_u = UBOUND(SrcWng_ContinuousStateTypeData%Gamma_FW,2)
  IF (.NOT. ALLOCATED(DstWng_ContinuousStateTypeData%Gamma_FW)) THEN 
    ALLOCATE(DstWng_ContinuousStateTypeData%Gamma_FW(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ContinuousStateTypeData%Gamma_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ContinuousStateTypeData%Gamma_FW = SrcWng_ContinuousStateTypeData%Gamma_FW
ENDIF
IF (ALLOCATED(SrcWng_ContinuousStateTypeData%Eps_NW)) THEN
  i1_l = LBOUND(SrcWng_ContinuousStateTypeData%Eps_NW,1)
  i1_u = UBOUND(SrcWng_ContinuousStateTypeData%Eps_NW,1)
  i2_l = LBOUND(SrcWng_ContinuousStateTypeData%Eps_NW,2)
  i2_u = UBOUND(SrcWng_ContinuousStateTypeData%Eps_NW,2)
  i3_l = LBOUND(SrcWng_ContinuousStateTypeData%Eps_NW,3)
  i3_u = UBOUND(SrcWng_ContinuousStateTypeData%Eps_NW,3)
  IF (.NOT. ALLOCATED(DstWng_ContinuousStateTypeData%Eps_NW)) THEN 
    ALLOCATE(DstWng_ContinuousStateTypeData%Eps_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ContinuousStateTypeData%Eps_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ContinuousStateTypeData%Eps_NW = SrcWng_ContinuousStateTypeData%Eps_NW
ENDIF
IF (ALLOCATED(SrcWng_ContinuousStateTypeData%Eps_FW)) THEN
  i1_l = LBOUND(SrcWng_ContinuousStateTypeData%Eps_FW,1)
  i1_u = UBOUND(SrcWng_ContinuousStateTypeData%Eps_FW,1)
  i2_l = LBOUND(SrcWng_ContinuousStateTypeData%Eps_FW,2)
  i2_u = UBOUND(SrcWng_ContinuousStateTypeData%Eps_FW,2)
  i3_l = LBOUND(SrcWng_ContinuousStateTypeData%Eps_FW,3)
  i3_u = UBOUND(SrcWng_ContinuousStateTypeData%Eps_FW,3)
  IF (.NOT. ALLOCATED(DstWng_ContinuousStateTypeData%Eps_FW)) THEN 
    ALLOCATE(DstWng_ContinuousStateTypeData%Eps_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ContinuousStateTypeData%Eps_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ContinuousStateTypeData%Eps_FW = SrcWng_ContinuousStateTypeData%Eps_FW
ENDIF
IF (ALLOCATED(SrcWng_ContinuousStateTypeData%r_NW)) THEN
  i1_l = LBOUND(SrcWng_ContinuousStateTypeData%r_NW,1)
  i1_u = UBOUND(SrcWng_ContinuousStateTypeData%r_NW,1)
  i2_l = LBOUND(SrcWng_ContinuousStateTypeData%r_NW,2)
  i2_u = UBOUND(SrcWng_ContinuousStateTypeData%r_NW,2)
  i3_l = LBOUND(SrcWng_ContinuousStateTypeData%r_NW,3)
  i3_u = UBOUND(SrcWng_ContinuousStateTypeData%r_NW,3)
  IF (.NOT. ALLOCATED(DstWng_ContinuousStateTypeData%r_NW)) THEN 
    ALLOCATE(DstWng_ContinuousStateTypeData%r_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ContinuousStateTypeData%r_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ContinuousStateTypeData%r_NW = SrcWng_ContinuousStateTypeData%r_NW
ENDIF
IF (ALLOCATED(SrcWng_ContinuousStateTypeData%r_FW)) THEN
  i1_l = LBOUND(SrcWng_ContinuousStateTypeData%r_FW,1)
  i1_u = UBOUND(SrcWng_ContinuousStateTypeData%r_FW,1)
  i2_l = LBOUND(SrcWng_ContinuousStateTypeData%r_FW,2)
  i2_u = UBOUND(SrcWng_ContinuousStateTypeData%r_FW,2)
  i3_l = LBOUND(SrcWng_ContinuousStateTypeData%r_FW,3)
  i3_u = UBOUND(SrcWng_ContinuousStateTypeData%r_FW,3)
  IF (.NOT. ALLOCATED(DstWng_ContinuousStateTypeData%r_FW)) THEN 
    ALLOCATE(DstWng_ContinuousStateTypeData%r_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ContinuousStateTypeData%r_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ContinuousStateTypeData%r_FW = SrcWng_ContinuousStateTypeData%r_FW
ENDIF
 END SUBROUTINE FVW_CopyWng_ContinuousStateType

 SUBROUTINE FVW_DestroyWng_ContinuousStateType( Wng_ContinuousStateTypeData, ErrStat, ErrMsg )
  TYPE(Wng_ContinuousStateType), INTENT(INOUT) :: Wng_ContinuousStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_ContinuousStateType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_ContinuousStateTypeData%Gamma_NW)) THEN
  DEALLOCATE(Wng_ContinuousStateTypeData%Gamma_NW)
ENDIF
IF (ALLOCATED(Wng_ContinuousStateTypeData%Gamma_FW)) THEN
  DEALLOCATE(Wng_ContinuousStateTypeData%Gamma_FW)
ENDIF
IF (ALLOCATED(Wng_ContinuousStateTypeData%Eps_NW)) THEN
  DEALLOCATE(Wng_ContinuousStateTypeData%Eps_NW)
ENDIF
IF (ALLOCATED(Wng_ContinuousStateTypeData%Eps_FW)) THEN
  DEALLOCATE(Wng_ContinuousStateTypeData%Eps_FW)
ENDIF
IF (ALLOCATED(Wng_ContinuousStateTypeData%r_NW)) THEN
  DEALLOCATE(Wng_ContinuousStateTypeData%r_NW)
ENDIF
IF (ALLOCATED(Wng_ContinuousStateTypeData%r_FW)) THEN
  DEALLOCATE(Wng_ContinuousStateTypeData%r_FW)
ENDIF
 END SUBROUTINE FVW_DestroyWng_ContinuousStateType


subroutine FVW_PackWng_ContinuousStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_ContinuousStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Gamma_NW
   call RegPack(Buf, allocated(InData%Gamma_NW))
   if (allocated(InData%Gamma_NW)) then
      call RegPackBounds(Buf, 2, lbound(InData%Gamma_NW), ubound(InData%Gamma_NW))
      call RegPack(Buf, InData%Gamma_NW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gamma_FW
   call RegPack(Buf, allocated(InData%Gamma_FW))
   if (allocated(InData%Gamma_FW)) then
      call RegPackBounds(Buf, 2, lbound(InData%Gamma_FW), ubound(InData%Gamma_FW))
      call RegPack(Buf, InData%Gamma_FW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Eps_NW
   call RegPack(Buf, allocated(InData%Eps_NW))
   if (allocated(InData%Eps_NW)) then
      call RegPackBounds(Buf, 3, lbound(InData%Eps_NW), ubound(InData%Eps_NW))
      call RegPack(Buf, InData%Eps_NW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Eps_FW
   call RegPack(Buf, allocated(InData%Eps_FW))
   if (allocated(InData%Eps_FW)) then
      call RegPackBounds(Buf, 3, lbound(InData%Eps_FW), ubound(InData%Eps_FW))
      call RegPack(Buf, InData%Eps_FW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_NW
   call RegPack(Buf, allocated(InData%r_NW))
   if (allocated(InData%r_NW)) then
      call RegPackBounds(Buf, 3, lbound(InData%r_NW), ubound(InData%r_NW))
      call RegPack(Buf, InData%r_NW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_FW
   call RegPack(Buf, allocated(InData%r_FW))
   if (allocated(InData%r_FW)) then
      call RegPackBounds(Buf, 3, lbound(InData%r_FW), ubound(InData%r_FW))
      call RegPack(Buf, InData%r_FW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_ContinuousStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_ContinuousStateType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Gamma_NW
   if (allocated(OutData%Gamma_NW)) deallocate(OutData%Gamma_NW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Gamma_NW(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_NW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Gamma_NW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Gamma_FW
   if (allocated(OutData%Gamma_FW)) deallocate(OutData%Gamma_FW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Gamma_FW(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_FW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Gamma_FW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Eps_NW
   if (allocated(OutData%Eps_NW)) deallocate(OutData%Eps_NW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Eps_NW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Eps_NW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Eps_NW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Eps_FW
   if (allocated(OutData%Eps_FW)) deallocate(OutData%Eps_FW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Eps_FW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Eps_FW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Eps_FW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! r_NW
   if (allocated(OutData%r_NW)) deallocate(OutData%r_NW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_NW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_NW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_NW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! r_FW
   if (allocated(OutData%r_FW)) deallocate(OutData%r_FW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_FW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_FW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_FW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%W)) THEN
  i1_l = LBOUND(SrcContStateData%W,1)
  i1_u = UBOUND(SrcContStateData%W,1)
  IF (.NOT. ALLOCATED(DstContStateData%W)) THEN 
    ALLOCATE(DstContStateData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%W,1), UBOUND(SrcContStateData%W,1)
      CALL FVW_Copywng_continuousstatetype( SrcContStateData%W(i1), DstContStateData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcContStateData%UA)) THEN
  i1_l = LBOUND(SrcContStateData%UA,1)
  i1_u = UBOUND(SrcContStateData%UA,1)
  IF (.NOT. ALLOCATED(DstContStateData%UA)) THEN 
    ALLOCATE(DstContStateData%UA(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%UA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%UA,1), UBOUND(SrcContStateData%UA,1)
      CALL UA_CopyContState( SrcContStateData%UA(i1), DstContStateData%UA(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FVW_CopyContState

 SUBROUTINE FVW_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%W)) THEN
DO i1 = LBOUND(ContStateData%W,1), UBOUND(ContStateData%W,1)
  CALL FVW_DestroyWng_ContinuousStateType( ContStateData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%W)
ENDIF
IF (ALLOCATED(ContStateData%UA)) THEN
DO i1 = LBOUND(ContStateData%UA,1), UBOUND(ContStateData%UA,1)
  CALL UA_DestroyContState( ContStateData%UA(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%UA)
ENDIF
 END SUBROUTINE FVW_DestroyContState


subroutine FVW_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_ContinuousStateType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA
   call RegPack(Buf, allocated(InData%UA))
   if (allocated(InData%UA)) then
      call RegPackBounds(Buf, 1, lbound(InData%UA), ubound(InData%UA))
      LB(1:1) = lbound(InData%UA)
      UB(1:1) = ubound(InData%UA)
      do i1 = LB(1), UB(1)
         call UA_PackContState(Buf, InData%UA(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_ContinuousStateType(Buf, OutData%W(i1)) ! W 
      end do
   end if
   ! UA
   if (allocated(OutData%UA)) deallocate(OutData%UA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UA(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call UA_UnpackContState(Buf, OutData%UA(i1)) ! UA 
      end do
   end if
end subroutine
 SUBROUTINE FVW_CopyWng_OutputType( SrcWng_OutputTypeData, DstWng_OutputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_OutputType), INTENT(IN) :: SrcWng_OutputTypeData
   TYPE(Wng_OutputType), INTENT(INOUT) :: DstWng_OutputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_OutputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_OutputTypeData%Vind)) THEN
  i1_l = LBOUND(SrcWng_OutputTypeData%Vind,1)
  i1_u = UBOUND(SrcWng_OutputTypeData%Vind,1)
  i2_l = LBOUND(SrcWng_OutputTypeData%Vind,2)
  i2_u = UBOUND(SrcWng_OutputTypeData%Vind,2)
  IF (.NOT. ALLOCATED(DstWng_OutputTypeData%Vind)) THEN 
    ALLOCATE(DstWng_OutputTypeData%Vind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_OutputTypeData%Vind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_OutputTypeData%Vind = SrcWng_OutputTypeData%Vind
ENDIF
 END SUBROUTINE FVW_CopyWng_OutputType

 SUBROUTINE FVW_DestroyWng_OutputType( Wng_OutputTypeData, ErrStat, ErrMsg )
  TYPE(Wng_OutputType), INTENT(INOUT) :: Wng_OutputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_OutputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_OutputTypeData%Vind)) THEN
  DEALLOCATE(Wng_OutputTypeData%Vind)
ENDIF
 END SUBROUTINE FVW_DestroyWng_OutputType


subroutine FVW_PackWng_OutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_OutputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Vind
   call RegPack(Buf, allocated(InData%Vind))
   if (allocated(InData%Vind)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vind), ubound(InData%Vind))
      call RegPack(Buf, InData%Vind)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_OutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_OutputType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Vind
   if (allocated(OutData%Vind)) deallocate(OutData%Vind)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vind(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vind)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(FVW_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%W)) THEN
  i1_l = LBOUND(SrcOutputData%W,1)
  i1_u = UBOUND(SrcOutputData%W,1)
  IF (.NOT. ALLOCATED(DstOutputData%W)) THEN 
    ALLOCATE(DstOutputData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%W,1), UBOUND(SrcOutputData%W,1)
      CALL FVW_Copywng_outputtype( SrcOutputData%W(i1), DstOutputData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FVW_CopyOutput

 SUBROUTINE FVW_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FVW_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%W)) THEN
DO i1 = LBOUND(OutputData%W,1), UBOUND(OutputData%W,1)
  CALL FVW_DestroyWng_OutputType( OutputData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%W)
ENDIF
 END SUBROUTINE FVW_DestroyOutput


subroutine FVW_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_OutputType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_OutputType(Buf, OutData%W(i1)) ! W 
      end do
   end if
end subroutine
 SUBROUTINE FVW_CopyWng_MiscVarType( SrcWng_MiscVarTypeData, DstWng_MiscVarTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_MiscVarType), INTENT(IN) :: SrcWng_MiscVarTypeData
   TYPE(Wng_MiscVarType), INTENT(INOUT) :: DstWng_MiscVarTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_MiscVarType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_MiscVarTypeData%LE)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%LE,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%LE,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%LE,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%LE,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%LE)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%LE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%LE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%LE = SrcWng_MiscVarTypeData%LE
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%TE)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%TE,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%TE,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%TE,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%TE,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%TE)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%TE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%TE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%TE = SrcWng_MiscVarTypeData%TE
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%r_LL)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%r_LL,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%r_LL,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%r_LL,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%r_LL,2)
  i3_l = LBOUND(SrcWng_MiscVarTypeData%r_LL,3)
  i3_u = UBOUND(SrcWng_MiscVarTypeData%r_LL,3)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%r_LL)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%r_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%r_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%r_LL = SrcWng_MiscVarTypeData%r_LL
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%CP)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%CP,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%CP,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%CP,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%CP,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%CP)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%CP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%CP = SrcWng_MiscVarTypeData%CP
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Tang)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Tang,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Tang,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Tang,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Tang,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Tang)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Tang(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Tang.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Tang = SrcWng_MiscVarTypeData%Tang
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Norm)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Norm,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Norm,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Norm,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Norm,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Norm)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Norm(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Norm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Norm = SrcWng_MiscVarTypeData%Norm
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Orth)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Orth,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Orth,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Orth,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Orth,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Orth)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Orth(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Orth.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Orth = SrcWng_MiscVarTypeData%Orth
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%dl)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%dl,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%dl,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%dl,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%dl,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%dl)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%dl(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%dl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%dl = SrcWng_MiscVarTypeData%dl
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Area)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Area,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Area,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Area)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Area(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Area.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Area = SrcWng_MiscVarTypeData%Area
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%diag_LL)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%diag_LL,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%diag_LL,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%diag_LL)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%diag_LL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%diag_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%diag_LL = SrcWng_MiscVarTypeData%diag_LL
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vind_CP)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vind_CP,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vind_CP,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vind_CP,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vind_CP,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vind_CP)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vind_CP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vind_CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vind_CP = SrcWng_MiscVarTypeData%Vind_CP
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vtot_CP)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vtot_CP,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vtot_CP,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vtot_CP,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vtot_CP,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vtot_CP)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vtot_CP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vtot_CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vtot_CP = SrcWng_MiscVarTypeData%Vtot_CP
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vstr_CP)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vstr_CP,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vstr_CP,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vstr_CP,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vstr_CP,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vstr_CP)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vstr_CP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vstr_CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vstr_CP = SrcWng_MiscVarTypeData%Vstr_CP
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vwnd_CP)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_CP,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_CP,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_CP,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_CP,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vwnd_CP)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vwnd_CP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vwnd_CP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vwnd_CP = SrcWng_MiscVarTypeData%Vwnd_CP
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vwnd_NW)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_NW,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_NW,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_NW,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_NW,2)
  i3_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_NW,3)
  i3_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_NW,3)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vwnd_NW)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vwnd_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vwnd_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vwnd_NW = SrcWng_MiscVarTypeData%Vwnd_NW
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vwnd_FW)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_FW,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_FW,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_FW,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_FW,2)
  i3_l = LBOUND(SrcWng_MiscVarTypeData%Vwnd_FW,3)
  i3_u = UBOUND(SrcWng_MiscVarTypeData%Vwnd_FW,3)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vwnd_FW)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vwnd_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vwnd_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vwnd_FW = SrcWng_MiscVarTypeData%Vwnd_FW
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vind_NW)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vind_NW,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vind_NW,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vind_NW,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vind_NW,2)
  i3_l = LBOUND(SrcWng_MiscVarTypeData%Vind_NW,3)
  i3_u = UBOUND(SrcWng_MiscVarTypeData%Vind_NW,3)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vind_NW)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vind_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vind_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vind_NW = SrcWng_MiscVarTypeData%Vind_NW
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vind_FW)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vind_FW,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vind_FW,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vind_FW,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vind_FW,2)
  i3_l = LBOUND(SrcWng_MiscVarTypeData%Vind_FW,3)
  i3_u = UBOUND(SrcWng_MiscVarTypeData%Vind_FW,3)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vind_FW)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vind_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vind_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vind_FW = SrcWng_MiscVarTypeData%Vind_FW
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%PitchAndTwist)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%PitchAndTwist,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%PitchAndTwist,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%PitchAndTwist)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%PitchAndTwist(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%PitchAndTwist.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%PitchAndTwist = SrcWng_MiscVarTypeData%PitchAndTwist
ENDIF
    DstWng_MiscVarTypeData%iTip = SrcWng_MiscVarTypeData%iTip
    DstWng_MiscVarTypeData%iRoot = SrcWng_MiscVarTypeData%iRoot
IF (ALLOCATED(SrcWng_MiscVarTypeData%alpha_LL)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%alpha_LL,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%alpha_LL,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%alpha_LL)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%alpha_LL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%alpha_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%alpha_LL = SrcWng_MiscVarTypeData%alpha_LL
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vreln_LL)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vreln_LL,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vreln_LL,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vreln_LL)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vreln_LL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vreln_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vreln_LL = SrcWng_MiscVarTypeData%Vreln_LL
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%u_UA)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%u_UA,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%u_UA,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%u_UA,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%u_UA,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%u_UA)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%u_UA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%u_UA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i2 = LBOUND(SrcWng_MiscVarTypeData%u_UA,2), UBOUND(SrcWng_MiscVarTypeData%u_UA,2)
    DO i1 = LBOUND(SrcWng_MiscVarTypeData%u_UA,1), UBOUND(SrcWng_MiscVarTypeData%u_UA,1)
      CALL UA_CopyInput( SrcWng_MiscVarTypeData%u_UA(i1,i2), DstWng_MiscVarTypeData%u_UA(i1,i2), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
    ENDDO
ENDIF
      CALL UA_CopyMisc( SrcWng_MiscVarTypeData%m_UA, DstWng_MiscVarTypeData%m_UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL UA_CopyOutput( SrcWng_MiscVarTypeData%y_UA, DstWng_MiscVarTypeData%y_UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL UA_CopyParam( SrcWng_MiscVarTypeData%p_UA, DstWng_MiscVarTypeData%p_UA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcWng_MiscVarTypeData%Vind_LL)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%Vind_LL,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%Vind_LL,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%Vind_LL,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%Vind_LL,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%Vind_LL)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%Vind_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%Vind_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%Vind_LL = SrcWng_MiscVarTypeData%Vind_LL
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_AxInd)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_AxInd,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_AxInd,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_AxInd)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_AxInd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_AxInd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_AxInd = SrcWng_MiscVarTypeData%BN_AxInd
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_TanInd)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_TanInd,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_TanInd,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_TanInd)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_TanInd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_TanInd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_TanInd = SrcWng_MiscVarTypeData%BN_TanInd
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Vrel)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Vrel,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Vrel,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Vrel)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Vrel(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Vrel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Vrel = SrcWng_MiscVarTypeData%BN_Vrel
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_alpha)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_alpha,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_alpha,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_alpha)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_alpha(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_alpha.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_alpha = SrcWng_MiscVarTypeData%BN_alpha
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_phi)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_phi,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_phi,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_phi)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_phi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_phi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_phi = SrcWng_MiscVarTypeData%BN_phi
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Re)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Re,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Re,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Re)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Re(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Re.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Re = SrcWng_MiscVarTypeData%BN_Re
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_URelWind_s)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_URelWind_s,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_URelWind_s,1)
  i2_l = LBOUND(SrcWng_MiscVarTypeData%BN_URelWind_s,2)
  i2_u = UBOUND(SrcWng_MiscVarTypeData%BN_URelWind_s,2)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_URelWind_s)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_URelWind_s(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_URelWind_s.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_URelWind_s = SrcWng_MiscVarTypeData%BN_URelWind_s
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cl_Static)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cl_Static,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cl_Static,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cl_Static)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cl_Static(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cl_Static.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cl_Static = SrcWng_MiscVarTypeData%BN_Cl_Static
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cd_Static)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cd_Static,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cd_Static,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cd_Static)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cd_Static(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cd_Static.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cd_Static = SrcWng_MiscVarTypeData%BN_Cd_Static
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cm_Static)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cm_Static,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cm_Static,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cm_Static)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cm_Static(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cm_Static.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cm_Static = SrcWng_MiscVarTypeData%BN_Cm_Static
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cpmin)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cpmin,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cpmin,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cpmin)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cpmin(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cpmin.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cpmin = SrcWng_MiscVarTypeData%BN_Cpmin
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cl)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cl,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cl,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cl)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cl(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cl = SrcWng_MiscVarTypeData%BN_Cl
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cd)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cd,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cd,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cd)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cd = SrcWng_MiscVarTypeData%BN_Cd
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cm)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cm,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cm,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cm)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cm = SrcWng_MiscVarTypeData%BN_Cm
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cx)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cx,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cx,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cx)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cx = SrcWng_MiscVarTypeData%BN_Cx
ENDIF
IF (ALLOCATED(SrcWng_MiscVarTypeData%BN_Cy)) THEN
  i1_l = LBOUND(SrcWng_MiscVarTypeData%BN_Cy,1)
  i1_u = UBOUND(SrcWng_MiscVarTypeData%BN_Cy,1)
  IF (.NOT. ALLOCATED(DstWng_MiscVarTypeData%BN_Cy)) THEN 
    ALLOCATE(DstWng_MiscVarTypeData%BN_Cy(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_MiscVarTypeData%BN_Cy.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_MiscVarTypeData%BN_Cy = SrcWng_MiscVarTypeData%BN_Cy
ENDIF
 END SUBROUTINE FVW_CopyWng_MiscVarType

 SUBROUTINE FVW_DestroyWng_MiscVarType( Wng_MiscVarTypeData, ErrStat, ErrMsg )
  TYPE(Wng_MiscVarType), INTENT(INOUT) :: Wng_MiscVarTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_MiscVarType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_MiscVarTypeData%LE)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%LE)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%TE)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%TE)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%r_LL)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%r_LL)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%CP)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%CP)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Tang)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Tang)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Norm)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Norm)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Orth)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Orth)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%dl)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%dl)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Area)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Area)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%diag_LL)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%diag_LL)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vind_CP)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vind_CP)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vtot_CP)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vtot_CP)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vstr_CP)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vstr_CP)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vwnd_CP)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vwnd_CP)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vwnd_NW)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vwnd_NW)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vwnd_FW)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vwnd_FW)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vind_NW)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vind_NW)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vind_FW)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vind_FW)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%PitchAndTwist)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%PitchAndTwist)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%alpha_LL)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%alpha_LL)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%Vreln_LL)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vreln_LL)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%u_UA)) THEN
DO i2 = LBOUND(Wng_MiscVarTypeData%u_UA,2), UBOUND(Wng_MiscVarTypeData%u_UA,2)
DO i1 = LBOUND(Wng_MiscVarTypeData%u_UA,1), UBOUND(Wng_MiscVarTypeData%u_UA,1)
  CALL UA_DestroyInput( Wng_MiscVarTypeData%u_UA(i1,i2), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
ENDDO
  DEALLOCATE(Wng_MiscVarTypeData%u_UA)
ENDIF
  CALL UA_DestroyMisc( Wng_MiscVarTypeData%m_UA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL UA_DestroyOutput( Wng_MiscVarTypeData%y_UA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL UA_DestroyParam( Wng_MiscVarTypeData%p_UA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(Wng_MiscVarTypeData%Vind_LL)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%Vind_LL)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_AxInd)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_AxInd)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_TanInd)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_TanInd)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Vrel)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Vrel)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_alpha)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_alpha)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_phi)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_phi)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Re)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Re)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_URelWind_s)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_URelWind_s)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cl_Static)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cl_Static)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cd_Static)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cd_Static)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cm_Static)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cm_Static)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cpmin)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cpmin)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cl)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cl)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cd)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cd)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cm)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cm)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cx)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cx)
ENDIF
IF (ALLOCATED(Wng_MiscVarTypeData%BN_Cy)) THEN
  DEALLOCATE(Wng_MiscVarTypeData%BN_Cy)
ENDIF
 END SUBROUTINE FVW_DestroyWng_MiscVarType


subroutine FVW_PackWng_MiscVarType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_MiscVarType'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   if (Buf%ErrStat >= AbortErrLev) return
   ! LE
   call RegPack(Buf, allocated(InData%LE))
   if (allocated(InData%LE)) then
      call RegPackBounds(Buf, 2, lbound(InData%LE), ubound(InData%LE))
      call RegPack(Buf, InData%LE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TE
   call RegPack(Buf, allocated(InData%TE))
   if (allocated(InData%TE)) then
      call RegPackBounds(Buf, 2, lbound(InData%TE), ubound(InData%TE))
      call RegPack(Buf, InData%TE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_LL
   call RegPack(Buf, allocated(InData%r_LL))
   if (allocated(InData%r_LL)) then
      call RegPackBounds(Buf, 3, lbound(InData%r_LL), ubound(InData%r_LL))
      call RegPack(Buf, InData%r_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CP
   call RegPack(Buf, allocated(InData%CP))
   if (allocated(InData%CP)) then
      call RegPackBounds(Buf, 2, lbound(InData%CP), ubound(InData%CP))
      call RegPack(Buf, InData%CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tang
   call RegPack(Buf, allocated(InData%Tang))
   if (allocated(InData%Tang)) then
      call RegPackBounds(Buf, 2, lbound(InData%Tang), ubound(InData%Tang))
      call RegPack(Buf, InData%Tang)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Norm
   call RegPack(Buf, allocated(InData%Norm))
   if (allocated(InData%Norm)) then
      call RegPackBounds(Buf, 2, lbound(InData%Norm), ubound(InData%Norm))
      call RegPack(Buf, InData%Norm)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Orth
   call RegPack(Buf, allocated(InData%Orth))
   if (allocated(InData%Orth)) then
      call RegPackBounds(Buf, 2, lbound(InData%Orth), ubound(InData%Orth))
      call RegPack(Buf, InData%Orth)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dl
   call RegPack(Buf, allocated(InData%dl))
   if (allocated(InData%dl)) then
      call RegPackBounds(Buf, 2, lbound(InData%dl), ubound(InData%dl))
      call RegPack(Buf, InData%dl)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Area
   call RegPack(Buf, allocated(InData%Area))
   if (allocated(InData%Area)) then
      call RegPackBounds(Buf, 1, lbound(InData%Area), ubound(InData%Area))
      call RegPack(Buf, InData%Area)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! diag_LL
   call RegPack(Buf, allocated(InData%diag_LL))
   if (allocated(InData%diag_LL)) then
      call RegPackBounds(Buf, 1, lbound(InData%diag_LL), ubound(InData%diag_LL))
      call RegPack(Buf, InData%diag_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vind_CP
   call RegPack(Buf, allocated(InData%Vind_CP))
   if (allocated(InData%Vind_CP)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vind_CP), ubound(InData%Vind_CP))
      call RegPack(Buf, InData%Vind_CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vtot_CP
   call RegPack(Buf, allocated(InData%Vtot_CP))
   if (allocated(InData%Vtot_CP)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vtot_CP), ubound(InData%Vtot_CP))
      call RegPack(Buf, InData%Vtot_CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vstr_CP
   call RegPack(Buf, allocated(InData%Vstr_CP))
   if (allocated(InData%Vstr_CP)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vstr_CP), ubound(InData%Vstr_CP))
      call RegPack(Buf, InData%Vstr_CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vwnd_CP
   call RegPack(Buf, allocated(InData%Vwnd_CP))
   if (allocated(InData%Vwnd_CP)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vwnd_CP), ubound(InData%Vwnd_CP))
      call RegPack(Buf, InData%Vwnd_CP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vwnd_NW
   call RegPack(Buf, allocated(InData%Vwnd_NW))
   if (allocated(InData%Vwnd_NW)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vwnd_NW), ubound(InData%Vwnd_NW))
      call RegPack(Buf, InData%Vwnd_NW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vwnd_FW
   call RegPack(Buf, allocated(InData%Vwnd_FW))
   if (allocated(InData%Vwnd_FW)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vwnd_FW), ubound(InData%Vwnd_FW))
      call RegPack(Buf, InData%Vwnd_FW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vind_NW
   call RegPack(Buf, allocated(InData%Vind_NW))
   if (allocated(InData%Vind_NW)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vind_NW), ubound(InData%Vind_NW))
      call RegPack(Buf, InData%Vind_NW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vind_FW
   call RegPack(Buf, allocated(InData%Vind_FW))
   if (allocated(InData%Vind_FW)) then
      call RegPackBounds(Buf, 3, lbound(InData%Vind_FW), ubound(InData%Vind_FW))
      call RegPack(Buf, InData%Vind_FW)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PitchAndTwist
   call RegPack(Buf, allocated(InData%PitchAndTwist))
   if (allocated(InData%PitchAndTwist)) then
      call RegPackBounds(Buf, 1, lbound(InData%PitchAndTwist), ubound(InData%PitchAndTwist))
      call RegPack(Buf, InData%PitchAndTwist)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! iTip
   call RegPack(Buf, InData%iTip)
   if (RegCheckErr(Buf, RoutineName)) return
   ! iRoot
   call RegPack(Buf, InData%iRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! alpha_LL
   call RegPack(Buf, allocated(InData%alpha_LL))
   if (allocated(InData%alpha_LL)) then
      call RegPackBounds(Buf, 1, lbound(InData%alpha_LL), ubound(InData%alpha_LL))
      call RegPack(Buf, InData%alpha_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vreln_LL
   call RegPack(Buf, allocated(InData%Vreln_LL))
   if (allocated(InData%Vreln_LL)) then
      call RegPackBounds(Buf, 1, lbound(InData%Vreln_LL), ubound(InData%Vreln_LL))
      call RegPack(Buf, InData%Vreln_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_UA
   call RegPack(Buf, allocated(InData%u_UA))
   if (allocated(InData%u_UA)) then
      call RegPackBounds(Buf, 2, lbound(InData%u_UA), ubound(InData%u_UA))
      LB(1:2) = lbound(InData%u_UA)
      UB(1:2) = ubound(InData%u_UA)
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call UA_PackInput(Buf, InData%u_UA(i1,i2)) 
         end do
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! m_UA
   call UA_PackMisc(Buf, InData%m_UA) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! y_UA
   call UA_PackOutput(Buf, InData%y_UA) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! p_UA
   call UA_PackParam(Buf, InData%p_UA) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vind_LL
   call RegPack(Buf, allocated(InData%Vind_LL))
   if (allocated(InData%Vind_LL)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vind_LL), ubound(InData%Vind_LL))
      call RegPack(Buf, InData%Vind_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_AxInd
   call RegPack(Buf, allocated(InData%BN_AxInd))
   if (allocated(InData%BN_AxInd)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_AxInd), ubound(InData%BN_AxInd))
      call RegPack(Buf, InData%BN_AxInd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_TanInd
   call RegPack(Buf, allocated(InData%BN_TanInd))
   if (allocated(InData%BN_TanInd)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_TanInd), ubound(InData%BN_TanInd))
      call RegPack(Buf, InData%BN_TanInd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Vrel
   call RegPack(Buf, allocated(InData%BN_Vrel))
   if (allocated(InData%BN_Vrel)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Vrel), ubound(InData%BN_Vrel))
      call RegPack(Buf, InData%BN_Vrel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_alpha
   call RegPack(Buf, allocated(InData%BN_alpha))
   if (allocated(InData%BN_alpha)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_alpha), ubound(InData%BN_alpha))
      call RegPack(Buf, InData%BN_alpha)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_phi
   call RegPack(Buf, allocated(InData%BN_phi))
   if (allocated(InData%BN_phi)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_phi), ubound(InData%BN_phi))
      call RegPack(Buf, InData%BN_phi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Re
   call RegPack(Buf, allocated(InData%BN_Re))
   if (allocated(InData%BN_Re)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Re), ubound(InData%BN_Re))
      call RegPack(Buf, InData%BN_Re)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_URelWind_s
   call RegPack(Buf, allocated(InData%BN_URelWind_s))
   if (allocated(InData%BN_URelWind_s)) then
      call RegPackBounds(Buf, 2, lbound(InData%BN_URelWind_s), ubound(InData%BN_URelWind_s))
      call RegPack(Buf, InData%BN_URelWind_s)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cl_Static
   call RegPack(Buf, allocated(InData%BN_Cl_Static))
   if (allocated(InData%BN_Cl_Static)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cl_Static), ubound(InData%BN_Cl_Static))
      call RegPack(Buf, InData%BN_Cl_Static)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cd_Static
   call RegPack(Buf, allocated(InData%BN_Cd_Static))
   if (allocated(InData%BN_Cd_Static)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cd_Static), ubound(InData%BN_Cd_Static))
      call RegPack(Buf, InData%BN_Cd_Static)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cm_Static
   call RegPack(Buf, allocated(InData%BN_Cm_Static))
   if (allocated(InData%BN_Cm_Static)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cm_Static), ubound(InData%BN_Cm_Static))
      call RegPack(Buf, InData%BN_Cm_Static)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cpmin
   call RegPack(Buf, allocated(InData%BN_Cpmin))
   if (allocated(InData%BN_Cpmin)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cpmin), ubound(InData%BN_Cpmin))
      call RegPack(Buf, InData%BN_Cpmin)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cl
   call RegPack(Buf, allocated(InData%BN_Cl))
   if (allocated(InData%BN_Cl)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cl), ubound(InData%BN_Cl))
      call RegPack(Buf, InData%BN_Cl)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cd
   call RegPack(Buf, allocated(InData%BN_Cd))
   if (allocated(InData%BN_Cd)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cd), ubound(InData%BN_Cd))
      call RegPack(Buf, InData%BN_Cd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cm
   call RegPack(Buf, allocated(InData%BN_Cm))
   if (allocated(InData%BN_Cm)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cm), ubound(InData%BN_Cm))
      call RegPack(Buf, InData%BN_Cm)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cx
   call RegPack(Buf, allocated(InData%BN_Cx))
   if (allocated(InData%BN_Cx)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cx), ubound(InData%BN_Cx))
      call RegPack(Buf, InData%BN_Cx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BN_Cy
   call RegPack(Buf, allocated(InData%BN_Cy))
   if (allocated(InData%BN_Cy)) then
      call RegPackBounds(Buf, 1, lbound(InData%BN_Cy), ubound(InData%BN_Cy))
      call RegPack(Buf, InData%BN_Cy)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_MiscVarType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_MiscVarType'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LE
   if (allocated(OutData%LE)) deallocate(OutData%LE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TE
   if (allocated(OutData%TE)) deallocate(OutData%TE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! r_LL
   if (allocated(OutData%r_LL)) deallocate(OutData%r_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_LL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CP
   if (allocated(OutData%CP)) deallocate(OutData%CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Tang
   if (allocated(OutData%Tang)) deallocate(OutData%Tang)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Tang(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Tang.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Tang)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Norm
   if (allocated(OutData%Norm)) deallocate(OutData%Norm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Norm(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Norm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Norm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Orth
   if (allocated(OutData%Orth)) deallocate(OutData%Orth)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Orth(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Orth.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Orth)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dl
   if (allocated(OutData%dl)) deallocate(OutData%dl)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dl(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dl.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dl)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Area
   if (allocated(OutData%Area)) deallocate(OutData%Area)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Area(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Area.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Area)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! diag_LL
   if (allocated(OutData%diag_LL)) deallocate(OutData%diag_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%diag_LL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%diag_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%diag_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vind_CP
   if (allocated(OutData%Vind_CP)) deallocate(OutData%Vind_CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vind_CP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vind_CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vtot_CP
   if (allocated(OutData%Vtot_CP)) deallocate(OutData%Vtot_CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vtot_CP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vtot_CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vtot_CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vstr_CP
   if (allocated(OutData%Vstr_CP)) deallocate(OutData%Vstr_CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vstr_CP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vstr_CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vstr_CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vwnd_CP
   if (allocated(OutData%Vwnd_CP)) deallocate(OutData%Vwnd_CP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vwnd_CP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_CP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vwnd_CP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vwnd_NW
   if (allocated(OutData%Vwnd_NW)) deallocate(OutData%Vwnd_NW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vwnd_NW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_NW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vwnd_NW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vwnd_FW
   if (allocated(OutData%Vwnd_FW)) deallocate(OutData%Vwnd_FW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vwnd_FW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_FW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vwnd_FW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vind_NW
   if (allocated(OutData%Vind_NW)) deallocate(OutData%Vind_NW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vind_NW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_NW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vind_NW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vind_FW
   if (allocated(OutData%Vind_FW)) deallocate(OutData%Vind_FW)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vind_FW(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_FW.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vind_FW)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PitchAndTwist
   if (allocated(OutData%PitchAndTwist)) deallocate(OutData%PitchAndTwist)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PitchAndTwist(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PitchAndTwist.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PitchAndTwist)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! iTip
   call RegUnpack(Buf, OutData%iTip)
   if (RegCheckErr(Buf, RoutineName)) return
   ! iRoot
   call RegUnpack(Buf, OutData%iRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! alpha_LL
   if (allocated(OutData%alpha_LL)) deallocate(OutData%alpha_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%alpha_LL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%alpha_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%alpha_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Vreln_LL
   if (allocated(OutData%Vreln_LL)) deallocate(OutData%Vreln_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vreln_LL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vreln_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vreln_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! u_UA
   if (allocated(OutData%u_UA)) deallocate(OutData%u_UA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_UA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_UA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i2 = LB(2), UB(2)
         do i1 = LB(1), UB(1)
            call UA_UnpackInput(Buf, OutData%u_UA(i1,i2)) ! u_UA 
         end do
      end do
   end if
   ! m_UA
   call UA_UnpackMisc(Buf, OutData%m_UA) ! m_UA 
   ! y_UA
   call UA_UnpackOutput(Buf, OutData%y_UA) ! y_UA 
   ! p_UA
   call UA_UnpackParam(Buf, OutData%p_UA) ! p_UA 
   ! Vind_LL
   if (allocated(OutData%Vind_LL)) deallocate(OutData%Vind_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vind_LL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vind_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_AxInd
   if (allocated(OutData%BN_AxInd)) deallocate(OutData%BN_AxInd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_AxInd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_AxInd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_AxInd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_TanInd
   if (allocated(OutData%BN_TanInd)) deallocate(OutData%BN_TanInd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_TanInd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_TanInd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_TanInd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Vrel
   if (allocated(OutData%BN_Vrel)) deallocate(OutData%BN_Vrel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Vrel(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Vrel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Vrel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_alpha
   if (allocated(OutData%BN_alpha)) deallocate(OutData%BN_alpha)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_alpha(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_alpha.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_alpha)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_phi
   if (allocated(OutData%BN_phi)) deallocate(OutData%BN_phi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_phi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_phi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_phi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Re
   if (allocated(OutData%BN_Re)) deallocate(OutData%BN_Re)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Re(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Re.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Re)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_URelWind_s
   if (allocated(OutData%BN_URelWind_s)) deallocate(OutData%BN_URelWind_s)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_URelWind_s(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_URelWind_s.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_URelWind_s)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cl_Static
   if (allocated(OutData%BN_Cl_Static)) deallocate(OutData%BN_Cl_Static)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cl_Static(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cl_Static.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cl_Static)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cd_Static
   if (allocated(OutData%BN_Cd_Static)) deallocate(OutData%BN_Cd_Static)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cd_Static(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cd_Static.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cd_Static)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cm_Static
   if (allocated(OutData%BN_Cm_Static)) deallocate(OutData%BN_Cm_Static)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cm_Static(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cm_Static.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cm_Static)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cpmin
   if (allocated(OutData%BN_Cpmin)) deallocate(OutData%BN_Cpmin)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cpmin(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cpmin.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cpmin)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cl
   if (allocated(OutData%BN_Cl)) deallocate(OutData%BN_Cl)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cl(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cl.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cl)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cd
   if (allocated(OutData%BN_Cd)) deallocate(OutData%BN_Cd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cm
   if (allocated(OutData%BN_Cm)) deallocate(OutData%BN_Cm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cx
   if (allocated(OutData%BN_Cx)) deallocate(OutData%BN_Cx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BN_Cy
   if (allocated(OutData%BN_Cy)) deallocate(OutData%BN_Cy)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BN_Cy(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BN_Cy.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BN_Cy)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(FVW_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%W)) THEN
  i1_l = LBOUND(SrcMiscData%W,1)
  i1_u = UBOUND(SrcMiscData%W,1)
  IF (.NOT. ALLOCATED(DstMiscData%W)) THEN 
    ALLOCATE(DstMiscData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%W,1), UBOUND(SrcMiscData%W,1)
      CALL FVW_Copywng_miscvartype( SrcMiscData%W(i1), DstMiscData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstMiscData%FirstCall = SrcMiscData%FirstCall
    DstMiscData%nNW = SrcMiscData%nNW
    DstMiscData%nFW = SrcMiscData%nFW
    DstMiscData%iStep = SrcMiscData%iStep
    DstMiscData%VTKstep = SrcMiscData%VTKstep
    DstMiscData%VTKlastTime = SrcMiscData%VTKlastTime
IF (ALLOCATED(SrcMiscData%r_wind)) THEN
  i1_l = LBOUND(SrcMiscData%r_wind,1)
  i1_u = UBOUND(SrcMiscData%r_wind,1)
  i2_l = LBOUND(SrcMiscData%r_wind,2)
  i2_u = UBOUND(SrcMiscData%r_wind,2)
  IF (.NOT. ALLOCATED(DstMiscData%r_wind)) THEN 
    ALLOCATE(DstMiscData%r_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_wind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_wind = SrcMiscData%r_wind
ENDIF
    DstMiscData%ComputeWakeInduced = SrcMiscData%ComputeWakeInduced
    DstMiscData%OldWakeTime = SrcMiscData%OldWakeTime
      CALL FVW_CopyContState( SrcMiscData%dxdt, DstMiscData%dxdt, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FVW_CopyContState( SrcMiscData%x1, DstMiscData%x1, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FVW_CopyContState( SrcMiscData%x2, DstMiscData%x2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%t1 = SrcMiscData%t1
    DstMiscData%t2 = SrcMiscData%t2
    DstMiscData%UA_Flag = SrcMiscData%UA_Flag
      CALL FVW_Copyt_sgmt( SrcMiscData%Sgmt, DstMiscData%Sgmt, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FVW_Copyt_part( SrcMiscData%Part, DstMiscData%Part, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMiscData%CPs)) THEN
  i1_l = LBOUND(SrcMiscData%CPs,1)
  i1_u = UBOUND(SrcMiscData%CPs,1)
  i2_l = LBOUND(SrcMiscData%CPs,2)
  i2_u = UBOUND(SrcMiscData%CPs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CPs)) THEN 
    ALLOCATE(DstMiscData%CPs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CPs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CPs = SrcMiscData%CPs
ENDIF
IF (ALLOCATED(SrcMiscData%Uind)) THEN
  i1_l = LBOUND(SrcMiscData%Uind,1)
  i1_u = UBOUND(SrcMiscData%Uind,1)
  i2_l = LBOUND(SrcMiscData%Uind,2)
  i2_u = UBOUND(SrcMiscData%Uind,2)
  IF (.NOT. ALLOCATED(DstMiscData%Uind)) THEN 
    ALLOCATE(DstMiscData%Uind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Uind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Uind = SrcMiscData%Uind
ENDIF
IF (ALLOCATED(SrcMiscData%GridOutputs)) THEN
  i1_l = LBOUND(SrcMiscData%GridOutputs,1)
  i1_u = UBOUND(SrcMiscData%GridOutputs,1)
  IF (.NOT. ALLOCATED(DstMiscData%GridOutputs)) THEN 
    ALLOCATE(DstMiscData%GridOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%GridOutputs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%GridOutputs,1), UBOUND(SrcMiscData%GridOutputs,1)
      CALL FVW_Copygridouttype( SrcMiscData%GridOutputs(i1), DstMiscData%GridOutputs(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FVW_CopyMisc

 SUBROUTINE FVW_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(FVW_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%W)) THEN
DO i1 = LBOUND(MiscData%W,1), UBOUND(MiscData%W,1)
  CALL FVW_DestroyWng_MiscVarType( MiscData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%W)
ENDIF
IF (ALLOCATED(MiscData%r_wind)) THEN
  DEALLOCATE(MiscData%r_wind)
ENDIF
  CALL FVW_DestroyContState( MiscData%dxdt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FVW_DestroyContState( MiscData%x1, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FVW_DestroyContState( MiscData%x2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FVW_DestroyT_Sgmt( MiscData%Sgmt, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FVW_DestroyT_Part( MiscData%Part, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%CPs)) THEN
  DEALLOCATE(MiscData%CPs)
ENDIF
IF (ALLOCATED(MiscData%Uind)) THEN
  DEALLOCATE(MiscData%Uind)
ENDIF
IF (ALLOCATED(MiscData%GridOutputs)) THEN
DO i1 = LBOUND(MiscData%GridOutputs,1), UBOUND(MiscData%GridOutputs,1)
  CALL FVW_DestroyGridOutType( MiscData%GridOutputs(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%GridOutputs)
ENDIF
 END SUBROUTINE FVW_DestroyMisc


subroutine FVW_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_MiscVarType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstCall
   call RegPack(Buf, InData%FirstCall)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNW
   call RegPack(Buf, InData%nNW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFW
   call RegPack(Buf, InData%nFW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! iStep
   call RegPack(Buf, InData%iStep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKstep
   call RegPack(Buf, InData%VTKstep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKlastTime
   call RegPack(Buf, InData%VTKlastTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_wind
   call RegPack(Buf, allocated(InData%r_wind))
   if (allocated(InData%r_wind)) then
      call RegPackBounds(Buf, 2, lbound(InData%r_wind), ubound(InData%r_wind))
      call RegPack(Buf, InData%r_wind)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ComputeWakeInduced
   call RegPack(Buf, InData%ComputeWakeInduced)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OldWakeTime
   call RegPack(Buf, InData%OldWakeTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dxdt
   call FVW_PackContState(Buf, InData%dxdt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! x1
   call FVW_PackContState(Buf, InData%x1) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! x2
   call FVW_PackContState(Buf, InData%x2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! t1
   call RegPack(Buf, InData%t1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! t2
   call RegPack(Buf, InData%t2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA_Flag
   call RegPack(Buf, InData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Sgmt
   call FVW_PackT_Sgmt(Buf, InData%Sgmt) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Part
   call FVW_PackT_Part(Buf, InData%Part) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! CPs
   call RegPack(Buf, allocated(InData%CPs))
   if (allocated(InData%CPs)) then
      call RegPackBounds(Buf, 2, lbound(InData%CPs), ubound(InData%CPs))
      call RegPack(Buf, InData%CPs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Uind
   call RegPack(Buf, allocated(InData%Uind))
   if (allocated(InData%Uind)) then
      call RegPackBounds(Buf, 2, lbound(InData%Uind), ubound(InData%Uind))
      call RegPack(Buf, InData%Uind)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GridOutputs
   call RegPack(Buf, allocated(InData%GridOutputs))
   if (allocated(InData%GridOutputs)) then
      call RegPackBounds(Buf, 1, lbound(InData%GridOutputs), ubound(InData%GridOutputs))
      LB(1:1) = lbound(InData%GridOutputs)
      UB(1:1) = ubound(InData%GridOutputs)
      do i1 = LB(1), UB(1)
         call FVW_PackGridOutType(Buf, InData%GridOutputs(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_MiscVarType(Buf, OutData%W(i1)) ! W 
      end do
   end if
   ! FirstCall
   call RegUnpack(Buf, OutData%FirstCall)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNW
   call RegUnpack(Buf, OutData%nNW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFW
   call RegUnpack(Buf, OutData%nFW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! iStep
   call RegUnpack(Buf, OutData%iStep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKstep
   call RegUnpack(Buf, OutData%VTKstep)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKlastTime
   call RegUnpack(Buf, OutData%VTKlastTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_wind
   if (allocated(OutData%r_wind)) deallocate(OutData%r_wind)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r_wind(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_wind.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r_wind)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ComputeWakeInduced
   call RegUnpack(Buf, OutData%ComputeWakeInduced)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OldWakeTime
   call RegUnpack(Buf, OutData%OldWakeTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dxdt
   call FVW_UnpackContState(Buf, OutData%dxdt) ! dxdt 
   ! x1
   call FVW_UnpackContState(Buf, OutData%x1) ! x1 
   ! x2
   call FVW_UnpackContState(Buf, OutData%x2) ! x2 
   ! t1
   call RegUnpack(Buf, OutData%t1)
   if (RegCheckErr(Buf, RoutineName)) return
   ! t2
   call RegUnpack(Buf, OutData%t2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA_Flag
   call RegUnpack(Buf, OutData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Sgmt
   call FVW_UnpackT_Sgmt(Buf, OutData%Sgmt) ! Sgmt 
   ! Part
   call FVW_UnpackT_Part(Buf, OutData%Part) ! Part 
   ! CPs
   if (allocated(OutData%CPs)) deallocate(OutData%CPs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CPs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CPs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CPs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Uind
   if (allocated(OutData%Uind)) deallocate(OutData%Uind)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Uind(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Uind.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Uind)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GridOutputs
   if (allocated(OutData%GridOutputs)) deallocate(OutData%GridOutputs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GridOutputs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GridOutputs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackGridOutType(Buf, OutData%GridOutputs(i1)) ! GridOutputs 
      end do
   end if
end subroutine
 SUBROUTINE FVW_CopyRot_InputType( SrcRot_InputTypeData, DstRot_InputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Rot_InputType), INTENT(IN) :: SrcRot_InputTypeData
   TYPE(Rot_InputType), INTENT(INOUT) :: DstRot_InputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyRot_InputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRot_InputTypeData%HubOrientation = SrcRot_InputTypeData%HubOrientation
    DstRot_InputTypeData%HubPosition = SrcRot_InputTypeData%HubPosition
 END SUBROUTINE FVW_CopyRot_InputType

 SUBROUTINE FVW_DestroyRot_InputType( Rot_InputTypeData, ErrStat, ErrMsg )
  TYPE(Rot_InputType), INTENT(INOUT) :: Rot_InputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyRot_InputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE FVW_DestroyRot_InputType


subroutine FVW_PackRot_InputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Rot_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackRot_InputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! HubOrientation
   call RegPack(Buf, InData%HubOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubPosition
   call RegPack(Buf, InData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackRot_InputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Rot_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackRot_InputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! HubOrientation
   call RegUnpack(Buf, OutData%HubOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubPosition
   call RegUnpack(Buf, OutData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyWng_InputType( SrcWng_InputTypeData, DstWng_InputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_InputType), INTENT(IN) :: SrcWng_InputTypeData
   TYPE(Wng_InputType), INTENT(INOUT) :: DstWng_InputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_InputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_InputTypeData%Vwnd_LL)) THEN
  i1_l = LBOUND(SrcWng_InputTypeData%Vwnd_LL,1)
  i1_u = UBOUND(SrcWng_InputTypeData%Vwnd_LL,1)
  i2_l = LBOUND(SrcWng_InputTypeData%Vwnd_LL,2)
  i2_u = UBOUND(SrcWng_InputTypeData%Vwnd_LL,2)
  IF (.NOT. ALLOCATED(DstWng_InputTypeData%Vwnd_LL)) THEN 
    ALLOCATE(DstWng_InputTypeData%Vwnd_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_InputTypeData%Vwnd_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_InputTypeData%Vwnd_LL = SrcWng_InputTypeData%Vwnd_LL
ENDIF
IF (ALLOCATED(SrcWng_InputTypeData%omega_z)) THEN
  i1_l = LBOUND(SrcWng_InputTypeData%omega_z,1)
  i1_u = UBOUND(SrcWng_InputTypeData%omega_z,1)
  IF (.NOT. ALLOCATED(DstWng_InputTypeData%omega_z)) THEN 
    ALLOCATE(DstWng_InputTypeData%omega_z(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_InputTypeData%omega_z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_InputTypeData%omega_z = SrcWng_InputTypeData%omega_z
ENDIF
 END SUBROUTINE FVW_CopyWng_InputType

 SUBROUTINE FVW_DestroyWng_InputType( Wng_InputTypeData, ErrStat, ErrMsg )
  TYPE(Wng_InputType), INTENT(INOUT) :: Wng_InputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_InputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_InputTypeData%Vwnd_LL)) THEN
  DEALLOCATE(Wng_InputTypeData%Vwnd_LL)
ENDIF
IF (ALLOCATED(Wng_InputTypeData%omega_z)) THEN
  DEALLOCATE(Wng_InputTypeData%omega_z)
ENDIF
 END SUBROUTINE FVW_DestroyWng_InputType


subroutine FVW_PackWng_InputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_InputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Vwnd_LL
   call RegPack(Buf, allocated(InData%Vwnd_LL))
   if (allocated(InData%Vwnd_LL)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vwnd_LL), ubound(InData%Vwnd_LL))
      call RegPack(Buf, InData%Vwnd_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! omega_z
   call RegPack(Buf, allocated(InData%omega_z))
   if (allocated(InData%omega_z)) then
      call RegPackBounds(Buf, 1, lbound(InData%omega_z), ubound(InData%omega_z))
      call RegPack(Buf, InData%omega_z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_InputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_InputType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Vwnd_LL
   if (allocated(OutData%Vwnd_LL)) deallocate(OutData%Vwnd_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vwnd_LL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vwnd_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! omega_z
   if (allocated(OutData%omega_z)) deallocate(OutData%omega_z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%omega_z(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%omega_z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%omega_z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(FVW_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%rotors)) THEN
  i1_l = LBOUND(SrcInputData%rotors,1)
  i1_u = UBOUND(SrcInputData%rotors,1)
  IF (.NOT. ALLOCATED(DstInputData%rotors)) THEN 
    ALLOCATE(DstInputData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%rotors,1), UBOUND(SrcInputData%rotors,1)
      CALL FVW_Copyrot_inputtype( SrcInputData%rotors(i1), DstInputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%W)) THEN
  i1_l = LBOUND(SrcInputData%W,1)
  i1_u = UBOUND(SrcInputData%W,1)
  IF (.NOT. ALLOCATED(DstInputData%W)) THEN 
    ALLOCATE(DstInputData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%W,1), UBOUND(SrcInputData%W,1)
      CALL FVW_Copywng_inputtype( SrcInputData%W(i1), DstInputData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%WingsMesh)) THEN
  i1_l = LBOUND(SrcInputData%WingsMesh,1)
  i1_u = UBOUND(SrcInputData%WingsMesh,1)
  IF (.NOT. ALLOCATED(DstInputData%WingsMesh)) THEN 
    ALLOCATE(DstInputData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%WingsMesh,1), UBOUND(SrcInputData%WingsMesh,1)
      CALL MeshCopy( SrcInputData%WingsMesh(i1), DstInputData%WingsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%V_wind)) THEN
  i1_l = LBOUND(SrcInputData%V_wind,1)
  i1_u = UBOUND(SrcInputData%V_wind,1)
  i2_l = LBOUND(SrcInputData%V_wind,2)
  i2_u = UBOUND(SrcInputData%V_wind,2)
  IF (.NOT. ALLOCATED(DstInputData%V_wind)) THEN 
    ALLOCATE(DstInputData%V_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%V_wind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%V_wind = SrcInputData%V_wind
ENDIF
 END SUBROUTINE FVW_CopyInput

 SUBROUTINE FVW_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FVW_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%rotors)) THEN
DO i1 = LBOUND(InputData%rotors,1), UBOUND(InputData%rotors,1)
  CALL FVW_DestroyRot_InputType( InputData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%rotors)
ENDIF
IF (ALLOCATED(InputData%W)) THEN
DO i1 = LBOUND(InputData%W,1), UBOUND(InputData%W,1)
  CALL FVW_DestroyWng_InputType( InputData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%W)
ENDIF
IF (ALLOCATED(InputData%WingsMesh)) THEN
DO i1 = LBOUND(InputData%WingsMesh,1), UBOUND(InputData%WingsMesh,1)
  CALL MeshDestroy( InputData%WingsMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%WingsMesh)
ENDIF
IF (ALLOCATED(InputData%V_wind)) THEN
  DEALLOCATE(InputData%V_wind)
ENDIF
 END SUBROUTINE FVW_DestroyInput


subroutine FVW_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call FVW_PackRot_InputType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_InputType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WingsMesh
   call RegPack(Buf, allocated(InData%WingsMesh))
   if (allocated(InData%WingsMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%WingsMesh), ubound(InData%WingsMesh))
      LB(1:1) = lbound(InData%WingsMesh)
      UB(1:1) = ubound(InData%WingsMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%WingsMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_wind
   call RegPack(Buf, allocated(InData%V_wind))
   if (allocated(InData%V_wind)) then
      call RegPackBounds(Buf, 2, lbound(InData%V_wind), ubound(InData%V_wind))
      call RegPack(Buf, InData%V_wind)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackRot_InputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_InputType(Buf, OutData%W(i1)) ! W 
      end do
   end if
   ! WingsMesh
   if (allocated(OutData%WingsMesh)) deallocate(OutData%WingsMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WingsMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WingsMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%WingsMesh(i1)) ! WingsMesh 
      end do
   end if
   ! V_wind
   if (allocated(OutData%V_wind)) deallocate(OutData%V_wind)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%V_wind(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%V_wind.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%V_wind)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%Dummy = SrcDiscStateData%Dummy
IF (ALLOCATED(SrcDiscStateData%UA)) THEN
  i1_l = LBOUND(SrcDiscStateData%UA,1)
  i1_u = UBOUND(SrcDiscStateData%UA,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%UA)) THEN 
    ALLOCATE(DstDiscStateData%UA(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%UA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%UA,1), UBOUND(SrcDiscStateData%UA,1)
      CALL UA_CopyDiscState( SrcDiscStateData%UA(i1), DstDiscStateData%UA(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FVW_CopyDiscState

 SUBROUTINE FVW_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%UA)) THEN
DO i1 = LBOUND(DiscStateData%UA,1), UBOUND(DiscStateData%UA,1)
  CALL UA_DestroyDiscState( DiscStateData%UA(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%UA)
ENDIF
 END SUBROUTINE FVW_DestroyDiscState


subroutine FVW_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Dummy
   call RegPack(Buf, InData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA
   call RegPack(Buf, allocated(InData%UA))
   if (allocated(InData%UA)) then
      call RegPackBounds(Buf, 1, lbound(InData%UA), ubound(InData%UA))
      LB(1:1) = lbound(InData%UA)
      UB(1:1) = ubound(InData%UA)
      do i1 = LB(1), UB(1)
         call UA_PackDiscState(Buf, InData%UA(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Dummy
   call RegUnpack(Buf, OutData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA
   if (allocated(OutData%UA)) deallocate(OutData%UA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UA(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call UA_UnpackDiscState(Buf, OutData%UA(i1)) ! UA 
      end do
   end if
end subroutine
 SUBROUTINE FVW_CopyWng_ConstraintStateType( SrcWng_ConstraintStateTypeData, DstWng_ConstraintStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_ConstraintStateType), INTENT(IN) :: SrcWng_ConstraintStateTypeData
   TYPE(Wng_ConstraintStateType), INTENT(INOUT) :: DstWng_ConstraintStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_ConstraintStateType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_ConstraintStateTypeData%Gamma_LL)) THEN
  i1_l = LBOUND(SrcWng_ConstraintStateTypeData%Gamma_LL,1)
  i1_u = UBOUND(SrcWng_ConstraintStateTypeData%Gamma_LL,1)
  IF (.NOT. ALLOCATED(DstWng_ConstraintStateTypeData%Gamma_LL)) THEN 
    ALLOCATE(DstWng_ConstraintStateTypeData%Gamma_LL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_ConstraintStateTypeData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_ConstraintStateTypeData%Gamma_LL = SrcWng_ConstraintStateTypeData%Gamma_LL
ENDIF
 END SUBROUTINE FVW_CopyWng_ConstraintStateType

 SUBROUTINE FVW_DestroyWng_ConstraintStateType( Wng_ConstraintStateTypeData, ErrStat, ErrMsg )
  TYPE(Wng_ConstraintStateType), INTENT(INOUT) :: Wng_ConstraintStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_ConstraintStateType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_ConstraintStateTypeData%Gamma_LL)) THEN
  DEALLOCATE(Wng_ConstraintStateTypeData%Gamma_LL)
ENDIF
 END SUBROUTINE FVW_DestroyWng_ConstraintStateType


subroutine FVW_PackWng_ConstraintStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_ConstraintStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Gamma_LL
   call RegPack(Buf, allocated(InData%Gamma_LL))
   if (allocated(InData%Gamma_LL)) then
      call RegPackBounds(Buf, 1, lbound(InData%Gamma_LL), ubound(InData%Gamma_LL))
      call RegPack(Buf, InData%Gamma_LL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_ConstraintStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_ConstraintStateType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Gamma_LL
   if (allocated(OutData%Gamma_LL)) deallocate(OutData%Gamma_LL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Gamma_LL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_LL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Gamma_LL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FVW_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcConstrStateData%W)) THEN
  i1_l = LBOUND(SrcConstrStateData%W,1)
  i1_u = UBOUND(SrcConstrStateData%W,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%W)) THEN 
    ALLOCATE(DstConstrStateData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%W,1), UBOUND(SrcConstrStateData%W,1)
      CALL FVW_Copywng_constraintstatetype( SrcConstrStateData%W(i1), DstConstrStateData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstConstrStateData%residual = SrcConstrStateData%residual
 END SUBROUTINE FVW_CopyConstrState

 SUBROUTINE FVW_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ConstrStateData%W)) THEN
DO i1 = LBOUND(ConstrStateData%W,1), UBOUND(ConstrStateData%W,1)
  CALL FVW_DestroyWng_ConstraintStateType( ConstrStateData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%W)
ENDIF
 END SUBROUTINE FVW_DestroyConstrState


subroutine FVW_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_ConstraintStateType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! residual
   call RegPack(Buf, InData%residual)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_ConstraintStateType(Buf, OutData%W(i1)) ! W 
      end do
   end if
   ! residual
   call RegUnpack(Buf, OutData%residual)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(FVW_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%Dummy = SrcOtherStateData%Dummy
IF (ALLOCATED(SrcOtherStateData%UA)) THEN
  i1_l = LBOUND(SrcOtherStateData%UA,1)
  i1_u = UBOUND(SrcOtherStateData%UA,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%UA)) THEN 
    ALLOCATE(DstOtherStateData%UA(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%UA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%UA,1), UBOUND(SrcOtherStateData%UA,1)
      CALL UA_CopyOtherState( SrcOtherStateData%UA(i1), DstOtherStateData%UA(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE FVW_CopyOtherState

 SUBROUTINE FVW_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FVW_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%UA)) THEN
DO i1 = LBOUND(OtherStateData%UA,1), UBOUND(OtherStateData%UA,1)
  CALL UA_DestroyOtherState( OtherStateData%UA(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%UA)
ENDIF
 END SUBROUTINE FVW_DestroyOtherState


subroutine FVW_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Dummy
   call RegPack(Buf, InData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA
   call RegPack(Buf, allocated(InData%UA))
   if (allocated(InData%UA)) then
      call RegPackBounds(Buf, 1, lbound(InData%UA), ubound(InData%UA))
      LB(1:1) = lbound(InData%UA)
      UB(1:1) = ubound(InData%UA)
      do i1 = LB(1), UB(1)
         call UA_PackOtherState(Buf, InData%UA(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Dummy
   call RegUnpack(Buf, OutData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA
   if (allocated(OutData%UA)) deallocate(OutData%UA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UA(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call UA_UnpackOtherState(Buf, OutData%UA(i1)) ! UA 
      end do
   end if
end subroutine
 SUBROUTINE FVW_CopyWng_InitInputType( SrcWng_InitInputTypeData, DstWng_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Wng_InitInputType), INTENT(IN) :: SrcWng_InitInputTypeData
   TYPE(Wng_InitInputType), INTENT(INOUT) :: DstWng_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyWng_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcWng_InitInputTypeData%AFindx)) THEN
  i1_l = LBOUND(SrcWng_InitInputTypeData%AFindx,1)
  i1_u = UBOUND(SrcWng_InitInputTypeData%AFindx,1)
  i2_l = LBOUND(SrcWng_InitInputTypeData%AFindx,2)
  i2_u = UBOUND(SrcWng_InitInputTypeData%AFindx,2)
  IF (.NOT. ALLOCATED(DstWng_InitInputTypeData%AFindx)) THEN 
    ALLOCATE(DstWng_InitInputTypeData%AFindx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_InitInputTypeData%AFindx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_InitInputTypeData%AFindx = SrcWng_InitInputTypeData%AFindx
ENDIF
IF (ALLOCATED(SrcWng_InitInputTypeData%chord)) THEN
  i1_l = LBOUND(SrcWng_InitInputTypeData%chord,1)
  i1_u = UBOUND(SrcWng_InitInputTypeData%chord,1)
  IF (.NOT. ALLOCATED(DstWng_InitInputTypeData%chord)) THEN 
    ALLOCATE(DstWng_InitInputTypeData%chord(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_InitInputTypeData%chord.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_InitInputTypeData%chord = SrcWng_InitInputTypeData%chord
ENDIF
IF (ALLOCATED(SrcWng_InitInputTypeData%RElm)) THEN
  i1_l = LBOUND(SrcWng_InitInputTypeData%RElm,1)
  i1_u = UBOUND(SrcWng_InitInputTypeData%RElm,1)
  IF (.NOT. ALLOCATED(DstWng_InitInputTypeData%RElm)) THEN 
    ALLOCATE(DstWng_InitInputTypeData%RElm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstWng_InitInputTypeData%RElm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstWng_InitInputTypeData%RElm = SrcWng_InitInputTypeData%RElm
ENDIF
    DstWng_InitInputTypeData%iRotor = SrcWng_InitInputTypeData%iRotor
    DstWng_InitInputTypeData%UAOff_innerNode = SrcWng_InitInputTypeData%UAOff_innerNode
    DstWng_InitInputTypeData%UAOff_outerNode = SrcWng_InitInputTypeData%UAOff_outerNode
 END SUBROUTINE FVW_CopyWng_InitInputType

 SUBROUTINE FVW_DestroyWng_InitInputType( Wng_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Wng_InitInputType), INTENT(INOUT) :: Wng_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyWng_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Wng_InitInputTypeData%AFindx)) THEN
  DEALLOCATE(Wng_InitInputTypeData%AFindx)
ENDIF
IF (ALLOCATED(Wng_InitInputTypeData%chord)) THEN
  DEALLOCATE(Wng_InitInputTypeData%chord)
ENDIF
IF (ALLOCATED(Wng_InitInputTypeData%RElm)) THEN
  DEALLOCATE(Wng_InitInputTypeData%RElm)
ENDIF
 END SUBROUTINE FVW_DestroyWng_InitInputType


subroutine FVW_PackWng_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Wng_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackWng_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AFindx
   call RegPack(Buf, allocated(InData%AFindx))
   if (allocated(InData%AFindx)) then
      call RegPackBounds(Buf, 2, lbound(InData%AFindx), ubound(InData%AFindx))
      call RegPack(Buf, InData%AFindx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! chord
   call RegPack(Buf, allocated(InData%chord))
   if (allocated(InData%chord)) then
      call RegPackBounds(Buf, 1, lbound(InData%chord), ubound(InData%chord))
      call RegPack(Buf, InData%chord)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RElm
   call RegPack(Buf, allocated(InData%RElm))
   if (allocated(InData%RElm)) then
      call RegPackBounds(Buf, 1, lbound(InData%RElm), ubound(InData%RElm))
      call RegPack(Buf, InData%RElm)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! iRotor
   call RegPack(Buf, InData%iRotor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAOff_innerNode
   call RegPack(Buf, InData%UAOff_innerNode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAOff_outerNode
   call RegPack(Buf, InData%UAOff_outerNode)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackWng_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Wng_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackWng_InitInputType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AFindx
   if (allocated(OutData%AFindx)) deallocate(OutData%AFindx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFindx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFindx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFindx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! chord
   if (allocated(OutData%chord)) deallocate(OutData%chord)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%chord(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%chord)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RElm
   if (allocated(OutData%RElm)) deallocate(OutData%RElm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RElm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RElm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RElm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! iRotor
   call RegUnpack(Buf, OutData%iRotor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAOff_innerNode
   call RegUnpack(Buf, OutData%UAOff_innerNode)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAOff_outerNode
   call RegUnpack(Buf, OutData%UAOff_outerNode)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InitInputType), INTENT(INOUT) :: SrcInitInputData
   TYPE(FVW_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%FVWFileName = SrcInitInputData%FVWFileName
    DstInitInputData%RootName = SrcInitInputData%RootName
IF (ALLOCATED(SrcInitInputData%W)) THEN
  i1_l = LBOUND(SrcInitInputData%W,1)
  i1_u = UBOUND(SrcInitInputData%W,1)
  IF (.NOT. ALLOCATED(DstInitInputData%W)) THEN 
    ALLOCATE(DstInitInputData%W(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%W,1), UBOUND(SrcInitInputData%W,1)
      CALL FVW_Copywng_initinputtype( SrcInitInputData%W(i1), DstInitInputData%W(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInitInputData%WingsMesh)) THEN
  i1_l = LBOUND(SrcInitInputData%WingsMesh,1)
  i1_u = UBOUND(SrcInitInputData%WingsMesh,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WingsMesh)) THEN 
    ALLOCATE(DstInitInputData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%WingsMesh,1), UBOUND(SrcInitInputData%WingsMesh,1)
      CALL MeshCopy( SrcInitInputData%WingsMesh(i1), DstInitInputData%WingsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%numBladeNodes = SrcInitInputData%numBladeNodes
    DstInitInputData%DTaero = SrcInitInputData%DTaero
    DstInitInputData%KinVisc = SrcInitInputData%KinVisc
    DstInitInputData%MHK = SrcInitInputData%MHK
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%UAMod = SrcInitInputData%UAMod
    DstInitInputData%UA_Flag = SrcInitInputData%UA_Flag
    DstInitInputData%Flookup = SrcInitInputData%Flookup
    DstInitInputData%a_s = SrcInitInputData%a_s
    DstInitInputData%SumPrint = SrcInitInputData%SumPrint
 END SUBROUTINE FVW_CopyInitInput

 SUBROUTINE FVW_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FVW_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%W)) THEN
DO i1 = LBOUND(InitInputData%W,1), UBOUND(InitInputData%W,1)
  CALL FVW_DestroyWng_InitInputType( InitInputData%W(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InitInputData%W)
ENDIF
IF (ALLOCATED(InitInputData%WingsMesh)) THEN
DO i1 = LBOUND(InitInputData%WingsMesh,1), UBOUND(InitInputData%WingsMesh,1)
  CALL MeshDestroy( InitInputData%WingsMesh(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InitInputData%WingsMesh)
ENDIF
 END SUBROUTINE FVW_DestroyInitInput


subroutine FVW_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackInitInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! FVWFileName
   call RegPack(Buf, InData%FVWFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 1, lbound(InData%W), ubound(InData%W))
      LB(1:1) = lbound(InData%W)
      UB(1:1) = ubound(InData%W)
      do i1 = LB(1), UB(1)
         call FVW_PackWng_InitInputType(Buf, InData%W(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WingsMesh
   call RegPack(Buf, allocated(InData%WingsMesh))
   if (allocated(InData%WingsMesh)) then
      call RegPackBounds(Buf, 1, lbound(InData%WingsMesh), ubound(InData%WingsMesh))
      LB(1:1) = lbound(InData%WingsMesh)
      UB(1:1) = ubound(InData%WingsMesh)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%WingsMesh(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! numBladeNodes
   call RegPack(Buf, InData%numBladeNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTaero
   call RegPack(Buf, InData%DTaero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegPack(Buf, InData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAMod
   call RegPack(Buf, InData%UAMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA_Flag
   call RegPack(Buf, InData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Flookup
   call RegPack(Buf, InData%Flookup)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a_s
   call RegPack(Buf, InData%a_s)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegPack(Buf, InData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackInitInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! FVWFileName
   call RegUnpack(Buf, OutData%FVWFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackWng_InitInputType(Buf, OutData%W(i1)) ! W 
      end do
   end if
   ! WingsMesh
   if (allocated(OutData%WingsMesh)) deallocate(OutData%WingsMesh)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WingsMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WingsMesh.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%WingsMesh(i1)) ! WingsMesh 
      end do
   end if
   ! numBladeNodes
   call RegUnpack(Buf, OutData%numBladeNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTaero
   call RegUnpack(Buf, OutData%DTaero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAMod
   call RegUnpack(Buf, OutData%UAMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA_Flag
   call RegUnpack(Buf, OutData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Flookup
   call RegUnpack(Buf, OutData%Flookup)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a_s
   call RegUnpack(Buf, OutData%a_s)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(FVW_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%CircSolvMethod = SrcInputFileData%CircSolvMethod
    DstInputFileData%CirculationFile = SrcInputFileData%CirculationFile
    DstInputFileData%CircSolvMaxIter = SrcInputFileData%CircSolvMaxIter
    DstInputFileData%CircSolvConvCrit = SrcInputFileData%CircSolvConvCrit
    DstInputFileData%CircSolvRelaxation = SrcInputFileData%CircSolvRelaxation
    DstInputFileData%IntMethod = SrcInputFileData%IntMethod
    DstInputFileData%FreeWake = SrcInputFileData%FreeWake
    DstInputFileData%FreeWakeStart = SrcInputFileData%FreeWakeStart
    DstInputFileData%FullCircStart = SrcInputFileData%FullCircStart
    DstInputFileData%DTfvw = SrcInputFileData%DTfvw
    DstInputFileData%CircSolvPolar = SrcInputFileData%CircSolvPolar
    DstInputFileData%nNWPanels = SrcInputFileData%nNWPanels
    DstInputFileData%nNWPanelsFree = SrcInputFileData%nNWPanelsFree
    DstInputFileData%nFWPanels = SrcInputFileData%nFWPanels
    DstInputFileData%nFWPanelsFree = SrcInputFileData%nFWPanelsFree
    DstInputFileData%FWShedVorticity = SrcInputFileData%FWShedVorticity
    DstInputFileData%DiffusionMethod = SrcInputFileData%DiffusionMethod
    DstInputFileData%CoreSpreadEddyVisc = SrcInputFileData%CoreSpreadEddyVisc
    DstInputFileData%RegDeterMethod = SrcInputFileData%RegDeterMethod
    DstInputFileData%RegFunction = SrcInputFileData%RegFunction
    DstInputFileData%WakeRegMethod = SrcInputFileData%WakeRegMethod
    DstInputFileData%WakeRegParam = SrcInputFileData%WakeRegParam
    DstInputFileData%WingRegParam = SrcInputFileData%WingRegParam
    DstInputFileData%ShearModel = SrcInputFileData%ShearModel
    DstInputFileData%TwrShadowOnWake = SrcInputFileData%TwrShadowOnWake
    DstInputFileData%VelocityMethod = SrcInputFileData%VelocityMethod
    DstInputFileData%TreeBranchFactor = SrcInputFileData%TreeBranchFactor
    DstInputFileData%PartPerSegment = SrcInputFileData%PartPerSegment
    DstInputFileData%WrVTK = SrcInputFileData%WrVTK
    DstInputFileData%VTKBlades = SrcInputFileData%VTKBlades
    DstInputFileData%DTvtk = SrcInputFileData%DTvtk
    DstInputFileData%VTKCoord = SrcInputFileData%VTKCoord
 END SUBROUTINE FVW_CopyInputFile

 SUBROUTINE FVW_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(FVW_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE FVW_DestroyInputFile


subroutine FVW_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackInputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   ! CircSolvMethod
   call RegPack(Buf, InData%CircSolvMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CirculationFile
   call RegPack(Buf, InData%CirculationFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvMaxIter
   call RegPack(Buf, InData%CircSolvMaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvConvCrit
   call RegPack(Buf, InData%CircSolvConvCrit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvRelaxation
   call RegPack(Buf, InData%CircSolvRelaxation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IntMethod
   call RegPack(Buf, InData%IntMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeWake
   call RegPack(Buf, InData%FreeWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeWakeStart
   call RegPack(Buf, InData%FreeWakeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FullCircStart
   call RegPack(Buf, InData%FullCircStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTfvw
   call RegPack(Buf, InData%DTfvw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvPolar
   call RegPack(Buf, InData%CircSolvPolar)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWPanels
   call RegPack(Buf, InData%nNWPanels)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWPanelsFree
   call RegPack(Buf, InData%nNWPanelsFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWPanels
   call RegPack(Buf, InData%nFWPanels)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWPanelsFree
   call RegPack(Buf, InData%nFWPanelsFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FWShedVorticity
   call RegPack(Buf, InData%FWShedVorticity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffusionMethod
   call RegPack(Buf, InData%DiffusionMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CoreSpreadEddyVisc
   call RegPack(Buf, InData%CoreSpreadEddyVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegDeterMethod
   call RegPack(Buf, InData%RegDeterMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegFunction
   call RegPack(Buf, InData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegMethod
   call RegPack(Buf, InData%WakeRegMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegParam
   call RegPack(Buf, InData%WakeRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WingRegParam
   call RegPack(Buf, InData%WingRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShearModel
   call RegPack(Buf, InData%ShearModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadowOnWake
   call RegPack(Buf, InData%TwrShadowOnWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelocityMethod
   call RegPack(Buf, InData%VelocityMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TreeBranchFactor
   call RegPack(Buf, InData%TreeBranchFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PartPerSegment
   call RegPack(Buf, InData%PartPerSegment)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrVTK
   call RegPack(Buf, InData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKBlades
   call RegPack(Buf, InData%VTKBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTvtk
   call RegPack(Buf, InData%DTvtk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKCoord
   call RegPack(Buf, InData%VTKCoord)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackInputFile'
   if (Buf%ErrStat /= ErrID_None) return
   ! CircSolvMethod
   call RegUnpack(Buf, OutData%CircSolvMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CirculationFile
   call RegUnpack(Buf, OutData%CirculationFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvMaxIter
   call RegUnpack(Buf, OutData%CircSolvMaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvConvCrit
   call RegUnpack(Buf, OutData%CircSolvConvCrit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvRelaxation
   call RegUnpack(Buf, OutData%CircSolvRelaxation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IntMethod
   call RegUnpack(Buf, OutData%IntMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeWake
   call RegUnpack(Buf, OutData%FreeWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeWakeStart
   call RegUnpack(Buf, OutData%FreeWakeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FullCircStart
   call RegUnpack(Buf, OutData%FullCircStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTfvw
   call RegUnpack(Buf, OutData%DTfvw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CircSolvPolar
   call RegUnpack(Buf, OutData%CircSolvPolar)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWPanels
   call RegUnpack(Buf, OutData%nNWPanels)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNWPanelsFree
   call RegUnpack(Buf, OutData%nNWPanelsFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWPanels
   call RegUnpack(Buf, OutData%nFWPanels)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFWPanelsFree
   call RegUnpack(Buf, OutData%nFWPanelsFree)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FWShedVorticity
   call RegUnpack(Buf, OutData%FWShedVorticity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffusionMethod
   call RegUnpack(Buf, OutData%DiffusionMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CoreSpreadEddyVisc
   call RegUnpack(Buf, OutData%CoreSpreadEddyVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegDeterMethod
   call RegUnpack(Buf, OutData%RegDeterMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RegFunction
   call RegUnpack(Buf, OutData%RegFunction)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegMethod
   call RegUnpack(Buf, OutData%WakeRegMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeRegParam
   call RegUnpack(Buf, OutData%WakeRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WingRegParam
   call RegUnpack(Buf, OutData%WingRegParam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShearModel
   call RegUnpack(Buf, OutData%ShearModel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadowOnWake
   call RegUnpack(Buf, OutData%TwrShadowOnWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelocityMethod
   call RegUnpack(Buf, OutData%VelocityMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TreeBranchFactor
   call RegUnpack(Buf, OutData%TreeBranchFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PartPerSegment
   call RegUnpack(Buf, OutData%PartPerSegment)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrVTK
   call RegUnpack(Buf, OutData%WrVTK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKBlades
   call RegUnpack(Buf, OutData%VTKBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTvtk
   call RegUnpack(Buf, OutData%DTvtk)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VTKCoord
   call RegUnpack(Buf, OutData%VTKCoord)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FVW_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(FVW_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%Dummy = SrcInitOutputData%Dummy
 END SUBROUTINE FVW_CopyInitOutput

 SUBROUTINE FVW_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FVW_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE FVW_DestroyInitOutput


subroutine FVW_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FVW_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FVW_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Dummy
   call RegPack(Buf, InData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FVW_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FVW_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FVW_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Dummy
   call RegUnpack(Buf, OutData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

 SUBROUTINE FVW_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FVW_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL FVW_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FVW_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FVW_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FVW_Input_ExtrapInterp


 SUBROUTINE FVW_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(FVW_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FVW_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%rotors) .AND. ALLOCATED(u1%rotors)) THEN
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i2 = LBOUND(u_out%rotors(i01)%HubOrientation,2),UBOUND(u_out%rotors(i01)%HubOrientation,2)
    DO i1 = LBOUND(u_out%rotors(i01)%HubOrientation,1),UBOUND(u_out%rotors(i01)%HubOrientation,1)
      b = -(u1%rotors(i01)%HubOrientation(i1,i2) - u2%rotors(i01)%HubOrientation(i1,i2))
      u_out%rotors(i01)%HubOrientation(i1,i2) = u1%rotors(i01)%HubOrientation(i1,i2) + b * ScaleFactor
    END DO
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%HubPosition,1),UBOUND(u_out%rotors(i01)%HubPosition,1)
    b = -(u1%rotors(i01)%HubPosition(i1) - u2%rotors(i01)%HubPosition(i1))
    u_out%rotors(i01)%HubPosition(i1) = u1%rotors(i01)%HubPosition(i1) + b * ScaleFactor
  END DO
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%W) .AND. ALLOCATED(u1%W)) THEN
  DO i01 = LBOUND(u_out%W,1),UBOUND(u_out%W,1)
IF (ALLOCATED(u_out%W(i01)%Vwnd_LL) .AND. ALLOCATED(u1%W(i01)%Vwnd_LL)) THEN
  DO i2 = LBOUND(u_out%W(i01)%Vwnd_LL,2),UBOUND(u_out%W(i01)%Vwnd_LL,2)
    DO i1 = LBOUND(u_out%W(i01)%Vwnd_LL,1),UBOUND(u_out%W(i01)%Vwnd_LL,1)
      b = -(u1%W(i01)%Vwnd_LL(i1,i2) - u2%W(i01)%Vwnd_LL(i1,i2))
      u_out%W(i01)%Vwnd_LL(i1,i2) = u1%W(i01)%Vwnd_LL(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%W,1),UBOUND(u_out%W,1)
IF (ALLOCATED(u_out%W(i01)%omega_z) .AND. ALLOCATED(u1%W(i01)%omega_z)) THEN
  DO i1 = LBOUND(u_out%W(i01)%omega_z,1),UBOUND(u_out%W(i01)%omega_z,1)
    b = -(u1%W(i01)%omega_z(i1) - u2%W(i01)%omega_z(i1))
    u_out%W(i01)%omega_z(i1) = u1%W(i01)%omega_z(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%WingsMesh) .AND. ALLOCATED(u1%WingsMesh)) THEN
  DO i1 = LBOUND(u_out%WingsMesh,1),UBOUND(u_out%WingsMesh,1)
      CALL MeshExtrapInterp1(u1%WingsMesh(i1), u2%WingsMesh(i1), tin, u_out%WingsMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%V_wind) .AND. ALLOCATED(u1%V_wind)) THEN
  DO i2 = LBOUND(u_out%V_wind,2),UBOUND(u_out%V_wind,2)
    DO i1 = LBOUND(u_out%V_wind,1),UBOUND(u_out%V_wind,1)
      b = -(u1%V_wind(i1,i2) - u2%V_wind(i1,i2))
      u_out%V_wind(i1,i2) = u1%V_wind(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE FVW_Input_ExtrapInterp1


 SUBROUTINE FVW_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(FVW_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(FVW_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FVW_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%rotors) .AND. ALLOCATED(u1%rotors)) THEN
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i2 = LBOUND(u_out%rotors(i01)%HubOrientation,2),UBOUND(u_out%rotors(i01)%HubOrientation,2)
    DO i1 = LBOUND(u_out%rotors(i01)%HubOrientation,1),UBOUND(u_out%rotors(i01)%HubOrientation,1)
      b = (t(3)**2*(u1%rotors(i01)%HubOrientation(i1,i2) - u2%rotors(i01)%HubOrientation(i1,i2)) + t(2)**2*(-u1%rotors(i01)%HubOrientation(i1,i2) + u3%rotors(i01)%HubOrientation(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rotors(i01)%HubOrientation(i1,i2) + t(3)*u2%rotors(i01)%HubOrientation(i1,i2) - t(2)*u3%rotors(i01)%HubOrientation(i1,i2) ) * scaleFactor
      u_out%rotors(i01)%HubOrientation(i1,i2) = u1%rotors(i01)%HubOrientation(i1,i2) + b  + c * t_out
    END DO
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%HubPosition,1),UBOUND(u_out%rotors(i01)%HubPosition,1)
    b = (t(3)**2*(u1%rotors(i01)%HubPosition(i1) - u2%rotors(i01)%HubPosition(i1)) + t(2)**2*(-u1%rotors(i01)%HubPosition(i1) + u3%rotors(i01)%HubPosition(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%HubPosition(i1) + t(3)*u2%rotors(i01)%HubPosition(i1) - t(2)*u3%rotors(i01)%HubPosition(i1) ) * scaleFactor
    u_out%rotors(i01)%HubPosition(i1) = u1%rotors(i01)%HubPosition(i1) + b  + c * t_out
  END DO
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%W) .AND. ALLOCATED(u1%W)) THEN
  DO i01 = LBOUND(u_out%W,1),UBOUND(u_out%W,1)
IF (ALLOCATED(u_out%W(i01)%Vwnd_LL) .AND. ALLOCATED(u1%W(i01)%Vwnd_LL)) THEN
  DO i2 = LBOUND(u_out%W(i01)%Vwnd_LL,2),UBOUND(u_out%W(i01)%Vwnd_LL,2)
    DO i1 = LBOUND(u_out%W(i01)%Vwnd_LL,1),UBOUND(u_out%W(i01)%Vwnd_LL,1)
      b = (t(3)**2*(u1%W(i01)%Vwnd_LL(i1,i2) - u2%W(i01)%Vwnd_LL(i1,i2)) + t(2)**2*(-u1%W(i01)%Vwnd_LL(i1,i2) + u3%W(i01)%Vwnd_LL(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%W(i01)%Vwnd_LL(i1,i2) + t(3)*u2%W(i01)%Vwnd_LL(i1,i2) - t(2)*u3%W(i01)%Vwnd_LL(i1,i2) ) * scaleFactor
      u_out%W(i01)%Vwnd_LL(i1,i2) = u1%W(i01)%Vwnd_LL(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%W,1),UBOUND(u_out%W,1)
IF (ALLOCATED(u_out%W(i01)%omega_z) .AND. ALLOCATED(u1%W(i01)%omega_z)) THEN
  DO i1 = LBOUND(u_out%W(i01)%omega_z,1),UBOUND(u_out%W(i01)%omega_z,1)
    b = (t(3)**2*(u1%W(i01)%omega_z(i1) - u2%W(i01)%omega_z(i1)) + t(2)**2*(-u1%W(i01)%omega_z(i1) + u3%W(i01)%omega_z(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%W(i01)%omega_z(i1) + t(3)*u2%W(i01)%omega_z(i1) - t(2)*u3%W(i01)%omega_z(i1) ) * scaleFactor
    u_out%W(i01)%omega_z(i1) = u1%W(i01)%omega_z(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%WingsMesh) .AND. ALLOCATED(u1%WingsMesh)) THEN
  DO i1 = LBOUND(u_out%WingsMesh,1),UBOUND(u_out%WingsMesh,1)
      CALL MeshExtrapInterp2(u1%WingsMesh(i1), u2%WingsMesh(i1), u3%WingsMesh(i1), tin, u_out%WingsMesh(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%V_wind) .AND. ALLOCATED(u1%V_wind)) THEN
  DO i2 = LBOUND(u_out%V_wind,2),UBOUND(u_out%V_wind,2)
    DO i1 = LBOUND(u_out%V_wind,1),UBOUND(u_out%V_wind,1)
      b = (t(3)**2*(u1%V_wind(i1,i2) - u2%V_wind(i1,i2)) + t(2)**2*(-u1%V_wind(i1,i2) + u3%V_wind(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%V_wind(i1,i2) + t(3)*u2%V_wind(i1,i2) - t(2)*u3%V_wind(i1,i2) ) * scaleFactor
      u_out%V_wind(i1,i2) = u1%V_wind(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE FVW_Input_ExtrapInterp2


 SUBROUTINE FVW_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FVW_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL FVW_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FVW_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FVW_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FVW_Output_ExtrapInterp


 SUBROUTINE FVW_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(FVW_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FVW_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%W) .AND. ALLOCATED(y1%W)) THEN
  DO i01 = LBOUND(y_out%W,1),UBOUND(y_out%W,1)
IF (ALLOCATED(y_out%W(i01)%Vind) .AND. ALLOCATED(y1%W(i01)%Vind)) THEN
  DO i2 = LBOUND(y_out%W(i01)%Vind,2),UBOUND(y_out%W(i01)%Vind,2)
    DO i1 = LBOUND(y_out%W(i01)%Vind,1),UBOUND(y_out%W(i01)%Vind,1)
      b = -(y1%W(i01)%Vind(i1,i2) - y2%W(i01)%Vind(i1,i2))
      y_out%W(i01)%Vind(i1,i2) = y1%W(i01)%Vind(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
 END SUBROUTINE FVW_Output_ExtrapInterp1


 SUBROUTINE FVW_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(FVW_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(FVW_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FVW_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%W) .AND. ALLOCATED(y1%W)) THEN
  DO i01 = LBOUND(y_out%W,1),UBOUND(y_out%W,1)
IF (ALLOCATED(y_out%W(i01)%Vind) .AND. ALLOCATED(y1%W(i01)%Vind)) THEN
  DO i2 = LBOUND(y_out%W(i01)%Vind,2),UBOUND(y_out%W(i01)%Vind,2)
    DO i1 = LBOUND(y_out%W(i01)%Vind,1),UBOUND(y_out%W(i01)%Vind,1)
      b = (t(3)**2*(y1%W(i01)%Vind(i1,i2) - y2%W(i01)%Vind(i1,i2)) + t(2)**2*(-y1%W(i01)%Vind(i1,i2) + y3%W(i01)%Vind(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*y1%W(i01)%Vind(i1,i2) + t(3)*y2%W(i01)%Vind(i1,i2) - t(2)*y3%W(i01)%Vind(i1,i2) ) * scaleFactor
      y_out%W(i01)%Vind(i1,i2) = y1%W(i01)%Vind(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
 END SUBROUTINE FVW_Output_ExtrapInterp2

END MODULE FVW_Types
!ENDOFREGISTRYGENERATEDFILE
