!STARTOFREGISTRYGENERATEDFILE 'AeroDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn_Types
!.................................................................................................................................
! This file is part of AeroDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE BEMT_Types
USE FVW_Types
USE AeroAcoustics_Types
USE InflowWind_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: ModelUnknown = -1      !  [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_none = 0      ! Wake model - none [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_BEMT = 1      ! Wake model - BEMT (blade elememnt momentum theory) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_DBEMT = 2      ! Wake model - DBEMT (dynamic elememnt momentum theory) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: WakeMod_FVW = 3      ! Wake model - FVW (free vortex wake, OLAF) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AFAeroMod_steady = 1      ! steady model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AFAeroMod_BL_unsteady = 2      ! Beddoes-Leishman unsteady model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrPotent_none = 0      ! no tower potential flow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrPotent_baseline = 1      ! baseline tower potential flow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrPotent_Bak = 2      ! tower potential flow with Bak correction [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrShadow_none = 0      ! no tower shadow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrShadow_Powles = 1      ! Powles tower shadow model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TwrShadow_Eames = 2      ! Eames tower shadow model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinAero_none = 0      ! no tail fin aero [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinAero_polar = 1      ! polar-based tail fin aerodynamics [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinAero_USB = 2      ! unsteady slender body tail fin aerodynamics model [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinIndMod_none = 0      ! no induction [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: TFinIndMod_rotavg = 1      ! rotor averaged induction [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: APM_BEM_NoSweepPitchTwist = 1      ! Original AeroDyn model where momentum balance is done in the WithoutSweepPitchTwist system [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: APM_BEM_Polar = 2      ! Use staggered polar grid for momentum balance in each annulus [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: APM_LiftingLine = 3      ! Use the blade lifting line (i.e. the structural) orientation (currently for OLAF with VAWT) [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: AD_MaxBl_Out = 3      ! Maximum number of blades for information output (or linearization) [-]
! =========  TFinParameterType  =======
  TYPE, PUBLIC :: TFinParameterType
    INTEGER(IntKi)  :: TFinMod      !< Tail fin aerodynamics model {0=none, 1=polar-based, 2=USB-based} [(switch)]
    REAL(ReKi)  :: TFinChord      !< Tail fin chord [used only when TFinMod=1] [m]
    REAL(ReKi)  :: TFinArea      !< Tail fin planform area [used only when TFinMod=1] [m^2]
    INTEGER(IntKi)  :: TFinIndMod      !< Model for induced velocity calculation {0=none, 1=rotor-average} [(switch)]
    INTEGER(IntKi)  :: TFinAFID      !< Index of Tail fin airfoil number [1 to NumAFfiles] [-]
  END TYPE TFinParameterType
! =======================
! =========  TFinInputFileType  =======
  TYPE, PUBLIC :: TFinInputFileType
    INTEGER(IntKi)  :: TFinMod      !< Tail fin aerodynamics model {0=none, 1=polar-based, 2=USB-based} [(switch)]
    REAL(ReKi)  :: TFinChord      !< Tail fin chord [used only when TFinMod=1] [m]
    REAL(ReKi)  :: TFinArea      !< Tail fin planform area [used only when TFinMod=1] [m^2]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinRefP_n      !< Undeflected position of the tail fin reference point wrt the tower top [m]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinAngles      !< Tail fin chordline skew, tilt, and bank angles about the reference point [(deg)]
    INTEGER(IntKi)  :: TFinIndMod      !< Model for induced velocity calculation {0=none, 1=rotor-average} [(switch)]
    INTEGER(IntKi)  :: TFinAFID      !< Index of Tail fin airfoil number [1 to NumAFfiles] [-]
  END TYPE TFinInputFileType
! =======================
! =========  AD_VTK_BLSurfaceType  =======
  TYPE, PUBLIC :: AD_VTK_BLSurfaceType
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AirfoilCoords      !< x,y coordinates for airfoil around each blade node on a blade (relative to reference) [-]
  END TYPE AD_VTK_BLSurfaceType
! =======================
! =========  AD_VTK_RotSurfaceType  =======
  TYPE, PUBLIC :: AD_VTK_RotSurfaceType
    TYPE(AD_VTK_BLSurfaceType) , DIMENSION(:), ALLOCATABLE  :: BladeShape      !< AirfoilCoords for each blade [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: TowerRad      !< radius of each ED tower node [m]
  END TYPE AD_VTK_RotSurfaceType
! =======================
! =========  RotInitInputType  =======
  TYPE, PUBLIC :: RotInitInputType
    INTEGER(IntKi)  :: NumBlades      !< Number of blades on the turbine [-]
    REAL(ReKi) , DIMENSION(1:3)  :: HubPosition      !< X-Y-Z reference position of hub [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: HubOrientation      !< DCM reference orientation of hub [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BladeRootPosition      !< X-Y-Z reference position of each blade root (3 x NumBlades) [m]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: BladeRootOrientation      !< DCM reference orientation of blade roots (3x3 x NumBlades) [-]
    REAL(R8Ki) , DIMENSION(1:3)  :: NacellePosition      !< X-Y-Z reference position of nacelle [m]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: NacelleOrientation      !< DCM reference orientation of nacelle [-]
    INTEGER(IntKi)  :: AeroProjMod = 1      !< Flag to switch between different projection models [-]
    INTEGER(IntKi)  :: AeroBEM_Mod = -1      !< Flag to switch between different BEM Model [-]
  END TYPE RotInitInputType
! =======================
! =========  AD_InitInputType  =======
  TYPE, PUBLIC :: AD_InitInputType
    TYPE(RotInitInputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Init Input Types for rotors [-]
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    LOGICAL  :: UsePrimaryInputFile = .TRUE.      !< Read input file instead of passed data [-]
    TYPE(FileInfoType)  :: PassedPrimaryInputData      !< Primary input file as FileInfoType (set by driver/glue code) [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
    REAL(ReKi)  :: Gravity      !< Gravity force [Nm/s^2]
    INTEGER(IntKi)  :: MHK      !< MHK turbine type switch [-]
    REAL(ReKi)  :: defFldDens      !< Default fluid density from the driver; may be overwritten [kg/m^3]
    REAL(ReKi)  :: defKinVisc      !< Default kinematic viscosity from the driver; may be overwritten [m^2/s]
    REAL(ReKi)  :: defSpdSound      !< Default speed of sound from the driver; may be overwritten [m/s]
    REAL(ReKi)  :: defPatm      !< Default atmospheric pressure from the driver; may be overwritten [Pa]
    REAL(ReKi)  :: defPvap      !< Default vapor pressure from the driver; may be overwritten [Pa]
    REAL(ReKi)  :: WtrDpth      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL      !< Offset between still-water level and mean sea level [m]
  END TYPE AD_InitInputType
! =======================
! =========  AD_BladePropsType  =======
  TYPE, PUBLIC :: AD_BladePropsType
    INTEGER(IntKi)  :: NumBlNds      !< Number of blade nodes used in the analysis [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlSpn      !< Span at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCrvAC      !< Curve at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlSwpAC      !< Sweep at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCrvAng      !< Curve angle at blade node [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlTwist      !< Twist at blade node [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlChord      !< Chord at blade node [m]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BlAFID      !< ID of Airfoil at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCb      !< Coefficient of buoyancy at blade node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCenBn      !< Center of buoyancy normal offset at blade node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BlCenBt      !< Center of buoyancy tangential offset at blade node [m]
  END TYPE AD_BladePropsType
! =======================
! =========  AD_BladeShape  =======
  TYPE, PUBLIC :: AD_BladeShape
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AirfoilCoords      !< x-y coordinates for airfoils, relative to node [m]
  END TYPE AD_BladeShape
! =======================
! =========  RotInitOutputType  =======
  TYPE, PUBLIC :: RotInitOutputType
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output-to-file channels [-]
    TYPE(AD_BladeShape) , DIMENSION(:), ALLOCATABLE  :: BladeShape      !< airfoil coordinates for each blade [m]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the continuous states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Flag that tells FAST/MBC3 if the outputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Flag that tells FAST/MBC3 if the continuous states used in linearization are in the rotating frame (not used for glue) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
    TYPE(AD_BladePropsType) , DIMENSION(:), ALLOCATABLE  :: BladeProps      !< blade property information from blade input files [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrElev      !< Elevation at tower node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDiam      !< Diameter of tower at node [m]
  END TYPE RotInitOutputType
! =======================
! =========  AD_InitOutputType  =======
  TYPE, PUBLIC :: AD_InitOutputType
    TYPE(RotInitOutputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Rotor init output type [-]
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
  END TYPE AD_InitOutputType
! =======================
! =========  RotInputFile  =======
  TYPE, PUBLIC :: RotInputFile
    TYPE(AD_BladePropsType) , DIMENSION(:), ALLOCATABLE  :: BladeProps      !< blade property information from blade input files [-]
    INTEGER(IntKi)  :: NumTwrNds      !< Number of tower nodes used in the analysis [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrElev      !< Elevation at tower node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDiam      !< Diameter of tower at node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCd      !< Coefficient of drag at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrTI      !< Turbulence intensity for tower shadow at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCb      !< Coefficient of buoyancy at tower node [-]
    REAL(ReKi)  :: VolHub      !< Hub volume [m^3]
    REAL(ReKi)  :: HubCenBx      !< Hub center of buoyancy x direction offset [m]
    REAL(ReKi)  :: VolNac      !< Nacelle volume [m^3]
    REAL(ReKi) , DIMENSION(1:3)  :: NacCenB      !< Position of nacelle center of buoyancy from yaw bearing in nacelle coordinates [m]
    LOGICAL  :: TFinAero = .FALSE.      !< Calculate tail fin aerodynamics model (flag) [flag]
    CHARACTER(1024)  :: TFinFile      !< Input file for tail fin aerodynamics [used only when TFinAero=True] [-]
    TYPE(TFinInputFileType)  :: TFin      !< Input file data for tail fin [-]
  END TYPE RotInputFile
! =======================
! =========  AD_InputFile  =======
  TYPE, PUBLIC :: AD_InputFile
    LOGICAL  :: Echo      !< Echo input file to echo file [-]
    REAL(DbKi)  :: DTAero      !< Time interval for aerodynamic calculations {or "default"} [s]
    INTEGER(IntKi)  :: WakeMod      !< Type of wake/induction model {0=none, 1=BEMT, 2=DBEMT, 3=FVW} [-]
    INTEGER(IntKi)  :: AFAeroMod      !< Type of blade airfoil aerodynamics model {1=steady model, 2=Beddoes-Leishman unsteady model} [-]
    INTEGER(IntKi)  :: TwrPotent      !< Type of tower influence on wind based on potential flow around the tower {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} [-]
    INTEGER(IntKi)  :: TwrShadow      !< Type of tower influence on wind based on downstream tower shadow {0=none, 1=Powles model, 2=Eames model} [-]
    LOGICAL  :: TwrAero      !< Calculate tower aerodynamic loads? [flag]
    LOGICAL  :: FrozenWake      !< Flag that tells this module it should assume a frozen wake during linearization. [-]
    LOGICAL  :: CavitCheck      !< Flag that tells us if we want to check for cavitation [-]
    LOGICAL  :: Buoyancy      !< Include buoyancy effects? [flag]
    LOGICAL  :: CompAA      !< Compute AeroAcoustic noise [flag]
    CHARACTER(1024)  :: AA_InputFile      !< AeroAcoustics input file name [quoted strings]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: ADBlFile      !< AD blade file (NumBl filenames) [quoted strings]
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    REAL(ReKi)  :: Patm      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap      !< Vapour pressure [Pa]
    REAL(ReKi)  :: SpdSound      !< Speed of sound [m/s]
    INTEGER(IntKi)  :: SkewMod      !< Type of skewed-wake correction model {0=orthogonal, 1=uncoupled, 2=Pitt/Peters, 3=coupled} [unused when WakeMod=0] [-]
    REAL(ReKi)  :: SkewModFactor      !< Constant used in Pitt/Peters skewed wake model (default is 15*pi/32) [-]
    LOGICAL  :: TipLoss      !< Use the Prandtl tip-loss model? [unused when WakeMod=0] [flag]
    LOGICAL  :: HubLoss      !< Use the Prandtl hub-loss model? [unused when WakeMod=0] [flag]
    LOGICAL  :: TanInd      !< Include tangential induction in BEMT calculations? [unused when WakeMod=0] [flag]
    LOGICAL  :: AIDrag      !< Include the drag term in the axial-induction calculation? [unused when WakeMod=0] [flag]
    LOGICAL  :: TIDrag      !< Include the drag term in the tangential-induction calculation? [unused when WakeMod=0 or TanInd=FALSE] [flag]
    REAL(ReKi)  :: IndToler      !< Convergence tolerance for BEM induction factors [unused when WakeMod=0] [-]
    REAL(ReKi)  :: MaxIter      !< Maximum number of iteration steps [unused when WakeMod=0] [-]
    INTEGER(IntKi)  :: UAMod      !< Unsteady Aero Model Switch (switch) {1=Baseline model (Original), 2=Gonzalez's variant (changes in Cn,Cc,Cm), 3=Minnema/Pierce variant (changes in Cc and Cm)} [used only when AFAeroMod=2] [-]
    LOGICAL  :: FLookup      !< Flag to indicate whether a lookup for f' will be calculated (TRUE) or whether best-fit exponential equations will be used (FALSE); if FALSE S1-S4 must be provided in airfoil input files [used only when AFAeroMod=2] [flag]
    REAL(ReKi)  :: InCol_Alfa      !< The column in the airfoil tables that contains the angle of attack [-]
    REAL(ReKi)  :: InCol_Cl      !< The column in the airfoil tables that contains the lift coefficient [-]
    REAL(ReKi)  :: InCol_Cd      !< The column in the airfoil tables that contains the drag coefficient [-]
    REAL(ReKi)  :: InCol_Cm      !< The column in the airfoil tables that contains the pitching-moment coefficient; use zero if there is no Cm column [-]
    REAL(ReKi)  :: InCol_Cpmin      !< The column in the airfoil tables that contains the drag coefficient; use zero if there is no Cpmin column [-]
    INTEGER(IntKi)  :: AFTabMod      !< Interpolation method for multiple airfoil tables {1 = 1D on AoA (only first table is used); 2 = 2D on AoA and Re; 3 = 2D on AoA and UserProp} [-]
    INTEGER(IntKi)  :: NumAFfiles      !< Number of airfoil files used [-]
    CHARACTER(1024)  :: FVWFileName      !< FVW input filename [quoted string]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: AFNames      !< Airfoil file names (NumAF lines) [quoted strings]
    LOGICAL  :: UseBlCm      !< Include aerodynamic pitching moment in calculations? [flag]
    LOGICAL  :: SumPrint      !< Generate a summary file listing input options and interpolated properties to "<rootname>.AD.sum"? [flag]
    INTEGER(IntKi)  :: NBlOuts      !< Number of blade node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: BlOutNd      !< Blade nodes whose values will be output [-]
    INTEGER(IntKi)  :: NTwOuts      !< Number of tower node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: TwOutNd      !< Tower nodes whose values will be output [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< List of user-requested output channels [-]
    REAL(ReKi)  :: tau1_const      !< time constant for DBEMT [used only when WakeMod=2 and DBEMT_Mod/=2] [s]
    INTEGER(IntKi)  :: DBEMT_Mod      !< Type of dynamic BEMT (DBEMT) model {1=constant tau1, 2=time-dependent tau1} [-]
    INTEGER(IntKi)  :: BldNd_NumOuts      !< Number of requested output channels per blade node (AD_AllBldNdOuts) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: BldNd_OutList      !< List of user-requested output channels (AD_AllBldNdOuts) [-]
    CHARACTER(1024)  :: BldNd_BlOutNd_Str      !< String to parse for the blade nodes to actually output (AD_AllBldNdOuts) [-]
    INTEGER(IntKi)  :: BldNd_BladesOut      !< The blades to output (AD_AllBldNdOuts) [-]
    REAL(ReKi)  :: UAStartRad      !< Starting [radius]
    REAL(ReKi)  :: UAEndRad      !< Ending [radius]
    TYPE(RotInputFile) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Rotor (blades and tower) input file data [-]
  END TYPE AD_InputFile
! =======================
! =========  RotContinuousStateType  =======
  TYPE, PUBLIC :: RotContinuousStateType
    TYPE(BEMT_ContinuousStateType)  :: BEMT      !< Continuous states from the BEMT module [-]
    TYPE(AA_ContinuousStateType)  :: AA      !< Continuous states from the AA module [-]
  END TYPE RotContinuousStateType
! =======================
! =========  AD_ContinuousStateType  =======
  TYPE, PUBLIC :: AD_ContinuousStateType
    TYPE(RotContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Continuous states for each rotor [-]
    TYPE(FVW_ContinuousStateType)  :: FVW      !< Continuous states from the FVW module [-]
  END TYPE AD_ContinuousStateType
! =======================
! =========  RotDiscreteStateType  =======
  TYPE, PUBLIC :: RotDiscreteStateType
    TYPE(BEMT_DiscreteStateType)  :: BEMT      !< Discrete states from the BEMT module [-]
    TYPE(AA_DiscreteStateType)  :: AA      !< Discrete states from the AA module [-]
  END TYPE RotDiscreteStateType
! =======================
! =========  AD_DiscreteStateType  =======
  TYPE, PUBLIC :: AD_DiscreteStateType
    TYPE(RotDiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Discrete states for each rotor [-]
    TYPE(FVW_DiscreteStateType)  :: FVW      !< Discrete states from the FVW module [-]
  END TYPE AD_DiscreteStateType
! =======================
! =========  RotConstraintStateType  =======
  TYPE, PUBLIC :: RotConstraintStateType
    TYPE(BEMT_ConstraintStateType)  :: BEMT      !< Constraint states from the BEMT module [-]
    TYPE(AA_ConstraintStateType)  :: AA      !< Constraint states from the AA module [-]
  END TYPE RotConstraintStateType
! =======================
! =========  AD_ConstraintStateType  =======
  TYPE, PUBLIC :: AD_ConstraintStateType
    TYPE(RotConstraintStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Constraint states for each rotor [-]
    TYPE(FVW_ConstraintStateType)  :: FVW      !< Constraint states from the FVW module [-]
  END TYPE AD_ConstraintStateType
! =======================
! =========  RotOtherStateType  =======
  TYPE, PUBLIC :: RotOtherStateType
    TYPE(BEMT_OtherStateType)  :: BEMT      !< OtherStates from the BEMT module [-]
    TYPE(AA_OtherStateType)  :: AA      !< OtherStates from the AA module [-]
  END TYPE RotOtherStateType
! =======================
! =========  AD_OtherStateType  =======
  TYPE, PUBLIC :: AD_OtherStateType
    TYPE(RotOtherStateType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< OtherStates from the BEMT module [-]
    TYPE(FVW_OtherStateType)  :: FVW      !< OtherStates from the FVW module [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WakeLocationPoints      !< wake points velocity [m/s]
  END TYPE AD_OtherStateType
! =======================
! =========  RotMiscVarType  =======
  TYPE, PUBLIC :: RotMiscVarType
    TYPE(BEMT_MiscVarType)  :: BEMT      !< MiscVars from the BEMT module [-]
    TYPE(BEMT_OutputType)  :: BEMT_y      !< Outputs from the BEMT module [-]
    TYPE(BEMT_InputType) , DIMENSION(1:2)  :: BEMT_u      !< Inputs to the BEMT module [-]
    TYPE(AA_MiscVarType)  :: AA      !< MiscVars from the AA module [-]
    TYPE(AA_OutputType)  :: AA_y      !< Outputs from the AA module [-]
    TYPE(AA_InputType)  :: AA_u      !< Inputs to the AA module [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: DisturbedInflow      !< InflowOnBlade values modified by tower influence [m/s]
    REAL(R8Ki) , DIMENSION(:,:,:,:), ALLOCATABLE  :: orientationAnnulus      !< Coordinate system equivalent to BladeMotion Orientation, but without live sweep, blade-pitch, and twist angles [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AllOuts      !< An array holding the value of all of the calculated (not only selected) output channels [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: W_Twr      !< relative wind speed normal to the tower at node j [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: X_Twr      !< local x-component of force per unit length of the jth node in the tower [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Y_Twr      !< local y-component of force per unit length of the jth node in the tower [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Curve      !< curvature angle, saved for possible output to file [rad]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrClrnc      !< Distance between tower (including tower radius) and blade node (not including blade width), saved for possible output to file [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: X      !< normal force per unit length (normal to the plane, not chord) of the jth node in the kth blade [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Y      !< tangential force per unit length (tangential to the plane, not chord) of the jth node in the kth blade [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Z      !< axial force per unit length (tangential to the plane, not chord) of the jth node in the kth blade [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: M      !< pitching moment per unit length of the jth node in the kth blade [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Mx      !< pitching moment per unit length of the jth node in the kth blade (in x direction) [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: My      !< pitching moment per unit length of the jth node in the kth blade  (in y direction) [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Mz      !< pitching moment per unit length of the jth node in the kth blade  (in z direction) [Nm/m]
    REAL(ReKi) , DIMENSION(1:3)  :: V_DiskAvg      !< disk-average relative wind speed [m/s]
    REAL(ReKi)  :: yaw      !< Yaw calculated in  SetInputsForBEMT [rad]
    REAL(ReKi)  :: tilt      !< tilt calculated in  SetInputsForBEMT [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: hub_theta_x_root      !< angles saved for FAST.Farm [rad]
    REAL(ReKi)  :: V_dot_x 
    TYPE(MeshType)  :: HubLoad      !< mesh at hub; used to compute an integral for mapping the output blade loads to a single point (for writing to file only) [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: B_L_2_H_P      !< mapping data structure to map each bladeLoad output mesh to the MiscVar%HubLoad mesh [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SigmaCavitCrit      !< critical cavitation number-  inception value (above which cavit will occur) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: SigmaCavit      !< cavitation number at node  [-]
    LOGICAL , DIMENSION(:,:), ALLOCATABLE  :: CavitWarnSet      !< cavitation warning issued  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlFB      !< buoyant force per unit length at blade node [N/m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BlMB      !< buoyant moment per unit length at blade node [Nm/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrFB      !< buoyant force per unit length at tower node [N/m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TwrMB      !< buoyant moment per unit length at tower node [Nm/m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HubFB      !< buoyant force at hub node [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: HubMB      !< buoyant moment at hub node [Nm]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NacFB      !< buoyant force at nacelle (tower top) node [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: NacMB      !< buoyant moment at nacelle (tower top) node [Nm]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootLoad      !< meshes at blade root; used to compute an integral for mapping the output blade loads to single points (for writing to file only) [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: B_L_2_R_P      !< mapping data structure to map each bladeLoad output mesh to corresponding MiscVar%BladeRootLoad mesh [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeBuoyLoadPoint      !< point mesh for lumped buoyant blade loads [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeBuoyLoad      !< line mesh for per unit length buoyant blade loads [-]
    TYPE(MeshMapType) , DIMENSION(:), ALLOCATABLE  :: B_P_2_B_L      !< mapping data structure to map buoyant blade point loads (m%BladeBuoyLoadPoint) to buoyant blade line loads (m%BladeBuoyLoad) [-]
    TYPE(MeshType)  :: TwrBuoyLoadPoint      !< point mesh for lumped buoyant tower loads [-]
    TYPE(MeshType)  :: TwrBuoyLoad      !< line mesh for per unit length buoyant tower loads [-]
    TYPE(MeshMapType)  :: T_P_2_T_L      !< mapping data structure to map buoyant tower point loads (m%TwrBuoyLoadPoint) to buoyant tower line loads (m%TwrBuoyLoad) [-]
    LOGICAL  :: FirstWarn_TowerStrike      !< flag to avoid printing tower strike multiple times [-]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgDiskVel      !< disk-averaged U,V,W (undisturbed) [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: AvgDiskVelDist      !< disk-averaged U,V,W (disturbed) [m/s]
    REAL(ReKi)  :: TFinAlpha      !< Angle of attack for tailfin [-]
    REAL(ReKi)  :: TFinRe      !< Reynolds number for tailfin [-]
    REAL(ReKi)  :: TFinVrel      !< Orthogonal relative velocity nrom at the reference point [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinVund_i      !< Undisturbed wind velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinVind_i      !< Induced velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinVrel_i      !< Relative velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinSTV_i      !< Structural velocity at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinF_i      !< Forces at the reference point of the fin in the inertial system [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TFinM_i      !< Moments at the reference point of the fin in the inertial system [-]
  END TYPE RotMiscVarType
! =======================
! =========  AD_MiscVarType  =======
  TYPE, PUBLIC :: AD_MiscVarType
    TYPE(RotMiscVarType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< MiscVars for each rotor [-]
    TYPE(FVW_InputType) , DIMENSION(:), ALLOCATABLE  :: FVW_u      !< Inputs to the FVW module [-]
    TYPE(FVW_OutputType)  :: FVW_y      !< Outputs from the FVW module [-]
    TYPE(FVW_MiscVarType)  :: FVW      !< MiscVars from the FVW module [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WindPos      !< XYZ coordinates to query for wind velocity/acceleration [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WindVel      !< XYZ components of wind velocity [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WindAcc      !< XYZ components of wind acceleration [-]
  END TYPE AD_MiscVarType
! =======================
! =========  RotParameterType  =======
  TYPE, PUBLIC :: RotParameterType
    INTEGER(IntKi)  :: NumBlades      !< Number of blades on the turbine [-]
    INTEGER(IntKi)  :: NumBlNds      !< Number of nodes on each blade [-]
    INTEGER(IntKi)  :: NumTwrNds      !< Number of nodes on the tower [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDiam      !< Diameter of tower at node [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCd      !< Coefficient of drag at tower node [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrTI      !< Turbulence intensity for tower shadow at tower node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlTwist      !< Twist at blade node [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrCb      !< Coefficient of buoyancy at tower node [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlCenBn      !< Normal offset between aerodynamic center and center of buoyancy at blade node [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlCenBt      !< Tangential offset between aerodynamic center and center of buoyancy at blade node [m]
    REAL(ReKi)  :: VolHub      !< Hub volume [m^3]
    REAL(ReKi)  :: HubCenBx      !< Hub center of buoyancy x direction offset [m]
    REAL(ReKi)  :: VolNac      !< Nacelle volume [m^3]
    REAL(ReKi) , DIMENSION(1:3)  :: NacCenB      !< Position of nacelle center of buoyancy from yaw bearing in nacelle coordinates [m]
    REAL(ReKi)  :: VolBl      !< Buoyancy volume of all blades [m^3]
    REAL(ReKi)  :: VolTwr      !< Buoyancy volume of the tower [m^3]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlRad      !< Matrix of equivalent blade radius at each node, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlDL      !< Matrix of blade element length based on CB, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlTaper      !< Matrix of blade element taper, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlAxCent      !< Matrix of blade element axial centroid, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrRad      !< Array of equivalent tower radius at each node, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrDL      !< Array of tower element length, used in buoyancy calculation [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrTaper      !< Array of tower element taper, used in buoyancy calculation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: TwrAxCent      !< Array of tower element axial centroid, used in buoyancy calculation [-]
    TYPE(BEMT_ParameterType)  :: BEMT      !< Parameters for BEMT module [-]
    TYPE(AA_ParameterType)  :: AA      !< Parameters for AA module [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
    INTEGER(IntKi)  :: Jac_ny      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: NumBl_Lin      !< number of blades in the jacobian [-]
    INTEGER(IntKi)  :: TwrPotent      !< Type of tower influence on wind based on potential flow around the tower {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} [-]
    INTEGER(IntKi)  :: TwrShadow      !< Type of tower influence on wind based on downstream tower shadow {0=none, 1=Powles model, 2=Eames model} [-]
    LOGICAL  :: TwrAero      !< Calculate tower aerodynamic loads? [flag]
    LOGICAL  :: FrozenWake      !< Flag that tells this module it should assume a frozen wake during linearization. [-]
    LOGICAL  :: CavitCheck      !< Flag that tells us if we want to check for cavitation [-]
    LOGICAL  :: Buoyancy      !< Include buoyancy effects? [flag]
    INTEGER(IntKi)  :: MHK      !< MHK [flag]
    LOGICAL  :: CompAA      !< Compute AeroAcoustic noise [flag]
    REAL(ReKi)  :: AirDens      !< Air density [kg/m^3]
    REAL(ReKi)  :: KinVisc      !< Kinematic air viscosity [m^2/s]
    REAL(ReKi)  :: SpdSound      !< Speed of sound [m/s]
    REAL(ReKi)  :: Gravity      !< Gravitational acceleration [m/s^2]
    REAL(ReKi)  :: Patm      !< Atmospheric pressure [Pa]
    REAL(ReKi)  :: Pvap      !< Vapour pressure [Pa]
    REAL(ReKi)  :: WtrDpth      !< Water depth [m]
    REAL(ReKi)  :: MSL2SWL      !< Offset between still-water level and mean sea level [m]
    INTEGER(IntKi)  :: AeroProjMod = 1      !< Flag to switch between different projection models [-]
    INTEGER(IntKi)  :: AeroBEM_Mod = -1      !< Flag to switch between different BEM Model [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    INTEGER(IntKi)  :: NBlOuts      !< Number of blade node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: BlOutNd      !< Blade nodes whose values will be output [-]
    INTEGER(IntKi)  :: NTwOuts      !< Number of tower node outputs [0 - 9] [-]
    INTEGER(IntKi) , DIMENSION(1:9)  :: TwOutNd      !< Tower nodes whose values will be output [-]
    INTEGER(IntKi)  :: BldNd_NumOuts      !< Number of requested output channels per blade node (AD_AllBldNdOuts) [-]
    INTEGER(IntKi)  :: BldNd_TotNumOuts      !< Total number of requested output channels of blade node information (BldNd_NumOuts * BldNd_BlOutNd * BldNd_BladesOut -- AD_AllBldNdOuts) [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: BldNd_OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BldNd_BlOutNd      !< The blade nodes to actually output (AD_AllBldNdOuts) [-]
    INTEGER(IntKi)  :: BldNd_BladesOut      !< The blades to output (AD_AllBldNdOuts) [-]
    LOGICAL  :: TFinAero = .FALSE.      !< Calculate tail fin aerodynamics model (flag) [flag]
    TYPE(TFinParameterType)  :: TFin      !< Parameters for tail fin of current rotor [-]
  END TYPE RotParameterType
! =======================
! =========  AD_ParameterType  =======
  TYPE, PUBLIC :: AD_ParameterType
    TYPE(RotParameterType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Parameter types for each rotor [-]
    REAL(DbKi)  :: DT      !< Time step for continuous state integration & discrete state update [seconds]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(AFI_ParameterType) , DIMENSION(:), ALLOCATABLE  :: AFI      !< AirfoilInfo parameters [-]
    INTEGER(IntKi)  :: SkewMod      !< Type of skewed-wake correction model {0=orthogonal, 1=uncoupled, 2=Pitt/Peters, 3=coupled} [unused when WakeMod=0] [-]
    INTEGER(IntKi)  :: WakeMod      !< Type of wake/induction model {0=none, 1=BEMT, 2=DBEMT, 3=FVW} [-]
    TYPE(FVW_ParameterType)  :: FVW      !< Parameters for FVW module [-]
    LOGICAL  :: CompAeroMaps = .FALSE.      !< flag to determine if AeroDyn is computing aero maps (true) or running a normal simulation (false) [-]
    LOGICAL  :: UA_Flag      !< logical flag indicating whether to use UnsteadyAero [-]
    TYPE(FlowFieldType) , POINTER :: FlowField => NULL()      !< Pointer of InflowWinds flow field data type [-]
  END TYPE AD_ParameterType
! =======================
! =========  RotInputType  =======
  TYPE, PUBLIC :: RotInputType
    TYPE(MeshType)  :: NacelleMotion      !< motion on the nacelle [-]
    TYPE(MeshType)  :: TowerMotion      !< motion on the tower [-]
    TYPE(MeshType)  :: HubMotion      !< motion on the hub [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeRootMotion      !< motion on each blade root [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeMotion      !< motion on each blade [-]
    TYPE(MeshType)  :: TFinMotion      !< motion of tail fin (at tail fin ref point) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: InflowOnBlade      !< U,V,W at nodes on each blade (note if we change the requirement that NumNodes is the same for each blade, this will need to change) [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowOnTower      !< U,V,W at nodes on the tower [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: InflowOnHub      !< U,V,W at hub [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: InflowOnNacelle      !< U,V,W at nacelle [m/s]
    REAL(ReKi) , DIMENSION(1:3)  :: InflowOnTailFin      !< U,V,W at tailfin [m/s]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: UserProp      !< Optional user property for interpolating airfoils (per element per blade) [-]
  END TYPE RotInputType
! =======================
! =========  AD_InputType  =======
  TYPE, PUBLIC :: AD_InputType
    TYPE(RotInputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Inputs for each rotor [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: InflowWakeVel      !< U,V,W at wake points [m/s]
  END TYPE AD_InputType
! =======================
! =========  RotOutputType  =======
  TYPE, PUBLIC :: RotOutputType
    TYPE(MeshType)  :: NacelleLoad      !< loads on the nacelle [-]
    TYPE(MeshType)  :: HubLoad      !< loads on the hub [-]
    TYPE(MeshType)  :: TowerLoad      !< loads on the tower [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: BladeLoad      !< loads on each blade [-]
    TYPE(MeshType)  :: TFinLoad      !< loads on tail fin (at tail fin ref point) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
  END TYPE RotOutputType
! =======================
! =========  AD_OutputType  =======
  TYPE, PUBLIC :: AD_OutputType
    TYPE(RotOutputType) , DIMENSION(:), ALLOCATABLE  :: rotors      !< Ouputs for each rotor [-]
  END TYPE AD_OutputType
! =======================
CONTAINS
 SUBROUTINE AD_CopyTFinParameterType( SrcTFinParameterTypeData, DstTFinParameterTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(TFinParameterType), INTENT(IN) :: SrcTFinParameterTypeData
   TYPE(TFinParameterType), INTENT(INOUT) :: DstTFinParameterTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyTFinParameterType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstTFinParameterTypeData%TFinMod = SrcTFinParameterTypeData%TFinMod
    DstTFinParameterTypeData%TFinChord = SrcTFinParameterTypeData%TFinChord
    DstTFinParameterTypeData%TFinArea = SrcTFinParameterTypeData%TFinArea
    DstTFinParameterTypeData%TFinIndMod = SrcTFinParameterTypeData%TFinIndMod
    DstTFinParameterTypeData%TFinAFID = SrcTFinParameterTypeData%TFinAFID
 END SUBROUTINE AD_CopyTFinParameterType

 SUBROUTINE AD_DestroyTFinParameterType( TFinParameterTypeData, ErrStat, ErrMsg )
  TYPE(TFinParameterType), INTENT(INOUT) :: TFinParameterTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyTFinParameterType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD_DestroyTFinParameterType


subroutine AD_PackTFinParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TFinParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackTFinParameterType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TFinMod
   call RegPack(Buf, InData%TFinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinChord
   call RegPack(Buf, InData%TFinChord)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinArea
   call RegPack(Buf, InData%TFinArea)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinIndMod
   call RegPack(Buf, InData%TFinIndMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAFID
   call RegPack(Buf, InData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackTFinParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TFinParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackTFinParameterType'
   if (Buf%ErrStat /= ErrID_None) return
   ! TFinMod
   call RegUnpack(Buf, OutData%TFinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinChord
   call RegUnpack(Buf, OutData%TFinChord)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinArea
   call RegUnpack(Buf, OutData%TFinArea)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinIndMod
   call RegUnpack(Buf, OutData%TFinIndMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAFID
   call RegUnpack(Buf, OutData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD_CopyTFinInputFileType( SrcTFinInputFileTypeData, DstTFinInputFileTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(TFinInputFileType), INTENT(IN) :: SrcTFinInputFileTypeData
   TYPE(TFinInputFileType), INTENT(INOUT) :: DstTFinInputFileTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyTFinInputFileType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstTFinInputFileTypeData%TFinMod = SrcTFinInputFileTypeData%TFinMod
    DstTFinInputFileTypeData%TFinChord = SrcTFinInputFileTypeData%TFinChord
    DstTFinInputFileTypeData%TFinArea = SrcTFinInputFileTypeData%TFinArea
    DstTFinInputFileTypeData%TFinRefP_n = SrcTFinInputFileTypeData%TFinRefP_n
    DstTFinInputFileTypeData%TFinAngles = SrcTFinInputFileTypeData%TFinAngles
    DstTFinInputFileTypeData%TFinIndMod = SrcTFinInputFileTypeData%TFinIndMod
    DstTFinInputFileTypeData%TFinAFID = SrcTFinInputFileTypeData%TFinAFID
 END SUBROUTINE AD_CopyTFinInputFileType

 SUBROUTINE AD_DestroyTFinInputFileType( TFinInputFileTypeData, ErrStat, ErrMsg )
  TYPE(TFinInputFileType), INTENT(INOUT) :: TFinInputFileTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyTFinInputFileType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE AD_DestroyTFinInputFileType


subroutine AD_PackTFinInputFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TFinInputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackTFinInputFileType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TFinMod
   call RegPack(Buf, InData%TFinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinChord
   call RegPack(Buf, InData%TFinChord)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinArea
   call RegPack(Buf, InData%TFinArea)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinRefP_n
   call RegPack(Buf, InData%TFinRefP_n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAngles
   call RegPack(Buf, InData%TFinAngles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinIndMod
   call RegPack(Buf, InData%TFinIndMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAFID
   call RegPack(Buf, InData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackTFinInputFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TFinInputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackTFinInputFileType'
   if (Buf%ErrStat /= ErrID_None) return
   ! TFinMod
   call RegUnpack(Buf, OutData%TFinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinChord
   call RegUnpack(Buf, OutData%TFinChord)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinArea
   call RegUnpack(Buf, OutData%TFinArea)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinRefP_n
   call RegUnpack(Buf, OutData%TFinRefP_n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAngles
   call RegUnpack(Buf, OutData%TFinAngles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinIndMod
   call RegUnpack(Buf, OutData%TFinIndMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAFID
   call RegUnpack(Buf, OutData%TFinAFID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD_CopyVTK_BLSurfaceType( SrcVTK_BLSurfaceTypeData, DstVTK_BLSurfaceTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_VTK_BLSurfaceType), INTENT(IN) :: SrcVTK_BLSurfaceTypeData
   TYPE(AD_VTK_BLSurfaceType), INTENT(INOUT) :: DstVTK_BLSurfaceTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyVTK_BLSurfaceType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcVTK_BLSurfaceTypeData%AirfoilCoords)) THEN
  i1_l = LBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,1)
  i1_u = UBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,1)
  i2_l = LBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,2)
  i2_u = UBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,2)
  i3_l = LBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,3)
  i3_u = UBOUND(SrcVTK_BLSurfaceTypeData%AirfoilCoords,3)
  IF (.NOT. ALLOCATED(DstVTK_BLSurfaceTypeData%AirfoilCoords)) THEN 
    ALLOCATE(DstVTK_BLSurfaceTypeData%AirfoilCoords(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_BLSurfaceTypeData%AirfoilCoords.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_BLSurfaceTypeData%AirfoilCoords = SrcVTK_BLSurfaceTypeData%AirfoilCoords
ENDIF
 END SUBROUTINE AD_CopyVTK_BLSurfaceType

 SUBROUTINE AD_DestroyVTK_BLSurfaceType( VTK_BLSurfaceTypeData, ErrStat, ErrMsg )
  TYPE(AD_VTK_BLSurfaceType), INTENT(INOUT) :: VTK_BLSurfaceTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyVTK_BLSurfaceType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(VTK_BLSurfaceTypeData%AirfoilCoords)) THEN
  DEALLOCATE(VTK_BLSurfaceTypeData%AirfoilCoords)
ENDIF
 END SUBROUTINE AD_DestroyVTK_BLSurfaceType


subroutine AD_PackVTK_BLSurfaceType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_VTK_BLSurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackVTK_BLSurfaceType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AirfoilCoords
   call RegPack(Buf, allocated(InData%AirfoilCoords))
   if (allocated(InData%AirfoilCoords)) then
      call RegPackBounds(Buf, 3, lbound(InData%AirfoilCoords), ubound(InData%AirfoilCoords))
      call RegPack(Buf, InData%AirfoilCoords)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackVTK_BLSurfaceType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_VTK_BLSurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackVTK_BLSurfaceType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AirfoilCoords
   if (allocated(OutData%AirfoilCoords)) deallocate(OutData%AirfoilCoords)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AirfoilCoords.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AirfoilCoords)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyVTK_RotSurfaceType( SrcVTK_RotSurfaceTypeData, DstVTK_RotSurfaceTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_VTK_RotSurfaceType), INTENT(IN) :: SrcVTK_RotSurfaceTypeData
   TYPE(AD_VTK_RotSurfaceType), INTENT(INOUT) :: DstVTK_RotSurfaceTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyVTK_RotSurfaceType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcVTK_RotSurfaceTypeData%BladeShape)) THEN
  i1_l = LBOUND(SrcVTK_RotSurfaceTypeData%BladeShape,1)
  i1_u = UBOUND(SrcVTK_RotSurfaceTypeData%BladeShape,1)
  IF (.NOT. ALLOCATED(DstVTK_RotSurfaceTypeData%BladeShape)) THEN 
    ALLOCATE(DstVTK_RotSurfaceTypeData%BladeShape(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_RotSurfaceTypeData%BladeShape.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcVTK_RotSurfaceTypeData%BladeShape,1), UBOUND(SrcVTK_RotSurfaceTypeData%BladeShape,1)
      CALL AD_Copyvtk_blsurfacetype( SrcVTK_RotSurfaceTypeData%BladeShape(i1), DstVTK_RotSurfaceTypeData%BladeShape(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcVTK_RotSurfaceTypeData%TowerRad)) THEN
  i1_l = LBOUND(SrcVTK_RotSurfaceTypeData%TowerRad,1)
  i1_u = UBOUND(SrcVTK_RotSurfaceTypeData%TowerRad,1)
  IF (.NOT. ALLOCATED(DstVTK_RotSurfaceTypeData%TowerRad)) THEN 
    ALLOCATE(DstVTK_RotSurfaceTypeData%TowerRad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstVTK_RotSurfaceTypeData%TowerRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstVTK_RotSurfaceTypeData%TowerRad = SrcVTK_RotSurfaceTypeData%TowerRad
ENDIF
 END SUBROUTINE AD_CopyVTK_RotSurfaceType

 SUBROUTINE AD_DestroyVTK_RotSurfaceType( VTK_RotSurfaceTypeData, ErrStat, ErrMsg )
  TYPE(AD_VTK_RotSurfaceType), INTENT(INOUT) :: VTK_RotSurfaceTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyVTK_RotSurfaceType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(VTK_RotSurfaceTypeData%BladeShape)) THEN
DO i1 = LBOUND(VTK_RotSurfaceTypeData%BladeShape,1), UBOUND(VTK_RotSurfaceTypeData%BladeShape,1)
  CALL AD_DestroyVTK_BLSurfaceType( VTK_RotSurfaceTypeData%BladeShape(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(VTK_RotSurfaceTypeData%BladeShape)
ENDIF
IF (ALLOCATED(VTK_RotSurfaceTypeData%TowerRad)) THEN
  DEALLOCATE(VTK_RotSurfaceTypeData%TowerRad)
ENDIF
 END SUBROUTINE AD_DestroyVTK_RotSurfaceType


subroutine AD_PackVTK_RotSurfaceType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_VTK_RotSurfaceType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackVTK_RotSurfaceType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! BladeShape
   call RegPack(Buf, allocated(InData%BladeShape))
   if (allocated(InData%BladeShape)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeShape), ubound(InData%BladeShape))
      LB(1:1) = lbound(InData%BladeShape)
      UB(1:1) = ubound(InData%BladeShape)
      do i1 = LB(1), UB(1)
         call AD_PackVTK_BLSurfaceType(Buf, InData%BladeShape(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerRad
   call RegPack(Buf, allocated(InData%TowerRad))
   if (allocated(InData%TowerRad)) then
      call RegPackBounds(Buf, 1, lbound(InData%TowerRad), ubound(InData%TowerRad))
      call RegPack(Buf, InData%TowerRad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackVTK_RotSurfaceType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_VTK_RotSurfaceType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackVTK_RotSurfaceType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! BladeShape
   if (allocated(OutData%BladeShape)) deallocate(OutData%BladeShape)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeShape(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeShape.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackVTK_BLSurfaceType(Buf, OutData%BladeShape(i1)) ! BladeShape 
      end do
   end if
   ! TowerRad
   if (allocated(OutData%TowerRad)) deallocate(OutData%TowerRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TowerRad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TowerRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TowerRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyRotInitInputType( SrcRotInitInputTypeData, DstRotInitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotInitInputType), INTENT(IN) :: SrcRotInitInputTypeData
   TYPE(RotInitInputType), INTENT(INOUT) :: DstRotInitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotInitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotInitInputTypeData%NumBlades = SrcRotInitInputTypeData%NumBlades
    DstRotInitInputTypeData%HubPosition = SrcRotInitInputTypeData%HubPosition
    DstRotInitInputTypeData%HubOrientation = SrcRotInitInputTypeData%HubOrientation
IF (ALLOCATED(SrcRotInitInputTypeData%BladeRootPosition)) THEN
  i1_l = LBOUND(SrcRotInitInputTypeData%BladeRootPosition,1)
  i1_u = UBOUND(SrcRotInitInputTypeData%BladeRootPosition,1)
  i2_l = LBOUND(SrcRotInitInputTypeData%BladeRootPosition,2)
  i2_u = UBOUND(SrcRotInitInputTypeData%BladeRootPosition,2)
  IF (.NOT. ALLOCATED(DstRotInitInputTypeData%BladeRootPosition)) THEN 
    ALLOCATE(DstRotInitInputTypeData%BladeRootPosition(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitInputTypeData%BladeRootPosition.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitInputTypeData%BladeRootPosition = SrcRotInitInputTypeData%BladeRootPosition
ENDIF
IF (ALLOCATED(SrcRotInitInputTypeData%BladeRootOrientation)) THEN
  i1_l = LBOUND(SrcRotInitInputTypeData%BladeRootOrientation,1)
  i1_u = UBOUND(SrcRotInitInputTypeData%BladeRootOrientation,1)
  i2_l = LBOUND(SrcRotInitInputTypeData%BladeRootOrientation,2)
  i2_u = UBOUND(SrcRotInitInputTypeData%BladeRootOrientation,2)
  i3_l = LBOUND(SrcRotInitInputTypeData%BladeRootOrientation,3)
  i3_u = UBOUND(SrcRotInitInputTypeData%BladeRootOrientation,3)
  IF (.NOT. ALLOCATED(DstRotInitInputTypeData%BladeRootOrientation)) THEN 
    ALLOCATE(DstRotInitInputTypeData%BladeRootOrientation(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitInputTypeData%BladeRootOrientation.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitInputTypeData%BladeRootOrientation = SrcRotInitInputTypeData%BladeRootOrientation
ENDIF
    DstRotInitInputTypeData%NacellePosition = SrcRotInitInputTypeData%NacellePosition
    DstRotInitInputTypeData%NacelleOrientation = SrcRotInitInputTypeData%NacelleOrientation
    DstRotInitInputTypeData%AeroProjMod = SrcRotInitInputTypeData%AeroProjMod
    DstRotInitInputTypeData%AeroBEM_Mod = SrcRotInitInputTypeData%AeroBEM_Mod
 END SUBROUTINE AD_CopyRotInitInputType

 SUBROUTINE AD_DestroyRotInitInputType( RotInitInputTypeData, ErrStat, ErrMsg )
  TYPE(RotInitInputType), INTENT(INOUT) :: RotInitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotInitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(RotInitInputTypeData%BladeRootPosition)) THEN
  DEALLOCATE(RotInitInputTypeData%BladeRootPosition)
ENDIF
IF (ALLOCATED(RotInitInputTypeData%BladeRootOrientation)) THEN
  DEALLOCATE(RotInitInputTypeData%BladeRootOrientation)
ENDIF
 END SUBROUTINE AD_DestroyRotInitInputType


subroutine AD_PackRotInitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumBlades
   call RegPack(Buf, InData%NumBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubPosition
   call RegPack(Buf, InData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubOrientation
   call RegPack(Buf, InData%HubOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootPosition
   call RegPack(Buf, allocated(InData%BladeRootPosition))
   if (allocated(InData%BladeRootPosition)) then
      call RegPackBounds(Buf, 2, lbound(InData%BladeRootPosition), ubound(InData%BladeRootPosition))
      call RegPack(Buf, InData%BladeRootPosition)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootOrientation
   call RegPack(Buf, allocated(InData%BladeRootOrientation))
   if (allocated(InData%BladeRootOrientation)) then
      call RegPackBounds(Buf, 3, lbound(InData%BladeRootOrientation), ubound(InData%BladeRootOrientation))
      call RegPack(Buf, InData%BladeRootOrientation)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacellePosition
   call RegPack(Buf, InData%NacellePosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacelleOrientation
   call RegPack(Buf, InData%NacelleOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroProjMod
   call RegPack(Buf, InData%AeroProjMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroBEM_Mod
   call RegPack(Buf, InData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInitInputType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NumBlades
   call RegUnpack(Buf, OutData%NumBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubPosition
   call RegUnpack(Buf, OutData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubOrientation
   call RegUnpack(Buf, OutData%HubOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootPosition
   if (allocated(OutData%BladeRootPosition)) deallocate(OutData%BladeRootPosition)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootPosition(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootPosition.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootPosition)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeRootOrientation
   if (allocated(OutData%BladeRootOrientation)) deallocate(OutData%BladeRootOrientation)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootOrientation(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootOrientation.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BladeRootOrientation)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NacellePosition
   call RegUnpack(Buf, OutData%NacellePosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacelleOrientation
   call RegUnpack(Buf, OutData%NacelleOrientation)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroProjMod
   call RegUnpack(Buf, OutData%AeroProjMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroBEM_Mod
   call RegUnpack(Buf, OutData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(AD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitInputData%rotors)) THEN
  i1_l = LBOUND(SrcInitInputData%rotors,1)
  i1_u = UBOUND(SrcInitInputData%rotors,1)
  IF (.NOT. ALLOCATED(DstInitInputData%rotors)) THEN 
    ALLOCATE(DstInitInputData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%rotors,1), UBOUND(SrcInitInputData%rotors,1)
      CALL AD_Copyrotinitinputtype( SrcInitInputData%rotors(i1), DstInitInputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%UsePrimaryInputFile = SrcInitInputData%UsePrimaryInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedPrimaryInputData, DstInitInputData%PassedPrimaryInputData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%Linearize = SrcInitInputData%Linearize
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%MHK = SrcInitInputData%MHK
    DstInitInputData%defFldDens = SrcInitInputData%defFldDens
    DstInitInputData%defKinVisc = SrcInitInputData%defKinVisc
    DstInitInputData%defSpdSound = SrcInitInputData%defSpdSound
    DstInitInputData%defPatm = SrcInitInputData%defPatm
    DstInitInputData%defPvap = SrcInitInputData%defPvap
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
 END SUBROUTINE AD_CopyInitInput

 SUBROUTINE AD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(AD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%rotors)) THEN
DO i1 = LBOUND(InitInputData%rotors,1), UBOUND(InitInputData%rotors,1)
  CALL AD_DestroyRotInitInputType( InitInputData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InitInputData%rotors)
ENDIF
  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedPrimaryInputData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyInitInput


subroutine AD_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInitInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInitInputType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsePrimaryInputFile
   call RegPack(Buf, InData%UsePrimaryInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedPrimaryInputData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegPack(Buf, InData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defFldDens
   call RegPack(Buf, InData%defFldDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defKinVisc
   call RegPack(Buf, InData%defKinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defSpdSound
   call RegPack(Buf, InData%defSpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defPatm
   call RegPack(Buf, InData%defPatm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defPvap
   call RegPack(Buf, InData%defPvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInitInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInitInputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsePrimaryInputFile
   call RegUnpack(Buf, OutData%UsePrimaryInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedPrimaryInputData) ! PassedPrimaryInputData 
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defFldDens
   call RegUnpack(Buf, OutData%defFldDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defKinVisc
   call RegUnpack(Buf, OutData%defKinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defSpdSound
   call RegUnpack(Buf, OutData%defSpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defPatm
   call RegUnpack(Buf, OutData%defPatm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defPvap
   call RegUnpack(Buf, OutData%defPvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD_CopyBladePropsType( SrcBladePropsTypeData, DstBladePropsTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_BladePropsType), INTENT(IN) :: SrcBladePropsTypeData
   TYPE(AD_BladePropsType), INTENT(INOUT) :: DstBladePropsTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyBladePropsType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBladePropsTypeData%NumBlNds = SrcBladePropsTypeData%NumBlNds
IF (ALLOCATED(SrcBladePropsTypeData%BlSpn)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlSpn,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlSpn,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlSpn)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlSpn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlSpn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlSpn = SrcBladePropsTypeData%BlSpn
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCrvAC)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCrvAC,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCrvAC,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCrvAC)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCrvAC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCrvAC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCrvAC = SrcBladePropsTypeData%BlCrvAC
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlSwpAC)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlSwpAC,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlSwpAC,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlSwpAC)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlSwpAC(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlSwpAC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlSwpAC = SrcBladePropsTypeData%BlSwpAC
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCrvAng)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCrvAng,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCrvAng,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCrvAng)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCrvAng(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCrvAng.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCrvAng = SrcBladePropsTypeData%BlCrvAng
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlTwist)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlTwist,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlTwist,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlTwist)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlTwist(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlTwist.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlTwist = SrcBladePropsTypeData%BlTwist
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlChord)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlChord,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlChord,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlChord)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlChord(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlChord.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlChord = SrcBladePropsTypeData%BlChord
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlAFID)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlAFID,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlAFID,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlAFID)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlAFID(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlAFID.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlAFID = SrcBladePropsTypeData%BlAFID
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCb)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCb,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCb,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCb)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCb = SrcBladePropsTypeData%BlCb
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCenBn)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCenBn,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCenBn,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCenBn)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCenBn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCenBn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCenBn = SrcBladePropsTypeData%BlCenBn
ENDIF
IF (ALLOCATED(SrcBladePropsTypeData%BlCenBt)) THEN
  i1_l = LBOUND(SrcBladePropsTypeData%BlCenBt,1)
  i1_u = UBOUND(SrcBladePropsTypeData%BlCenBt,1)
  IF (.NOT. ALLOCATED(DstBladePropsTypeData%BlCenBt)) THEN 
    ALLOCATE(DstBladePropsTypeData%BlCenBt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladePropsTypeData%BlCenBt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladePropsTypeData%BlCenBt = SrcBladePropsTypeData%BlCenBt
ENDIF
 END SUBROUTINE AD_CopyBladePropsType

 SUBROUTINE AD_DestroyBladePropsType( BladePropsTypeData, ErrStat, ErrMsg )
  TYPE(AD_BladePropsType), INTENT(INOUT) :: BladePropsTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyBladePropsType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(BladePropsTypeData%BlSpn)) THEN
  DEALLOCATE(BladePropsTypeData%BlSpn)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCrvAC)) THEN
  DEALLOCATE(BladePropsTypeData%BlCrvAC)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlSwpAC)) THEN
  DEALLOCATE(BladePropsTypeData%BlSwpAC)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCrvAng)) THEN
  DEALLOCATE(BladePropsTypeData%BlCrvAng)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlTwist)) THEN
  DEALLOCATE(BladePropsTypeData%BlTwist)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlChord)) THEN
  DEALLOCATE(BladePropsTypeData%BlChord)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlAFID)) THEN
  DEALLOCATE(BladePropsTypeData%BlAFID)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCb)) THEN
  DEALLOCATE(BladePropsTypeData%BlCb)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCenBn)) THEN
  DEALLOCATE(BladePropsTypeData%BlCenBn)
ENDIF
IF (ALLOCATED(BladePropsTypeData%BlCenBt)) THEN
  DEALLOCATE(BladePropsTypeData%BlCenBt)
ENDIF
 END SUBROUTINE AD_DestroyBladePropsType


subroutine AD_PackBladePropsType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_BladePropsType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackBladePropsType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumBlNds
   call RegPack(Buf, InData%NumBlNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlSpn
   call RegPack(Buf, allocated(InData%BlSpn))
   if (allocated(InData%BlSpn)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlSpn), ubound(InData%BlSpn))
      call RegPack(Buf, InData%BlSpn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCrvAC
   call RegPack(Buf, allocated(InData%BlCrvAC))
   if (allocated(InData%BlCrvAC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCrvAC), ubound(InData%BlCrvAC))
      call RegPack(Buf, InData%BlCrvAC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlSwpAC
   call RegPack(Buf, allocated(InData%BlSwpAC))
   if (allocated(InData%BlSwpAC)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlSwpAC), ubound(InData%BlSwpAC))
      call RegPack(Buf, InData%BlSwpAC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCrvAng
   call RegPack(Buf, allocated(InData%BlCrvAng))
   if (allocated(InData%BlCrvAng)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCrvAng), ubound(InData%BlCrvAng))
      call RegPack(Buf, InData%BlCrvAng)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlTwist
   call RegPack(Buf, allocated(InData%BlTwist))
   if (allocated(InData%BlTwist)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlTwist), ubound(InData%BlTwist))
      call RegPack(Buf, InData%BlTwist)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlChord
   call RegPack(Buf, allocated(InData%BlChord))
   if (allocated(InData%BlChord)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlChord), ubound(InData%BlChord))
      call RegPack(Buf, InData%BlChord)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAFID
   call RegPack(Buf, allocated(InData%BlAFID))
   if (allocated(InData%BlAFID)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlAFID), ubound(InData%BlAFID))
      call RegPack(Buf, InData%BlAFID)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCb
   call RegPack(Buf, allocated(InData%BlCb))
   if (allocated(InData%BlCb)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCb), ubound(InData%BlCb))
      call RegPack(Buf, InData%BlCb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCenBn
   call RegPack(Buf, allocated(InData%BlCenBn))
   if (allocated(InData%BlCenBn)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCenBn), ubound(InData%BlCenBn))
      call RegPack(Buf, InData%BlCenBn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCenBt
   call RegPack(Buf, allocated(InData%BlCenBt))
   if (allocated(InData%BlCenBt)) then
      call RegPackBounds(Buf, 1, lbound(InData%BlCenBt), ubound(InData%BlCenBt))
      call RegPack(Buf, InData%BlCenBt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackBladePropsType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_BladePropsType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackBladePropsType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NumBlNds
   call RegUnpack(Buf, OutData%NumBlNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlSpn
   if (allocated(OutData%BlSpn)) deallocate(OutData%BlSpn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlSpn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlSpn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlSpn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCrvAC
   if (allocated(OutData%BlCrvAC)) deallocate(OutData%BlCrvAC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCrvAC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCrvAC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCrvAC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlSwpAC
   if (allocated(OutData%BlSwpAC)) deallocate(OutData%BlSwpAC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlSwpAC(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlSwpAC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlSwpAC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCrvAng
   if (allocated(OutData%BlCrvAng)) deallocate(OutData%BlCrvAng)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCrvAng(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCrvAng.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCrvAng)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlTwist
   if (allocated(OutData%BlTwist)) deallocate(OutData%BlTwist)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlTwist(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTwist.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlTwist)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlChord
   if (allocated(OutData%BlChord)) deallocate(OutData%BlChord)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlChord(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlChord.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlChord)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlAFID
   if (allocated(OutData%BlAFID)) deallocate(OutData%BlAFID)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlAFID(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAFID.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlAFID)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCb
   if (allocated(OutData%BlCb)) deallocate(OutData%BlCb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCenBn
   if (allocated(OutData%BlCenBn)) deallocate(OutData%BlCenBn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCenBt
   if (allocated(OutData%BlCenBt)) deallocate(OutData%BlCenBt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyBladeShape( SrcBladeShapeData, DstBladeShapeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_BladeShape), INTENT(IN) :: SrcBladeShapeData
   TYPE(AD_BladeShape), INTENT(INOUT) :: DstBladeShapeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyBladeShape'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcBladeShapeData%AirfoilCoords)) THEN
  i1_l = LBOUND(SrcBladeShapeData%AirfoilCoords,1)
  i1_u = UBOUND(SrcBladeShapeData%AirfoilCoords,1)
  i2_l = LBOUND(SrcBladeShapeData%AirfoilCoords,2)
  i2_u = UBOUND(SrcBladeShapeData%AirfoilCoords,2)
  i3_l = LBOUND(SrcBladeShapeData%AirfoilCoords,3)
  i3_u = UBOUND(SrcBladeShapeData%AirfoilCoords,3)
  IF (.NOT. ALLOCATED(DstBladeShapeData%AirfoilCoords)) THEN 
    ALLOCATE(DstBladeShapeData%AirfoilCoords(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstBladeShapeData%AirfoilCoords.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstBladeShapeData%AirfoilCoords = SrcBladeShapeData%AirfoilCoords
ENDIF
 END SUBROUTINE AD_CopyBladeShape

 SUBROUTINE AD_DestroyBladeShape( BladeShapeData, ErrStat, ErrMsg )
  TYPE(AD_BladeShape), INTENT(INOUT) :: BladeShapeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyBladeShape'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(BladeShapeData%AirfoilCoords)) THEN
  DEALLOCATE(BladeShapeData%AirfoilCoords)
ENDIF
 END SUBROUTINE AD_DestroyBladeShape


subroutine AD_PackBladeShape(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_BladeShape), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackBladeShape'
   if (Buf%ErrStat >= AbortErrLev) return
   ! AirfoilCoords
   call RegPack(Buf, allocated(InData%AirfoilCoords))
   if (allocated(InData%AirfoilCoords)) then
      call RegPackBounds(Buf, 3, lbound(InData%AirfoilCoords), ubound(InData%AirfoilCoords))
      call RegPack(Buf, InData%AirfoilCoords)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackBladeShape(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_BladeShape), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackBladeShape'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AirfoilCoords
   if (allocated(OutData%AirfoilCoords)) deallocate(OutData%AirfoilCoords)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AirfoilCoords(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AirfoilCoords.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AirfoilCoords)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyRotInitOutputType( SrcRotInitOutputTypeData, DstRotInitOutputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotInitOutputType), INTENT(IN) :: SrcRotInitOutputTypeData
   TYPE(RotInitOutputType), INTENT(INOUT) :: DstRotInitOutputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotInitOutputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotInitOutputTypeData%AirDens = SrcRotInitOutputTypeData%AirDens
IF (ALLOCATED(SrcRotInitOutputTypeData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%WriteOutputHdr)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%WriteOutputHdr = SrcRotInitOutputTypeData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%WriteOutputUnt)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%WriteOutputUnt = SrcRotInitOutputTypeData%WriteOutputUnt
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%BladeShape)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%BladeShape,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%BladeShape,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%BladeShape)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%BladeShape(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%BladeShape.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInitOutputTypeData%BladeShape,1), UBOUND(SrcRotInitOutputTypeData%BladeShape,1)
      CALL AD_Copybladeshape( SrcRotInitOutputTypeData%BladeShape(i1), DstRotInitOutputTypeData%BladeShape(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%LinNames_y)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%LinNames_y,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%LinNames_y,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%LinNames_y)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%LinNames_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%LinNames_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%LinNames_y = SrcRotInitOutputTypeData%LinNames_y
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%LinNames_x)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%LinNames_x,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%LinNames_x,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%LinNames_x)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%LinNames_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%LinNames_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%LinNames_x = SrcRotInitOutputTypeData%LinNames_x
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%LinNames_u)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%LinNames_u,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%LinNames_u,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%LinNames_u)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%LinNames_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%LinNames_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%LinNames_u = SrcRotInitOutputTypeData%LinNames_u
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%RotFrame_y)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%RotFrame_y,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%RotFrame_y,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%RotFrame_y)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%RotFrame_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%RotFrame_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%RotFrame_y = SrcRotInitOutputTypeData%RotFrame_y
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%RotFrame_x)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%RotFrame_x,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%RotFrame_x,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%RotFrame_x)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%RotFrame_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%RotFrame_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%RotFrame_x = SrcRotInitOutputTypeData%RotFrame_x
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%RotFrame_u)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%RotFrame_u,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%RotFrame_u,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%RotFrame_u)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%RotFrame_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%RotFrame_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%RotFrame_u = SrcRotInitOutputTypeData%RotFrame_u
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%IsLoad_u)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%IsLoad_u,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%IsLoad_u,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%IsLoad_u)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%IsLoad_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%IsLoad_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%IsLoad_u = SrcRotInitOutputTypeData%IsLoad_u
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%BladeProps)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%BladeProps,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%BladeProps,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%BladeProps)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%BladeProps(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%BladeProps.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInitOutputTypeData%BladeProps,1), UBOUND(SrcRotInitOutputTypeData%BladeProps,1)
      CALL AD_Copybladepropstype( SrcRotInitOutputTypeData%BladeProps(i1), DstRotInitOutputTypeData%BladeProps(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%DerivOrder_x)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%DerivOrder_x,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%DerivOrder_x,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%DerivOrder_x)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%DerivOrder_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%DerivOrder_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%DerivOrder_x = SrcRotInitOutputTypeData%DerivOrder_x
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%TwrElev)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%TwrElev,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%TwrElev,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%TwrElev)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%TwrElev(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%TwrElev.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%TwrElev = SrcRotInitOutputTypeData%TwrElev
ENDIF
IF (ALLOCATED(SrcRotInitOutputTypeData%TwrDiam)) THEN
  i1_l = LBOUND(SrcRotInitOutputTypeData%TwrDiam,1)
  i1_u = UBOUND(SrcRotInitOutputTypeData%TwrDiam,1)
  IF (.NOT. ALLOCATED(DstRotInitOutputTypeData%TwrDiam)) THEN 
    ALLOCATE(DstRotInitOutputTypeData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInitOutputTypeData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInitOutputTypeData%TwrDiam = SrcRotInitOutputTypeData%TwrDiam
ENDIF
 END SUBROUTINE AD_CopyRotInitOutputType

 SUBROUTINE AD_DestroyRotInitOutputType( RotInitOutputTypeData, ErrStat, ErrMsg )
  TYPE(RotInitOutputType), INTENT(INOUT) :: RotInitOutputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotInitOutputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(RotInitOutputTypeData%WriteOutputHdr)) THEN
  DEALLOCATE(RotInitOutputTypeData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%WriteOutputUnt)) THEN
  DEALLOCATE(RotInitOutputTypeData%WriteOutputUnt)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%BladeShape)) THEN
DO i1 = LBOUND(RotInitOutputTypeData%BladeShape,1), UBOUND(RotInitOutputTypeData%BladeShape,1)
  CALL AD_DestroyBladeShape( RotInitOutputTypeData%BladeShape(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInitOutputTypeData%BladeShape)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%LinNames_y)) THEN
  DEALLOCATE(RotInitOutputTypeData%LinNames_y)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%LinNames_x)) THEN
  DEALLOCATE(RotInitOutputTypeData%LinNames_x)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%LinNames_u)) THEN
  DEALLOCATE(RotInitOutputTypeData%LinNames_u)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%RotFrame_y)) THEN
  DEALLOCATE(RotInitOutputTypeData%RotFrame_y)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%RotFrame_x)) THEN
  DEALLOCATE(RotInitOutputTypeData%RotFrame_x)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%RotFrame_u)) THEN
  DEALLOCATE(RotInitOutputTypeData%RotFrame_u)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%IsLoad_u)) THEN
  DEALLOCATE(RotInitOutputTypeData%IsLoad_u)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%BladeProps)) THEN
DO i1 = LBOUND(RotInitOutputTypeData%BladeProps,1), UBOUND(RotInitOutputTypeData%BladeProps,1)
  CALL AD_DestroyBladePropsType( RotInitOutputTypeData%BladeProps(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInitOutputTypeData%BladeProps)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%DerivOrder_x)) THEN
  DEALLOCATE(RotInitOutputTypeData%DerivOrder_x)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%TwrElev)) THEN
  DEALLOCATE(RotInitOutputTypeData%TwrElev)
ENDIF
IF (ALLOCATED(RotInitOutputTypeData%TwrDiam)) THEN
  DEALLOCATE(RotInitOutputTypeData%TwrDiam)
ENDIF
 END SUBROUTINE AD_DestroyRotInitOutputType


subroutine AD_PackRotInitOutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInitOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeShape
   call RegPack(Buf, allocated(InData%BladeShape))
   if (allocated(InData%BladeShape)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeShape), ubound(InData%BladeShape))
      LB(1:1) = lbound(InData%BladeShape)
      UB(1:1) = ubound(InData%BladeShape)
      do i1 = LB(1), UB(1)
         call AD_PackBladeShape(Buf, InData%BladeShape(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_y
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_x
   call RegPack(Buf, allocated(InData%LinNames_x))
   if (allocated(InData%LinNames_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_x), ubound(InData%LinNames_x))
      call RegPack(Buf, InData%LinNames_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_u
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_y
   call RegPack(Buf, allocated(InData%RotFrame_y))
   if (allocated(InData%RotFrame_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_y), ubound(InData%RotFrame_y))
      call RegPack(Buf, InData%RotFrame_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_x
   call RegPack(Buf, allocated(InData%RotFrame_x))
   if (allocated(InData%RotFrame_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_x), ubound(InData%RotFrame_x))
      call RegPack(Buf, InData%RotFrame_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_u
   call RegPack(Buf, allocated(InData%RotFrame_u))
   if (allocated(InData%RotFrame_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_u), ubound(InData%RotFrame_u))
      call RegPack(Buf, InData%RotFrame_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsLoad_u
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeProps
   call RegPack(Buf, allocated(InData%BladeProps))
   if (allocated(InData%BladeProps)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeProps), ubound(InData%BladeProps))
      LB(1:1) = lbound(InData%BladeProps)
      UB(1:1) = ubound(InData%BladeProps)
      do i1 = LB(1), UB(1)
         call AD_PackBladePropsType(Buf, InData%BladeProps(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DerivOrder_x
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrElev
   call RegPack(Buf, allocated(InData%TwrElev))
   if (allocated(InData%TwrElev)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrElev), ubound(InData%TwrElev))
      call RegPack(Buf, InData%TwrElev)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrDiam
   call RegPack(Buf, allocated(InData%TwrDiam))
   if (allocated(InData%TwrDiam)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDiam), ubound(InData%TwrDiam))
      call RegPack(Buf, InData%TwrDiam)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInitOutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInitOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeShape
   if (allocated(OutData%BladeShape)) deallocate(OutData%BladeShape)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeShape(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeShape.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBladeShape(Buf, OutData%BladeShape(i1)) ! BladeShape 
      end do
   end if
   ! LinNames_y
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_x
   if (allocated(OutData%LinNames_x)) deallocate(OutData%LinNames_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_u
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_y
   if (allocated(OutData%RotFrame_y)) deallocate(OutData%RotFrame_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_x
   if (allocated(OutData%RotFrame_x)) deallocate(OutData%RotFrame_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_u
   if (allocated(OutData%RotFrame_u)) deallocate(OutData%RotFrame_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsLoad_u
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeProps
   if (allocated(OutData%BladeProps)) deallocate(OutData%BladeProps)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeProps(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeProps.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBladePropsType(Buf, OutData%BladeProps(i1)) ! BladeProps 
      end do
   end if
   ! DerivOrder_x
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrElev
   if (allocated(OutData%TwrElev)) deallocate(OutData%TwrElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrElev(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrElev)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrDiam
   if (allocated(OutData%TwrDiam)) deallocate(OutData%TwrDiam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDiam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(AD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%rotors)) THEN
  i1_l = LBOUND(SrcInitOutputData%rotors,1)
  i1_u = UBOUND(SrcInitOutputData%rotors,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%rotors)) THEN 
    ALLOCATE(DstInitOutputData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitOutputData%rotors,1), UBOUND(SrcInitOutputData%rotors,1)
      CALL AD_Copyrotinitoutputtype( SrcInitOutputData%rotors(i1), DstInitOutputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyInitOutput

 SUBROUTINE AD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(AD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%rotors)) THEN
DO i1 = LBOUND(InitOutputData%rotors,1), UBOUND(InitOutputData%rotors,1)
  CALL AD_DestroyRotInitOutputType( InitOutputData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InitOutputData%rotors)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyInitOutput


subroutine AD_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInitOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInitOutputType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInitOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInitOutputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
end subroutine
 SUBROUTINE AD_CopyRotInputFile( SrcRotInputFileData, DstRotInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotInputFile), INTENT(IN) :: SrcRotInputFileData
   TYPE(RotInputFile), INTENT(INOUT) :: DstRotInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcRotInputFileData%BladeProps)) THEN
  i1_l = LBOUND(SrcRotInputFileData%BladeProps,1)
  i1_u = UBOUND(SrcRotInputFileData%BladeProps,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%BladeProps)) THEN 
    ALLOCATE(DstRotInputFileData%BladeProps(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%BladeProps.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInputFileData%BladeProps,1), UBOUND(SrcRotInputFileData%BladeProps,1)
      CALL AD_Copybladepropstype( SrcRotInputFileData%BladeProps(i1), DstRotInputFileData%BladeProps(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstRotInputFileData%NumTwrNds = SrcRotInputFileData%NumTwrNds
IF (ALLOCATED(SrcRotInputFileData%TwrElev)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrElev,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrElev,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrElev)) THEN 
    ALLOCATE(DstRotInputFileData%TwrElev(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrElev.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrElev = SrcRotInputFileData%TwrElev
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrDiam)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrDiam,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrDiam,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrDiam)) THEN 
    ALLOCATE(DstRotInputFileData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrDiam = SrcRotInputFileData%TwrDiam
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrCd)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrCd,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrCd,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrCd)) THEN 
    ALLOCATE(DstRotInputFileData%TwrCd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrCd = SrcRotInputFileData%TwrCd
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrTI)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrTI,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrTI,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrTI)) THEN 
    ALLOCATE(DstRotInputFileData%TwrTI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrTI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrTI = SrcRotInputFileData%TwrTI
ENDIF
IF (ALLOCATED(SrcRotInputFileData%TwrCb)) THEN
  i1_l = LBOUND(SrcRotInputFileData%TwrCb,1)
  i1_u = UBOUND(SrcRotInputFileData%TwrCb,1)
  IF (.NOT. ALLOCATED(DstRotInputFileData%TwrCb)) THEN 
    ALLOCATE(DstRotInputFileData%TwrCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputFileData%TwrCb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputFileData%TwrCb = SrcRotInputFileData%TwrCb
ENDIF
    DstRotInputFileData%VolHub = SrcRotInputFileData%VolHub
    DstRotInputFileData%HubCenBx = SrcRotInputFileData%HubCenBx
    DstRotInputFileData%VolNac = SrcRotInputFileData%VolNac
    DstRotInputFileData%NacCenB = SrcRotInputFileData%NacCenB
    DstRotInputFileData%TFinAero = SrcRotInputFileData%TFinAero
    DstRotInputFileData%TFinFile = SrcRotInputFileData%TFinFile
      CALL AD_Copytfininputfiletype( SrcRotInputFileData%TFin, DstRotInputFileData%TFin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotInputFile

 SUBROUTINE AD_DestroyRotInputFile( RotInputFileData, ErrStat, ErrMsg )
  TYPE(RotInputFile), INTENT(INOUT) :: RotInputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(RotInputFileData%BladeProps)) THEN
DO i1 = LBOUND(RotInputFileData%BladeProps,1), UBOUND(RotInputFileData%BladeProps,1)
  CALL AD_DestroyBladePropsType( RotInputFileData%BladeProps(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInputFileData%BladeProps)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrElev)) THEN
  DEALLOCATE(RotInputFileData%TwrElev)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrDiam)) THEN
  DEALLOCATE(RotInputFileData%TwrDiam)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrCd)) THEN
  DEALLOCATE(RotInputFileData%TwrCd)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrTI)) THEN
  DEALLOCATE(RotInputFileData%TwrTI)
ENDIF
IF (ALLOCATED(RotInputFileData%TwrCb)) THEN
  DEALLOCATE(RotInputFileData%TwrCb)
ENDIF
  CALL AD_DestroyTFinInputFileType( RotInputFileData%TFin, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotInputFile


subroutine AD_PackRotInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! BladeProps
   call RegPack(Buf, allocated(InData%BladeProps))
   if (allocated(InData%BladeProps)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeProps), ubound(InData%BladeProps))
      LB(1:1) = lbound(InData%BladeProps)
      UB(1:1) = ubound(InData%BladeProps)
      do i1 = LB(1), UB(1)
         call AD_PackBladePropsType(Buf, InData%BladeProps(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTwrNds
   call RegPack(Buf, InData%NumTwrNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrElev
   call RegPack(Buf, allocated(InData%TwrElev))
   if (allocated(InData%TwrElev)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrElev), ubound(InData%TwrElev))
      call RegPack(Buf, InData%TwrElev)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrDiam
   call RegPack(Buf, allocated(InData%TwrDiam))
   if (allocated(InData%TwrDiam)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDiam), ubound(InData%TwrDiam))
      call RegPack(Buf, InData%TwrDiam)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrCd
   call RegPack(Buf, allocated(InData%TwrCd))
   if (allocated(InData%TwrCd)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCd), ubound(InData%TwrCd))
      call RegPack(Buf, InData%TwrCd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrTI
   call RegPack(Buf, allocated(InData%TwrTI))
   if (allocated(InData%TwrTI)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrTI), ubound(InData%TwrTI))
      call RegPack(Buf, InData%TwrTI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrCb
   call RegPack(Buf, allocated(InData%TwrCb))
   if (allocated(InData%TwrCb)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCb), ubound(InData%TwrCb))
      call RegPack(Buf, InData%TwrCb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolHub
   call RegPack(Buf, InData%VolHub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubCenBx
   call RegPack(Buf, InData%HubCenBx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolNac
   call RegPack(Buf, InData%VolNac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacCenB
   call RegPack(Buf, InData%NacCenB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAero
   call RegPack(Buf, InData%TFinAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinFile
   call RegPack(Buf, InData%TFinFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFin
   call AD_PackTFinInputFileType(Buf, InData%TFin) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! BladeProps
   if (allocated(OutData%BladeProps)) deallocate(OutData%BladeProps)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeProps(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeProps.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackBladePropsType(Buf, OutData%BladeProps(i1)) ! BladeProps 
      end do
   end if
   ! NumTwrNds
   call RegUnpack(Buf, OutData%NumTwrNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrElev
   if (allocated(OutData%TwrElev)) deallocate(OutData%TwrElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrElev(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrElev)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrDiam
   if (allocated(OutData%TwrDiam)) deallocate(OutData%TwrDiam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDiam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrCd
   if (allocated(OutData%TwrCd)) deallocate(OutData%TwrCd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrTI
   if (allocated(OutData%TwrTI)) deallocate(OutData%TwrTI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrTI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrTI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrCb
   if (allocated(OutData%TwrCb)) deallocate(OutData%TwrCb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VolHub
   call RegUnpack(Buf, OutData%VolHub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubCenBx
   call RegUnpack(Buf, OutData%HubCenBx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolNac
   call RegUnpack(Buf, OutData%VolNac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacCenB
   call RegUnpack(Buf, OutData%NacCenB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAero
   call RegUnpack(Buf, OutData%TFinAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinFile
   call RegUnpack(Buf, OutData%TFinFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFin
   call AD_UnpackTFinInputFileType(Buf, OutData%TFin) ! TFin 
end subroutine
 SUBROUTINE AD_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(AD_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%DTAero = SrcInputFileData%DTAero
    DstInputFileData%WakeMod = SrcInputFileData%WakeMod
    DstInputFileData%AFAeroMod = SrcInputFileData%AFAeroMod
    DstInputFileData%TwrPotent = SrcInputFileData%TwrPotent
    DstInputFileData%TwrShadow = SrcInputFileData%TwrShadow
    DstInputFileData%TwrAero = SrcInputFileData%TwrAero
    DstInputFileData%FrozenWake = SrcInputFileData%FrozenWake
    DstInputFileData%CavitCheck = SrcInputFileData%CavitCheck
    DstInputFileData%Buoyancy = SrcInputFileData%Buoyancy
    DstInputFileData%CompAA = SrcInputFileData%CompAA
    DstInputFileData%AA_InputFile = SrcInputFileData%AA_InputFile
IF (ALLOCATED(SrcInputFileData%ADBlFile)) THEN
  i1_l = LBOUND(SrcInputFileData%ADBlFile,1)
  i1_u = UBOUND(SrcInputFileData%ADBlFile,1)
  IF (.NOT. ALLOCATED(DstInputFileData%ADBlFile)) THEN 
    ALLOCATE(DstInputFileData%ADBlFile(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%ADBlFile.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%ADBlFile = SrcInputFileData%ADBlFile
ENDIF
    DstInputFileData%AirDens = SrcInputFileData%AirDens
    DstInputFileData%KinVisc = SrcInputFileData%KinVisc
    DstInputFileData%Patm = SrcInputFileData%Patm
    DstInputFileData%Pvap = SrcInputFileData%Pvap
    DstInputFileData%SpdSound = SrcInputFileData%SpdSound
    DstInputFileData%SkewMod = SrcInputFileData%SkewMod
    DstInputFileData%SkewModFactor = SrcInputFileData%SkewModFactor
    DstInputFileData%TipLoss = SrcInputFileData%TipLoss
    DstInputFileData%HubLoss = SrcInputFileData%HubLoss
    DstInputFileData%TanInd = SrcInputFileData%TanInd
    DstInputFileData%AIDrag = SrcInputFileData%AIDrag
    DstInputFileData%TIDrag = SrcInputFileData%TIDrag
    DstInputFileData%IndToler = SrcInputFileData%IndToler
    DstInputFileData%MaxIter = SrcInputFileData%MaxIter
    DstInputFileData%UAMod = SrcInputFileData%UAMod
    DstInputFileData%FLookup = SrcInputFileData%FLookup
    DstInputFileData%InCol_Alfa = SrcInputFileData%InCol_Alfa
    DstInputFileData%InCol_Cl = SrcInputFileData%InCol_Cl
    DstInputFileData%InCol_Cd = SrcInputFileData%InCol_Cd
    DstInputFileData%InCol_Cm = SrcInputFileData%InCol_Cm
    DstInputFileData%InCol_Cpmin = SrcInputFileData%InCol_Cpmin
    DstInputFileData%AFTabMod = SrcInputFileData%AFTabMod
    DstInputFileData%NumAFfiles = SrcInputFileData%NumAFfiles
    DstInputFileData%FVWFileName = SrcInputFileData%FVWFileName
IF (ALLOCATED(SrcInputFileData%AFNames)) THEN
  i1_l = LBOUND(SrcInputFileData%AFNames,1)
  i1_u = UBOUND(SrcInputFileData%AFNames,1)
  IF (.NOT. ALLOCATED(DstInputFileData%AFNames)) THEN 
    ALLOCATE(DstInputFileData%AFNames(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AFNames.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%AFNames = SrcInputFileData%AFNames
ENDIF
    DstInputFileData%UseBlCm = SrcInputFileData%UseBlCm
    DstInputFileData%SumPrint = SrcInputFileData%SumPrint
    DstInputFileData%NBlOuts = SrcInputFileData%NBlOuts
    DstInputFileData%BlOutNd = SrcInputFileData%BlOutNd
    DstInputFileData%NTwOuts = SrcInputFileData%NTwOuts
    DstInputFileData%TwOutNd = SrcInputFileData%TwOutNd
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
    DstInputFileData%tau1_const = SrcInputFileData%tau1_const
    DstInputFileData%DBEMT_Mod = SrcInputFileData%DBEMT_Mod
    DstInputFileData%BldNd_NumOuts = SrcInputFileData%BldNd_NumOuts
IF (ALLOCATED(SrcInputFileData%BldNd_OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%BldNd_OutList,1)
  i1_u = UBOUND(SrcInputFileData%BldNd_OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%BldNd_OutList)) THEN 
    ALLOCATE(DstInputFileData%BldNd_OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%BldNd_OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%BldNd_OutList = SrcInputFileData%BldNd_OutList
ENDIF
    DstInputFileData%BldNd_BlOutNd_Str = SrcInputFileData%BldNd_BlOutNd_Str
    DstInputFileData%BldNd_BladesOut = SrcInputFileData%BldNd_BladesOut
    DstInputFileData%UAStartRad = SrcInputFileData%UAStartRad
    DstInputFileData%UAEndRad = SrcInputFileData%UAEndRad
IF (ALLOCATED(SrcInputFileData%rotors)) THEN
  i1_l = LBOUND(SrcInputFileData%rotors,1)
  i1_u = UBOUND(SrcInputFileData%rotors,1)
  IF (.NOT. ALLOCATED(DstInputFileData%rotors)) THEN 
    ALLOCATE(DstInputFileData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputFileData%rotors,1), UBOUND(SrcInputFileData%rotors,1)
      CALL AD_Copyrotinputfile( SrcInputFileData%rotors(i1), DstInputFileData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AD_CopyInputFile

 SUBROUTINE AD_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(AD_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputFileData%ADBlFile)) THEN
  DEALLOCATE(InputFileData%ADBlFile)
ENDIF
IF (ALLOCATED(InputFileData%AFNames)) THEN
  DEALLOCATE(InputFileData%AFNames)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
IF (ALLOCATED(InputFileData%BldNd_OutList)) THEN
  DEALLOCATE(InputFileData%BldNd_OutList)
ENDIF
IF (ALLOCATED(InputFileData%rotors)) THEN
DO i1 = LBOUND(InputFileData%rotors,1), UBOUND(InputFileData%rotors,1)
  CALL AD_DestroyRotInputFile( InputFileData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputFileData%rotors)
ENDIF
 END SUBROUTINE AD_DestroyInputFile


subroutine AD_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTAero
   call RegPack(Buf, InData%DTAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeMod
   call RegPack(Buf, InData%WakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFAeroMod
   call RegPack(Buf, InData%AFAeroMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrPotent
   call RegPack(Buf, InData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadow
   call RegPack(Buf, InData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrAero
   call RegPack(Buf, InData%TwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FrozenWake
   call RegPack(Buf, InData%FrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CavitCheck
   call RegPack(Buf, InData%CavitCheck)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Buoyancy
   call RegPack(Buf, InData%Buoyancy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAA
   call RegPack(Buf, InData%CompAA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA_InputFile
   call RegPack(Buf, InData%AA_InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ADBlFile
   call RegPack(Buf, allocated(InData%ADBlFile))
   if (allocated(InData%ADBlFile)) then
      call RegPackBounds(Buf, 1, lbound(InData%ADBlFile), ubound(InData%ADBlFile))
      call RegPack(Buf, InData%ADBlFile)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Patm
   call RegPack(Buf, InData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pvap
   call RegPack(Buf, InData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdSound
   call RegPack(Buf, InData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SkewMod
   call RegPack(Buf, InData%SkewMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SkewModFactor
   call RegPack(Buf, InData%SkewModFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TipLoss
   call RegPack(Buf, InData%TipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoss
   call RegPack(Buf, InData%HubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TanInd
   call RegPack(Buf, InData%TanInd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AIDrag
   call RegPack(Buf, InData%AIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TIDrag
   call RegPack(Buf, InData%TIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IndToler
   call RegPack(Buf, InData%IndToler)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MaxIter
   call RegPack(Buf, InData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAMod
   call RegPack(Buf, InData%UAMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FLookup
   call RegPack(Buf, InData%FLookup)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Alfa
   call RegPack(Buf, InData%InCol_Alfa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cl
   call RegPack(Buf, InData%InCol_Cl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cd
   call RegPack(Buf, InData%InCol_Cd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cm
   call RegPack(Buf, InData%InCol_Cm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cpmin
   call RegPack(Buf, InData%InCol_Cpmin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFTabMod
   call RegPack(Buf, InData%AFTabMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumAFfiles
   call RegPack(Buf, InData%NumAFfiles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVWFileName
   call RegPack(Buf, InData%FVWFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFNames
   call RegPack(Buf, allocated(InData%AFNames))
   if (allocated(InData%AFNames)) then
      call RegPackBounds(Buf, 1, lbound(InData%AFNames), ubound(InData%AFNames))
      call RegPack(Buf, InData%AFNames)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseBlCm
   call RegPack(Buf, InData%UseBlCm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegPack(Buf, InData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBlOuts
   call RegPack(Buf, InData%NBlOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlOutNd
   call RegPack(Buf, InData%BlOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwOuts
   call RegPack(Buf, InData%NTwOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwOutNd
   call RegPack(Buf, InData%TwOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! tau1_const
   call RegPack(Buf, InData%tau1_const)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DBEMT_Mod
   call RegPack(Buf, InData%DBEMT_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_NumOuts
   call RegPack(Buf, InData%BldNd_NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_OutList
   call RegPack(Buf, allocated(InData%BldNd_OutList))
   if (allocated(InData%BldNd_OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%BldNd_OutList), ubound(InData%BldNd_OutList))
      call RegPack(Buf, InData%BldNd_OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_BlOutNd_Str
   call RegPack(Buf, InData%BldNd_BlOutNd_Str)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_BladesOut
   call RegPack(Buf, InData%BldNd_BladesOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAStartRad
   call RegPack(Buf, InData%UAStartRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAEndRad
   call RegPack(Buf, InData%UAEndRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInputFile(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInputFile'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTAero
   call RegUnpack(Buf, OutData%DTAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeMod
   call RegUnpack(Buf, OutData%WakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFAeroMod
   call RegUnpack(Buf, OutData%AFAeroMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrPotent
   call RegUnpack(Buf, OutData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadow
   call RegUnpack(Buf, OutData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrAero
   call RegUnpack(Buf, OutData%TwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FrozenWake
   call RegUnpack(Buf, OutData%FrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CavitCheck
   call RegUnpack(Buf, OutData%CavitCheck)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Buoyancy
   call RegUnpack(Buf, OutData%Buoyancy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAA
   call RegUnpack(Buf, OutData%CompAA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA_InputFile
   call RegUnpack(Buf, OutData%AA_InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ADBlFile
   if (allocated(OutData%ADBlFile)) deallocate(OutData%ADBlFile)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ADBlFile(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ADBlFile.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ADBlFile)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Patm
   call RegUnpack(Buf, OutData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pvap
   call RegUnpack(Buf, OutData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdSound
   call RegUnpack(Buf, OutData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SkewMod
   call RegUnpack(Buf, OutData%SkewMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SkewModFactor
   call RegUnpack(Buf, OutData%SkewModFactor)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TipLoss
   call RegUnpack(Buf, OutData%TipLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoss
   call RegUnpack(Buf, OutData%HubLoss)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TanInd
   call RegUnpack(Buf, OutData%TanInd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AIDrag
   call RegUnpack(Buf, OutData%AIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TIDrag
   call RegUnpack(Buf, OutData%TIDrag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IndToler
   call RegUnpack(Buf, OutData%IndToler)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MaxIter
   call RegUnpack(Buf, OutData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAMod
   call RegUnpack(Buf, OutData%UAMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FLookup
   call RegUnpack(Buf, OutData%FLookup)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Alfa
   call RegUnpack(Buf, OutData%InCol_Alfa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cl
   call RegUnpack(Buf, OutData%InCol_Cl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cd
   call RegUnpack(Buf, OutData%InCol_Cd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cm
   call RegUnpack(Buf, OutData%InCol_Cm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InCol_Cpmin
   call RegUnpack(Buf, OutData%InCol_Cpmin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFTabMod
   call RegUnpack(Buf, OutData%AFTabMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumAFfiles
   call RegUnpack(Buf, OutData%NumAFfiles)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVWFileName
   call RegUnpack(Buf, OutData%FVWFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFNames
   if (allocated(OutData%AFNames)) deallocate(OutData%AFNames)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFNames(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFNames.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AFNames)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UseBlCm
   call RegUnpack(Buf, OutData%UseBlCm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBlOuts
   call RegUnpack(Buf, OutData%NBlOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlOutNd
   call RegUnpack(Buf, OutData%BlOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwOuts
   call RegUnpack(Buf, OutData%NTwOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwOutNd
   call RegUnpack(Buf, OutData%TwOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! tau1_const
   call RegUnpack(Buf, OutData%tau1_const)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DBEMT_Mod
   call RegUnpack(Buf, OutData%DBEMT_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_NumOuts
   call RegUnpack(Buf, OutData%BldNd_NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_OutList
   if (allocated(OutData%BldNd_OutList)) deallocate(OutData%BldNd_OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BldNd_OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BldNd_OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BldNd_BlOutNd_Str
   call RegUnpack(Buf, OutData%BldNd_BlOutNd_Str)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_BladesOut
   call RegUnpack(Buf, OutData%BldNd_BladesOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAStartRad
   call RegUnpack(Buf, OutData%UAStartRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UAEndRad
   call RegUnpack(Buf, OutData%UAEndRad)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInputFile(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
end subroutine
 SUBROUTINE AD_CopyRotContinuousStateType( SrcRotContinuousStateTypeData, DstRotContinuousStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotContinuousStateType), INTENT(IN) :: SrcRotContinuousStateTypeData
   TYPE(RotContinuousStateType), INTENT(INOUT) :: DstRotContinuousStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotContinuousStateType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyContState( SrcRotContinuousStateTypeData%BEMT, DstRotContinuousStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyContState( SrcRotContinuousStateTypeData%AA, DstRotContinuousStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotContinuousStateType

 SUBROUTINE AD_DestroyRotContinuousStateType( RotContinuousStateTypeData, ErrStat, ErrMsg )
  TYPE(RotContinuousStateType), INTENT(INOUT) :: RotContinuousStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotContinuousStateType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL BEMT_DestroyContState( RotContinuousStateTypeData%BEMT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyContState( RotContinuousStateTypeData%AA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotContinuousStateType


subroutine AD_PackRotContinuousStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotContinuousStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! BEMT
   call BEMT_PackContState(Buf, InData%BEMT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA
   call AA_PackContState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotContinuousStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotContinuousStateType'
   if (Buf%ErrStat /= ErrID_None) return
   ! BEMT
   call BEMT_UnpackContState(Buf, OutData%BEMT) ! BEMT 
   ! AA
   call AA_UnpackContState(Buf, OutData%AA) ! AA 
end subroutine
 SUBROUTINE AD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(AD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%rotors)) THEN
  i1_l = LBOUND(SrcContStateData%rotors,1)
  i1_u = UBOUND(SrcContStateData%rotors,1)
  IF (.NOT. ALLOCATED(DstContStateData%rotors)) THEN 
    ALLOCATE(DstContStateData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%rotors,1), UBOUND(SrcContStateData%rotors,1)
      CALL AD_Copyrotcontinuousstatetype( SrcContStateData%rotors(i1), DstContStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL FVW_CopyContState( SrcContStateData%FVW, DstContStateData%FVW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyContState

 SUBROUTINE AD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(AD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%rotors)) THEN
DO i1 = LBOUND(ContStateData%rotors,1), UBOUND(ContStateData%rotors,1)
  CALL AD_DestroyRotContinuousStateType( ContStateData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%rotors)
ENDIF
  CALL FVW_DestroyContState( ContStateData%FVW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyContState


subroutine AD_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotContinuousStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_PackContState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotContinuousStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! FVW
   call FVW_UnpackContState(Buf, OutData%FVW) ! FVW 
end subroutine
 SUBROUTINE AD_CopyRotDiscreteStateType( SrcRotDiscreteStateTypeData, DstRotDiscreteStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotDiscreteStateType), INTENT(IN) :: SrcRotDiscreteStateTypeData
   TYPE(RotDiscreteStateType), INTENT(INOUT) :: DstRotDiscreteStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotDiscreteStateType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyDiscState( SrcRotDiscreteStateTypeData%BEMT, DstRotDiscreteStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyDiscState( SrcRotDiscreteStateTypeData%AA, DstRotDiscreteStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotDiscreteStateType

 SUBROUTINE AD_DestroyRotDiscreteStateType( RotDiscreteStateTypeData, ErrStat, ErrMsg )
  TYPE(RotDiscreteStateType), INTENT(INOUT) :: RotDiscreteStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotDiscreteStateType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL BEMT_DestroyDiscState( RotDiscreteStateTypeData%BEMT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyDiscState( RotDiscreteStateTypeData%AA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotDiscreteStateType


subroutine AD_PackRotDiscreteStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotDiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotDiscreteStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! BEMT
   call BEMT_PackDiscState(Buf, InData%BEMT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA
   call AA_PackDiscState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotDiscreteStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotDiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotDiscreteStateType'
   if (Buf%ErrStat /= ErrID_None) return
   ! BEMT
   call BEMT_UnpackDiscState(Buf, OutData%BEMT) ! BEMT 
   ! AA
   call AA_UnpackDiscState(Buf, OutData%AA) ! AA 
end subroutine
 SUBROUTINE AD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(AD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%rotors)) THEN
  i1_l = LBOUND(SrcDiscStateData%rotors,1)
  i1_u = UBOUND(SrcDiscStateData%rotors,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%rotors)) THEN 
    ALLOCATE(DstDiscStateData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%rotors,1), UBOUND(SrcDiscStateData%rotors,1)
      CALL AD_Copyrotdiscretestatetype( SrcDiscStateData%rotors(i1), DstDiscStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL FVW_CopyDiscState( SrcDiscStateData%FVW, DstDiscStateData%FVW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyDiscState

 SUBROUTINE AD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(AD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%rotors)) THEN
DO i1 = LBOUND(DiscStateData%rotors,1), UBOUND(DiscStateData%rotors,1)
  CALL AD_DestroyRotDiscreteStateType( DiscStateData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%rotors)
ENDIF
  CALL FVW_DestroyDiscState( DiscStateData%FVW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyDiscState


subroutine AD_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotDiscreteStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_PackDiscState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotDiscreteStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! FVW
   call FVW_UnpackDiscState(Buf, OutData%FVW) ! FVW 
end subroutine
 SUBROUTINE AD_CopyRotConstraintStateType( SrcRotConstraintStateTypeData, DstRotConstraintStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotConstraintStateType), INTENT(IN) :: SrcRotConstraintStateTypeData
   TYPE(RotConstraintStateType), INTENT(INOUT) :: DstRotConstraintStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotConstraintStateType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyConstrState( SrcRotConstraintStateTypeData%BEMT, DstRotConstraintStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyConstrState( SrcRotConstraintStateTypeData%AA, DstRotConstraintStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotConstraintStateType

 SUBROUTINE AD_DestroyRotConstraintStateType( RotConstraintStateTypeData, ErrStat, ErrMsg )
  TYPE(RotConstraintStateType), INTENT(INOUT) :: RotConstraintStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotConstraintStateType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL BEMT_DestroyConstrState( RotConstraintStateTypeData%BEMT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyConstrState( RotConstraintStateTypeData%AA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotConstraintStateType


subroutine AD_PackRotConstraintStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotConstraintStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! BEMT
   call BEMT_PackConstrState(Buf, InData%BEMT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA
   call AA_PackConstrState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotConstraintStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotConstraintStateType'
   if (Buf%ErrStat /= ErrID_None) return
   ! BEMT
   call BEMT_UnpackConstrState(Buf, OutData%BEMT) ! BEMT 
   ! AA
   call AA_UnpackConstrState(Buf, OutData%AA) ! AA 
end subroutine
 SUBROUTINE AD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(AD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcConstrStateData%rotors)) THEN
  i1_l = LBOUND(SrcConstrStateData%rotors,1)
  i1_u = UBOUND(SrcConstrStateData%rotors,1)
  IF (.NOT. ALLOCATED(DstConstrStateData%rotors)) THEN 
    ALLOCATE(DstConstrStateData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcConstrStateData%rotors,1), UBOUND(SrcConstrStateData%rotors,1)
      CALL AD_Copyrotconstraintstatetype( SrcConstrStateData%rotors(i1), DstConstrStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL FVW_CopyConstrState( SrcConstrStateData%FVW, DstConstrStateData%FVW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyConstrState

 SUBROUTINE AD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(AD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ConstrStateData%rotors)) THEN
DO i1 = LBOUND(ConstrStateData%rotors,1), UBOUND(ConstrStateData%rotors,1)
  CALL AD_DestroyRotConstraintStateType( ConstrStateData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ConstrStateData%rotors)
ENDIF
  CALL FVW_DestroyConstrState( ConstrStateData%FVW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyConstrState


subroutine AD_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotConstraintStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_PackConstrState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackConstrState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotConstraintStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! FVW
   call FVW_UnpackConstrState(Buf, OutData%FVW) ! FVW 
end subroutine
 SUBROUTINE AD_CopyRotOtherStateType( SrcRotOtherStateTypeData, DstRotOtherStateTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotOtherStateType), INTENT(IN) :: SrcRotOtherStateTypeData
   TYPE(RotOtherStateType), INTENT(INOUT) :: DstRotOtherStateTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotOtherStateType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyOtherState( SrcRotOtherStateTypeData%BEMT, DstRotOtherStateTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyOtherState( SrcRotOtherStateTypeData%AA, DstRotOtherStateTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotOtherStateType

 SUBROUTINE AD_DestroyRotOtherStateType( RotOtherStateTypeData, ErrStat, ErrMsg )
  TYPE(RotOtherStateType), INTENT(INOUT) :: RotOtherStateTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotOtherStateType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL BEMT_DestroyOtherState( RotOtherStateTypeData%BEMT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyOtherState( RotOtherStateTypeData%AA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotOtherStateType


subroutine AD_PackRotOtherStateType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotOtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotOtherStateType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! BEMT
   call BEMT_PackOtherState(Buf, InData%BEMT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA
   call AA_PackOtherState(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotOtherStateType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotOtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotOtherStateType'
   if (Buf%ErrStat /= ErrID_None) return
   ! BEMT
   call BEMT_UnpackOtherState(Buf, OutData%BEMT) ! BEMT 
   ! AA
   call AA_UnpackOtherState(Buf, OutData%AA) ! AA 
end subroutine
 SUBROUTINE AD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(AD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%rotors)) THEN
  i1_l = LBOUND(SrcOtherStateData%rotors,1)
  i1_u = UBOUND(SrcOtherStateData%rotors,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%rotors)) THEN 
    ALLOCATE(DstOtherStateData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%rotors,1), UBOUND(SrcOtherStateData%rotors,1)
      CALL AD_Copyrototherstatetype( SrcOtherStateData%rotors(i1), DstOtherStateData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL FVW_CopyOtherState( SrcOtherStateData%FVW, DstOtherStateData%FVW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOtherStateData%WakeLocationPoints)) THEN
  i1_l = LBOUND(SrcOtherStateData%WakeLocationPoints,1)
  i1_u = UBOUND(SrcOtherStateData%WakeLocationPoints,1)
  i2_l = LBOUND(SrcOtherStateData%WakeLocationPoints,2)
  i2_u = UBOUND(SrcOtherStateData%WakeLocationPoints,2)
  IF (.NOT. ALLOCATED(DstOtherStateData%WakeLocationPoints)) THEN 
    ALLOCATE(DstOtherStateData%WakeLocationPoints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%WakeLocationPoints.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%WakeLocationPoints = SrcOtherStateData%WakeLocationPoints
ENDIF
 END SUBROUTINE AD_CopyOtherState

 SUBROUTINE AD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(AD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%rotors)) THEN
DO i1 = LBOUND(OtherStateData%rotors,1), UBOUND(OtherStateData%rotors,1)
  CALL AD_DestroyRotOtherStateType( OtherStateData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%rotors)
ENDIF
  CALL FVW_DestroyOtherState( OtherStateData%FVW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(OtherStateData%WakeLocationPoints)) THEN
  DEALLOCATE(OtherStateData%WakeLocationPoints)
ENDIF
 END SUBROUTINE AD_DestroyOtherState


subroutine AD_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackOtherState'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotOtherStateType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_PackOtherState(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeLocationPoints
   call RegPack(Buf, allocated(InData%WakeLocationPoints))
   if (allocated(InData%WakeLocationPoints)) then
      call RegPackBounds(Buf, 2, lbound(InData%WakeLocationPoints), ubound(InData%WakeLocationPoints))
      call RegPack(Buf, InData%WakeLocationPoints)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackOtherState'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotOtherStateType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! FVW
   call FVW_UnpackOtherState(Buf, OutData%FVW) ! FVW 
   ! WakeLocationPoints
   if (allocated(OutData%WakeLocationPoints)) deallocate(OutData%WakeLocationPoints)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WakeLocationPoints(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WakeLocationPoints.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WakeLocationPoints)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyRotMiscVarType( SrcRotMiscVarTypeData, DstRotMiscVarTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotMiscVarType), INTENT(INOUT) :: SrcRotMiscVarTypeData
   TYPE(RotMiscVarType), INTENT(INOUT) :: DstRotMiscVarTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotMiscVarType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL BEMT_CopyMisc( SrcRotMiscVarTypeData%BEMT, DstRotMiscVarTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL BEMT_CopyOutput( SrcRotMiscVarTypeData%BEMT_y, DstRotMiscVarTypeData%BEMT_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BEMT_u,1), UBOUND(SrcRotMiscVarTypeData%BEMT_u,1)
      CALL BEMT_CopyInput( SrcRotMiscVarTypeData%BEMT_u(i1), DstRotMiscVarTypeData%BEMT_u(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
      CALL AA_CopyMisc( SrcRotMiscVarTypeData%AA, DstRotMiscVarTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyOutput( SrcRotMiscVarTypeData%AA_y, DstRotMiscVarTypeData%AA_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyInput( SrcRotMiscVarTypeData%AA_u, DstRotMiscVarTypeData%AA_u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotMiscVarTypeData%DisturbedInflow)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%DisturbedInflow,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%DisturbedInflow,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%DisturbedInflow,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%DisturbedInflow,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%DisturbedInflow,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%DisturbedInflow,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%DisturbedInflow)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%DisturbedInflow(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%DisturbedInflow.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%DisturbedInflow = SrcRotMiscVarTypeData%DisturbedInflow
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%orientationAnnulus)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,3)
  i4_l = LBOUND(SrcRotMiscVarTypeData%orientationAnnulus,4)
  i4_u = UBOUND(SrcRotMiscVarTypeData%orientationAnnulus,4)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%orientationAnnulus)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%orientationAnnulus(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%orientationAnnulus.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%orientationAnnulus = SrcRotMiscVarTypeData%orientationAnnulus
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%AllOuts)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%AllOuts,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%AllOuts,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%AllOuts)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%AllOuts(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%AllOuts.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%AllOuts = SrcRotMiscVarTypeData%AllOuts
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%W_Twr)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%W_Twr,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%W_Twr,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%W_Twr)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%W_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%W_Twr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%W_Twr = SrcRotMiscVarTypeData%W_Twr
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%X_Twr)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%X_Twr,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%X_Twr,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%X_Twr)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%X_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%X_Twr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%X_Twr = SrcRotMiscVarTypeData%X_Twr
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Y_Twr)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Y_Twr,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Y_Twr,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Y_Twr)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Y_Twr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Y_Twr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Y_Twr = SrcRotMiscVarTypeData%Y_Twr
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Curve)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Curve,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Curve,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Curve,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Curve,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Curve)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Curve(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Curve.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Curve = SrcRotMiscVarTypeData%Curve
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrClrnc)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrClrnc,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrClrnc,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrClrnc,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrClrnc,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrClrnc)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrClrnc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrClrnc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrClrnc = SrcRotMiscVarTypeData%TwrClrnc
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%X)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%X,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%X,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%X,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%X,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%X)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%X(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%X.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%X = SrcRotMiscVarTypeData%X
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Y)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Y,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Y,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Y,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Y,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Y)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Y(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Y = SrcRotMiscVarTypeData%Y
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Z)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Z,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Z,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Z,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Z,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Z)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Z(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Z.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Z = SrcRotMiscVarTypeData%Z
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%M)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%M,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%M,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%M,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%M,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%M)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%M = SrcRotMiscVarTypeData%M
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Mx)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Mx,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Mx,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Mx,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Mx,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Mx)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Mx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Mx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Mx = SrcRotMiscVarTypeData%Mx
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%My)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%My,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%My,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%My,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%My,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%My)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%My(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%My.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%My = SrcRotMiscVarTypeData%My
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%Mz)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%Mz,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%Mz,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%Mz,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%Mz,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%Mz)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%Mz(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%Mz.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%Mz = SrcRotMiscVarTypeData%Mz
ENDIF
    DstRotMiscVarTypeData%V_DiskAvg = SrcRotMiscVarTypeData%V_DiskAvg
    DstRotMiscVarTypeData%yaw = SrcRotMiscVarTypeData%yaw
    DstRotMiscVarTypeData%tilt = SrcRotMiscVarTypeData%tilt
IF (ALLOCATED(SrcRotMiscVarTypeData%hub_theta_x_root)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%hub_theta_x_root,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%hub_theta_x_root,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%hub_theta_x_root)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%hub_theta_x_root(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%hub_theta_x_root.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%hub_theta_x_root = SrcRotMiscVarTypeData%hub_theta_x_root
ENDIF
    DstRotMiscVarTypeData%V_dot_x = SrcRotMiscVarTypeData%V_dot_x
      CALL MeshCopy( SrcRotMiscVarTypeData%HubLoad, DstRotMiscVarTypeData%HubLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotMiscVarTypeData%B_L_2_H_P)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%B_L_2_H_P)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%B_L_2_H_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_L_2_H_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1), UBOUND(SrcRotMiscVarTypeData%B_L_2_H_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%B_L_2_H_P(i1), DstRotMiscVarTypeData%B_L_2_H_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%SigmaCavitCrit)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavitCrit,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%SigmaCavitCrit)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%SigmaCavitCrit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%SigmaCavitCrit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%SigmaCavitCrit = SrcRotMiscVarTypeData%SigmaCavitCrit
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%SigmaCavit)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavit,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavit,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%SigmaCavit,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%SigmaCavit,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%SigmaCavit)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%SigmaCavit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%SigmaCavit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%SigmaCavit = SrcRotMiscVarTypeData%SigmaCavit
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%CavitWarnSet)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%CavitWarnSet,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%CavitWarnSet,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%CavitWarnSet,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%CavitWarnSet,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%CavitWarnSet)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%CavitWarnSet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%CavitWarnSet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%CavitWarnSet = SrcRotMiscVarTypeData%CavitWarnSet
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlFB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlFB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlFB,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlFB,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlFB,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlFB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlFB = SrcRotMiscVarTypeData%BlFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BlMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BlMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BlMB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%BlMB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%BlMB,2)
  i3_l = LBOUND(SrcRotMiscVarTypeData%BlMB,3)
  i3_u = UBOUND(SrcRotMiscVarTypeData%BlMB,3)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BlMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BlMB(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BlMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%BlMB = SrcRotMiscVarTypeData%BlMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrFB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrFB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrFB,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrFB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrFB = SrcRotMiscVarTypeData%TwrFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%TwrMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%TwrMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%TwrMB,1)
  i2_l = LBOUND(SrcRotMiscVarTypeData%TwrMB,2)
  i2_u = UBOUND(SrcRotMiscVarTypeData%TwrMB,2)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%TwrMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%TwrMB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%TwrMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%TwrMB = SrcRotMiscVarTypeData%TwrMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%HubFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%HubFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%HubFB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%HubFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%HubFB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%HubFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%HubFB = SrcRotMiscVarTypeData%HubFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%HubMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%HubMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%HubMB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%HubMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%HubMB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%HubMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%HubMB = SrcRotMiscVarTypeData%HubMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%NacFB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%NacFB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%NacFB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%NacFB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%NacFB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%NacFB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%NacFB = SrcRotMiscVarTypeData%NacFB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%NacMB)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%NacMB,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%NacMB,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%NacMB)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%NacMB(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%NacMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotMiscVarTypeData%NacMB = SrcRotMiscVarTypeData%NacMB
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BladeRootLoad)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BladeRootLoad)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BladeRootLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeRootLoad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1), UBOUND(SrcRotMiscVarTypeData%BladeRootLoad,1)
      CALL MeshCopy( SrcRotMiscVarTypeData%BladeRootLoad(i1), DstRotMiscVarTypeData%BladeRootLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%B_L_2_R_P)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%B_L_2_R_P)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%B_L_2_R_P(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_L_2_R_P.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1), UBOUND(SrcRotMiscVarTypeData%B_L_2_R_P,1)
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%B_L_2_R_P(i1), DstRotMiscVarTypeData%B_L_2_R_P(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BladeBuoyLoadPoint)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BladeBuoyLoadPoint)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BladeBuoyLoadPoint(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeBuoyLoadPoint.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1), UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoadPoint,1)
      CALL MeshCopy( SrcRotMiscVarTypeData%BladeBuoyLoadPoint(i1), DstRotMiscVarTypeData%BladeBuoyLoadPoint(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%BladeBuoyLoad)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%BladeBuoyLoad)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%BladeBuoyLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%BladeBuoyLoad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1), UBOUND(SrcRotMiscVarTypeData%BladeBuoyLoad,1)
      CALL MeshCopy( SrcRotMiscVarTypeData%BladeBuoyLoad(i1), DstRotMiscVarTypeData%BladeBuoyLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotMiscVarTypeData%B_P_2_B_L)) THEN
  i1_l = LBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1)
  i1_u = UBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1)
  IF (.NOT. ALLOCATED(DstRotMiscVarTypeData%B_P_2_B_L)) THEN 
    ALLOCATE(DstRotMiscVarTypeData%B_P_2_B_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotMiscVarTypeData%B_P_2_B_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1), UBOUND(SrcRotMiscVarTypeData%B_P_2_B_L,1)
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%B_P_2_B_L(i1), DstRotMiscVarTypeData%B_P_2_B_L(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcRotMiscVarTypeData%TwrBuoyLoadPoint, DstRotMiscVarTypeData%TwrBuoyLoadPoint, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotMiscVarTypeData%TwrBuoyLoad, DstRotMiscVarTypeData%TwrBuoyLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcRotMiscVarTypeData%T_P_2_T_L, DstRotMiscVarTypeData%T_P_2_T_L, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstRotMiscVarTypeData%FirstWarn_TowerStrike = SrcRotMiscVarTypeData%FirstWarn_TowerStrike
    DstRotMiscVarTypeData%AvgDiskVel = SrcRotMiscVarTypeData%AvgDiskVel
    DstRotMiscVarTypeData%AvgDiskVelDist = SrcRotMiscVarTypeData%AvgDiskVelDist
    DstRotMiscVarTypeData%TFinAlpha = SrcRotMiscVarTypeData%TFinAlpha
    DstRotMiscVarTypeData%TFinRe = SrcRotMiscVarTypeData%TFinRe
    DstRotMiscVarTypeData%TFinVrel = SrcRotMiscVarTypeData%TFinVrel
    DstRotMiscVarTypeData%TFinVund_i = SrcRotMiscVarTypeData%TFinVund_i
    DstRotMiscVarTypeData%TFinVind_i = SrcRotMiscVarTypeData%TFinVind_i
    DstRotMiscVarTypeData%TFinVrel_i = SrcRotMiscVarTypeData%TFinVrel_i
    DstRotMiscVarTypeData%TFinSTV_i = SrcRotMiscVarTypeData%TFinSTV_i
    DstRotMiscVarTypeData%TFinF_i = SrcRotMiscVarTypeData%TFinF_i
    DstRotMiscVarTypeData%TFinM_i = SrcRotMiscVarTypeData%TFinM_i
 END SUBROUTINE AD_CopyRotMiscVarType

 SUBROUTINE AD_DestroyRotMiscVarType( RotMiscVarTypeData, ErrStat, ErrMsg )
  TYPE(RotMiscVarType), INTENT(INOUT) :: RotMiscVarTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotMiscVarType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL BEMT_DestroyMisc( RotMiscVarTypeData%BEMT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL BEMT_DestroyOutput( RotMiscVarTypeData%BEMT_y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
DO i1 = LBOUND(RotMiscVarTypeData%BEMT_u,1), UBOUND(RotMiscVarTypeData%BEMT_u,1)
  CALL BEMT_DestroyInput( RotMiscVarTypeData%BEMT_u(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  CALL AA_DestroyMisc( RotMiscVarTypeData%AA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyOutput( RotMiscVarTypeData%AA_y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyInput( RotMiscVarTypeData%AA_u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotMiscVarTypeData%DisturbedInflow)) THEN
  DEALLOCATE(RotMiscVarTypeData%DisturbedInflow)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%orientationAnnulus)) THEN
  DEALLOCATE(RotMiscVarTypeData%orientationAnnulus)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%AllOuts)) THEN
  DEALLOCATE(RotMiscVarTypeData%AllOuts)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%W_Twr)) THEN
  DEALLOCATE(RotMiscVarTypeData%W_Twr)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%X_Twr)) THEN
  DEALLOCATE(RotMiscVarTypeData%X_Twr)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Y_Twr)) THEN
  DEALLOCATE(RotMiscVarTypeData%Y_Twr)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Curve)) THEN
  DEALLOCATE(RotMiscVarTypeData%Curve)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrClrnc)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrClrnc)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%X)) THEN
  DEALLOCATE(RotMiscVarTypeData%X)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Y)) THEN
  DEALLOCATE(RotMiscVarTypeData%Y)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Z)) THEN
  DEALLOCATE(RotMiscVarTypeData%Z)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%M)) THEN
  DEALLOCATE(RotMiscVarTypeData%M)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Mx)) THEN
  DEALLOCATE(RotMiscVarTypeData%Mx)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%My)) THEN
  DEALLOCATE(RotMiscVarTypeData%My)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%Mz)) THEN
  DEALLOCATE(RotMiscVarTypeData%Mz)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%hub_theta_x_root)) THEN
  DEALLOCATE(RotMiscVarTypeData%hub_theta_x_root)
ENDIF
  CALL MeshDestroy( RotMiscVarTypeData%HubLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotMiscVarTypeData%B_L_2_H_P)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%B_L_2_H_P,1), UBOUND(RotMiscVarTypeData%B_L_2_H_P,1)
  CALL NWTC_Library_DestroyMeshMapType( RotMiscVarTypeData%B_L_2_H_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%B_L_2_H_P)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%SigmaCavitCrit)) THEN
  DEALLOCATE(RotMiscVarTypeData%SigmaCavitCrit)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%SigmaCavit)) THEN
  DEALLOCATE(RotMiscVarTypeData%SigmaCavit)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%CavitWarnSet)) THEN
  DEALLOCATE(RotMiscVarTypeData%CavitWarnSet)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BlMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%BlMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%TwrMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%TwrMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%HubFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%HubFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%HubMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%HubMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%NacFB)) THEN
  DEALLOCATE(RotMiscVarTypeData%NacFB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%NacMB)) THEN
  DEALLOCATE(RotMiscVarTypeData%NacMB)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BladeRootLoad)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%BladeRootLoad,1), UBOUND(RotMiscVarTypeData%BladeRootLoad,1)
  CALL MeshDestroy( RotMiscVarTypeData%BladeRootLoad(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%BladeRootLoad)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%B_L_2_R_P)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%B_L_2_R_P,1), UBOUND(RotMiscVarTypeData%B_L_2_R_P,1)
  CALL NWTC_Library_DestroyMeshMapType( RotMiscVarTypeData%B_L_2_R_P(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%B_L_2_R_P)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BladeBuoyLoadPoint)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%BladeBuoyLoadPoint,1), UBOUND(RotMiscVarTypeData%BladeBuoyLoadPoint,1)
  CALL MeshDestroy( RotMiscVarTypeData%BladeBuoyLoadPoint(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%BladeBuoyLoadPoint)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%BladeBuoyLoad)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%BladeBuoyLoad,1), UBOUND(RotMiscVarTypeData%BladeBuoyLoad,1)
  CALL MeshDestroy( RotMiscVarTypeData%BladeBuoyLoad(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%BladeBuoyLoad)
ENDIF
IF (ALLOCATED(RotMiscVarTypeData%B_P_2_B_L)) THEN
DO i1 = LBOUND(RotMiscVarTypeData%B_P_2_B_L,1), UBOUND(RotMiscVarTypeData%B_P_2_B_L,1)
  CALL NWTC_Library_DestroyMeshMapType( RotMiscVarTypeData%B_P_2_B_L(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotMiscVarTypeData%B_P_2_B_L)
ENDIF
  CALL MeshDestroy( RotMiscVarTypeData%TwrBuoyLoadPoint, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotMiscVarTypeData%TwrBuoyLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( RotMiscVarTypeData%T_P_2_T_L, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotMiscVarType


subroutine AD_PackRotMiscVarType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotMiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotMiscVarType'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   if (Buf%ErrStat >= AbortErrLev) return
   ! BEMT
   call BEMT_PackMisc(Buf, InData%BEMT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BEMT_y
   call BEMT_PackOutput(Buf, InData%BEMT_y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BEMT_u
   LB(1:1) = lbound(InData%BEMT_u)
   UB(1:1) = ubound(InData%BEMT_u)
   do i1 = LB(1), UB(1)
      call BEMT_PackInput(Buf, InData%BEMT_u(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA
   call AA_PackMisc(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA_y
   call AA_PackOutput(Buf, InData%AA_y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA_u
   call AA_PackInput(Buf, InData%AA_u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisturbedInflow
   call RegPack(Buf, allocated(InData%DisturbedInflow))
   if (allocated(InData%DisturbedInflow)) then
      call RegPackBounds(Buf, 3, lbound(InData%DisturbedInflow), ubound(InData%DisturbedInflow))
      call RegPack(Buf, InData%DisturbedInflow)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! orientationAnnulus
   call RegPack(Buf, allocated(InData%orientationAnnulus))
   if (allocated(InData%orientationAnnulus)) then
      call RegPackBounds(Buf, 4, lbound(InData%orientationAnnulus), ubound(InData%orientationAnnulus))
      call RegPack(Buf, InData%orientationAnnulus)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AllOuts
   call RegPack(Buf, allocated(InData%AllOuts))
   if (allocated(InData%AllOuts)) then
      call RegPackBounds(Buf, 1, lbound(InData%AllOuts), ubound(InData%AllOuts))
      call RegPack(Buf, InData%AllOuts)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! W_Twr
   call RegPack(Buf, allocated(InData%W_Twr))
   if (allocated(InData%W_Twr)) then
      call RegPackBounds(Buf, 1, lbound(InData%W_Twr), ubound(InData%W_Twr))
      call RegPack(Buf, InData%W_Twr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! X_Twr
   call RegPack(Buf, allocated(InData%X_Twr))
   if (allocated(InData%X_Twr)) then
      call RegPackBounds(Buf, 1, lbound(InData%X_Twr), ubound(InData%X_Twr))
      call RegPack(Buf, InData%X_Twr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y_Twr
   call RegPack(Buf, allocated(InData%Y_Twr))
   if (allocated(InData%Y_Twr)) then
      call RegPackBounds(Buf, 1, lbound(InData%Y_Twr), ubound(InData%Y_Twr))
      call RegPack(Buf, InData%Y_Twr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Curve
   call RegPack(Buf, allocated(InData%Curve))
   if (allocated(InData%Curve)) then
      call RegPackBounds(Buf, 2, lbound(InData%Curve), ubound(InData%Curve))
      call RegPack(Buf, InData%Curve)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrClrnc
   call RegPack(Buf, allocated(InData%TwrClrnc))
   if (allocated(InData%TwrClrnc)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrClrnc), ubound(InData%TwrClrnc))
      call RegPack(Buf, InData%TwrClrnc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! X
   call RegPack(Buf, allocated(InData%X))
   if (allocated(InData%X)) then
      call RegPackBounds(Buf, 2, lbound(InData%X), ubound(InData%X))
      call RegPack(Buf, InData%X)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y
   call RegPack(Buf, allocated(InData%Y))
   if (allocated(InData%Y)) then
      call RegPackBounds(Buf, 2, lbound(InData%Y), ubound(InData%Y))
      call RegPack(Buf, InData%Y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z
   call RegPack(Buf, allocated(InData%Z))
   if (allocated(InData%Z)) then
      call RegPackBounds(Buf, 2, lbound(InData%Z), ubound(InData%Z))
      call RegPack(Buf, InData%Z)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegPack(Buf, allocated(InData%M))
   if (allocated(InData%M)) then
      call RegPackBounds(Buf, 2, lbound(InData%M), ubound(InData%M))
      call RegPack(Buf, InData%M)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mx
   call RegPack(Buf, allocated(InData%Mx))
   if (allocated(InData%Mx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Mx), ubound(InData%Mx))
      call RegPack(Buf, InData%Mx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! My
   call RegPack(Buf, allocated(InData%My))
   if (allocated(InData%My)) then
      call RegPackBounds(Buf, 2, lbound(InData%My), ubound(InData%My))
      call RegPack(Buf, InData%My)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mz
   call RegPack(Buf, allocated(InData%Mz))
   if (allocated(InData%Mz)) then
      call RegPackBounds(Buf, 2, lbound(InData%Mz), ubound(InData%Mz))
      call RegPack(Buf, InData%Mz)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_DiskAvg
   call RegPack(Buf, InData%V_DiskAvg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! yaw
   call RegPack(Buf, InData%yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! tilt
   call RegPack(Buf, InData%tilt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! hub_theta_x_root
   call RegPack(Buf, allocated(InData%hub_theta_x_root))
   if (allocated(InData%hub_theta_x_root)) then
      call RegPackBounds(Buf, 1, lbound(InData%hub_theta_x_root), ubound(InData%hub_theta_x_root))
      call RegPack(Buf, InData%hub_theta_x_root)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! V_dot_x
   call RegPack(Buf, InData%V_dot_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoad
   call MeshPack(Buf, InData%HubLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_L_2_H_P
   call RegPack(Buf, allocated(InData%B_L_2_H_P))
   if (allocated(InData%B_L_2_H_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%B_L_2_H_P), ubound(InData%B_L_2_H_P))
      LB(1:1) = lbound(InData%B_L_2_H_P)
      UB(1:1) = ubound(InData%B_L_2_H_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%B_L_2_H_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SigmaCavitCrit
   call RegPack(Buf, allocated(InData%SigmaCavitCrit))
   if (allocated(InData%SigmaCavitCrit)) then
      call RegPackBounds(Buf, 2, lbound(InData%SigmaCavitCrit), ubound(InData%SigmaCavitCrit))
      call RegPack(Buf, InData%SigmaCavitCrit)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SigmaCavit
   call RegPack(Buf, allocated(InData%SigmaCavit))
   if (allocated(InData%SigmaCavit)) then
      call RegPackBounds(Buf, 2, lbound(InData%SigmaCavit), ubound(InData%SigmaCavit))
      call RegPack(Buf, InData%SigmaCavit)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CavitWarnSet
   call RegPack(Buf, allocated(InData%CavitWarnSet))
   if (allocated(InData%CavitWarnSet)) then
      call RegPackBounds(Buf, 2, lbound(InData%CavitWarnSet), ubound(InData%CavitWarnSet))
      call RegPack(Buf, InData%CavitWarnSet)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlFB
   call RegPack(Buf, allocated(InData%BlFB))
   if (allocated(InData%BlFB)) then
      call RegPackBounds(Buf, 3, lbound(InData%BlFB), ubound(InData%BlFB))
      call RegPack(Buf, InData%BlFB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlMB
   call RegPack(Buf, allocated(InData%BlMB))
   if (allocated(InData%BlMB)) then
      call RegPackBounds(Buf, 3, lbound(InData%BlMB), ubound(InData%BlMB))
      call RegPack(Buf, InData%BlMB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrFB
   call RegPack(Buf, allocated(InData%TwrFB))
   if (allocated(InData%TwrFB)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrFB), ubound(InData%TwrFB))
      call RegPack(Buf, InData%TwrFB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrMB
   call RegPack(Buf, allocated(InData%TwrMB))
   if (allocated(InData%TwrMB)) then
      call RegPackBounds(Buf, 2, lbound(InData%TwrMB), ubound(InData%TwrMB))
      call RegPack(Buf, InData%TwrMB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubFB
   call RegPack(Buf, allocated(InData%HubFB))
   if (allocated(InData%HubFB)) then
      call RegPackBounds(Buf, 1, lbound(InData%HubFB), ubound(InData%HubFB))
      call RegPack(Buf, InData%HubFB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubMB
   call RegPack(Buf, allocated(InData%HubMB))
   if (allocated(InData%HubMB)) then
      call RegPackBounds(Buf, 1, lbound(InData%HubMB), ubound(InData%HubMB))
      call RegPack(Buf, InData%HubMB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacFB
   call RegPack(Buf, allocated(InData%NacFB))
   if (allocated(InData%NacFB)) then
      call RegPackBounds(Buf, 1, lbound(InData%NacFB), ubound(InData%NacFB))
      call RegPack(Buf, InData%NacFB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacMB
   call RegPack(Buf, allocated(InData%NacMB))
   if (allocated(InData%NacMB)) then
      call RegPackBounds(Buf, 1, lbound(InData%NacMB), ubound(InData%NacMB))
      call RegPack(Buf, InData%NacMB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootLoad
   call RegPack(Buf, allocated(InData%BladeRootLoad))
   if (allocated(InData%BladeRootLoad)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeRootLoad), ubound(InData%BladeRootLoad))
      LB(1:1) = lbound(InData%BladeRootLoad)
      UB(1:1) = ubound(InData%BladeRootLoad)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeRootLoad(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_L_2_R_P
   call RegPack(Buf, allocated(InData%B_L_2_R_P))
   if (allocated(InData%B_L_2_R_P)) then
      call RegPackBounds(Buf, 1, lbound(InData%B_L_2_R_P), ubound(InData%B_L_2_R_P))
      LB(1:1) = lbound(InData%B_L_2_R_P)
      UB(1:1) = ubound(InData%B_L_2_R_P)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%B_L_2_R_P(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeBuoyLoadPoint
   call RegPack(Buf, allocated(InData%BladeBuoyLoadPoint))
   if (allocated(InData%BladeBuoyLoadPoint)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeBuoyLoadPoint), ubound(InData%BladeBuoyLoadPoint))
      LB(1:1) = lbound(InData%BladeBuoyLoadPoint)
      UB(1:1) = ubound(InData%BladeBuoyLoadPoint)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeBuoyLoadPoint(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeBuoyLoad
   call RegPack(Buf, allocated(InData%BladeBuoyLoad))
   if (allocated(InData%BladeBuoyLoad)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeBuoyLoad), ubound(InData%BladeBuoyLoad))
      LB(1:1) = lbound(InData%BladeBuoyLoad)
      UB(1:1) = ubound(InData%BladeBuoyLoad)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeBuoyLoad(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! B_P_2_B_L
   call RegPack(Buf, allocated(InData%B_P_2_B_L))
   if (allocated(InData%B_P_2_B_L)) then
      call RegPackBounds(Buf, 1, lbound(InData%B_P_2_B_L), ubound(InData%B_P_2_B_L))
      LB(1:1) = lbound(InData%B_P_2_B_L)
      UB(1:1) = ubound(InData%B_P_2_B_L)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackMeshMapType(Buf, InData%B_P_2_B_L(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBuoyLoadPoint
   call MeshPack(Buf, InData%TwrBuoyLoadPoint) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrBuoyLoad
   call MeshPack(Buf, InData%TwrBuoyLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! T_P_2_T_L
   call NWTC_Library_PackMeshMapType(Buf, InData%T_P_2_T_L) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstWarn_TowerStrike
   call RegPack(Buf, InData%FirstWarn_TowerStrike)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgDiskVel
   call RegPack(Buf, InData%AvgDiskVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgDiskVelDist
   call RegPack(Buf, InData%AvgDiskVelDist)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAlpha
   call RegPack(Buf, InData%TFinAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinRe
   call RegPack(Buf, InData%TFinRe)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVrel
   call RegPack(Buf, InData%TFinVrel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVund_i
   call RegPack(Buf, InData%TFinVund_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVind_i
   call RegPack(Buf, InData%TFinVind_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVrel_i
   call RegPack(Buf, InData%TFinVrel_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinSTV_i
   call RegPack(Buf, InData%TFinSTV_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinF_i
   call RegPack(Buf, InData%TFinF_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinM_i
   call RegPack(Buf, InData%TFinM_i)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotMiscVarType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotMiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotMiscVarType'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! BEMT
   call BEMT_UnpackMisc(Buf, OutData%BEMT) ! BEMT 
   ! BEMT_y
   call BEMT_UnpackOutput(Buf, OutData%BEMT_y) ! BEMT_y 
   ! BEMT_u
   LB(1:1) = lbound(OutData%BEMT_u)
   UB(1:1) = ubound(OutData%BEMT_u)
   do i1 = LB(1), UB(1)
      call BEMT_UnpackInput(Buf, OutData%BEMT_u(i1)) ! BEMT_u 
   end do
   ! AA
   call AA_UnpackMisc(Buf, OutData%AA) ! AA 
   ! AA_y
   call AA_UnpackOutput(Buf, OutData%AA_y) ! AA_y 
   ! AA_u
   call AA_UnpackInput(Buf, OutData%AA_u) ! AA_u 
   ! DisturbedInflow
   if (allocated(OutData%DisturbedInflow)) deallocate(OutData%DisturbedInflow)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DisturbedInflow(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DisturbedInflow.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DisturbedInflow)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! orientationAnnulus
   if (allocated(OutData%orientationAnnulus)) deallocate(OutData%orientationAnnulus)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%orientationAnnulus(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%orientationAnnulus.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%orientationAnnulus)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AllOuts
   if (allocated(OutData%AllOuts)) deallocate(OutData%AllOuts)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AllOuts(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOuts.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AllOuts)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! W_Twr
   if (allocated(OutData%W_Twr)) deallocate(OutData%W_Twr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W_Twr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W_Twr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%W_Twr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! X_Twr
   if (allocated(OutData%X_Twr)) deallocate(OutData%X_Twr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X_Twr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X_Twr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X_Twr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Y_Twr
   if (allocated(OutData%Y_Twr)) deallocate(OutData%Y_Twr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y_Twr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y_Twr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y_Twr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Curve
   if (allocated(OutData%Curve)) deallocate(OutData%Curve)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Curve(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Curve.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Curve)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrClrnc
   if (allocated(OutData%TwrClrnc)) deallocate(OutData%TwrClrnc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrClrnc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrClrnc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrClrnc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! X
   if (allocated(OutData%X)) deallocate(OutData%X)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%X(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%X.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%X)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Y
   if (allocated(OutData%Y)) deallocate(OutData%Y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Y(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Z
   if (allocated(OutData%Z)) deallocate(OutData%Z)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Z(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Z.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Z)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! M
   if (allocated(OutData%M)) deallocate(OutData%M)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%M(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%M)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Mx
   if (allocated(OutData%Mx)) deallocate(OutData%Mx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Mx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Mx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! My
   if (allocated(OutData%My)) deallocate(OutData%My)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%My(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%My.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%My)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Mz
   if (allocated(OutData%Mz)) deallocate(OutData%Mz)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Mz(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Mz.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Mz)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! V_DiskAvg
   call RegUnpack(Buf, OutData%V_DiskAvg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! yaw
   call RegUnpack(Buf, OutData%yaw)
   if (RegCheckErr(Buf, RoutineName)) return
   ! tilt
   call RegUnpack(Buf, OutData%tilt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! hub_theta_x_root
   if (allocated(OutData%hub_theta_x_root)) deallocate(OutData%hub_theta_x_root)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%hub_theta_x_root(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%hub_theta_x_root.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%hub_theta_x_root)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! V_dot_x
   call RegUnpack(Buf, OutData%V_dot_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoad
   call MeshUnpack(Buf, OutData%HubLoad) ! HubLoad 
   ! B_L_2_H_P
   if (allocated(OutData%B_L_2_H_P)) deallocate(OutData%B_L_2_H_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B_L_2_H_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_L_2_H_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%B_L_2_H_P(i1)) ! B_L_2_H_P 
      end do
   end if
   ! SigmaCavitCrit
   if (allocated(OutData%SigmaCavitCrit)) deallocate(OutData%SigmaCavitCrit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SigmaCavitCrit(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SigmaCavitCrit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SigmaCavitCrit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SigmaCavit
   if (allocated(OutData%SigmaCavit)) deallocate(OutData%SigmaCavit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SigmaCavit(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SigmaCavit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SigmaCavit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CavitWarnSet
   if (allocated(OutData%CavitWarnSet)) deallocate(OutData%CavitWarnSet)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CavitWarnSet(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CavitWarnSet.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CavitWarnSet)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlFB
   if (allocated(OutData%BlFB)) deallocate(OutData%BlFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlFB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlMB
   if (allocated(OutData%BlMB)) deallocate(OutData%BlMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlMB(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrFB
   if (allocated(OutData%TwrFB)) deallocate(OutData%TwrFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrFB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrMB
   if (allocated(OutData%TwrMB)) deallocate(OutData%TwrMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrMB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HubFB
   if (allocated(OutData%HubFB)) deallocate(OutData%HubFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HubFB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HubFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HubFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HubMB
   if (allocated(OutData%HubMB)) deallocate(OutData%HubMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HubMB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HubMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HubMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NacFB
   if (allocated(OutData%NacFB)) deallocate(OutData%NacFB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NacFB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NacFB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NacFB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NacMB
   if (allocated(OutData%NacMB)) deallocate(OutData%NacMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NacMB(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NacMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NacMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BladeRootLoad
   if (allocated(OutData%BladeRootLoad)) deallocate(OutData%BladeRootLoad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootLoad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootLoad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeRootLoad(i1)) ! BladeRootLoad 
      end do
   end if
   ! B_L_2_R_P
   if (allocated(OutData%B_L_2_R_P)) deallocate(OutData%B_L_2_R_P)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B_L_2_R_P(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_L_2_R_P.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%B_L_2_R_P(i1)) ! B_L_2_R_P 
      end do
   end if
   ! BladeBuoyLoadPoint
   if (allocated(OutData%BladeBuoyLoadPoint)) deallocate(OutData%BladeBuoyLoadPoint)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeBuoyLoadPoint(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeBuoyLoadPoint.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeBuoyLoadPoint(i1)) ! BladeBuoyLoadPoint 
      end do
   end if
   ! BladeBuoyLoad
   if (allocated(OutData%BladeBuoyLoad)) deallocate(OutData%BladeBuoyLoad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeBuoyLoad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeBuoyLoad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeBuoyLoad(i1)) ! BladeBuoyLoad 
      end do
   end if
   ! B_P_2_B_L
   if (allocated(OutData%B_P_2_B_L)) deallocate(OutData%B_P_2_B_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B_P_2_B_L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B_P_2_B_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackMeshMapType(Buf, OutData%B_P_2_B_L(i1)) ! B_P_2_B_L 
      end do
   end if
   ! TwrBuoyLoadPoint
   call MeshUnpack(Buf, OutData%TwrBuoyLoadPoint) ! TwrBuoyLoadPoint 
   ! TwrBuoyLoad
   call MeshUnpack(Buf, OutData%TwrBuoyLoad) ! TwrBuoyLoad 
   ! T_P_2_T_L
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%T_P_2_T_L) ! T_P_2_T_L 
   ! FirstWarn_TowerStrike
   call RegUnpack(Buf, OutData%FirstWarn_TowerStrike)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgDiskVel
   call RegUnpack(Buf, OutData%AvgDiskVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AvgDiskVelDist
   call RegUnpack(Buf, OutData%AvgDiskVelDist)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAlpha
   call RegUnpack(Buf, OutData%TFinAlpha)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinRe
   call RegUnpack(Buf, OutData%TFinRe)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVrel
   call RegUnpack(Buf, OutData%TFinVrel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVund_i
   call RegUnpack(Buf, OutData%TFinVund_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVind_i
   call RegUnpack(Buf, OutData%TFinVind_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinVrel_i
   call RegUnpack(Buf, OutData%TFinVrel_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinSTV_i
   call RegUnpack(Buf, OutData%TFinSTV_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinF_i
   call RegUnpack(Buf, OutData%TFinF_i)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinM_i
   call RegUnpack(Buf, OutData%TFinM_i)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE AD_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_MiscVarType), INTENT(INOUT) :: SrcMiscData
   TYPE(AD_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%rotors)) THEN
  i1_l = LBOUND(SrcMiscData%rotors,1)
  i1_u = UBOUND(SrcMiscData%rotors,1)
  IF (.NOT. ALLOCATED(DstMiscData%rotors)) THEN 
    ALLOCATE(DstMiscData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%rotors,1), UBOUND(SrcMiscData%rotors,1)
      CALL AD_Copyrotmiscvartype( SrcMiscData%rotors(i1), DstMiscData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%FVW_u)) THEN
  i1_l = LBOUND(SrcMiscData%FVW_u,1)
  i1_u = UBOUND(SrcMiscData%FVW_u,1)
  IF (.NOT. ALLOCATED(DstMiscData%FVW_u)) THEN 
    ALLOCATE(DstMiscData%FVW_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FVW_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%FVW_u,1), UBOUND(SrcMiscData%FVW_u,1)
      CALL FVW_CopyInput( SrcMiscData%FVW_u(i1), DstMiscData%FVW_u(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL FVW_CopyOutput( SrcMiscData%FVW_y, DstMiscData%FVW_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL FVW_CopyMisc( SrcMiscData%FVW, DstMiscData%FVW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMiscData%WindPos)) THEN
  i1_l = LBOUND(SrcMiscData%WindPos,1)
  i1_u = UBOUND(SrcMiscData%WindPos,1)
  i2_l = LBOUND(SrcMiscData%WindPos,2)
  i2_u = UBOUND(SrcMiscData%WindPos,2)
  IF (.NOT. ALLOCATED(DstMiscData%WindPos)) THEN 
    ALLOCATE(DstMiscData%WindPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WindPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%WindPos = SrcMiscData%WindPos
ENDIF
IF (ALLOCATED(SrcMiscData%WindVel)) THEN
  i1_l = LBOUND(SrcMiscData%WindVel,1)
  i1_u = UBOUND(SrcMiscData%WindVel,1)
  i2_l = LBOUND(SrcMiscData%WindVel,2)
  i2_u = UBOUND(SrcMiscData%WindVel,2)
  IF (.NOT. ALLOCATED(DstMiscData%WindVel)) THEN 
    ALLOCATE(DstMiscData%WindVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WindVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%WindVel = SrcMiscData%WindVel
ENDIF
IF (ALLOCATED(SrcMiscData%WindAcc)) THEN
  i1_l = LBOUND(SrcMiscData%WindAcc,1)
  i1_u = UBOUND(SrcMiscData%WindAcc,1)
  i2_l = LBOUND(SrcMiscData%WindAcc,2)
  i2_u = UBOUND(SrcMiscData%WindAcc,2)
  IF (.NOT. ALLOCATED(DstMiscData%WindAcc)) THEN 
    ALLOCATE(DstMiscData%WindAcc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WindAcc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%WindAcc = SrcMiscData%WindAcc
ENDIF
 END SUBROUTINE AD_CopyMisc

 SUBROUTINE AD_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(AD_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%rotors)) THEN
DO i1 = LBOUND(MiscData%rotors,1), UBOUND(MiscData%rotors,1)
  CALL AD_DestroyRotMiscVarType( MiscData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%rotors)
ENDIF
IF (ALLOCATED(MiscData%FVW_u)) THEN
DO i1 = LBOUND(MiscData%FVW_u,1), UBOUND(MiscData%FVW_u,1)
  CALL FVW_DestroyInput( MiscData%FVW_u(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%FVW_u)
ENDIF
  CALL FVW_DestroyOutput( MiscData%FVW_y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL FVW_DestroyMisc( MiscData%FVW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%WindPos)) THEN
  DEALLOCATE(MiscData%WindPos)
ENDIF
IF (ALLOCATED(MiscData%WindVel)) THEN
  DEALLOCATE(MiscData%WindVel)
ENDIF
IF (ALLOCATED(MiscData%WindAcc)) THEN
  DEALLOCATE(MiscData%WindAcc)
ENDIF
 END SUBROUTINE AD_DestroyMisc


subroutine AD_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotMiscVarType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW_u
   call RegPack(Buf, allocated(InData%FVW_u))
   if (allocated(InData%FVW_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%FVW_u), ubound(InData%FVW_u))
      LB(1:1) = lbound(InData%FVW_u)
      UB(1:1) = ubound(InData%FVW_u)
      do i1 = LB(1), UB(1)
         call FVW_PackInput(Buf, InData%FVW_u(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW_y
   call FVW_PackOutput(Buf, InData%FVW_y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_PackMisc(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindPos
   call RegPack(Buf, allocated(InData%WindPos))
   if (allocated(InData%WindPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%WindPos), ubound(InData%WindPos))
      call RegPack(Buf, InData%WindPos)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindVel
   call RegPack(Buf, allocated(InData%WindVel))
   if (allocated(InData%WindVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%WindVel), ubound(InData%WindVel))
      call RegPack(Buf, InData%WindVel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindAcc
   call RegPack(Buf, allocated(InData%WindAcc))
   if (allocated(InData%WindAcc)) then
      call RegPackBounds(Buf, 2, lbound(InData%WindAcc), ubound(InData%WindAcc))
      call RegPack(Buf, InData%WindAcc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotMiscVarType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! FVW_u
   if (allocated(OutData%FVW_u)) deallocate(OutData%FVW_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FVW_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FVW_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call FVW_UnpackInput(Buf, OutData%FVW_u(i1)) ! FVW_u 
      end do
   end if
   ! FVW_y
   call FVW_UnpackOutput(Buf, OutData%FVW_y) ! FVW_y 
   ! FVW
   call FVW_UnpackMisc(Buf, OutData%FVW) ! FVW 
   ! WindPos
   if (allocated(OutData%WindPos)) deallocate(OutData%WindPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WindVel
   if (allocated(OutData%WindVel)) deallocate(OutData%WindVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WindAcc
   if (allocated(OutData%WindAcc)) deallocate(OutData%WindAcc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WindAcc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindAcc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WindAcc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyRotParameterType( SrcRotParameterTypeData, DstRotParameterTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotParameterType), INTENT(IN) :: SrcRotParameterTypeData
   TYPE(RotParameterType), INTENT(INOUT) :: DstRotParameterTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotParameterType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRotParameterTypeData%NumBlades = SrcRotParameterTypeData%NumBlades
    DstRotParameterTypeData%NumBlNds = SrcRotParameterTypeData%NumBlNds
    DstRotParameterTypeData%NumTwrNds = SrcRotParameterTypeData%NumTwrNds
IF (ALLOCATED(SrcRotParameterTypeData%TwrDiam)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrDiam,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrDiam,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrDiam)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrDiam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrDiam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrDiam = SrcRotParameterTypeData%TwrDiam
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrCd)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrCd,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrCd,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrCd)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrCd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrCd = SrcRotParameterTypeData%TwrCd
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrTI)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrTI,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrTI,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrTI)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrTI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrTI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrTI = SrcRotParameterTypeData%TwrTI
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlTwist)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlTwist,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlTwist,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlTwist,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlTwist,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlTwist)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlTwist(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlTwist.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlTwist = SrcRotParameterTypeData%BlTwist
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrCb)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrCb,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrCb,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrCb)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrCb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrCb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrCb = SrcRotParameterTypeData%TwrCb
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlCenBn)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlCenBn,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlCenBn,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlCenBn,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlCenBn,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlCenBn)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlCenBn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlCenBn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlCenBn = SrcRotParameterTypeData%BlCenBn
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlCenBt)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlCenBt,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlCenBt,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlCenBt,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlCenBt,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlCenBt)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlCenBt(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlCenBt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlCenBt = SrcRotParameterTypeData%BlCenBt
ENDIF
    DstRotParameterTypeData%VolHub = SrcRotParameterTypeData%VolHub
    DstRotParameterTypeData%HubCenBx = SrcRotParameterTypeData%HubCenBx
    DstRotParameterTypeData%VolNac = SrcRotParameterTypeData%VolNac
    DstRotParameterTypeData%NacCenB = SrcRotParameterTypeData%NacCenB
    DstRotParameterTypeData%VolBl = SrcRotParameterTypeData%VolBl
    DstRotParameterTypeData%VolTwr = SrcRotParameterTypeData%VolTwr
IF (ALLOCATED(SrcRotParameterTypeData%BlRad)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlRad,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlRad,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlRad,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlRad,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlRad)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlRad(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlRad = SrcRotParameterTypeData%BlRad
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlDL)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlDL,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlDL,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlDL,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlDL,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlDL)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlDL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlDL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlDL = SrcRotParameterTypeData%BlDL
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlTaper)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlTaper,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlTaper,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlTaper,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlTaper,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlTaper)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlTaper(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlTaper.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlTaper = SrcRotParameterTypeData%BlTaper
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BlAxCent)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BlAxCent,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BlAxCent,1)
  i2_l = LBOUND(SrcRotParameterTypeData%BlAxCent,2)
  i2_u = UBOUND(SrcRotParameterTypeData%BlAxCent,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BlAxCent)) THEN 
    ALLOCATE(DstRotParameterTypeData%BlAxCent(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BlAxCent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BlAxCent = SrcRotParameterTypeData%BlAxCent
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrRad)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrRad,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrRad,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrRad)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrRad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrRad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrRad = SrcRotParameterTypeData%TwrRad
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrDL)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrDL,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrDL,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrDL)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrDL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrDL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrDL = SrcRotParameterTypeData%TwrDL
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrTaper)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrTaper,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrTaper,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrTaper)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrTaper(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrTaper.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrTaper = SrcRotParameterTypeData%TwrTaper
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%TwrAxCent)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%TwrAxCent,1)
  i1_u = UBOUND(SrcRotParameterTypeData%TwrAxCent,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%TwrAxCent)) THEN 
    ALLOCATE(DstRotParameterTypeData%TwrAxCent(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%TwrAxCent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%TwrAxCent = SrcRotParameterTypeData%TwrAxCent
ENDIF
      CALL BEMT_CopyParam( SrcRotParameterTypeData%BEMT, DstRotParameterTypeData%BEMT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL AA_CopyParam( SrcRotParameterTypeData%AA, DstRotParameterTypeData%AA, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotParameterTypeData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%Jac_u_indx,1)
  i1_u = UBOUND(SrcRotParameterTypeData%Jac_u_indx,1)
  i2_l = LBOUND(SrcRotParameterTypeData%Jac_u_indx,2)
  i2_u = UBOUND(SrcRotParameterTypeData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%Jac_u_indx)) THEN 
    ALLOCATE(DstRotParameterTypeData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%Jac_u_indx = SrcRotParameterTypeData%Jac_u_indx
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%du)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%du,1)
  i1_u = UBOUND(SrcRotParameterTypeData%du,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%du)) THEN 
    ALLOCATE(DstRotParameterTypeData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%du.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%du = SrcRotParameterTypeData%du
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%dx)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%dx,1)
  i1_u = UBOUND(SrcRotParameterTypeData%dx,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%dx)) THEN 
    ALLOCATE(DstRotParameterTypeData%dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%dx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%dx = SrcRotParameterTypeData%dx
ENDIF
    DstRotParameterTypeData%Jac_ny = SrcRotParameterTypeData%Jac_ny
    DstRotParameterTypeData%NumBl_Lin = SrcRotParameterTypeData%NumBl_Lin
    DstRotParameterTypeData%TwrPotent = SrcRotParameterTypeData%TwrPotent
    DstRotParameterTypeData%TwrShadow = SrcRotParameterTypeData%TwrShadow
    DstRotParameterTypeData%TwrAero = SrcRotParameterTypeData%TwrAero
    DstRotParameterTypeData%FrozenWake = SrcRotParameterTypeData%FrozenWake
    DstRotParameterTypeData%CavitCheck = SrcRotParameterTypeData%CavitCheck
    DstRotParameterTypeData%Buoyancy = SrcRotParameterTypeData%Buoyancy
    DstRotParameterTypeData%MHK = SrcRotParameterTypeData%MHK
    DstRotParameterTypeData%CompAA = SrcRotParameterTypeData%CompAA
    DstRotParameterTypeData%AirDens = SrcRotParameterTypeData%AirDens
    DstRotParameterTypeData%KinVisc = SrcRotParameterTypeData%KinVisc
    DstRotParameterTypeData%SpdSound = SrcRotParameterTypeData%SpdSound
    DstRotParameterTypeData%Gravity = SrcRotParameterTypeData%Gravity
    DstRotParameterTypeData%Patm = SrcRotParameterTypeData%Patm
    DstRotParameterTypeData%Pvap = SrcRotParameterTypeData%Pvap
    DstRotParameterTypeData%WtrDpth = SrcRotParameterTypeData%WtrDpth
    DstRotParameterTypeData%MSL2SWL = SrcRotParameterTypeData%MSL2SWL
    DstRotParameterTypeData%AeroProjMod = SrcRotParameterTypeData%AeroProjMod
    DstRotParameterTypeData%AeroBEM_Mod = SrcRotParameterTypeData%AeroBEM_Mod
    DstRotParameterTypeData%NumOuts = SrcRotParameterTypeData%NumOuts
    DstRotParameterTypeData%RootName = SrcRotParameterTypeData%RootName
IF (ALLOCATED(SrcRotParameterTypeData%OutParam)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%OutParam,1)
  i1_u = UBOUND(SrcRotParameterTypeData%OutParam,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%OutParam)) THEN 
    ALLOCATE(DstRotParameterTypeData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotParameterTypeData%OutParam,1), UBOUND(SrcRotParameterTypeData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcRotParameterTypeData%OutParam(i1), DstRotParameterTypeData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstRotParameterTypeData%NBlOuts = SrcRotParameterTypeData%NBlOuts
    DstRotParameterTypeData%BlOutNd = SrcRotParameterTypeData%BlOutNd
    DstRotParameterTypeData%NTwOuts = SrcRotParameterTypeData%NTwOuts
    DstRotParameterTypeData%TwOutNd = SrcRotParameterTypeData%TwOutNd
    DstRotParameterTypeData%BldNd_NumOuts = SrcRotParameterTypeData%BldNd_NumOuts
    DstRotParameterTypeData%BldNd_TotNumOuts = SrcRotParameterTypeData%BldNd_TotNumOuts
IF (ALLOCATED(SrcRotParameterTypeData%BldNd_OutParam)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BldNd_OutParam,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BldNd_OutParam,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BldNd_OutParam)) THEN 
    ALLOCATE(DstRotParameterTypeData%BldNd_OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BldNd_OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotParameterTypeData%BldNd_OutParam,1), UBOUND(SrcRotParameterTypeData%BldNd_OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcRotParameterTypeData%BldNd_OutParam(i1), DstRotParameterTypeData%BldNd_OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotParameterTypeData%BldNd_BlOutNd)) THEN
  i1_l = LBOUND(SrcRotParameterTypeData%BldNd_BlOutNd,1)
  i1_u = UBOUND(SrcRotParameterTypeData%BldNd_BlOutNd,1)
  IF (.NOT. ALLOCATED(DstRotParameterTypeData%BldNd_BlOutNd)) THEN 
    ALLOCATE(DstRotParameterTypeData%BldNd_BlOutNd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotParameterTypeData%BldNd_BlOutNd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotParameterTypeData%BldNd_BlOutNd = SrcRotParameterTypeData%BldNd_BlOutNd
ENDIF
    DstRotParameterTypeData%BldNd_BladesOut = SrcRotParameterTypeData%BldNd_BladesOut
    DstRotParameterTypeData%TFinAero = SrcRotParameterTypeData%TFinAero
      CALL AD_Copytfinparametertype( SrcRotParameterTypeData%TFin, DstRotParameterTypeData%TFin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE AD_CopyRotParameterType

 SUBROUTINE AD_DestroyRotParameterType( RotParameterTypeData, ErrStat, ErrMsg )
  TYPE(RotParameterType), INTENT(INOUT) :: RotParameterTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotParameterType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(RotParameterTypeData%TwrDiam)) THEN
  DEALLOCATE(RotParameterTypeData%TwrDiam)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrCd)) THEN
  DEALLOCATE(RotParameterTypeData%TwrCd)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrTI)) THEN
  DEALLOCATE(RotParameterTypeData%TwrTI)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlTwist)) THEN
  DEALLOCATE(RotParameterTypeData%BlTwist)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrCb)) THEN
  DEALLOCATE(RotParameterTypeData%TwrCb)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlCenBn)) THEN
  DEALLOCATE(RotParameterTypeData%BlCenBn)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlCenBt)) THEN
  DEALLOCATE(RotParameterTypeData%BlCenBt)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlRad)) THEN
  DEALLOCATE(RotParameterTypeData%BlRad)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlDL)) THEN
  DEALLOCATE(RotParameterTypeData%BlDL)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlTaper)) THEN
  DEALLOCATE(RotParameterTypeData%BlTaper)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BlAxCent)) THEN
  DEALLOCATE(RotParameterTypeData%BlAxCent)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrRad)) THEN
  DEALLOCATE(RotParameterTypeData%TwrRad)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrDL)) THEN
  DEALLOCATE(RotParameterTypeData%TwrDL)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrTaper)) THEN
  DEALLOCATE(RotParameterTypeData%TwrTaper)
ENDIF
IF (ALLOCATED(RotParameterTypeData%TwrAxCent)) THEN
  DEALLOCATE(RotParameterTypeData%TwrAxCent)
ENDIF
  CALL BEMT_DestroyParam( RotParameterTypeData%BEMT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL AA_DestroyParam( RotParameterTypeData%AA, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotParameterTypeData%Jac_u_indx)) THEN
  DEALLOCATE(RotParameterTypeData%Jac_u_indx)
ENDIF
IF (ALLOCATED(RotParameterTypeData%du)) THEN
  DEALLOCATE(RotParameterTypeData%du)
ENDIF
IF (ALLOCATED(RotParameterTypeData%dx)) THEN
  DEALLOCATE(RotParameterTypeData%dx)
ENDIF
IF (ALLOCATED(RotParameterTypeData%OutParam)) THEN
DO i1 = LBOUND(RotParameterTypeData%OutParam,1), UBOUND(RotParameterTypeData%OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( RotParameterTypeData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotParameterTypeData%OutParam)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BldNd_OutParam)) THEN
DO i1 = LBOUND(RotParameterTypeData%BldNd_OutParam,1), UBOUND(RotParameterTypeData%BldNd_OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( RotParameterTypeData%BldNd_OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotParameterTypeData%BldNd_OutParam)
ENDIF
IF (ALLOCATED(RotParameterTypeData%BldNd_BlOutNd)) THEN
  DEALLOCATE(RotParameterTypeData%BldNd_BlOutNd)
ENDIF
  CALL AD_DestroyTFinParameterType( RotParameterTypeData%TFin, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE AD_DestroyRotParameterType


subroutine AD_PackRotParameterType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotParameterType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumBlades
   call RegPack(Buf, InData%NumBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBlNds
   call RegPack(Buf, InData%NumBlNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTwrNds
   call RegPack(Buf, InData%NumTwrNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrDiam
   call RegPack(Buf, allocated(InData%TwrDiam))
   if (allocated(InData%TwrDiam)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDiam), ubound(InData%TwrDiam))
      call RegPack(Buf, InData%TwrDiam)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrCd
   call RegPack(Buf, allocated(InData%TwrCd))
   if (allocated(InData%TwrCd)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCd), ubound(InData%TwrCd))
      call RegPack(Buf, InData%TwrCd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrTI
   call RegPack(Buf, allocated(InData%TwrTI))
   if (allocated(InData%TwrTI)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrTI), ubound(InData%TwrTI))
      call RegPack(Buf, InData%TwrTI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlTwist
   call RegPack(Buf, allocated(InData%BlTwist))
   if (allocated(InData%BlTwist)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlTwist), ubound(InData%BlTwist))
      call RegPack(Buf, InData%BlTwist)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrCb
   call RegPack(Buf, allocated(InData%TwrCb))
   if (allocated(InData%TwrCb)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrCb), ubound(InData%TwrCb))
      call RegPack(Buf, InData%TwrCb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCenBn
   call RegPack(Buf, allocated(InData%BlCenBn))
   if (allocated(InData%BlCenBn)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlCenBn), ubound(InData%BlCenBn))
      call RegPack(Buf, InData%BlCenBn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlCenBt
   call RegPack(Buf, allocated(InData%BlCenBt))
   if (allocated(InData%BlCenBt)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlCenBt), ubound(InData%BlCenBt))
      call RegPack(Buf, InData%BlCenBt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolHub
   call RegPack(Buf, InData%VolHub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubCenBx
   call RegPack(Buf, InData%HubCenBx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolNac
   call RegPack(Buf, InData%VolNac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacCenB
   call RegPack(Buf, InData%NacCenB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolBl
   call RegPack(Buf, InData%VolBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolTwr
   call RegPack(Buf, InData%VolTwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlRad
   call RegPack(Buf, allocated(InData%BlRad))
   if (allocated(InData%BlRad)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlRad), ubound(InData%BlRad))
      call RegPack(Buf, InData%BlRad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlDL
   call RegPack(Buf, allocated(InData%BlDL))
   if (allocated(InData%BlDL)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlDL), ubound(InData%BlDL))
      call RegPack(Buf, InData%BlDL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlTaper
   call RegPack(Buf, allocated(InData%BlTaper))
   if (allocated(InData%BlTaper)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlTaper), ubound(InData%BlTaper))
      call RegPack(Buf, InData%BlTaper)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlAxCent
   call RegPack(Buf, allocated(InData%BlAxCent))
   if (allocated(InData%BlAxCent)) then
      call RegPackBounds(Buf, 2, lbound(InData%BlAxCent), ubound(InData%BlAxCent))
      call RegPack(Buf, InData%BlAxCent)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrRad
   call RegPack(Buf, allocated(InData%TwrRad))
   if (allocated(InData%TwrRad)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrRad), ubound(InData%TwrRad))
      call RegPack(Buf, InData%TwrRad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrDL
   call RegPack(Buf, allocated(InData%TwrDL))
   if (allocated(InData%TwrDL)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrDL), ubound(InData%TwrDL))
      call RegPack(Buf, InData%TwrDL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrTaper
   call RegPack(Buf, allocated(InData%TwrTaper))
   if (allocated(InData%TwrTaper)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrTaper), ubound(InData%TwrTaper))
      call RegPack(Buf, InData%TwrTaper)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrAxCent
   call RegPack(Buf, allocated(InData%TwrAxCent))
   if (allocated(InData%TwrAxCent)) then
      call RegPackBounds(Buf, 1, lbound(InData%TwrAxCent), ubound(InData%TwrAxCent))
      call RegPack(Buf, InData%TwrAxCent)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BEMT
   call BEMT_PackParam(Buf, InData%BEMT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! AA
   call AA_PackParam(Buf, InData%AA) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! du
   call RegPack(Buf, allocated(InData%du))
   if (allocated(InData%du)) then
      call RegPackBounds(Buf, 1, lbound(InData%du), ubound(InData%du))
      call RegPack(Buf, InData%du)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegPack(Buf, allocated(InData%dx))
   if (allocated(InData%dx)) then
      call RegPackBounds(Buf, 1, lbound(InData%dx), ubound(InData%dx))
      call RegPack(Buf, InData%dx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegPack(Buf, InData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl_Lin
   call RegPack(Buf, InData%NumBl_Lin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrPotent
   call RegPack(Buf, InData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadow
   call RegPack(Buf, InData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrAero
   call RegPack(Buf, InData%TwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FrozenWake
   call RegPack(Buf, InData%FrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CavitCheck
   call RegPack(Buf, InData%CavitCheck)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Buoyancy
   call RegPack(Buf, InData%Buoyancy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegPack(Buf, InData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAA
   call RegPack(Buf, InData%CompAA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegPack(Buf, InData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegPack(Buf, InData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdSound
   call RegPack(Buf, InData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Patm
   call RegPack(Buf, InData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pvap
   call RegPack(Buf, InData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroProjMod
   call RegPack(Buf, InData%AeroProjMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroBEM_Mod
   call RegPack(Buf, InData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBlOuts
   call RegPack(Buf, InData%NBlOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlOutNd
   call RegPack(Buf, InData%BlOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwOuts
   call RegPack(Buf, InData%NTwOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwOutNd
   call RegPack(Buf, InData%TwOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_NumOuts
   call RegPack(Buf, InData%BldNd_NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_TotNumOuts
   call RegPack(Buf, InData%BldNd_TotNumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_OutParam
   call RegPack(Buf, allocated(InData%BldNd_OutParam))
   if (allocated(InData%BldNd_OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%BldNd_OutParam), ubound(InData%BldNd_OutParam))
      LB(1:1) = lbound(InData%BldNd_OutParam)
      UB(1:1) = ubound(InData%BldNd_OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%BldNd_OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_BlOutNd
   call RegPack(Buf, allocated(InData%BldNd_BlOutNd))
   if (allocated(InData%BldNd_BlOutNd)) then
      call RegPackBounds(Buf, 1, lbound(InData%BldNd_BlOutNd), ubound(InData%BldNd_BlOutNd))
      call RegPack(Buf, InData%BldNd_BlOutNd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_BladesOut
   call RegPack(Buf, InData%BldNd_BladesOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAero
   call RegPack(Buf, InData%TFinAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFin
   call AD_PackTFinParameterType(Buf, InData%TFin) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotParameterType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotParameterType'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NumBlades
   call RegUnpack(Buf, OutData%NumBlades)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBlNds
   call RegUnpack(Buf, OutData%NumBlNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTwrNds
   call RegUnpack(Buf, OutData%NumTwrNds)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrDiam
   if (allocated(OutData%TwrDiam)) deallocate(OutData%TwrDiam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDiam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDiam)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrCd
   if (allocated(OutData%TwrCd)) deallocate(OutData%TwrCd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrTI
   if (allocated(OutData%TwrTI)) deallocate(OutData%TwrTI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrTI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrTI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlTwist
   if (allocated(OutData%BlTwist)) deallocate(OutData%BlTwist)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlTwist(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTwist.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlTwist)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrCb
   if (allocated(OutData%TwrCb)) deallocate(OutData%TwrCb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrCb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrCb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrCb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCenBn
   if (allocated(OutData%BlCenBn)) deallocate(OutData%BlCenBn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBn(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlCenBt
   if (allocated(OutData%BlCenBt)) deallocate(OutData%BlCenBt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlCenBt(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlCenBt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlCenBt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VolHub
   call RegUnpack(Buf, OutData%VolHub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubCenBx
   call RegUnpack(Buf, OutData%HubCenBx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolNac
   call RegUnpack(Buf, OutData%VolNac)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NacCenB
   call RegUnpack(Buf, OutData%NacCenB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolBl
   call RegUnpack(Buf, OutData%VolBl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VolTwr
   call RegUnpack(Buf, OutData%VolTwr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlRad
   if (allocated(OutData%BlRad)) deallocate(OutData%BlRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlRad(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlDL
   if (allocated(OutData%BlDL)) deallocate(OutData%BlDL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlDL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlDL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlDL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlTaper
   if (allocated(OutData%BlTaper)) deallocate(OutData%BlTaper)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlTaper(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlTaper.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlTaper)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BlAxCent
   if (allocated(OutData%BlAxCent)) deallocate(OutData%BlAxCent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BlAxCent(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlAxCent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BlAxCent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrRad
   if (allocated(OutData%TwrRad)) deallocate(OutData%TwrRad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrRad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrRad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrRad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrDL
   if (allocated(OutData%TwrDL)) deallocate(OutData%TwrDL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrDL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrDL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrDL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrTaper
   if (allocated(OutData%TwrTaper)) deallocate(OutData%TwrTaper)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrTaper(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrTaper.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrTaper)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TwrAxCent
   if (allocated(OutData%TwrAxCent)) deallocate(OutData%TwrAxCent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TwrAxCent(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TwrAxCent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TwrAxCent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BEMT
   call BEMT_UnpackParam(Buf, OutData%BEMT) ! BEMT 
   ! AA
   call AA_UnpackParam(Buf, OutData%AA) ! AA 
   ! Jac_u_indx
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! du
   if (allocated(OutData%du)) deallocate(OutData%du)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%du(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%du)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dx
   if (allocated(OutData%dx)) deallocate(OutData%dx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_ny
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBl_Lin
   call RegUnpack(Buf, OutData%NumBl_Lin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrPotent
   call RegUnpack(Buf, OutData%TwrPotent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrShadow
   call RegUnpack(Buf, OutData%TwrShadow)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwrAero
   call RegUnpack(Buf, OutData%TwrAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FrozenWake
   call RegUnpack(Buf, OutData%FrozenWake)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CavitCheck
   call RegUnpack(Buf, OutData%CavitCheck)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Buoyancy
   call RegUnpack(Buf, OutData%Buoyancy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MHK
   call RegUnpack(Buf, OutData%MHK)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAA
   call RegUnpack(Buf, OutData%CompAA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AirDens
   call RegUnpack(Buf, OutData%AirDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KinVisc
   call RegUnpack(Buf, OutData%KinVisc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpdSound
   call RegUnpack(Buf, OutData%SpdSound)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Patm
   call RegUnpack(Buf, OutData%Patm)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pvap
   call RegUnpack(Buf, OutData%Pvap)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroProjMod
   call RegUnpack(Buf, OutData%AeroProjMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AeroBEM_Mod
   call RegUnpack(Buf, OutData%AeroBEM_Mod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! NBlOuts
   call RegUnpack(Buf, OutData%NBlOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BlOutNd
   call RegUnpack(Buf, OutData%BlOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTwOuts
   call RegUnpack(Buf, OutData%NTwOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TwOutNd
   call RegUnpack(Buf, OutData%TwOutNd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_NumOuts
   call RegUnpack(Buf, OutData%BldNd_NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_TotNumOuts
   call RegUnpack(Buf, OutData%BldNd_TotNumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BldNd_OutParam
   if (allocated(OutData%BldNd_OutParam)) deallocate(OutData%BldNd_OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BldNd_OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%BldNd_OutParam(i1)) ! BldNd_OutParam 
      end do
   end if
   ! BldNd_BlOutNd
   if (allocated(OutData%BldNd_BlOutNd)) deallocate(OutData%BldNd_BlOutNd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BldNd_BlOutNd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BldNd_BlOutNd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BldNd_BlOutNd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BldNd_BladesOut
   call RegUnpack(Buf, OutData%BldNd_BladesOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinAero
   call RegUnpack(Buf, OutData%TFinAero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFin
   call AD_UnpackTFinParameterType(Buf, OutData%TFin) ! TFin 
end subroutine
 SUBROUTINE AD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(AD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcParamData%rotors)) THEN
  i1_l = LBOUND(SrcParamData%rotors,1)
  i1_u = UBOUND(SrcParamData%rotors,1)
  IF (.NOT. ALLOCATED(DstParamData%rotors)) THEN 
    ALLOCATE(DstParamData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%rotors,1), UBOUND(SrcParamData%rotors,1)
      CALL AD_Copyrotparametertype( SrcParamData%rotors(i1), DstParamData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%DT = SrcParamData%DT
    DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%AFI)) THEN
  i1_l = LBOUND(SrcParamData%AFI,1)
  i1_u = UBOUND(SrcParamData%AFI,1)
  IF (.NOT. ALLOCATED(DstParamData%AFI)) THEN 
    ALLOCATE(DstParamData%AFI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AFI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%AFI,1), UBOUND(SrcParamData%AFI,1)
      CALL AFI_CopyParam( SrcParamData%AFI(i1), DstParamData%AFI(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%SkewMod = SrcParamData%SkewMod
    DstParamData%WakeMod = SrcParamData%WakeMod
      CALL FVW_CopyParam( SrcParamData%FVW, DstParamData%FVW, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstParamData%CompAeroMaps = SrcParamData%CompAeroMaps
    DstParamData%UA_Flag = SrcParamData%UA_Flag
    DstParamData%FlowField => SrcParamData%FlowField
 END SUBROUTINE AD_CopyParam

 SUBROUTINE AD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(AD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%rotors)) THEN
DO i1 = LBOUND(ParamData%rotors,1), UBOUND(ParamData%rotors,1)
  CALL AD_DestroyRotParameterType( ParamData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%rotors)
ENDIF
IF (ALLOCATED(ParamData%AFI)) THEN
DO i1 = LBOUND(ParamData%AFI,1), UBOUND(ParamData%AFI,1)
  CALL AFI_DestroyParam( ParamData%AFI(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%AFI)
ENDIF
  CALL FVW_DestroyParam( ParamData%FVW, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
NULLIFY(ParamData%FlowField)
 END SUBROUTINE AD_DestroyParam


subroutine AD_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackParam'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotParameterType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFI
   call RegPack(Buf, allocated(InData%AFI))
   if (allocated(InData%AFI)) then
      call RegPackBounds(Buf, 1, lbound(InData%AFI), ubound(InData%AFI))
      LB(1:1) = lbound(InData%AFI)
      UB(1:1) = ubound(InData%AFI)
      do i1 = LB(1), UB(1)
         call AFI_PackParam(Buf, InData%AFI(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SkewMod
   call RegPack(Buf, InData%SkewMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeMod
   call RegPack(Buf, InData%WakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_PackParam(Buf, InData%FVW) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! CompAeroMaps
   call RegPack(Buf, InData%CompAeroMaps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA_Flag
   call RegPack(Buf, InData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FlowField
   call RegPack(Buf, associated(InData%FlowField))
   if (associated(InData%FlowField)) then
      call RegPackPointer(Buf, c_loc(InData%FlowField), PtrInIndex)
      if (.not. PtrInIndex) then
         call IfW_FlowField_PackFlowFieldType(Buf, InData%FlowField) 
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackParam'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotParameterType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AFI
   if (allocated(OutData%AFI)) deallocate(OutData%AFI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AFI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AFI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AFI_UnpackParam(Buf, OutData%AFI(i1)) ! AFI 
      end do
   end if
   ! SkewMod
   call RegUnpack(Buf, OutData%SkewMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WakeMod
   call RegUnpack(Buf, OutData%WakeMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FVW
   call FVW_UnpackParam(Buf, OutData%FVW) ! FVW 
   ! CompAeroMaps
   call RegUnpack(Buf, OutData%CompAeroMaps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UA_Flag
   call RegUnpack(Buf, OutData%UA_Flag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FlowField
   if (associated(OutData%FlowField)) deallocate(OutData%FlowField)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%FlowField)
      else
         allocate(OutData%FlowField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FlowField.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%FlowField)
         call IfW_FlowField_UnpackFlowFieldType(Buf, OutData%FlowField) ! FlowField 
      end if
   else
      OutData%FlowField => null()
   end if
end subroutine
 SUBROUTINE AD_CopyRotInputType( SrcRotInputTypeData, DstRotInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotInputType), INTENT(INOUT) :: SrcRotInputTypeData
   TYPE(RotInputType), INTENT(INOUT) :: DstRotInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcRotInputTypeData%NacelleMotion, DstRotInputTypeData%NacelleMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotInputTypeData%TowerMotion, DstRotInputTypeData%TowerMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotInputTypeData%HubMotion, DstRotInputTypeData%HubMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotInputTypeData%BladeRootMotion)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%BladeRootMotion,1)
  i1_u = UBOUND(SrcRotInputTypeData%BladeRootMotion,1)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%BladeRootMotion)) THEN 
    ALLOCATE(DstRotInputTypeData%BladeRootMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%BladeRootMotion.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInputTypeData%BladeRootMotion,1), UBOUND(SrcRotInputTypeData%BladeRootMotion,1)
      CALL MeshCopy( SrcRotInputTypeData%BladeRootMotion(i1), DstRotInputTypeData%BladeRootMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcRotInputTypeData%BladeMotion)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%BladeMotion,1)
  i1_u = UBOUND(SrcRotInputTypeData%BladeMotion,1)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%BladeMotion)) THEN 
    ALLOCATE(DstRotInputTypeData%BladeMotion(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%BladeMotion.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotInputTypeData%BladeMotion,1), UBOUND(SrcRotInputTypeData%BladeMotion,1)
      CALL MeshCopy( SrcRotInputTypeData%BladeMotion(i1), DstRotInputTypeData%BladeMotion(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcRotInputTypeData%TFinMotion, DstRotInputTypeData%TFinMotion, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotInputTypeData%InflowOnBlade)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%InflowOnBlade,1)
  i1_u = UBOUND(SrcRotInputTypeData%InflowOnBlade,1)
  i2_l = LBOUND(SrcRotInputTypeData%InflowOnBlade,2)
  i2_u = UBOUND(SrcRotInputTypeData%InflowOnBlade,2)
  i3_l = LBOUND(SrcRotInputTypeData%InflowOnBlade,3)
  i3_u = UBOUND(SrcRotInputTypeData%InflowOnBlade,3)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%InflowOnBlade)) THEN 
    ALLOCATE(DstRotInputTypeData%InflowOnBlade(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%InflowOnBlade.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%InflowOnBlade = SrcRotInputTypeData%InflowOnBlade
ENDIF
IF (ALLOCATED(SrcRotInputTypeData%InflowOnTower)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%InflowOnTower,1)
  i1_u = UBOUND(SrcRotInputTypeData%InflowOnTower,1)
  i2_l = LBOUND(SrcRotInputTypeData%InflowOnTower,2)
  i2_u = UBOUND(SrcRotInputTypeData%InflowOnTower,2)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%InflowOnTower)) THEN 
    ALLOCATE(DstRotInputTypeData%InflowOnTower(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%InflowOnTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%InflowOnTower = SrcRotInputTypeData%InflowOnTower
ENDIF
    DstRotInputTypeData%InflowOnHub = SrcRotInputTypeData%InflowOnHub
    DstRotInputTypeData%InflowOnNacelle = SrcRotInputTypeData%InflowOnNacelle
    DstRotInputTypeData%InflowOnTailFin = SrcRotInputTypeData%InflowOnTailFin
IF (ALLOCATED(SrcRotInputTypeData%UserProp)) THEN
  i1_l = LBOUND(SrcRotInputTypeData%UserProp,1)
  i1_u = UBOUND(SrcRotInputTypeData%UserProp,1)
  i2_l = LBOUND(SrcRotInputTypeData%UserProp,2)
  i2_u = UBOUND(SrcRotInputTypeData%UserProp,2)
  IF (.NOT. ALLOCATED(DstRotInputTypeData%UserProp)) THEN 
    ALLOCATE(DstRotInputTypeData%UserProp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotInputTypeData%UserProp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotInputTypeData%UserProp = SrcRotInputTypeData%UserProp
ENDIF
 END SUBROUTINE AD_CopyRotInputType

 SUBROUTINE AD_DestroyRotInputType( RotInputTypeData, ErrStat, ErrMsg )
  TYPE(RotInputType), INTENT(INOUT) :: RotInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( RotInputTypeData%NacelleMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotInputTypeData%TowerMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotInputTypeData%HubMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotInputTypeData%BladeRootMotion)) THEN
DO i1 = LBOUND(RotInputTypeData%BladeRootMotion,1), UBOUND(RotInputTypeData%BladeRootMotion,1)
  CALL MeshDestroy( RotInputTypeData%BladeRootMotion(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInputTypeData%BladeRootMotion)
ENDIF
IF (ALLOCATED(RotInputTypeData%BladeMotion)) THEN
DO i1 = LBOUND(RotInputTypeData%BladeMotion,1), UBOUND(RotInputTypeData%BladeMotion,1)
  CALL MeshDestroy( RotInputTypeData%BladeMotion(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotInputTypeData%BladeMotion)
ENDIF
  CALL MeshDestroy( RotInputTypeData%TFinMotion, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotInputTypeData%InflowOnBlade)) THEN
  DEALLOCATE(RotInputTypeData%InflowOnBlade)
ENDIF
IF (ALLOCATED(RotInputTypeData%InflowOnTower)) THEN
  DEALLOCATE(RotInputTypeData%InflowOnTower)
ENDIF
IF (ALLOCATED(RotInputTypeData%UserProp)) THEN
  DEALLOCATE(RotInputTypeData%UserProp)
ENDIF
 END SUBROUTINE AD_DestroyRotInputType


subroutine AD_PackRotInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotInputType'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   if (Buf%ErrStat >= AbortErrLev) return
   ! NacelleMotion
   call MeshPack(Buf, InData%NacelleMotion) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerMotion
   call MeshPack(Buf, InData%TowerMotion) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubMotion
   call MeshPack(Buf, InData%HubMotion) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeRootMotion
   call RegPack(Buf, allocated(InData%BladeRootMotion))
   if (allocated(InData%BladeRootMotion)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeRootMotion), ubound(InData%BladeRootMotion))
      LB(1:1) = lbound(InData%BladeRootMotion)
      UB(1:1) = ubound(InData%BladeRootMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeRootMotion(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeMotion
   call RegPack(Buf, allocated(InData%BladeMotion))
   if (allocated(InData%BladeMotion)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeMotion), ubound(InData%BladeMotion))
      LB(1:1) = lbound(InData%BladeMotion)
      UB(1:1) = ubound(InData%BladeMotion)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeMotion(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinMotion
   call MeshPack(Buf, InData%TFinMotion) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnBlade
   call RegPack(Buf, allocated(InData%InflowOnBlade))
   if (allocated(InData%InflowOnBlade)) then
      call RegPackBounds(Buf, 3, lbound(InData%InflowOnBlade), ubound(InData%InflowOnBlade))
      call RegPack(Buf, InData%InflowOnBlade)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnTower
   call RegPack(Buf, allocated(InData%InflowOnTower))
   if (allocated(InData%InflowOnTower)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowOnTower), ubound(InData%InflowOnTower))
      call RegPack(Buf, InData%InflowOnTower)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnHub
   call RegPack(Buf, InData%InflowOnHub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnNacelle
   call RegPack(Buf, InData%InflowOnNacelle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnTailFin
   call RegPack(Buf, InData%InflowOnTailFin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UserProp
   call RegPack(Buf, allocated(InData%UserProp))
   if (allocated(InData%UserProp)) then
      call RegPackBounds(Buf, 2, lbound(InData%UserProp), ubound(InData%UserProp))
      call RegPack(Buf, InData%UserProp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotInputType'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NacelleMotion
   call MeshUnpack(Buf, OutData%NacelleMotion) ! NacelleMotion 
   ! TowerMotion
   call MeshUnpack(Buf, OutData%TowerMotion) ! TowerMotion 
   ! HubMotion
   call MeshUnpack(Buf, OutData%HubMotion) ! HubMotion 
   ! BladeRootMotion
   if (allocated(OutData%BladeRootMotion)) deallocate(OutData%BladeRootMotion)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeRootMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeRootMotion.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeRootMotion(i1)) ! BladeRootMotion 
      end do
   end if
   ! BladeMotion
   if (allocated(OutData%BladeMotion)) deallocate(OutData%BladeMotion)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeMotion(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeMotion.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeMotion(i1)) ! BladeMotion 
      end do
   end if
   ! TFinMotion
   call MeshUnpack(Buf, OutData%TFinMotion) ! TFinMotion 
   ! InflowOnBlade
   if (allocated(OutData%InflowOnBlade)) deallocate(OutData%InflowOnBlade)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowOnBlade(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowOnBlade.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowOnBlade)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InflowOnTower
   if (allocated(OutData%InflowOnTower)) deallocate(OutData%InflowOnTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowOnTower(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowOnTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowOnTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! InflowOnHub
   call RegUnpack(Buf, OutData%InflowOnHub)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnNacelle
   call RegUnpack(Buf, OutData%InflowOnNacelle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowOnTailFin
   call RegUnpack(Buf, OutData%InflowOnTailFin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UserProp
   if (allocated(OutData%UserProp)) deallocate(OutData%UserProp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UserProp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UserProp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UserProp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(AD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%rotors)) THEN
  i1_l = LBOUND(SrcInputData%rotors,1)
  i1_u = UBOUND(SrcInputData%rotors,1)
  IF (.NOT. ALLOCATED(DstInputData%rotors)) THEN 
    ALLOCATE(DstInputData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%rotors,1), UBOUND(SrcInputData%rotors,1)
      CALL AD_Copyrotinputtype( SrcInputData%rotors(i1), DstInputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%InflowWakeVel)) THEN
  i1_l = LBOUND(SrcInputData%InflowWakeVel,1)
  i1_u = UBOUND(SrcInputData%InflowWakeVel,1)
  i2_l = LBOUND(SrcInputData%InflowWakeVel,2)
  i2_u = UBOUND(SrcInputData%InflowWakeVel,2)
  IF (.NOT. ALLOCATED(DstInputData%InflowWakeVel)) THEN 
    ALLOCATE(DstInputData%InflowWakeVel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%InflowWakeVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%InflowWakeVel = SrcInputData%InflowWakeVel
ENDIF
 END SUBROUTINE AD_CopyInput

 SUBROUTINE AD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(AD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%rotors)) THEN
DO i1 = LBOUND(InputData%rotors,1), UBOUND(InputData%rotors,1)
  CALL AD_DestroyRotInputType( InputData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%rotors)
ENDIF
IF (ALLOCATED(InputData%InflowWakeVel)) THEN
  DEALLOCATE(InputData%InflowWakeVel)
ENDIF
 END SUBROUTINE AD_DestroyInput


subroutine AD_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotInputType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! InflowWakeVel
   call RegPack(Buf, allocated(InData%InflowWakeVel))
   if (allocated(InData%InflowWakeVel)) then
      call RegPackBounds(Buf, 2, lbound(InData%InflowWakeVel), ubound(InData%InflowWakeVel))
      call RegPack(Buf, InData%InflowWakeVel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackInput'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotInputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
   ! InflowWakeVel
   if (allocated(OutData%InflowWakeVel)) deallocate(OutData%InflowWakeVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%InflowWakeVel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%InflowWakeVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%InflowWakeVel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyRotOutputType( SrcRotOutputTypeData, DstRotOutputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(RotOutputType), INTENT(INOUT) :: SrcRotOutputTypeData
   TYPE(RotOutputType), INTENT(INOUT) :: DstRotOutputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyRotOutputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcRotOutputTypeData%NacelleLoad, DstRotOutputTypeData%NacelleLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotOutputTypeData%HubLoad, DstRotOutputTypeData%HubLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcRotOutputTypeData%TowerLoad, DstRotOutputTypeData%TowerLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotOutputTypeData%BladeLoad)) THEN
  i1_l = LBOUND(SrcRotOutputTypeData%BladeLoad,1)
  i1_u = UBOUND(SrcRotOutputTypeData%BladeLoad,1)
  IF (.NOT. ALLOCATED(DstRotOutputTypeData%BladeLoad)) THEN 
    ALLOCATE(DstRotOutputTypeData%BladeLoad(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotOutputTypeData%BladeLoad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcRotOutputTypeData%BladeLoad,1), UBOUND(SrcRotOutputTypeData%BladeLoad,1)
      CALL MeshCopy( SrcRotOutputTypeData%BladeLoad(i1), DstRotOutputTypeData%BladeLoad(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MeshCopy( SrcRotOutputTypeData%TFinLoad, DstRotOutputTypeData%TFinLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcRotOutputTypeData%WriteOutput)) THEN
  i1_l = LBOUND(SrcRotOutputTypeData%WriteOutput,1)
  i1_u = UBOUND(SrcRotOutputTypeData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstRotOutputTypeData%WriteOutput)) THEN 
    ALLOCATE(DstRotOutputTypeData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRotOutputTypeData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRotOutputTypeData%WriteOutput = SrcRotOutputTypeData%WriteOutput
ENDIF
 END SUBROUTINE AD_CopyRotOutputType

 SUBROUTINE AD_DestroyRotOutputType( RotOutputTypeData, ErrStat, ErrMsg )
  TYPE(RotOutputType), INTENT(INOUT) :: RotOutputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyRotOutputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( RotOutputTypeData%NacelleLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotOutputTypeData%HubLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( RotOutputTypeData%TowerLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotOutputTypeData%BladeLoad)) THEN
DO i1 = LBOUND(RotOutputTypeData%BladeLoad,1), UBOUND(RotOutputTypeData%BladeLoad,1)
  CALL MeshDestroy( RotOutputTypeData%BladeLoad(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(RotOutputTypeData%BladeLoad)
ENDIF
  CALL MeshDestroy( RotOutputTypeData%TFinLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(RotOutputTypeData%WriteOutput)) THEN
  DEALLOCATE(RotOutputTypeData%WriteOutput)
ENDIF
 END SUBROUTINE AD_DestroyRotOutputType


subroutine AD_PackRotOutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(RotOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackRotOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! NacelleLoad
   call MeshPack(Buf, InData%NacelleLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubLoad
   call MeshPack(Buf, InData%HubLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerLoad
   call MeshPack(Buf, InData%TowerLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BladeLoad
   call RegPack(Buf, allocated(InData%BladeLoad))
   if (allocated(InData%BladeLoad)) then
      call RegPackBounds(Buf, 1, lbound(InData%BladeLoad), ubound(InData%BladeLoad))
      LB(1:1) = lbound(InData%BladeLoad)
      UB(1:1) = ubound(InData%BladeLoad)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%BladeLoad(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TFinLoad
   call MeshPack(Buf, InData%TFinLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackRotOutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(RotOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackRotOutputType'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NacelleLoad
   call MeshUnpack(Buf, OutData%NacelleLoad) ! NacelleLoad 
   ! HubLoad
   call MeshUnpack(Buf, OutData%HubLoad) ! HubLoad 
   ! TowerLoad
   call MeshUnpack(Buf, OutData%TowerLoad) ! TowerLoad 
   ! BladeLoad
   if (allocated(OutData%BladeLoad)) deallocate(OutData%BladeLoad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BladeLoad(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BladeLoad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%BladeLoad(i1)) ! BladeLoad 
      end do
   end if
   ! TFinLoad
   call MeshUnpack(Buf, OutData%TFinLoad) ! TFinLoad 
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE AD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(AD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(AD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'AD_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%rotors)) THEN
  i1_l = LBOUND(SrcOutputData%rotors,1)
  i1_u = UBOUND(SrcOutputData%rotors,1)
  IF (.NOT. ALLOCATED(DstOutputData%rotors)) THEN 
    ALLOCATE(DstOutputData%rotors(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%rotors.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%rotors,1), UBOUND(SrcOutputData%rotors,1)
      CALL AD_Copyrotoutputtype( SrcOutputData%rotors(i1), DstOutputData%rotors(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE AD_CopyOutput

 SUBROUTINE AD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(AD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'AD_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%rotors)) THEN
DO i1 = LBOUND(OutputData%rotors,1), UBOUND(OutputData%rotors,1)
  CALL AD_DestroyRotOutputType( OutputData%rotors(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%rotors)
ENDIF
 END SUBROUTINE AD_DestroyOutput


subroutine AD_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(AD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'AD_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! rotors
   call RegPack(Buf, allocated(InData%rotors))
   if (allocated(InData%rotors)) then
      call RegPackBounds(Buf, 1, lbound(InData%rotors), ubound(InData%rotors))
      LB(1:1) = lbound(InData%rotors)
      UB(1:1) = ubound(InData%rotors)
      do i1 = LB(1), UB(1)
         call AD_PackRotOutputType(Buf, InData%rotors(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine AD_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(AD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'AD_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! rotors
   if (allocated(OutData%rotors)) deallocate(OutData%rotors)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rotors(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rotors.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call AD_UnpackRotOutputType(Buf, OutData%rotors(i1)) ! rotors 
      end do
   end if
end subroutine

 SUBROUTINE AD_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(AD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD_Input_ExtrapInterp


 SUBROUTINE AD_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(AD_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(AD_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(AD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
 INTEGER                                    :: i3    ! dim3 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%rotors) .AND. ALLOCATED(u1%rotors)) THEN
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp1(u1%rotors(i01)%NacelleMotion, u2%rotors(i01)%NacelleMotion, tin, u_out%rotors(i01)%NacelleMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp1(u1%rotors(i01)%TowerMotion, u2%rotors(i01)%TowerMotion, tin, u_out%rotors(i01)%TowerMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp1(u1%rotors(i01)%HubMotion, u2%rotors(i01)%HubMotion, tin, u_out%rotors(i01)%HubMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%BladeRootMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeRootMotion)) THEN
  DO i1 = LBOUND(u_out%rotors(i01)%BladeRootMotion,1),UBOUND(u_out%rotors(i01)%BladeRootMotion,1)
      CALL MeshExtrapInterp1(u1%rotors(i01)%BladeRootMotion(i1), u2%rotors(i01)%BladeRootMotion(i1), tin, u_out%rotors(i01)%BladeRootMotion(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%BladeMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeMotion)) THEN
  DO i1 = LBOUND(u_out%rotors(i01)%BladeMotion,1),UBOUND(u_out%rotors(i01)%BladeMotion,1)
      CALL MeshExtrapInterp1(u1%rotors(i01)%BladeMotion(i1), u2%rotors(i01)%BladeMotion(i1), tin, u_out%rotors(i01)%BladeMotion(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp1(u1%rotors(i01)%TFinMotion, u2%rotors(i01)%TFinMotion, tin, u_out%rotors(i01)%TFinMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%InflowOnBlade) .AND. ALLOCATED(u1%rotors(i01)%InflowOnBlade)) THEN
  DO i3 = LBOUND(u_out%rotors(i01)%InflowOnBlade,3),UBOUND(u_out%rotors(i01)%InflowOnBlade,3)
    DO i2 = LBOUND(u_out%rotors(i01)%InflowOnBlade,2),UBOUND(u_out%rotors(i01)%InflowOnBlade,2)
      DO i1 = LBOUND(u_out%rotors(i01)%InflowOnBlade,1),UBOUND(u_out%rotors(i01)%InflowOnBlade,1)
        b = -(u1%rotors(i01)%InflowOnBlade(i1,i2,i3) - u2%rotors(i01)%InflowOnBlade(i1,i2,i3))
        u_out%rotors(i01)%InflowOnBlade(i1,i2,i3) = u1%rotors(i01)%InflowOnBlade(i1,i2,i3) + b * ScaleFactor
      END DO
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%InflowOnTower) .AND. ALLOCATED(u1%rotors(i01)%InflowOnTower)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%InflowOnTower,2),UBOUND(u_out%rotors(i01)%InflowOnTower,2)
    DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTower,1),UBOUND(u_out%rotors(i01)%InflowOnTower,1)
      b = -(u1%rotors(i01)%InflowOnTower(i1,i2) - u2%rotors(i01)%InflowOnTower(i1,i2))
      u_out%rotors(i01)%InflowOnTower(i1,i2) = u1%rotors(i01)%InflowOnTower(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnHub,1),UBOUND(u_out%rotors(i01)%InflowOnHub,1)
    b = -(u1%rotors(i01)%InflowOnHub(i1) - u2%rotors(i01)%InflowOnHub(i1))
    u_out%rotors(i01)%InflowOnHub(i1) = u1%rotors(i01)%InflowOnHub(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnNacelle,1),UBOUND(u_out%rotors(i01)%InflowOnNacelle,1)
    b = -(u1%rotors(i01)%InflowOnNacelle(i1) - u2%rotors(i01)%InflowOnNacelle(i1))
    u_out%rotors(i01)%InflowOnNacelle(i1) = u1%rotors(i01)%InflowOnNacelle(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTailFin,1),UBOUND(u_out%rotors(i01)%InflowOnTailFin,1)
    b = -(u1%rotors(i01)%InflowOnTailFin(i1) - u2%rotors(i01)%InflowOnTailFin(i1))
    u_out%rotors(i01)%InflowOnTailFin(i1) = u1%rotors(i01)%InflowOnTailFin(i1) + b * ScaleFactor
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%UserProp) .AND. ALLOCATED(u1%rotors(i01)%UserProp)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%UserProp,2),UBOUND(u_out%rotors(i01)%UserProp,2)
    DO i1 = LBOUND(u_out%rotors(i01)%UserProp,1),UBOUND(u_out%rotors(i01)%UserProp,1)
      b = -(u1%rotors(i01)%UserProp(i1,i2) - u2%rotors(i01)%UserProp(i1,i2))
      u_out%rotors(i01)%UserProp(i1,i2) = u1%rotors(i01)%UserProp(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowWakeVel) .AND. ALLOCATED(u1%InflowWakeVel)) THEN
  DO i2 = LBOUND(u_out%InflowWakeVel,2),UBOUND(u_out%InflowWakeVel,2)
    DO i1 = LBOUND(u_out%InflowWakeVel,1),UBOUND(u_out%InflowWakeVel,1)
      b = -(u1%InflowWakeVel(i1,i2) - u2%InflowWakeVel(i1,i2))
      u_out%InflowWakeVel(i1,i2) = u1%InflowWakeVel(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE AD_Input_ExtrapInterp1


 SUBROUTINE AD_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(AD_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(AD_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(AD_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(AD_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
 INTEGER                                    :: i3    ! dim3 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%rotors) .AND. ALLOCATED(u1%rotors)) THEN
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp2(u1%rotors(i01)%NacelleMotion, u2%rotors(i01)%NacelleMotion, u3%rotors(i01)%NacelleMotion, tin, u_out%rotors(i01)%NacelleMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp2(u1%rotors(i01)%TowerMotion, u2%rotors(i01)%TowerMotion, u3%rotors(i01)%TowerMotion, tin, u_out%rotors(i01)%TowerMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp2(u1%rotors(i01)%HubMotion, u2%rotors(i01)%HubMotion, u3%rotors(i01)%HubMotion, tin, u_out%rotors(i01)%HubMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%BladeRootMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeRootMotion)) THEN
  DO i1 = LBOUND(u_out%rotors(i01)%BladeRootMotion,1),UBOUND(u_out%rotors(i01)%BladeRootMotion,1)
      CALL MeshExtrapInterp2(u1%rotors(i01)%BladeRootMotion(i1), u2%rotors(i01)%BladeRootMotion(i1), u3%rotors(i01)%BladeRootMotion(i1), tin, u_out%rotors(i01)%BladeRootMotion(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%BladeMotion) .AND. ALLOCATED(u1%rotors(i01)%BladeMotion)) THEN
  DO i1 = LBOUND(u_out%rotors(i01)%BladeMotion,1),UBOUND(u_out%rotors(i01)%BladeMotion,1)
      CALL MeshExtrapInterp2(u1%rotors(i01)%BladeMotion(i1), u2%rotors(i01)%BladeMotion(i1), u3%rotors(i01)%BladeMotion(i1), tin, u_out%rotors(i01)%BladeMotion(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
      CALL MeshExtrapInterp2(u1%rotors(i01)%TFinMotion, u2%rotors(i01)%TFinMotion, u3%rotors(i01)%TFinMotion, tin, u_out%rotors(i01)%TFinMotion, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%InflowOnBlade) .AND. ALLOCATED(u1%rotors(i01)%InflowOnBlade)) THEN
  DO i3 = LBOUND(u_out%rotors(i01)%InflowOnBlade,3),UBOUND(u_out%rotors(i01)%InflowOnBlade,3)
    DO i2 = LBOUND(u_out%rotors(i01)%InflowOnBlade,2),UBOUND(u_out%rotors(i01)%InflowOnBlade,2)
      DO i1 = LBOUND(u_out%rotors(i01)%InflowOnBlade,1),UBOUND(u_out%rotors(i01)%InflowOnBlade,1)
        b = (t(3)**2*(u1%rotors(i01)%InflowOnBlade(i1,i2,i3) - u2%rotors(i01)%InflowOnBlade(i1,i2,i3)) + t(2)**2*(-u1%rotors(i01)%InflowOnBlade(i1,i2,i3) + u3%rotors(i01)%InflowOnBlade(i1,i2,i3)))* scaleFactor
        c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnBlade(i1,i2,i3) + t(3)*u2%rotors(i01)%InflowOnBlade(i1,i2,i3) - t(2)*u3%rotors(i01)%InflowOnBlade(i1,i2,i3) ) * scaleFactor
        u_out%rotors(i01)%InflowOnBlade(i1,i2,i3) = u1%rotors(i01)%InflowOnBlade(i1,i2,i3) + b  + c * t_out
      END DO
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%InflowOnTower) .AND. ALLOCATED(u1%rotors(i01)%InflowOnTower)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%InflowOnTower,2),UBOUND(u_out%rotors(i01)%InflowOnTower,2)
    DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTower,1),UBOUND(u_out%rotors(i01)%InflowOnTower,1)
      b = (t(3)**2*(u1%rotors(i01)%InflowOnTower(i1,i2) - u2%rotors(i01)%InflowOnTower(i1,i2)) + t(2)**2*(-u1%rotors(i01)%InflowOnTower(i1,i2) + u3%rotors(i01)%InflowOnTower(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnTower(i1,i2) + t(3)*u2%rotors(i01)%InflowOnTower(i1,i2) - t(2)*u3%rotors(i01)%InflowOnTower(i1,i2) ) * scaleFactor
      u_out%rotors(i01)%InflowOnTower(i1,i2) = u1%rotors(i01)%InflowOnTower(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnHub,1),UBOUND(u_out%rotors(i01)%InflowOnHub,1)
    b = (t(3)**2*(u1%rotors(i01)%InflowOnHub(i1) - u2%rotors(i01)%InflowOnHub(i1)) + t(2)**2*(-u1%rotors(i01)%InflowOnHub(i1) + u3%rotors(i01)%InflowOnHub(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnHub(i1) + t(3)*u2%rotors(i01)%InflowOnHub(i1) - t(2)*u3%rotors(i01)%InflowOnHub(i1) ) * scaleFactor
    u_out%rotors(i01)%InflowOnHub(i1) = u1%rotors(i01)%InflowOnHub(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnNacelle,1),UBOUND(u_out%rotors(i01)%InflowOnNacelle,1)
    b = (t(3)**2*(u1%rotors(i01)%InflowOnNacelle(i1) - u2%rotors(i01)%InflowOnNacelle(i1)) + t(2)**2*(-u1%rotors(i01)%InflowOnNacelle(i1) + u3%rotors(i01)%InflowOnNacelle(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnNacelle(i1) + t(3)*u2%rotors(i01)%InflowOnNacelle(i1) - t(2)*u3%rotors(i01)%InflowOnNacelle(i1) ) * scaleFactor
    u_out%rotors(i01)%InflowOnNacelle(i1) = u1%rotors(i01)%InflowOnNacelle(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
  DO i1 = LBOUND(u_out%rotors(i01)%InflowOnTailFin,1),UBOUND(u_out%rotors(i01)%InflowOnTailFin,1)
    b = (t(3)**2*(u1%rotors(i01)%InflowOnTailFin(i1) - u2%rotors(i01)%InflowOnTailFin(i1)) + t(2)**2*(-u1%rotors(i01)%InflowOnTailFin(i1) + u3%rotors(i01)%InflowOnTailFin(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%rotors(i01)%InflowOnTailFin(i1) + t(3)*u2%rotors(i01)%InflowOnTailFin(i1) - t(2)*u3%rotors(i01)%InflowOnTailFin(i1) ) * scaleFactor
    u_out%rotors(i01)%InflowOnTailFin(i1) = u1%rotors(i01)%InflowOnTailFin(i1) + b  + c * t_out
  END DO
  ENDDO
  DO i01 = LBOUND(u_out%rotors,1),UBOUND(u_out%rotors,1)
IF (ALLOCATED(u_out%rotors(i01)%UserProp) .AND. ALLOCATED(u1%rotors(i01)%UserProp)) THEN
  DO i2 = LBOUND(u_out%rotors(i01)%UserProp,2),UBOUND(u_out%rotors(i01)%UserProp,2)
    DO i1 = LBOUND(u_out%rotors(i01)%UserProp,1),UBOUND(u_out%rotors(i01)%UserProp,1)
      b = (t(3)**2*(u1%rotors(i01)%UserProp(i1,i2) - u2%rotors(i01)%UserProp(i1,i2)) + t(2)**2*(-u1%rotors(i01)%UserProp(i1,i2) + u3%rotors(i01)%UserProp(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%rotors(i01)%UserProp(i1,i2) + t(3)*u2%rotors(i01)%UserProp(i1,i2) - t(2)*u3%rotors(i01)%UserProp(i1,i2) ) * scaleFactor
      u_out%rotors(i01)%UserProp(i1,i2) = u1%rotors(i01)%UserProp(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%InflowWakeVel) .AND. ALLOCATED(u1%InflowWakeVel)) THEN
  DO i2 = LBOUND(u_out%InflowWakeVel,2),UBOUND(u_out%InflowWakeVel,2)
    DO i1 = LBOUND(u_out%InflowWakeVel,1),UBOUND(u_out%InflowWakeVel,1)
      b = (t(3)**2*(u1%InflowWakeVel(i1,i2) - u2%InflowWakeVel(i1,i2)) + t(2)**2*(-u1%InflowWakeVel(i1,i2) + u3%InflowWakeVel(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%InflowWakeVel(i1,i2) + t(3)*u2%InflowWakeVel(i1,i2) - t(2)*u3%InflowWakeVel(i1,i2) ) * scaleFactor
      u_out%InflowWakeVel(i1,i2) = u1%InflowWakeVel(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE AD_Input_ExtrapInterp2


 SUBROUTINE AD_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(AD_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(AD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'AD_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL AD_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL AD_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL AD_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE AD_Output_ExtrapInterp


 SUBROUTINE AD_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(AD_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(AD_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(AD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'AD_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%rotors) .AND. ALLOCATED(y1%rotors)) THEN
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp1(y1%rotors(i01)%NacelleLoad, y2%rotors(i01)%NacelleLoad, tin, y_out%rotors(i01)%NacelleLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp1(y1%rotors(i01)%HubLoad, y2%rotors(i01)%HubLoad, tin, y_out%rotors(i01)%HubLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp1(y1%rotors(i01)%TowerLoad, y2%rotors(i01)%TowerLoad, tin, y_out%rotors(i01)%TowerLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
IF (ALLOCATED(y_out%rotors(i01)%BladeLoad) .AND. ALLOCATED(y1%rotors(i01)%BladeLoad)) THEN
  DO i1 = LBOUND(y_out%rotors(i01)%BladeLoad,1),UBOUND(y_out%rotors(i01)%BladeLoad,1)
      CALL MeshExtrapInterp1(y1%rotors(i01)%BladeLoad(i1), y2%rotors(i01)%BladeLoad(i1), tin, y_out%rotors(i01)%BladeLoad(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp1(y1%rotors(i01)%TFinLoad, y2%rotors(i01)%TFinLoad, tin, y_out%rotors(i01)%TFinLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
IF (ALLOCATED(y_out%rotors(i01)%WriteOutput) .AND. ALLOCATED(y1%rotors(i01)%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%rotors(i01)%WriteOutput,1),UBOUND(y_out%rotors(i01)%WriteOutput,1)
    b = -(y1%rotors(i01)%WriteOutput(i1) - y2%rotors(i01)%WriteOutput(i1))
    y_out%rotors(i01)%WriteOutput(i1) = y1%rotors(i01)%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
 END SUBROUTINE AD_Output_ExtrapInterp1


 SUBROUTINE AD_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(AD_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(AD_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(AD_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(AD_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'AD_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%rotors) .AND. ALLOCATED(y1%rotors)) THEN
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp2(y1%rotors(i01)%NacelleLoad, y2%rotors(i01)%NacelleLoad, y3%rotors(i01)%NacelleLoad, tin, y_out%rotors(i01)%NacelleLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp2(y1%rotors(i01)%HubLoad, y2%rotors(i01)%HubLoad, y3%rotors(i01)%HubLoad, tin, y_out%rotors(i01)%HubLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp2(y1%rotors(i01)%TowerLoad, y2%rotors(i01)%TowerLoad, y3%rotors(i01)%TowerLoad, tin, y_out%rotors(i01)%TowerLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
IF (ALLOCATED(y_out%rotors(i01)%BladeLoad) .AND. ALLOCATED(y1%rotors(i01)%BladeLoad)) THEN
  DO i1 = LBOUND(y_out%rotors(i01)%BladeLoad,1),UBOUND(y_out%rotors(i01)%BladeLoad,1)
      CALL MeshExtrapInterp2(y1%rotors(i01)%BladeLoad(i1), y2%rotors(i01)%BladeLoad(i1), y3%rotors(i01)%BladeLoad(i1), tin, y_out%rotors(i01)%BladeLoad(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
      CALL MeshExtrapInterp2(y1%rotors(i01)%TFinLoad, y2%rotors(i01)%TFinLoad, y3%rotors(i01)%TFinLoad, tin, y_out%rotors(i01)%TFinLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
  ENDDO
  DO i01 = LBOUND(y_out%rotors,1),UBOUND(y_out%rotors,1)
IF (ALLOCATED(y_out%rotors(i01)%WriteOutput) .AND. ALLOCATED(y1%rotors(i01)%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%rotors(i01)%WriteOutput,1),UBOUND(y_out%rotors(i01)%WriteOutput,1)
    b = (t(3)**2*(y1%rotors(i01)%WriteOutput(i1) - y2%rotors(i01)%WriteOutput(i1)) + t(2)**2*(-y1%rotors(i01)%WriteOutput(i1) + y3%rotors(i01)%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%rotors(i01)%WriteOutput(i1) + t(3)*y2%rotors(i01)%WriteOutput(i1) - t(2)*y3%rotors(i01)%WriteOutput(i1) ) * scaleFactor
    y_out%rotors(i01)%WriteOutput(i1) = y1%rotors(i01)%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
  ENDDO
END IF ! check if allocated
 END SUBROUTINE AD_Output_ExtrapInterp2

END MODULE AeroDyn_Types
!ENDOFREGISTRYGENERATEDFILE
