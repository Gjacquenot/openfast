!STARTOFREGISTRYGENERATEDFILE 'FEAMooring_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FEAMooring_Types
!.................................................................................................................................
! This file is part of FEAMooring.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FEAMooring. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FEAMooring_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  FEAM_InputFile  =======
  TYPE, PUBLIC :: FEAM_InputFile
    REAL(DbKi)  :: DT      !< Communication interval for mooring dynamics [s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCI      !< Mooring line inertia coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCD      !< Mooring line drag coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff      !< Mooring line axial stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen      !< Mooring line mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen      !< Mooring line displaced mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff      !< Seabed spring stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadAnch      !< Anchor Radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngAnch      !< Anchor Angle [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDpthAnch      !< Anchor Depth [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LRadFair      !< Fairlead Radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAngFair      !< Fairlead Radius [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDrftFair      !< Fairlead Draft [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LUnstrLen      !< Line unstretched length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Tension      !< Line Top Tension [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL      !< Linear spring stiffness at fairlead [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GSR      !< Rotational spring stiffness at fairlead [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GE      !< Reference tangent vector at fairlead [-]
    INTEGER(IntKi)  :: NumLines      !< Number of lines [-]
    INTEGER(IntKi)  :: NumElems      !< Number of elements [-]
    REAL(ReKi)  :: Eps      !< Tolerance for static iteration [-]
    REAL(ReKi)  :: Gravity      !< Gravity [-]
    REAL(ReKi)  :: WtrDens      !< Water density [-]
    INTEGER(IntKi)  :: MaxIter      !< Maximum number of iteration step for static analysis [-]
    LOGICAL  :: SumPrint      !< Print summary data to <RootName>.fsm? [-]
    INTEGER(IntKi)  :: OutFile      !< Switch to determine where output will be placed: (1: in module output file only; 2: in glue code output file only; 3: both) [-]
    LOGICAL  :: TabDelim      !< Use tab delimiters in text tabular output file? [-]
    CHARACTER(20)  :: OutFmt      !< Format used for text tabular output (except time) [-]
    REAL(DbKi)  :: Tstart      !< Time to start module's tabular output [s]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< List of user-requested output channels [-]
  END TYPE FEAM_InputFile
! =======================
! =========  FEAM_InitInputType  =======
  TYPE, PUBLIC :: FEAM_InitInputType
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit      !< Platform Initial Position [-]
    INTEGER(IntKi)  :: NStepWave      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0      !<  [-]
    REAL(ReKi)  :: Gravity      !< Gravity [-]
    REAL(ReKi)  :: WtrDens      !< Water density [-]
  END TYPE FEAM_InitInputType
! =======================
! =========  FEAM_InitOutputType  =======
  TYPE, PUBLIC :: FEAM_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchxi      !< Anchor coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchyi      !< Anchor coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LAnchzi      !< Anchor coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairxt      !< Fairlead coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairyt      !< Fairlead coordinate [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LFairzt      !< Fairlead coordinate [-]
  END TYPE FEAM_InitOutputType
! =======================
! =========  FEAM_ContinuousStateType  =======
  TYPE, PUBLIC :: FEAM_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU      !< Global matrix U (displacement) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDU      !< Global matrix DU (velocity) [-]
  END TYPE FEAM_ContinuousStateType
! =======================
! =========  FEAM_DiscreteStateType  =======
  TYPE, PUBLIC :: FEAM_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !< Remove this variable if you have discrete states [-]
  END TYPE FEAM_DiscreteStateType
! =======================
! =========  FEAM_ConstraintStateType  =======
  TYPE, PUBLIC :: FEAM_ConstraintStateType
    REAL(ReKi) , DIMENSION(1:3)  :: TSN      !< Lagrangian multiplier [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TZER      !< Lagrangian multiplier [-]
  END TYPE FEAM_ConstraintStateType
! =======================
! =========  FEAM_OtherStateType  =======
  TYPE, PUBLIC :: FEAM_OtherStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLU0      !< Global matrix U0 (previous state) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLDDU      !< Global matrix DDU (accleration) -- other state [-]
    LOGICAL  :: BottomTouch      !< Bottom touch flag [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GFORC0      !< Old element force matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: GMASS0      !< Old element mass matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FPA      !< Fairlead position - inputs from previous time step (we should replace this with a call to extrap-interp) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_RP      !< Fairlead tangent - part of output computation that was calculated in UpdateStates [-]
    INTEGER(IntKi)  :: INCR      !< FEAM step [-]
    REAL(ReKi) , DIMENSION(1:15)  :: RSDF      !< Line residue force - modifies values from previous call to FEAM_Solve [-]
    REAL(ReKi) , DIMENSION(1:15)  :: FORC0      !< - [Local old element force matrix]
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMAS0      !< Local old element mass matrix [-]
  END TYPE FEAM_OtherStateType
! =======================
! =========  FEAM_MiscVarType  =======
  TYPE, PUBLIC :: FEAM_MiscVarType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GLF      !< Global forcing matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLK      !< Global stiffness matrix [-]
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: EMASS      !< Line element mass [-]
    REAL(ReKi) , DIMENSION(1:15,1:15)  :: ESTIF      !< Line element stiffness [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAST_FP      !< Fairlead position at t+dt [-]
    REAL(ReKi) , DIMENSION(1:15)  :: FORCE      !< Line external force [-]
    REAL(ReKi) , DIMENSION(1:3)  :: FP      !< Fairlead position - used in Couple routine [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U      !< Local matrix U [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: U0      !< Local matrix U0 [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DU      !< Local matrix DU [-]
    REAL(ReKi) , DIMENSION(1:3,1:4)  :: DDU      !< Local matrix DDU [-]
    REAL(ReKi) , DIMENSION(1:3)  :: R      !< POSITION VECTOR OF NODE OF ROD ELEMENT [-]
    REAL(ReKi) , DIMENSION(1:3)  :: RP      !< DR/DS AT R (TANGENT - NEED NOT BE UNIT VECTOR) [-]
    REAL(ReKi) , DIMENSION(1:6)  :: RHSR      !< RIGHT HAND SIDE CONTRIBUTION TO 6 DEGREES OF FREEDOM OF ROD NODE [-]
    REAL(ReKi) , DIMENSION(1:3)  :: SLIN      !< LINEAR SPRING CONSTANT - portion of p%GSL [(UNITS OF FORCE/LENGTH)]
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: STIFR      !< STIFFNESS COEFFICIENTS FOR 6 DEGREES OF FREEDOM OF ROD NODE (X,DX/DS,Y,DY/DS,Z,DZ/DS) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: FAIR_ANG      !< Fairlead angle [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FAIR_T      !< Fairlead tension [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ANCH_ANG      !< Anchor angle [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ANCH_T      !< Anchor tension [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Coordinate      !< Mooring line coordinate [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Line_Tangent      !< Mooring line tangent vector [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_Lines      !< Mooring restoring force [-]
    INTEGER(IntKi)  :: LastIndWave      !< FEAM step [-]
  END TYPE FEAM_MiscVarType
! =======================
! =========  FEAM_ParameterType  =======
  TYPE, PUBLIC :: FEAM_ParameterType
    REAL(DbKi)  :: DT      !< Time step for continuous state integration & discrete state update [seconds]
    REAL(ReKi) , DIMENSION(1:3)  :: GRAV      !< Gravity [-]
    REAL(ReKi)  :: Eps      !< Tolerance for static iteration [-]
    REAL(ReKi)  :: Gravity      !< Gravity [-]
    REAL(ReKi)  :: WtrDens      !< Water density [-]
    INTEGER(IntKi)  :: MaxIter      !< Maximum number of iteration step for static analysis [-]
    INTEGER(IntKi)  :: NHBD      !< Bandwidth = (NBAND+1)/2 [-]
    INTEGER(IntKi)  :: NDIM      !< Dimension = 3 [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NEQ      !< Number of equation [-]
    INTEGER(IntKi)  :: NBAND      !< Bandwidth [-]
    INTEGER(IntKi)  :: NumLines      !< Number of lines [-]
    INTEGER(IntKi)  :: NumElems      !< Number of elements [-]
    INTEGER(IntKi)  :: NumNodes      !< Number of nodes [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GSL      !< Linear spring stiffness at fairlead [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GP      !< Fairlead position [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Elength      !< Element length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmElev      !< Bottom elevation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: BottmStiff      !< Bottom stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LMassDen      !< Line mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LDMassDen      !< Line displaced mass per unit length [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LEAStiff      !< Line axial stiffness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCI      !< Line inertia coefficient [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LineCD      !< Line drag coefficient [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Bvp      !< Boundary condtion [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc0      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel0      !<  [-]
    INTEGER(IntKi)  :: NStepWave      !< Number of wave steps [-]
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAP      !< Shape function [-]
    REAL(ReKi) , DIMENSION(1:6,1:4)  :: SHAPS      !< Shape function [-]
    REAL(ReKi) , DIMENSION(1:6)  :: GAUSSW      !< Shape function [-]
    INTEGER(IntKi)  :: NGAUSS      !< 6 POINT GAUSSIAN QUADRATURE INTEGRATION [-]
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPT      !< Shape function [-]
    REAL(ReKi) , DIMENSION(1:10,1:4)  :: SHAPTS      !< Shape function [-]
    INTEGER(IntKi)  :: NTRAP      !< 10 TRANPEZOIDE INTEGRATION point [-]
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: SBEND      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:3,1:4,1:4)  :: STEN      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:4,1:4)  :: RMASS      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:4,1:4,1:4,1:4)  :: RADDM      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: PMPN      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:4)  :: AM      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:3)  :: PM      !< Internal [-]
    INTEGER(IntKi) , DIMENSION(1:3,1:4)  :: IDOF      !< Internal [-]
    INTEGER(IntKi) , DIMENSION(1:3)  :: JDOF      !< Internal [-]
    REAL(ReKi) , DIMENSION(1:3,1:3,1:4)  :: PPA      !< Internal [-]
    REAL(ReKi)  :: PtfmRefzt      !< Platform reference [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      !< Column delimiter for output text files [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: GLUZR      !< Line coordinate & direction cosine [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: GTZER      !< Line tension [-]
  END TYPE FEAM_ParameterType
! =======================
! =========  FEAM_InputType  =======
  TYPE, PUBLIC :: FEAM_InputType
    TYPE(MeshType)  :: HydroForceLineMesh      !< Meshed input data [-]
    TYPE(MeshType)  :: PtFairleadDisplacement      !< Meshed input data [-]
  END TYPE FEAM_InputType
! =======================
! =========  FEAM_OutputType  =======
  TYPE, PUBLIC :: FEAM_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Data to be written to an output file: see WriteOutputHdr for names of each variable [see WriteOutputUnt]
    TYPE(MeshType)  :: PtFairleadLoad      !< Meshed output data [-]
    TYPE(MeshType)  :: LineMeshPosition      !< Meshed output data [-]
  END TYPE FEAM_OutputType
! =======================
CONTAINS
 SUBROUTINE FEAM_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(FEAM_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%DT = SrcInputFileData%DT
IF (ALLOCATED(SrcInputFileData%LineCI)) THEN
  i1_l = LBOUND(SrcInputFileData%LineCI,1)
  i1_u = UBOUND(SrcInputFileData%LineCI,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LineCI)) THEN 
    ALLOCATE(DstInputFileData%LineCI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LineCI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LineCI = SrcInputFileData%LineCI
ENDIF
IF (ALLOCATED(SrcInputFileData%LineCD)) THEN
  i1_l = LBOUND(SrcInputFileData%LineCD,1)
  i1_u = UBOUND(SrcInputFileData%LineCD,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LineCD)) THEN 
    ALLOCATE(DstInputFileData%LineCD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LineCD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LineCD = SrcInputFileData%LineCD
ENDIF
IF (ALLOCATED(SrcInputFileData%LEAStiff)) THEN
  i1_l = LBOUND(SrcInputFileData%LEAStiff,1)
  i1_u = UBOUND(SrcInputFileData%LEAStiff,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LEAStiff)) THEN 
    ALLOCATE(DstInputFileData%LEAStiff(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LEAStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LEAStiff = SrcInputFileData%LEAStiff
ENDIF
IF (ALLOCATED(SrcInputFileData%LMassDen)) THEN
  i1_l = LBOUND(SrcInputFileData%LMassDen,1)
  i1_u = UBOUND(SrcInputFileData%LMassDen,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LMassDen)) THEN 
    ALLOCATE(DstInputFileData%LMassDen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LMassDen.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LMassDen = SrcInputFileData%LMassDen
ENDIF
IF (ALLOCATED(SrcInputFileData%LDMassDen)) THEN
  i1_l = LBOUND(SrcInputFileData%LDMassDen,1)
  i1_u = UBOUND(SrcInputFileData%LDMassDen,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LDMassDen)) THEN 
    ALLOCATE(DstInputFileData%LDMassDen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LDMassDen.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LDMassDen = SrcInputFileData%LDMassDen
ENDIF
IF (ALLOCATED(SrcInputFileData%BottmStiff)) THEN
  i1_l = LBOUND(SrcInputFileData%BottmStiff,1)
  i1_u = UBOUND(SrcInputFileData%BottmStiff,1)
  IF (.NOT. ALLOCATED(DstInputFileData%BottmStiff)) THEN 
    ALLOCATE(DstInputFileData%BottmStiff(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%BottmStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%BottmStiff = SrcInputFileData%BottmStiff
ENDIF
IF (ALLOCATED(SrcInputFileData%LRadAnch)) THEN
  i1_l = LBOUND(SrcInputFileData%LRadAnch,1)
  i1_u = UBOUND(SrcInputFileData%LRadAnch,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LRadAnch)) THEN 
    ALLOCATE(DstInputFileData%LRadAnch(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LRadAnch.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LRadAnch = SrcInputFileData%LRadAnch
ENDIF
IF (ALLOCATED(SrcInputFileData%LAngAnch)) THEN
  i1_l = LBOUND(SrcInputFileData%LAngAnch,1)
  i1_u = UBOUND(SrcInputFileData%LAngAnch,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LAngAnch)) THEN 
    ALLOCATE(DstInputFileData%LAngAnch(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LAngAnch.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LAngAnch = SrcInputFileData%LAngAnch
ENDIF
IF (ALLOCATED(SrcInputFileData%LDpthAnch)) THEN
  i1_l = LBOUND(SrcInputFileData%LDpthAnch,1)
  i1_u = UBOUND(SrcInputFileData%LDpthAnch,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LDpthAnch)) THEN 
    ALLOCATE(DstInputFileData%LDpthAnch(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LDpthAnch.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LDpthAnch = SrcInputFileData%LDpthAnch
ENDIF
IF (ALLOCATED(SrcInputFileData%LRadFair)) THEN
  i1_l = LBOUND(SrcInputFileData%LRadFair,1)
  i1_u = UBOUND(SrcInputFileData%LRadFair,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LRadFair)) THEN 
    ALLOCATE(DstInputFileData%LRadFair(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LRadFair.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LRadFair = SrcInputFileData%LRadFair
ENDIF
IF (ALLOCATED(SrcInputFileData%LAngFair)) THEN
  i1_l = LBOUND(SrcInputFileData%LAngFair,1)
  i1_u = UBOUND(SrcInputFileData%LAngFair,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LAngFair)) THEN 
    ALLOCATE(DstInputFileData%LAngFair(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LAngFair.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LAngFair = SrcInputFileData%LAngFair
ENDIF
IF (ALLOCATED(SrcInputFileData%LDrftFair)) THEN
  i1_l = LBOUND(SrcInputFileData%LDrftFair,1)
  i1_u = UBOUND(SrcInputFileData%LDrftFair,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LDrftFair)) THEN 
    ALLOCATE(DstInputFileData%LDrftFair(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LDrftFair.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LDrftFair = SrcInputFileData%LDrftFair
ENDIF
IF (ALLOCATED(SrcInputFileData%LUnstrLen)) THEN
  i1_l = LBOUND(SrcInputFileData%LUnstrLen,1)
  i1_u = UBOUND(SrcInputFileData%LUnstrLen,1)
  IF (.NOT. ALLOCATED(DstInputFileData%LUnstrLen)) THEN 
    ALLOCATE(DstInputFileData%LUnstrLen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%LUnstrLen.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%LUnstrLen = SrcInputFileData%LUnstrLen
ENDIF
IF (ALLOCATED(SrcInputFileData%Tension)) THEN
  i1_l = LBOUND(SrcInputFileData%Tension,1)
  i1_u = UBOUND(SrcInputFileData%Tension,1)
  IF (.NOT. ALLOCATED(DstInputFileData%Tension)) THEN 
    ALLOCATE(DstInputFileData%Tension(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%Tension.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%Tension = SrcInputFileData%Tension
ENDIF
IF (ALLOCATED(SrcInputFileData%GSL)) THEN
  i1_l = LBOUND(SrcInputFileData%GSL,1)
  i1_u = UBOUND(SrcInputFileData%GSL,1)
  i2_l = LBOUND(SrcInputFileData%GSL,2)
  i2_u = UBOUND(SrcInputFileData%GSL,2)
  i3_l = LBOUND(SrcInputFileData%GSL,3)
  i3_u = UBOUND(SrcInputFileData%GSL,3)
  IF (.NOT. ALLOCATED(DstInputFileData%GSL)) THEN 
    ALLOCATE(DstInputFileData%GSL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GSL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%GSL = SrcInputFileData%GSL
ENDIF
IF (ALLOCATED(SrcInputFileData%GSR)) THEN
  i1_l = LBOUND(SrcInputFileData%GSR,1)
  i1_u = UBOUND(SrcInputFileData%GSR,1)
  i2_l = LBOUND(SrcInputFileData%GSR,2)
  i2_u = UBOUND(SrcInputFileData%GSR,2)
  IF (.NOT. ALLOCATED(DstInputFileData%GSR)) THEN 
    ALLOCATE(DstInputFileData%GSR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GSR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%GSR = SrcInputFileData%GSR
ENDIF
IF (ALLOCATED(SrcInputFileData%GE)) THEN
  i1_l = LBOUND(SrcInputFileData%GE,1)
  i1_u = UBOUND(SrcInputFileData%GE,1)
  i2_l = LBOUND(SrcInputFileData%GE,2)
  i2_u = UBOUND(SrcInputFileData%GE,2)
  i3_l = LBOUND(SrcInputFileData%GE,3)
  i3_u = UBOUND(SrcInputFileData%GE,3)
  IF (.NOT. ALLOCATED(DstInputFileData%GE)) THEN 
    ALLOCATE(DstInputFileData%GE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%GE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%GE = SrcInputFileData%GE
ENDIF
    DstInputFileData%NumLines = SrcInputFileData%NumLines
    DstInputFileData%NumElems = SrcInputFileData%NumElems
    DstInputFileData%Eps = SrcInputFileData%Eps
    DstInputFileData%Gravity = SrcInputFileData%Gravity
    DstInputFileData%WtrDens = SrcInputFileData%WtrDens
    DstInputFileData%MaxIter = SrcInputFileData%MaxIter
    DstInputFileData%SumPrint = SrcInputFileData%SumPrint
    DstInputFileData%OutFile = SrcInputFileData%OutFile
    DstInputFileData%TabDelim = SrcInputFileData%TabDelim
    DstInputFileData%OutFmt = SrcInputFileData%OutFmt
    DstInputFileData%Tstart = SrcInputFileData%Tstart
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
 END SUBROUTINE FEAM_CopyInputFile

 SUBROUTINE FEAM_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(FEAM_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputFileData%LineCI)) THEN
  DEALLOCATE(InputFileData%LineCI)
ENDIF
IF (ALLOCATED(InputFileData%LineCD)) THEN
  DEALLOCATE(InputFileData%LineCD)
ENDIF
IF (ALLOCATED(InputFileData%LEAStiff)) THEN
  DEALLOCATE(InputFileData%LEAStiff)
ENDIF
IF (ALLOCATED(InputFileData%LMassDen)) THEN
  DEALLOCATE(InputFileData%LMassDen)
ENDIF
IF (ALLOCATED(InputFileData%LDMassDen)) THEN
  DEALLOCATE(InputFileData%LDMassDen)
ENDIF
IF (ALLOCATED(InputFileData%BottmStiff)) THEN
  DEALLOCATE(InputFileData%BottmStiff)
ENDIF
IF (ALLOCATED(InputFileData%LRadAnch)) THEN
  DEALLOCATE(InputFileData%LRadAnch)
ENDIF
IF (ALLOCATED(InputFileData%LAngAnch)) THEN
  DEALLOCATE(InputFileData%LAngAnch)
ENDIF
IF (ALLOCATED(InputFileData%LDpthAnch)) THEN
  DEALLOCATE(InputFileData%LDpthAnch)
ENDIF
IF (ALLOCATED(InputFileData%LRadFair)) THEN
  DEALLOCATE(InputFileData%LRadFair)
ENDIF
IF (ALLOCATED(InputFileData%LAngFair)) THEN
  DEALLOCATE(InputFileData%LAngFair)
ENDIF
IF (ALLOCATED(InputFileData%LDrftFair)) THEN
  DEALLOCATE(InputFileData%LDrftFair)
ENDIF
IF (ALLOCATED(InputFileData%LUnstrLen)) THEN
  DEALLOCATE(InputFileData%LUnstrLen)
ENDIF
IF (ALLOCATED(InputFileData%Tension)) THEN
  DEALLOCATE(InputFileData%Tension)
ENDIF
IF (ALLOCATED(InputFileData%GSL)) THEN
  DEALLOCATE(InputFileData%GSL)
ENDIF
IF (ALLOCATED(InputFileData%GSR)) THEN
  DEALLOCATE(InputFileData%GSR)
ENDIF
IF (ALLOCATED(InputFileData%GE)) THEN
  DEALLOCATE(InputFileData%GE)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
 END SUBROUTINE FEAM_DestroyInputFile


subroutine FEAM_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackInputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineCI
   call RegPack(Buf, allocated(InData%LineCI))
   if (allocated(InData%LineCI)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineCI), ubound(InData%LineCI))
      call RegPack(Buf, InData%LineCI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineCD
   call RegPack(Buf, allocated(InData%LineCD))
   if (allocated(InData%LineCD)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineCD), ubound(InData%LineCD))
      call RegPack(Buf, InData%LineCD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LEAStiff
   call RegPack(Buf, allocated(InData%LEAStiff))
   if (allocated(InData%LEAStiff)) then
      call RegPackBounds(Buf, 1, lbound(InData%LEAStiff), ubound(InData%LEAStiff))
      call RegPack(Buf, InData%LEAStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LMassDen
   call RegPack(Buf, allocated(InData%LMassDen))
   if (allocated(InData%LMassDen)) then
      call RegPackBounds(Buf, 1, lbound(InData%LMassDen), ubound(InData%LMassDen))
      call RegPack(Buf, InData%LMassDen)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LDMassDen
   call RegPack(Buf, allocated(InData%LDMassDen))
   if (allocated(InData%LDMassDen)) then
      call RegPackBounds(Buf, 1, lbound(InData%LDMassDen), ubound(InData%LDMassDen))
      call RegPack(Buf, InData%LDMassDen)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BottmStiff
   call RegPack(Buf, allocated(InData%BottmStiff))
   if (allocated(InData%BottmStiff)) then
      call RegPackBounds(Buf, 1, lbound(InData%BottmStiff), ubound(InData%BottmStiff))
      call RegPack(Buf, InData%BottmStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LRadAnch
   call RegPack(Buf, allocated(InData%LRadAnch))
   if (allocated(InData%LRadAnch)) then
      call RegPackBounds(Buf, 1, lbound(InData%LRadAnch), ubound(InData%LRadAnch))
      call RegPack(Buf, InData%LRadAnch)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LAngAnch
   call RegPack(Buf, allocated(InData%LAngAnch))
   if (allocated(InData%LAngAnch)) then
      call RegPackBounds(Buf, 1, lbound(InData%LAngAnch), ubound(InData%LAngAnch))
      call RegPack(Buf, InData%LAngAnch)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LDpthAnch
   call RegPack(Buf, allocated(InData%LDpthAnch))
   if (allocated(InData%LDpthAnch)) then
      call RegPackBounds(Buf, 1, lbound(InData%LDpthAnch), ubound(InData%LDpthAnch))
      call RegPack(Buf, InData%LDpthAnch)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LRadFair
   call RegPack(Buf, allocated(InData%LRadFair))
   if (allocated(InData%LRadFair)) then
      call RegPackBounds(Buf, 1, lbound(InData%LRadFair), ubound(InData%LRadFair))
      call RegPack(Buf, InData%LRadFair)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LAngFair
   call RegPack(Buf, allocated(InData%LAngFair))
   if (allocated(InData%LAngFair)) then
      call RegPackBounds(Buf, 1, lbound(InData%LAngFair), ubound(InData%LAngFair))
      call RegPack(Buf, InData%LAngFair)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LDrftFair
   call RegPack(Buf, allocated(InData%LDrftFair))
   if (allocated(InData%LDrftFair)) then
      call RegPackBounds(Buf, 1, lbound(InData%LDrftFair), ubound(InData%LDrftFair))
      call RegPack(Buf, InData%LDrftFair)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LUnstrLen
   call RegPack(Buf, allocated(InData%LUnstrLen))
   if (allocated(InData%LUnstrLen)) then
      call RegPackBounds(Buf, 1, lbound(InData%LUnstrLen), ubound(InData%LUnstrLen))
      call RegPack(Buf, InData%LUnstrLen)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tension
   call RegPack(Buf, allocated(InData%Tension))
   if (allocated(InData%Tension)) then
      call RegPackBounds(Buf, 1, lbound(InData%Tension), ubound(InData%Tension))
      call RegPack(Buf, InData%Tension)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GSL
   call RegPack(Buf, allocated(InData%GSL))
   if (allocated(InData%GSL)) then
      call RegPackBounds(Buf, 3, lbound(InData%GSL), ubound(InData%GSL))
      call RegPack(Buf, InData%GSL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GSR
   call RegPack(Buf, allocated(InData%GSR))
   if (allocated(InData%GSR)) then
      call RegPackBounds(Buf, 2, lbound(InData%GSR), ubound(InData%GSR))
      call RegPack(Buf, InData%GSR)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GE
   call RegPack(Buf, allocated(InData%GE))
   if (allocated(InData%GE)) then
      call RegPackBounds(Buf, 3, lbound(InData%GE), ubound(InData%GE))
      call RegPack(Buf, InData%GE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumLines
   call RegPack(Buf, InData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumElems
   call RegPack(Buf, InData%NumElems)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Eps
   call RegPack(Buf, InData%Eps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MaxIter
   call RegPack(Buf, InData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegPack(Buf, InData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFile
   call RegPack(Buf, InData%OutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TabDelim
   call RegPack(Buf, InData%TabDelim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tstart
   call RegPack(Buf, InData%Tstart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackInputFile'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineCI
   if (allocated(OutData%LineCI)) deallocate(OutData%LineCI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineCI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineCI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineCI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LineCD
   if (allocated(OutData%LineCD)) deallocate(OutData%LineCD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineCD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineCD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineCD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LEAStiff
   if (allocated(OutData%LEAStiff)) deallocate(OutData%LEAStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LEAStiff(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LEAStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LEAStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LMassDen
   if (allocated(OutData%LMassDen)) deallocate(OutData%LMassDen)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LMassDen(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LMassDen.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LMassDen)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LDMassDen
   if (allocated(OutData%LDMassDen)) deallocate(OutData%LDMassDen)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LDMassDen(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LDMassDen.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LDMassDen)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BottmStiff
   if (allocated(OutData%BottmStiff)) deallocate(OutData%BottmStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BottmStiff(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BottmStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BottmStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LRadAnch
   if (allocated(OutData%LRadAnch)) deallocate(OutData%LRadAnch)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LRadAnch(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LRadAnch.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LRadAnch)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LAngAnch
   if (allocated(OutData%LAngAnch)) deallocate(OutData%LAngAnch)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LAngAnch(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LAngAnch.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LAngAnch)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LDpthAnch
   if (allocated(OutData%LDpthAnch)) deallocate(OutData%LDpthAnch)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LDpthAnch(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LDpthAnch.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LDpthAnch)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LRadFair
   if (allocated(OutData%LRadFair)) deallocate(OutData%LRadFair)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LRadFair(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LRadFair.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LRadFair)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LAngFair
   if (allocated(OutData%LAngFair)) deallocate(OutData%LAngFair)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LAngFair(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LAngFair.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LAngFair)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LDrftFair
   if (allocated(OutData%LDrftFair)) deallocate(OutData%LDrftFair)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LDrftFair(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LDrftFair.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LDrftFair)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LUnstrLen
   if (allocated(OutData%LUnstrLen)) deallocate(OutData%LUnstrLen)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LUnstrLen(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LUnstrLen.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LUnstrLen)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Tension
   if (allocated(OutData%Tension)) deallocate(OutData%Tension)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Tension(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Tension.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Tension)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GSL
   if (allocated(OutData%GSL)) deallocate(OutData%GSL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GSL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GSL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GSL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GSR
   if (allocated(OutData%GSR)) deallocate(OutData%GSR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GSR(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GSR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GSR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GE
   if (allocated(OutData%GE)) deallocate(OutData%GE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GE(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NumLines
   call RegUnpack(Buf, OutData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumElems
   call RegUnpack(Buf, OutData%NumElems)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Eps
   call RegUnpack(Buf, OutData%Eps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MaxIter
   call RegUnpack(Buf, OutData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumPrint
   call RegUnpack(Buf, OutData%SumPrint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFile
   call RegUnpack(Buf, OutData%OutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TabDelim
   call RegUnpack(Buf, OutData%TabDelim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tstart
   call RegUnpack(Buf, OutData%Tstart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FEAM_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(FEAM_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
    DstInitInputData%NStepWave = SrcInitInputData%NStepWave
IF (ALLOCATED(SrcInitInputData%WaveAcc0)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveAcc0,1)
  i1_u = UBOUND(SrcInitInputData%WaveAcc0,1)
  i2_l = LBOUND(SrcInitInputData%WaveAcc0,2)
  i2_u = UBOUND(SrcInitInputData%WaveAcc0,2)
  i3_l = LBOUND(SrcInitInputData%WaveAcc0,3)
  i3_u = UBOUND(SrcInitInputData%WaveAcc0,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveAcc0)) THEN 
    ALLOCATE(DstInitInputData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveAcc0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveAcc0 = SrcInitInputData%WaveAcc0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveTime)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveTime,1)
  i1_u = UBOUND(SrcInitInputData%WaveTime,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveTime)) THEN 
    ALLOCATE(DstInitInputData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveTime.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveTime = SrcInitInputData%WaveTime
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveVel0)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveVel0,1)
  i1_u = UBOUND(SrcInitInputData%WaveVel0,1)
  i2_l = LBOUND(SrcInitInputData%WaveVel0,2)
  i2_u = UBOUND(SrcInitInputData%WaveVel0,2)
  i3_l = LBOUND(SrcInitInputData%WaveVel0,3)
  i3_u = UBOUND(SrcInitInputData%WaveVel0,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveVel0)) THEN 
    ALLOCATE(DstInitInputData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveVel0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveVel0 = SrcInitInputData%WaveVel0
ENDIF
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
 END SUBROUTINE FEAM_CopyInitInput

 SUBROUTINE FEAM_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FEAM_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%WaveAcc0)) THEN
  DEALLOCATE(InitInputData%WaveAcc0)
ENDIF
IF (ALLOCATED(InitInputData%WaveTime)) THEN
  DEALLOCATE(InitInputData%WaveTime)
ENDIF
IF (ALLOCATED(InitInputData%WaveVel0)) THEN
  DEALLOCATE(InitInputData%WaveVel0)
ENDIF
 END SUBROUTINE FEAM_DestroyInitInput


subroutine FEAM_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmInit
   call RegPack(Buf, InData%PtfmInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAcc0
   call RegPack(Buf, allocated(InData%WaveAcc0))
   if (allocated(InData%WaveAcc0)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveAcc0), ubound(InData%WaveAcc0))
      call RegPack(Buf, InData%WaveAcc0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, allocated(InData%WaveTime))
   if (allocated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPack(Buf, InData%WaveTime)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveVel0
   call RegPack(Buf, allocated(InData%WaveVel0))
   if (allocated(InData%WaveVel0)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveVel0), ubound(InData%WaveVel0))
      call RegPack(Buf, InData%WaveVel0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmInit
   call RegUnpack(Buf, OutData%PtfmInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAcc0
   if (allocated(OutData%WaveAcc0)) deallocate(OutData%WaveAcc0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveAcc0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveAcc0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveTime
   if (allocated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveTime)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveVel0
   if (allocated(OutData%WaveVel0)) deallocate(OutData%WaveVel0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveVel0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveVel0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FEAM_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(FEAM_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%LAnchxi)) THEN
  i1_l = LBOUND(SrcInitOutputData%LAnchxi,1)
  i1_u = UBOUND(SrcInitOutputData%LAnchxi,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LAnchxi)) THEN 
    ALLOCATE(DstInitOutputData%LAnchxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LAnchxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LAnchxi = SrcInitOutputData%LAnchxi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LAnchyi)) THEN
  i1_l = LBOUND(SrcInitOutputData%LAnchyi,1)
  i1_u = UBOUND(SrcInitOutputData%LAnchyi,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LAnchyi)) THEN 
    ALLOCATE(DstInitOutputData%LAnchyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LAnchyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LAnchyi = SrcInitOutputData%LAnchyi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LAnchzi)) THEN
  i1_l = LBOUND(SrcInitOutputData%LAnchzi,1)
  i1_u = UBOUND(SrcInitOutputData%LAnchzi,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LAnchzi)) THEN 
    ALLOCATE(DstInitOutputData%LAnchzi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LAnchzi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LAnchzi = SrcInitOutputData%LAnchzi
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairxt)) THEN
  i1_l = LBOUND(SrcInitOutputData%LFairxt,1)
  i1_u = UBOUND(SrcInitOutputData%LFairxt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LFairxt)) THEN 
    ALLOCATE(DstInitOutputData%LFairxt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LFairxt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LFairxt = SrcInitOutputData%LFairxt
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairyt)) THEN
  i1_l = LBOUND(SrcInitOutputData%LFairyt,1)
  i1_u = UBOUND(SrcInitOutputData%LFairyt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LFairyt)) THEN 
    ALLOCATE(DstInitOutputData%LFairyt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LFairyt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LFairyt = SrcInitOutputData%LFairyt
ENDIF
IF (ALLOCATED(SrcInitOutputData%LFairzt)) THEN
  i1_l = LBOUND(SrcInitOutputData%LFairzt,1)
  i1_u = UBOUND(SrcInitOutputData%LFairzt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LFairzt)) THEN 
    ALLOCATE(DstInitOutputData%LFairzt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LFairzt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LFairzt = SrcInitOutputData%LFairzt
ENDIF
 END SUBROUTINE FEAM_CopyInitOutput

 SUBROUTINE FEAM_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FEAM_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%LAnchxi)) THEN
  DEALLOCATE(InitOutputData%LAnchxi)
ENDIF
IF (ALLOCATED(InitOutputData%LAnchyi)) THEN
  DEALLOCATE(InitOutputData%LAnchyi)
ENDIF
IF (ALLOCATED(InitOutputData%LAnchzi)) THEN
  DEALLOCATE(InitOutputData%LAnchzi)
ENDIF
IF (ALLOCATED(InitOutputData%LFairxt)) THEN
  DEALLOCATE(InitOutputData%LFairxt)
ENDIF
IF (ALLOCATED(InitOutputData%LFairyt)) THEN
  DEALLOCATE(InitOutputData%LFairyt)
ENDIF
IF (ALLOCATED(InitOutputData%LFairzt)) THEN
  DEALLOCATE(InitOutputData%LFairzt)
ENDIF
 END SUBROUTINE FEAM_DestroyInitOutput


subroutine FEAM_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! LAnchxi
   call RegPack(Buf, allocated(InData%LAnchxi))
   if (allocated(InData%LAnchxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%LAnchxi), ubound(InData%LAnchxi))
      call RegPack(Buf, InData%LAnchxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LAnchyi
   call RegPack(Buf, allocated(InData%LAnchyi))
   if (allocated(InData%LAnchyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%LAnchyi), ubound(InData%LAnchyi))
      call RegPack(Buf, InData%LAnchyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LAnchzi
   call RegPack(Buf, allocated(InData%LAnchzi))
   if (allocated(InData%LAnchzi)) then
      call RegPackBounds(Buf, 1, lbound(InData%LAnchzi), ubound(InData%LAnchzi))
      call RegPack(Buf, InData%LAnchzi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LFairxt
   call RegPack(Buf, allocated(InData%LFairxt))
   if (allocated(InData%LFairxt)) then
      call RegPackBounds(Buf, 1, lbound(InData%LFairxt), ubound(InData%LFairxt))
      call RegPack(Buf, InData%LFairxt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LFairyt
   call RegPack(Buf, allocated(InData%LFairyt))
   if (allocated(InData%LFairyt)) then
      call RegPackBounds(Buf, 1, lbound(InData%LFairyt), ubound(InData%LFairyt))
      call RegPack(Buf, InData%LFairyt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LFairzt
   call RegPack(Buf, allocated(InData%LFairzt))
   if (allocated(InData%LFairzt)) then
      call RegPackBounds(Buf, 1, lbound(InData%LFairzt), ubound(InData%LFairzt))
      call RegPack(Buf, InData%LFairzt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! LAnchxi
   if (allocated(OutData%LAnchxi)) deallocate(OutData%LAnchxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LAnchxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LAnchxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LAnchxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LAnchyi
   if (allocated(OutData%LAnchyi)) deallocate(OutData%LAnchyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LAnchyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LAnchyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LAnchyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LAnchzi
   if (allocated(OutData%LAnchzi)) deallocate(OutData%LAnchzi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LAnchzi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LAnchzi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LAnchzi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LFairxt
   if (allocated(OutData%LFairxt)) deallocate(OutData%LFairxt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LFairxt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LFairxt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LFairxt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LFairyt
   if (allocated(OutData%LFairyt)) deallocate(OutData%LFairyt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LFairyt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LFairyt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LFairyt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LFairzt
   if (allocated(OutData%LFairzt)) deallocate(OutData%LFairzt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LFairzt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LFairzt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LFairzt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FEAM_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%GLU)) THEN
  i1_l = LBOUND(SrcContStateData%GLU,1)
  i1_u = UBOUND(SrcContStateData%GLU,1)
  i2_l = LBOUND(SrcContStateData%GLU,2)
  i2_u = UBOUND(SrcContStateData%GLU,2)
  IF (.NOT. ALLOCATED(DstContStateData%GLU)) THEN 
    ALLOCATE(DstContStateData%GLU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%GLU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%GLU = SrcContStateData%GLU
ENDIF
IF (ALLOCATED(SrcContStateData%GLDU)) THEN
  i1_l = LBOUND(SrcContStateData%GLDU,1)
  i1_u = UBOUND(SrcContStateData%GLDU,1)
  i2_l = LBOUND(SrcContStateData%GLDU,2)
  i2_u = UBOUND(SrcContStateData%GLDU,2)
  IF (.NOT. ALLOCATED(DstContStateData%GLDU)) THEN 
    ALLOCATE(DstContStateData%GLDU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%GLDU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%GLDU = SrcContStateData%GLDU
ENDIF
 END SUBROUTINE FEAM_CopyContState

 SUBROUTINE FEAM_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FEAM_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%GLU)) THEN
  DEALLOCATE(ContStateData%GLU)
ENDIF
IF (ALLOCATED(ContStateData%GLDU)) THEN
  DEALLOCATE(ContStateData%GLDU)
ENDIF
 END SUBROUTINE FEAM_DestroyContState


subroutine FEAM_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! GLU
   call RegPack(Buf, allocated(InData%GLU))
   if (allocated(InData%GLU)) then
      call RegPackBounds(Buf, 2, lbound(InData%GLU), ubound(InData%GLU))
      call RegPack(Buf, InData%GLU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GLDU
   call RegPack(Buf, allocated(InData%GLDU))
   if (allocated(InData%GLDU)) then
      call RegPackBounds(Buf, 2, lbound(InData%GLDU), ubound(InData%GLDU))
      call RegPack(Buf, InData%GLDU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackContState'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! GLU
   if (allocated(OutData%GLU)) deallocate(OutData%GLU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GLDU
   if (allocated(OutData%GLDU)) deallocate(OutData%GLDU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLDU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLDU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLDU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FEAM_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(FEAM_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE FEAM_CopyDiscState

 SUBROUTINE FEAM_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FEAM_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE FEAM_DestroyDiscState


subroutine FEAM_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyDiscState
   call RegPack(Buf, InData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyDiscState
   call RegUnpack(Buf, OutData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FEAM_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%TSN = SrcConstrStateData%TSN
    DstConstrStateData%TZER = SrcConstrStateData%TZER
 END SUBROUTINE FEAM_CopyConstrState

 SUBROUTINE FEAM_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FEAM_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE FEAM_DestroyConstrState


subroutine FEAM_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TSN
   call RegPack(Buf, InData%TSN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TZER
   call RegPack(Buf, InData%TZER)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! TSN
   call RegUnpack(Buf, OutData%TSN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TZER
   call RegUnpack(Buf, OutData%TZER)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FEAM_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(FEAM_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%GLU0)) THEN
  i1_l = LBOUND(SrcOtherStateData%GLU0,1)
  i1_u = UBOUND(SrcOtherStateData%GLU0,1)
  i2_l = LBOUND(SrcOtherStateData%GLU0,2)
  i2_u = UBOUND(SrcOtherStateData%GLU0,2)
  IF (.NOT. ALLOCATED(DstOtherStateData%GLU0)) THEN 
    ALLOCATE(DstOtherStateData%GLU0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLU0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%GLU0 = SrcOtherStateData%GLU0
ENDIF
IF (ALLOCATED(SrcOtherStateData%GLDDU)) THEN
  i1_l = LBOUND(SrcOtherStateData%GLDDU,1)
  i1_u = UBOUND(SrcOtherStateData%GLDDU,1)
  i2_l = LBOUND(SrcOtherStateData%GLDDU,2)
  i2_u = UBOUND(SrcOtherStateData%GLDDU,2)
  IF (.NOT. ALLOCATED(DstOtherStateData%GLDDU)) THEN 
    ALLOCATE(DstOtherStateData%GLDDU(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GLDDU.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%GLDDU = SrcOtherStateData%GLDDU
ENDIF
    DstOtherStateData%BottomTouch = SrcOtherStateData%BottomTouch
IF (ALLOCATED(SrcOtherStateData%GFORC0)) THEN
  i1_l = LBOUND(SrcOtherStateData%GFORC0,1)
  i1_u = UBOUND(SrcOtherStateData%GFORC0,1)
  i2_l = LBOUND(SrcOtherStateData%GFORC0,2)
  i2_u = UBOUND(SrcOtherStateData%GFORC0,2)
  i3_l = LBOUND(SrcOtherStateData%GFORC0,3)
  i3_u = UBOUND(SrcOtherStateData%GFORC0,3)
  IF (.NOT. ALLOCATED(DstOtherStateData%GFORC0)) THEN 
    ALLOCATE(DstOtherStateData%GFORC0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GFORC0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%GFORC0 = SrcOtherStateData%GFORC0
ENDIF
IF (ALLOCATED(SrcOtherStateData%GMASS0)) THEN
  i1_l = LBOUND(SrcOtherStateData%GMASS0,1)
  i1_u = UBOUND(SrcOtherStateData%GMASS0,1)
  i2_l = LBOUND(SrcOtherStateData%GMASS0,2)
  i2_u = UBOUND(SrcOtherStateData%GMASS0,2)
  i3_l = LBOUND(SrcOtherStateData%GMASS0,3)
  i3_u = UBOUND(SrcOtherStateData%GMASS0,3)
  i4_l = LBOUND(SrcOtherStateData%GMASS0,4)
  i4_u = UBOUND(SrcOtherStateData%GMASS0,4)
  IF (.NOT. ALLOCATED(DstOtherStateData%GMASS0)) THEN 
    ALLOCATE(DstOtherStateData%GMASS0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%GMASS0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%GMASS0 = SrcOtherStateData%GMASS0
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_FPA)) THEN
  i1_l = LBOUND(SrcOtherStateData%FAST_FPA,1)
  i1_u = UBOUND(SrcOtherStateData%FAST_FPA,1)
  i2_l = LBOUND(SrcOtherStateData%FAST_FPA,2)
  i2_u = UBOUND(SrcOtherStateData%FAST_FPA,2)
  IF (.NOT. ALLOCATED(DstOtherStateData%FAST_FPA)) THEN 
    ALLOCATE(DstOtherStateData%FAST_FPA(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAST_FPA.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%FAST_FPA = SrcOtherStateData%FAST_FPA
ENDIF
IF (ALLOCATED(SrcOtherStateData%FAST_RP)) THEN
  i1_l = LBOUND(SrcOtherStateData%FAST_RP,1)
  i1_u = UBOUND(SrcOtherStateData%FAST_RP,1)
  i2_l = LBOUND(SrcOtherStateData%FAST_RP,2)
  i2_u = UBOUND(SrcOtherStateData%FAST_RP,2)
  IF (.NOT. ALLOCATED(DstOtherStateData%FAST_RP)) THEN 
    ALLOCATE(DstOtherStateData%FAST_RP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%FAST_RP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOtherStateData%FAST_RP = SrcOtherStateData%FAST_RP
ENDIF
    DstOtherStateData%INCR = SrcOtherStateData%INCR
    DstOtherStateData%RSDF = SrcOtherStateData%RSDF
    DstOtherStateData%FORC0 = SrcOtherStateData%FORC0
    DstOtherStateData%EMAS0 = SrcOtherStateData%EMAS0
 END SUBROUTINE FEAM_CopyOtherState

 SUBROUTINE FEAM_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FEAM_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%GLU0)) THEN
  DEALLOCATE(OtherStateData%GLU0)
ENDIF
IF (ALLOCATED(OtherStateData%GLDDU)) THEN
  DEALLOCATE(OtherStateData%GLDDU)
ENDIF
IF (ALLOCATED(OtherStateData%GFORC0)) THEN
  DEALLOCATE(OtherStateData%GFORC0)
ENDIF
IF (ALLOCATED(OtherStateData%GMASS0)) THEN
  DEALLOCATE(OtherStateData%GMASS0)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_FPA)) THEN
  DEALLOCATE(OtherStateData%FAST_FPA)
ENDIF
IF (ALLOCATED(OtherStateData%FAST_RP)) THEN
  DEALLOCATE(OtherStateData%FAST_RP)
ENDIF
 END SUBROUTINE FEAM_DestroyOtherState


subroutine FEAM_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! GLU0
   call RegPack(Buf, allocated(InData%GLU0))
   if (allocated(InData%GLU0)) then
      call RegPackBounds(Buf, 2, lbound(InData%GLU0), ubound(InData%GLU0))
      call RegPack(Buf, InData%GLU0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GLDDU
   call RegPack(Buf, allocated(InData%GLDDU))
   if (allocated(InData%GLDDU)) then
      call RegPackBounds(Buf, 2, lbound(InData%GLDDU), ubound(InData%GLDDU))
      call RegPack(Buf, InData%GLDDU)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BottomTouch
   call RegPack(Buf, InData%BottomTouch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GFORC0
   call RegPack(Buf, allocated(InData%GFORC0))
   if (allocated(InData%GFORC0)) then
      call RegPackBounds(Buf, 3, lbound(InData%GFORC0), ubound(InData%GFORC0))
      call RegPack(Buf, InData%GFORC0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GMASS0
   call RegPack(Buf, allocated(InData%GMASS0))
   if (allocated(InData%GMASS0)) then
      call RegPackBounds(Buf, 4, lbound(InData%GMASS0), ubound(InData%GMASS0))
      call RegPack(Buf, InData%GMASS0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAST_FPA
   call RegPack(Buf, allocated(InData%FAST_FPA))
   if (allocated(InData%FAST_FPA)) then
      call RegPackBounds(Buf, 2, lbound(InData%FAST_FPA), ubound(InData%FAST_FPA))
      call RegPack(Buf, InData%FAST_FPA)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAST_RP
   call RegPack(Buf, allocated(InData%FAST_RP))
   if (allocated(InData%FAST_RP)) then
      call RegPackBounds(Buf, 2, lbound(InData%FAST_RP), ubound(InData%FAST_RP))
      call RegPack(Buf, InData%FAST_RP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! INCR
   call RegPack(Buf, InData%INCR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RSDF
   call RegPack(Buf, InData%RSDF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FORC0
   call RegPack(Buf, InData%FORC0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EMAS0
   call RegPack(Buf, InData%EMAS0)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackOtherState'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! GLU0
   if (allocated(OutData%GLU0)) deallocate(OutData%GLU0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLU0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLU0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLU0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GLDDU
   if (allocated(OutData%GLDDU)) deallocate(OutData%GLDDU)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLDDU(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLDDU.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLDDU)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BottomTouch
   call RegUnpack(Buf, OutData%BottomTouch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GFORC0
   if (allocated(OutData%GFORC0)) deallocate(OutData%GFORC0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GFORC0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GFORC0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GFORC0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GMASS0
   if (allocated(OutData%GMASS0)) deallocate(OutData%GMASS0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GMASS0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GMASS0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GMASS0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FAST_FPA
   if (allocated(OutData%FAST_FPA)) deallocate(OutData%FAST_FPA)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FAST_FPA(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FAST_FPA.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FAST_FPA)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FAST_RP
   if (allocated(OutData%FAST_RP)) deallocate(OutData%FAST_RP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FAST_RP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FAST_RP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FAST_RP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! INCR
   call RegUnpack(Buf, OutData%INCR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RSDF
   call RegUnpack(Buf, OutData%RSDF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FORC0
   call RegUnpack(Buf, OutData%FORC0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EMAS0
   call RegUnpack(Buf, OutData%EMAS0)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FEAM_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(FEAM_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%GLF)) THEN
  i1_l = LBOUND(SrcMiscData%GLF,1)
  i1_u = UBOUND(SrcMiscData%GLF,1)
  i2_l = LBOUND(SrcMiscData%GLF,2)
  i2_u = UBOUND(SrcMiscData%GLF,2)
  IF (.NOT. ALLOCATED(DstMiscData%GLF)) THEN 
    ALLOCATE(DstMiscData%GLF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%GLF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%GLF = SrcMiscData%GLF
ENDIF
IF (ALLOCATED(SrcMiscData%GLK)) THEN
  i1_l = LBOUND(SrcMiscData%GLK,1)
  i1_u = UBOUND(SrcMiscData%GLK,1)
  i2_l = LBOUND(SrcMiscData%GLK,2)
  i2_u = UBOUND(SrcMiscData%GLK,2)
  i3_l = LBOUND(SrcMiscData%GLK,3)
  i3_u = UBOUND(SrcMiscData%GLK,3)
  IF (.NOT. ALLOCATED(DstMiscData%GLK)) THEN 
    ALLOCATE(DstMiscData%GLK(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%GLK.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%GLK = SrcMiscData%GLK
ENDIF
    DstMiscData%EMASS = SrcMiscData%EMASS
    DstMiscData%ESTIF = SrcMiscData%ESTIF
IF (ALLOCATED(SrcMiscData%FAST_FP)) THEN
  i1_l = LBOUND(SrcMiscData%FAST_FP,1)
  i1_u = UBOUND(SrcMiscData%FAST_FP,1)
  i2_l = LBOUND(SrcMiscData%FAST_FP,2)
  i2_u = UBOUND(SrcMiscData%FAST_FP,2)
  IF (.NOT. ALLOCATED(DstMiscData%FAST_FP)) THEN 
    ALLOCATE(DstMiscData%FAST_FP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FAST_FP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FAST_FP = SrcMiscData%FAST_FP
ENDIF
    DstMiscData%FORCE = SrcMiscData%FORCE
    DstMiscData%FP = SrcMiscData%FP
    DstMiscData%U = SrcMiscData%U
    DstMiscData%U0 = SrcMiscData%U0
    DstMiscData%DU = SrcMiscData%DU
    DstMiscData%DDU = SrcMiscData%DDU
    DstMiscData%R = SrcMiscData%R
    DstMiscData%RP = SrcMiscData%RP
    DstMiscData%RHSR = SrcMiscData%RHSR
    DstMiscData%SLIN = SrcMiscData%SLIN
    DstMiscData%STIFR = SrcMiscData%STIFR
IF (ALLOCATED(SrcMiscData%FAIR_ANG)) THEN
  i1_l = LBOUND(SrcMiscData%FAIR_ANG,1)
  i1_u = UBOUND(SrcMiscData%FAIR_ANG,1)
  i2_l = LBOUND(SrcMiscData%FAIR_ANG,2)
  i2_u = UBOUND(SrcMiscData%FAIR_ANG,2)
  IF (.NOT. ALLOCATED(DstMiscData%FAIR_ANG)) THEN 
    ALLOCATE(DstMiscData%FAIR_ANG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FAIR_ANG.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FAIR_ANG = SrcMiscData%FAIR_ANG
ENDIF
IF (ALLOCATED(SrcMiscData%FAIR_T)) THEN
  i1_l = LBOUND(SrcMiscData%FAIR_T,1)
  i1_u = UBOUND(SrcMiscData%FAIR_T,1)
  IF (.NOT. ALLOCATED(DstMiscData%FAIR_T)) THEN 
    ALLOCATE(DstMiscData%FAIR_T(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FAIR_T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FAIR_T = SrcMiscData%FAIR_T
ENDIF
IF (ALLOCATED(SrcMiscData%ANCH_ANG)) THEN
  i1_l = LBOUND(SrcMiscData%ANCH_ANG,1)
  i1_u = UBOUND(SrcMiscData%ANCH_ANG,1)
  i2_l = LBOUND(SrcMiscData%ANCH_ANG,2)
  i2_u = UBOUND(SrcMiscData%ANCH_ANG,2)
  IF (.NOT. ALLOCATED(DstMiscData%ANCH_ANG)) THEN 
    ALLOCATE(DstMiscData%ANCH_ANG(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ANCH_ANG.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%ANCH_ANG = SrcMiscData%ANCH_ANG
ENDIF
IF (ALLOCATED(SrcMiscData%ANCH_T)) THEN
  i1_l = LBOUND(SrcMiscData%ANCH_T,1)
  i1_u = UBOUND(SrcMiscData%ANCH_T,1)
  IF (.NOT. ALLOCATED(DstMiscData%ANCH_T)) THEN 
    ALLOCATE(DstMiscData%ANCH_T(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ANCH_T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%ANCH_T = SrcMiscData%ANCH_T
ENDIF
IF (ALLOCATED(SrcMiscData%Line_Coordinate)) THEN
  i1_l = LBOUND(SrcMiscData%Line_Coordinate,1)
  i1_u = UBOUND(SrcMiscData%Line_Coordinate,1)
  i2_l = LBOUND(SrcMiscData%Line_Coordinate,2)
  i2_u = UBOUND(SrcMiscData%Line_Coordinate,2)
  i3_l = LBOUND(SrcMiscData%Line_Coordinate,3)
  i3_u = UBOUND(SrcMiscData%Line_Coordinate,3)
  IF (.NOT. ALLOCATED(DstMiscData%Line_Coordinate)) THEN 
    ALLOCATE(DstMiscData%Line_Coordinate(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Line_Coordinate.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Line_Coordinate = SrcMiscData%Line_Coordinate
ENDIF
IF (ALLOCATED(SrcMiscData%Line_Tangent)) THEN
  i1_l = LBOUND(SrcMiscData%Line_Tangent,1)
  i1_u = UBOUND(SrcMiscData%Line_Tangent,1)
  i2_l = LBOUND(SrcMiscData%Line_Tangent,2)
  i2_u = UBOUND(SrcMiscData%Line_Tangent,2)
  i3_l = LBOUND(SrcMiscData%Line_Tangent,3)
  i3_u = UBOUND(SrcMiscData%Line_Tangent,3)
  IF (.NOT. ALLOCATED(DstMiscData%Line_Tangent)) THEN 
    ALLOCATE(DstMiscData%Line_Tangent(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Line_Tangent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Line_Tangent = SrcMiscData%Line_Tangent
ENDIF
IF (ALLOCATED(SrcMiscData%F_Lines)) THEN
  i1_l = LBOUND(SrcMiscData%F_Lines,1)
  i1_u = UBOUND(SrcMiscData%F_Lines,1)
  i2_l = LBOUND(SrcMiscData%F_Lines,2)
  i2_u = UBOUND(SrcMiscData%F_Lines,2)
  IF (.NOT. ALLOCATED(DstMiscData%F_Lines)) THEN 
    ALLOCATE(DstMiscData%F_Lines(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_Lines.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_Lines = SrcMiscData%F_Lines
ENDIF
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
 END SUBROUTINE FEAM_CopyMisc

 SUBROUTINE FEAM_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(FEAM_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%GLF)) THEN
  DEALLOCATE(MiscData%GLF)
ENDIF
IF (ALLOCATED(MiscData%GLK)) THEN
  DEALLOCATE(MiscData%GLK)
ENDIF
IF (ALLOCATED(MiscData%FAST_FP)) THEN
  DEALLOCATE(MiscData%FAST_FP)
ENDIF
IF (ALLOCATED(MiscData%FAIR_ANG)) THEN
  DEALLOCATE(MiscData%FAIR_ANG)
ENDIF
IF (ALLOCATED(MiscData%FAIR_T)) THEN
  DEALLOCATE(MiscData%FAIR_T)
ENDIF
IF (ALLOCATED(MiscData%ANCH_ANG)) THEN
  DEALLOCATE(MiscData%ANCH_ANG)
ENDIF
IF (ALLOCATED(MiscData%ANCH_T)) THEN
  DEALLOCATE(MiscData%ANCH_T)
ENDIF
IF (ALLOCATED(MiscData%Line_Coordinate)) THEN
  DEALLOCATE(MiscData%Line_Coordinate)
ENDIF
IF (ALLOCATED(MiscData%Line_Tangent)) THEN
  DEALLOCATE(MiscData%Line_Tangent)
ENDIF
IF (ALLOCATED(MiscData%F_Lines)) THEN
  DEALLOCATE(MiscData%F_Lines)
ENDIF
 END SUBROUTINE FEAM_DestroyMisc


subroutine FEAM_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! GLF
   call RegPack(Buf, allocated(InData%GLF))
   if (allocated(InData%GLF)) then
      call RegPackBounds(Buf, 2, lbound(InData%GLF), ubound(InData%GLF))
      call RegPack(Buf, InData%GLF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GLK
   call RegPack(Buf, allocated(InData%GLK))
   if (allocated(InData%GLK)) then
      call RegPackBounds(Buf, 3, lbound(InData%GLK), ubound(InData%GLK))
      call RegPack(Buf, InData%GLK)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! EMASS
   call RegPack(Buf, InData%EMASS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ESTIF
   call RegPack(Buf, InData%ESTIF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAST_FP
   call RegPack(Buf, allocated(InData%FAST_FP))
   if (allocated(InData%FAST_FP)) then
      call RegPackBounds(Buf, 2, lbound(InData%FAST_FP), ubound(InData%FAST_FP))
      call RegPack(Buf, InData%FAST_FP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FORCE
   call RegPack(Buf, InData%FORCE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FP
   call RegPack(Buf, InData%FP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegPack(Buf, InData%U)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U0
   call RegPack(Buf, InData%U0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DU
   call RegPack(Buf, InData%DU)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DDU
   call RegPack(Buf, InData%DDU)
   if (RegCheckErr(Buf, RoutineName)) return
   ! R
   call RegPack(Buf, InData%R)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RP
   call RegPack(Buf, InData%RP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RHSR
   call RegPack(Buf, InData%RHSR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SLIN
   call RegPack(Buf, InData%SLIN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! STIFR
   call RegPack(Buf, InData%STIFR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAIR_ANG
   call RegPack(Buf, allocated(InData%FAIR_ANG))
   if (allocated(InData%FAIR_ANG)) then
      call RegPackBounds(Buf, 2, lbound(InData%FAIR_ANG), ubound(InData%FAIR_ANG))
      call RegPack(Buf, InData%FAIR_ANG)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAIR_T
   call RegPack(Buf, allocated(InData%FAIR_T))
   if (allocated(InData%FAIR_T)) then
      call RegPackBounds(Buf, 1, lbound(InData%FAIR_T), ubound(InData%FAIR_T))
      call RegPack(Buf, InData%FAIR_T)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ANCH_ANG
   call RegPack(Buf, allocated(InData%ANCH_ANG))
   if (allocated(InData%ANCH_ANG)) then
      call RegPackBounds(Buf, 2, lbound(InData%ANCH_ANG), ubound(InData%ANCH_ANG))
      call RegPack(Buf, InData%ANCH_ANG)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ANCH_T
   call RegPack(Buf, allocated(InData%ANCH_T))
   if (allocated(InData%ANCH_T)) then
      call RegPackBounds(Buf, 1, lbound(InData%ANCH_T), ubound(InData%ANCH_T))
      call RegPack(Buf, InData%ANCH_T)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Line_Coordinate
   call RegPack(Buf, allocated(InData%Line_Coordinate))
   if (allocated(InData%Line_Coordinate)) then
      call RegPackBounds(Buf, 3, lbound(InData%Line_Coordinate), ubound(InData%Line_Coordinate))
      call RegPack(Buf, InData%Line_Coordinate)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Line_Tangent
   call RegPack(Buf, allocated(InData%Line_Tangent))
   if (allocated(InData%Line_Tangent)) then
      call RegPackBounds(Buf, 3, lbound(InData%Line_Tangent), ubound(InData%Line_Tangent))
      call RegPack(Buf, InData%Line_Tangent)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Lines
   call RegPack(Buf, allocated(InData%F_Lines))
   if (allocated(InData%F_Lines)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_Lines), ubound(InData%F_Lines))
      call RegPack(Buf, InData%F_Lines)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastIndWave
   call RegPack(Buf, InData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackMisc'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! GLF
   if (allocated(OutData%GLF)) deallocate(OutData%GLF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLF(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GLK
   if (allocated(OutData%GLK)) deallocate(OutData%GLK)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLK(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLK.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLK)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! EMASS
   call RegUnpack(Buf, OutData%EMASS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ESTIF
   call RegUnpack(Buf, OutData%ESTIF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAST_FP
   if (allocated(OutData%FAST_FP)) deallocate(OutData%FAST_FP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FAST_FP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FAST_FP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FAST_FP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FORCE
   call RegUnpack(Buf, OutData%FORCE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FP
   call RegUnpack(Buf, OutData%FP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegUnpack(Buf, OutData%U)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U0
   call RegUnpack(Buf, OutData%U0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DU
   call RegUnpack(Buf, OutData%DU)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DDU
   call RegUnpack(Buf, OutData%DDU)
   if (RegCheckErr(Buf, RoutineName)) return
   ! R
   call RegUnpack(Buf, OutData%R)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RP
   call RegUnpack(Buf, OutData%RP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RHSR
   call RegUnpack(Buf, OutData%RHSR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SLIN
   call RegUnpack(Buf, OutData%SLIN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! STIFR
   call RegUnpack(Buf, OutData%STIFR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FAIR_ANG
   if (allocated(OutData%FAIR_ANG)) deallocate(OutData%FAIR_ANG)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FAIR_ANG(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FAIR_ANG.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FAIR_ANG)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FAIR_T
   if (allocated(OutData%FAIR_T)) deallocate(OutData%FAIR_T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FAIR_T(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FAIR_T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FAIR_T)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ANCH_ANG
   if (allocated(OutData%ANCH_ANG)) deallocate(OutData%ANCH_ANG)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ANCH_ANG(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANCH_ANG.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ANCH_ANG)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ANCH_T
   if (allocated(OutData%ANCH_T)) deallocate(OutData%ANCH_T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ANCH_T(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ANCH_T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ANCH_T)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Line_Coordinate
   if (allocated(OutData%Line_Coordinate)) deallocate(OutData%Line_Coordinate)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Line_Coordinate(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Line_Coordinate.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Line_Coordinate)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Line_Tangent
   if (allocated(OutData%Line_Tangent)) deallocate(OutData%Line_Tangent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Line_Tangent(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Line_Tangent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Line_Tangent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_Lines
   if (allocated(OutData%F_Lines)) deallocate(OutData%F_Lines)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_Lines(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_Lines.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_Lines)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LastIndWave
   call RegUnpack(Buf, OutData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE FEAM_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(FEAM_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%GRAV = SrcParamData%GRAV
    DstParamData%Eps = SrcParamData%Eps
    DstParamData%Gravity = SrcParamData%Gravity
    DstParamData%WtrDens = SrcParamData%WtrDens
    DstParamData%MaxIter = SrcParamData%MaxIter
    DstParamData%NHBD = SrcParamData%NHBD
    DstParamData%NDIM = SrcParamData%NDIM
IF (ALLOCATED(SrcParamData%NEQ)) THEN
  i1_l = LBOUND(SrcParamData%NEQ,1)
  i1_u = UBOUND(SrcParamData%NEQ,1)
  IF (.NOT. ALLOCATED(DstParamData%NEQ)) THEN 
    ALLOCATE(DstParamData%NEQ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NEQ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%NEQ = SrcParamData%NEQ
ENDIF
    DstParamData%NBAND = SrcParamData%NBAND
    DstParamData%NumLines = SrcParamData%NumLines
    DstParamData%NumElems = SrcParamData%NumElems
    DstParamData%NumNodes = SrcParamData%NumNodes
IF (ALLOCATED(SrcParamData%GSL)) THEN
  i1_l = LBOUND(SrcParamData%GSL,1)
  i1_u = UBOUND(SrcParamData%GSL,1)
  i2_l = LBOUND(SrcParamData%GSL,2)
  i2_u = UBOUND(SrcParamData%GSL,2)
  i3_l = LBOUND(SrcParamData%GSL,3)
  i3_u = UBOUND(SrcParamData%GSL,3)
  IF (.NOT. ALLOCATED(DstParamData%GSL)) THEN 
    ALLOCATE(DstParamData%GSL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GSL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%GSL = SrcParamData%GSL
ENDIF
IF (ALLOCATED(SrcParamData%GP)) THEN
  i1_l = LBOUND(SrcParamData%GP,1)
  i1_u = UBOUND(SrcParamData%GP,1)
  i2_l = LBOUND(SrcParamData%GP,2)
  i2_u = UBOUND(SrcParamData%GP,2)
  IF (.NOT. ALLOCATED(DstParamData%GP)) THEN 
    ALLOCATE(DstParamData%GP(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GP.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%GP = SrcParamData%GP
ENDIF
IF (ALLOCATED(SrcParamData%Elength)) THEN
  i1_l = LBOUND(SrcParamData%Elength,1)
  i1_u = UBOUND(SrcParamData%Elength,1)
  IF (.NOT. ALLOCATED(DstParamData%Elength)) THEN 
    ALLOCATE(DstParamData%Elength(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Elength.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Elength = SrcParamData%Elength
ENDIF
IF (ALLOCATED(SrcParamData%BottmElev)) THEN
  i1_l = LBOUND(SrcParamData%BottmElev,1)
  i1_u = UBOUND(SrcParamData%BottmElev,1)
  IF (.NOT. ALLOCATED(DstParamData%BottmElev)) THEN 
    ALLOCATE(DstParamData%BottmElev(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BottmElev.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%BottmElev = SrcParamData%BottmElev
ENDIF
IF (ALLOCATED(SrcParamData%BottmStiff)) THEN
  i1_l = LBOUND(SrcParamData%BottmStiff,1)
  i1_u = UBOUND(SrcParamData%BottmStiff,1)
  IF (.NOT. ALLOCATED(DstParamData%BottmStiff)) THEN 
    ALLOCATE(DstParamData%BottmStiff(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%BottmStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%BottmStiff = SrcParamData%BottmStiff
ENDIF
IF (ALLOCATED(SrcParamData%LMassDen)) THEN
  i1_l = LBOUND(SrcParamData%LMassDen,1)
  i1_u = UBOUND(SrcParamData%LMassDen,1)
  IF (.NOT. ALLOCATED(DstParamData%LMassDen)) THEN 
    ALLOCATE(DstParamData%LMassDen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LMassDen.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%LMassDen = SrcParamData%LMassDen
ENDIF
IF (ALLOCATED(SrcParamData%LDMassDen)) THEN
  i1_l = LBOUND(SrcParamData%LDMassDen,1)
  i1_u = UBOUND(SrcParamData%LDMassDen,1)
  IF (.NOT. ALLOCATED(DstParamData%LDMassDen)) THEN 
    ALLOCATE(DstParamData%LDMassDen(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LDMassDen.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%LDMassDen = SrcParamData%LDMassDen
ENDIF
IF (ALLOCATED(SrcParamData%LEAStiff)) THEN
  i1_l = LBOUND(SrcParamData%LEAStiff,1)
  i1_u = UBOUND(SrcParamData%LEAStiff,1)
  IF (.NOT. ALLOCATED(DstParamData%LEAStiff)) THEN 
    ALLOCATE(DstParamData%LEAStiff(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LEAStiff.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%LEAStiff = SrcParamData%LEAStiff
ENDIF
IF (ALLOCATED(SrcParamData%LineCI)) THEN
  i1_l = LBOUND(SrcParamData%LineCI,1)
  i1_u = UBOUND(SrcParamData%LineCI,1)
  IF (.NOT. ALLOCATED(DstParamData%LineCI)) THEN 
    ALLOCATE(DstParamData%LineCI(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LineCI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%LineCI = SrcParamData%LineCI
ENDIF
IF (ALLOCATED(SrcParamData%LineCD)) THEN
  i1_l = LBOUND(SrcParamData%LineCD,1)
  i1_u = UBOUND(SrcParamData%LineCD,1)
  IF (.NOT. ALLOCATED(DstParamData%LineCD)) THEN 
    ALLOCATE(DstParamData%LineCD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%LineCD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%LineCD = SrcParamData%LineCD
ENDIF
IF (ALLOCATED(SrcParamData%Bvp)) THEN
  i1_l = LBOUND(SrcParamData%Bvp,1)
  i1_u = UBOUND(SrcParamData%Bvp,1)
  i2_l = LBOUND(SrcParamData%Bvp,2)
  i2_u = UBOUND(SrcParamData%Bvp,2)
  IF (.NOT. ALLOCATED(DstParamData%Bvp)) THEN 
    ALLOCATE(DstParamData%Bvp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Bvp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Bvp = SrcParamData%Bvp
ENDIF
IF (ALLOCATED(SrcParamData%WaveAcc0)) THEN
  i1_l = LBOUND(SrcParamData%WaveAcc0,1)
  i1_u = UBOUND(SrcParamData%WaveAcc0,1)
  i2_l = LBOUND(SrcParamData%WaveAcc0,2)
  i2_u = UBOUND(SrcParamData%WaveAcc0,2)
  i3_l = LBOUND(SrcParamData%WaveAcc0,3)
  i3_u = UBOUND(SrcParamData%WaveAcc0,3)
  IF (.NOT. ALLOCATED(DstParamData%WaveAcc0)) THEN 
    ALLOCATE(DstParamData%WaveAcc0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveAcc0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveAcc0 = SrcParamData%WaveAcc0
ENDIF
IF (ALLOCATED(SrcParamData%WaveTime)) THEN
  i1_l = LBOUND(SrcParamData%WaveTime,1)
  i1_u = UBOUND(SrcParamData%WaveTime,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveTime)) THEN 
    ALLOCATE(DstParamData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveTime.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveTime = SrcParamData%WaveTime
ENDIF
IF (ALLOCATED(SrcParamData%WaveVel0)) THEN
  i1_l = LBOUND(SrcParamData%WaveVel0,1)
  i1_u = UBOUND(SrcParamData%WaveVel0,1)
  i2_l = LBOUND(SrcParamData%WaveVel0,2)
  i2_u = UBOUND(SrcParamData%WaveVel0,2)
  i3_l = LBOUND(SrcParamData%WaveVel0,3)
  i3_u = UBOUND(SrcParamData%WaveVel0,3)
  IF (.NOT. ALLOCATED(DstParamData%WaveVel0)) THEN 
    ALLOCATE(DstParamData%WaveVel0(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveVel0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveVel0 = SrcParamData%WaveVel0
ENDIF
    DstParamData%NStepWave = SrcParamData%NStepWave
    DstParamData%SHAP = SrcParamData%SHAP
    DstParamData%SHAPS = SrcParamData%SHAPS
    DstParamData%GAUSSW = SrcParamData%GAUSSW
    DstParamData%NGAUSS = SrcParamData%NGAUSS
    DstParamData%SHAPT = SrcParamData%SHAPT
    DstParamData%SHAPTS = SrcParamData%SHAPTS
    DstParamData%NTRAP = SrcParamData%NTRAP
    DstParamData%SBEND = SrcParamData%SBEND
    DstParamData%STEN = SrcParamData%STEN
    DstParamData%RMASS = SrcParamData%RMASS
    DstParamData%RADDM = SrcParamData%RADDM
    DstParamData%PMPN = SrcParamData%PMPN
    DstParamData%AM = SrcParamData%AM
    DstParamData%PM = SrcParamData%PM
    DstParamData%IDOF = SrcParamData%IDOF
    DstParamData%JDOF = SrcParamData%JDOF
    DstParamData%PPA = SrcParamData%PPA
    DstParamData%PtfmRefzt = SrcParamData%PtfmRefzt
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%Delim = SrcParamData%Delim
IF (ALLOCATED(SrcParamData%GLUZR)) THEN
  i1_l = LBOUND(SrcParamData%GLUZR,1)
  i1_u = UBOUND(SrcParamData%GLUZR,1)
  i2_l = LBOUND(SrcParamData%GLUZR,2)
  i2_u = UBOUND(SrcParamData%GLUZR,2)
  i3_l = LBOUND(SrcParamData%GLUZR,3)
  i3_u = UBOUND(SrcParamData%GLUZR,3)
  IF (.NOT. ALLOCATED(DstParamData%GLUZR)) THEN 
    ALLOCATE(DstParamData%GLUZR(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GLUZR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%GLUZR = SrcParamData%GLUZR
ENDIF
IF (ALLOCATED(SrcParamData%GTZER)) THEN
  i1_l = LBOUND(SrcParamData%GTZER,1)
  i1_u = UBOUND(SrcParamData%GTZER,1)
  i2_l = LBOUND(SrcParamData%GTZER,2)
  i2_u = UBOUND(SrcParamData%GTZER,2)
  IF (.NOT. ALLOCATED(DstParamData%GTZER)) THEN 
    ALLOCATE(DstParamData%GTZER(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%GTZER.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%GTZER = SrcParamData%GTZER
ENDIF
 END SUBROUTINE FEAM_CopyParam

 SUBROUTINE FEAM_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FEAM_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%NEQ)) THEN
  DEALLOCATE(ParamData%NEQ)
ENDIF
IF (ALLOCATED(ParamData%GSL)) THEN
  DEALLOCATE(ParamData%GSL)
ENDIF
IF (ALLOCATED(ParamData%GP)) THEN
  DEALLOCATE(ParamData%GP)
ENDIF
IF (ALLOCATED(ParamData%Elength)) THEN
  DEALLOCATE(ParamData%Elength)
ENDIF
IF (ALLOCATED(ParamData%BottmElev)) THEN
  DEALLOCATE(ParamData%BottmElev)
ENDIF
IF (ALLOCATED(ParamData%BottmStiff)) THEN
  DEALLOCATE(ParamData%BottmStiff)
ENDIF
IF (ALLOCATED(ParamData%LMassDen)) THEN
  DEALLOCATE(ParamData%LMassDen)
ENDIF
IF (ALLOCATED(ParamData%LDMassDen)) THEN
  DEALLOCATE(ParamData%LDMassDen)
ENDIF
IF (ALLOCATED(ParamData%LEAStiff)) THEN
  DEALLOCATE(ParamData%LEAStiff)
ENDIF
IF (ALLOCATED(ParamData%LineCI)) THEN
  DEALLOCATE(ParamData%LineCI)
ENDIF
IF (ALLOCATED(ParamData%LineCD)) THEN
  DEALLOCATE(ParamData%LineCD)
ENDIF
IF (ALLOCATED(ParamData%Bvp)) THEN
  DEALLOCATE(ParamData%Bvp)
ENDIF
IF (ALLOCATED(ParamData%WaveAcc0)) THEN
  DEALLOCATE(ParamData%WaveAcc0)
ENDIF
IF (ALLOCATED(ParamData%WaveTime)) THEN
  DEALLOCATE(ParamData%WaveTime)
ENDIF
IF (ALLOCATED(ParamData%WaveVel0)) THEN
  DEALLOCATE(ParamData%WaveVel0)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( ParamData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
IF (ALLOCATED(ParamData%GLUZR)) THEN
  DEALLOCATE(ParamData%GLUZR)
ENDIF
IF (ALLOCATED(ParamData%GTZER)) THEN
  DEALLOCATE(ParamData%GTZER)
ENDIF
 END SUBROUTINE FEAM_DestroyParam


subroutine FEAM_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackParam'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GRAV
   call RegPack(Buf, InData%GRAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Eps
   call RegPack(Buf, InData%Eps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MaxIter
   call RegPack(Buf, InData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NHBD
   call RegPack(Buf, InData%NHBD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NDIM
   call RegPack(Buf, InData%NDIM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NEQ
   call RegPack(Buf, allocated(InData%NEQ))
   if (allocated(InData%NEQ)) then
      call RegPackBounds(Buf, 1, lbound(InData%NEQ), ubound(InData%NEQ))
      call RegPack(Buf, InData%NEQ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBAND
   call RegPack(Buf, InData%NBAND)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumLines
   call RegPack(Buf, InData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumElems
   call RegPack(Buf, InData%NumElems)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumNodes
   call RegPack(Buf, InData%NumNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GSL
   call RegPack(Buf, allocated(InData%GSL))
   if (allocated(InData%GSL)) then
      call RegPackBounds(Buf, 3, lbound(InData%GSL), ubound(InData%GSL))
      call RegPack(Buf, InData%GSL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GP
   call RegPack(Buf, allocated(InData%GP))
   if (allocated(InData%GP)) then
      call RegPackBounds(Buf, 2, lbound(InData%GP), ubound(InData%GP))
      call RegPack(Buf, InData%GP)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Elength
   call RegPack(Buf, allocated(InData%Elength))
   if (allocated(InData%Elength)) then
      call RegPackBounds(Buf, 1, lbound(InData%Elength), ubound(InData%Elength))
      call RegPack(Buf, InData%Elength)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BottmElev
   call RegPack(Buf, allocated(InData%BottmElev))
   if (allocated(InData%BottmElev)) then
      call RegPackBounds(Buf, 1, lbound(InData%BottmElev), ubound(InData%BottmElev))
      call RegPack(Buf, InData%BottmElev)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BottmStiff
   call RegPack(Buf, allocated(InData%BottmStiff))
   if (allocated(InData%BottmStiff)) then
      call RegPackBounds(Buf, 1, lbound(InData%BottmStiff), ubound(InData%BottmStiff))
      call RegPack(Buf, InData%BottmStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LMassDen
   call RegPack(Buf, allocated(InData%LMassDen))
   if (allocated(InData%LMassDen)) then
      call RegPackBounds(Buf, 1, lbound(InData%LMassDen), ubound(InData%LMassDen))
      call RegPack(Buf, InData%LMassDen)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LDMassDen
   call RegPack(Buf, allocated(InData%LDMassDen))
   if (allocated(InData%LDMassDen)) then
      call RegPackBounds(Buf, 1, lbound(InData%LDMassDen), ubound(InData%LDMassDen))
      call RegPack(Buf, InData%LDMassDen)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LEAStiff
   call RegPack(Buf, allocated(InData%LEAStiff))
   if (allocated(InData%LEAStiff)) then
      call RegPackBounds(Buf, 1, lbound(InData%LEAStiff), ubound(InData%LEAStiff))
      call RegPack(Buf, InData%LEAStiff)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineCI
   call RegPack(Buf, allocated(InData%LineCI))
   if (allocated(InData%LineCI)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineCI), ubound(InData%LineCI))
      call RegPack(Buf, InData%LineCI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineCD
   call RegPack(Buf, allocated(InData%LineCD))
   if (allocated(InData%LineCD)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineCD), ubound(InData%LineCD))
      call RegPack(Buf, InData%LineCD)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Bvp
   call RegPack(Buf, allocated(InData%Bvp))
   if (allocated(InData%Bvp)) then
      call RegPackBounds(Buf, 2, lbound(InData%Bvp), ubound(InData%Bvp))
      call RegPack(Buf, InData%Bvp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAcc0
   call RegPack(Buf, allocated(InData%WaveAcc0))
   if (allocated(InData%WaveAcc0)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveAcc0), ubound(InData%WaveAcc0))
      call RegPack(Buf, InData%WaveAcc0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, allocated(InData%WaveTime))
   if (allocated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPack(Buf, InData%WaveTime)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveVel0
   call RegPack(Buf, allocated(InData%WaveVel0))
   if (allocated(InData%WaveVel0)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveVel0), ubound(InData%WaveVel0))
      call RegPack(Buf, InData%WaveVel0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAP
   call RegPack(Buf, InData%SHAP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAPS
   call RegPack(Buf, InData%SHAPS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GAUSSW
   call RegPack(Buf, InData%GAUSSW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NGAUSS
   call RegPack(Buf, InData%NGAUSS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAPT
   call RegPack(Buf, InData%SHAPT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAPTS
   call RegPack(Buf, InData%SHAPTS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTRAP
   call RegPack(Buf, InData%NTRAP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SBEND
   call RegPack(Buf, InData%SBEND)
   if (RegCheckErr(Buf, RoutineName)) return
   ! STEN
   call RegPack(Buf, InData%STEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RMASS
   call RegPack(Buf, InData%RMASS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RADDM
   call RegPack(Buf, InData%RADDM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PMPN
   call RegPack(Buf, InData%PMPN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AM
   call RegPack(Buf, InData%AM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PM
   call RegPack(Buf, InData%PM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDOF
   call RegPack(Buf, InData%IDOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! JDOF
   call RegPack(Buf, InData%JDOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PPA
   call RegPack(Buf, InData%PPA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefzt
   call RegPack(Buf, InData%PtfmRefzt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GLUZR
   call RegPack(Buf, allocated(InData%GLUZR))
   if (allocated(InData%GLUZR)) then
      call RegPackBounds(Buf, 3, lbound(InData%GLUZR), ubound(InData%GLUZR))
      call RegPack(Buf, InData%GLUZR)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GTZER
   call RegPack(Buf, allocated(InData%GTZER))
   if (allocated(InData%GTZER)) then
      call RegPackBounds(Buf, 2, lbound(InData%GTZER), ubound(InData%GTZER))
      call RegPack(Buf, InData%GTZER)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackParam'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GRAV
   call RegUnpack(Buf, OutData%GRAV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Eps
   call RegUnpack(Buf, OutData%Eps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MaxIter
   call RegUnpack(Buf, OutData%MaxIter)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NHBD
   call RegUnpack(Buf, OutData%NHBD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NDIM
   call RegUnpack(Buf, OutData%NDIM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NEQ
   if (allocated(OutData%NEQ)) deallocate(OutData%NEQ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NEQ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NEQ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NEQ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NBAND
   call RegUnpack(Buf, OutData%NBAND)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumLines
   call RegUnpack(Buf, OutData%NumLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumElems
   call RegUnpack(Buf, OutData%NumElems)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumNodes
   call RegUnpack(Buf, OutData%NumNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GSL
   if (allocated(OutData%GSL)) deallocate(OutData%GSL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GSL(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GSL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GSL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GP
   if (allocated(OutData%GP)) deallocate(OutData%GP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GP(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GP)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Elength
   if (allocated(OutData%Elength)) deallocate(OutData%Elength)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Elength(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Elength.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Elength)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BottmElev
   if (allocated(OutData%BottmElev)) deallocate(OutData%BottmElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BottmElev(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BottmElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BottmElev)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BottmStiff
   if (allocated(OutData%BottmStiff)) deallocate(OutData%BottmStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BottmStiff(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BottmStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BottmStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LMassDen
   if (allocated(OutData%LMassDen)) deallocate(OutData%LMassDen)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LMassDen(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LMassDen.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LMassDen)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LDMassDen
   if (allocated(OutData%LDMassDen)) deallocate(OutData%LDMassDen)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LDMassDen(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LDMassDen.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LDMassDen)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LEAStiff
   if (allocated(OutData%LEAStiff)) deallocate(OutData%LEAStiff)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LEAStiff(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LEAStiff.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LEAStiff)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LineCI
   if (allocated(OutData%LineCI)) deallocate(OutData%LineCI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineCI(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineCI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineCI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LineCD
   if (allocated(OutData%LineCD)) deallocate(OutData%LineCD)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineCD(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineCD.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineCD)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Bvp
   if (allocated(OutData%Bvp)) deallocate(OutData%Bvp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Bvp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bvp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Bvp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveAcc0
   if (allocated(OutData%WaveAcc0)) deallocate(OutData%WaveAcc0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveAcc0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveAcc0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveTime
   if (allocated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveTime)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveVel0
   if (allocated(OutData%WaveVel0)) deallocate(OutData%WaveVel0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveVel0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveVel0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAP
   call RegUnpack(Buf, OutData%SHAP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAPS
   call RegUnpack(Buf, OutData%SHAPS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GAUSSW
   call RegUnpack(Buf, OutData%GAUSSW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NGAUSS
   call RegUnpack(Buf, OutData%NGAUSS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAPT
   call RegUnpack(Buf, OutData%SHAPT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SHAPTS
   call RegUnpack(Buf, OutData%SHAPTS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTRAP
   call RegUnpack(Buf, OutData%NTRAP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SBEND
   call RegUnpack(Buf, OutData%SBEND)
   if (RegCheckErr(Buf, RoutineName)) return
   ! STEN
   call RegUnpack(Buf, OutData%STEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RMASS
   call RegUnpack(Buf, OutData%RMASS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RADDM
   call RegUnpack(Buf, OutData%RADDM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PMPN
   call RegUnpack(Buf, OutData%PMPN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AM
   call RegUnpack(Buf, OutData%AM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PM
   call RegUnpack(Buf, OutData%PM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDOF
   call RegUnpack(Buf, OutData%IDOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! JDOF
   call RegUnpack(Buf, OutData%JDOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PPA
   call RegUnpack(Buf, OutData%PPA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefzt
   call RegUnpack(Buf, OutData%PtfmRefzt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GLUZR
   if (allocated(OutData%GLUZR)) deallocate(OutData%GLUZR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GLUZR(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GLUZR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GLUZR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GTZER
   if (allocated(OutData%GTZER)) deallocate(OutData%GTZER)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%GTZER(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%GTZER.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%GTZER)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE FEAM_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(FEAM_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcInputData%HydroForceLineMesh, DstInputData%HydroForceLineMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInputData%PtFairleadDisplacement, DstInputData%PtFairleadDisplacement, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FEAM_CopyInput

 SUBROUTINE FEAM_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FEAM_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( InputData%HydroForceLineMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( InputData%PtFairleadDisplacement, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FEAM_DestroyInput


subroutine FEAM_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! HydroForceLineMesh
   call MeshPack(Buf, InData%HydroForceLineMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtFairleadDisplacement
   call MeshPack(Buf, InData%PtFairleadDisplacement) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! HydroForceLineMesh
   call MeshUnpack(Buf, OutData%HydroForceLineMesh) ! HydroForceLineMesh 
   ! PtFairleadDisplacement
   call MeshUnpack(Buf, OutData%PtFairleadDisplacement) ! PtFairleadDisplacement 
end subroutine
 SUBROUTINE FEAM_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FEAM_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(FEAM_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FEAM_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
      CALL MeshCopy( SrcOutputData%PtFairleadLoad, DstOutputData%PtFairleadLoad, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcOutputData%LineMeshPosition, DstOutputData%LineMeshPosition, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE FEAM_CopyOutput

 SUBROUTINE FEAM_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FEAM_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'FEAM_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
  CALL MeshDestroy( OutputData%PtFairleadLoad, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( OutputData%LineMeshPosition, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE FEAM_DestroyOutput


subroutine FEAM_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FEAM_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'FEAM_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtFairleadLoad
   call MeshPack(Buf, InData%PtFairleadLoad) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineMeshPosition
   call MeshPack(Buf, InData%LineMeshPosition) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine FEAM_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FEAM_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'FEAM_UnPackOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtFairleadLoad
   call MeshUnpack(Buf, OutData%PtFairleadLoad) ! PtFairleadLoad 
   ! LineMeshPosition
   call MeshUnpack(Buf, OutData%LineMeshPosition) ! LineMeshPosition 
end subroutine

 SUBROUTINE FEAM_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(FEAM_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FEAM_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL FEAM_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FEAM_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FEAM_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Input_ExtrapInterp


 SUBROUTINE FEAM_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(FEAM_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(FEAM_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(FEAM_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FEAM_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(u1%HydroForceLineMesh, u2%HydroForceLineMesh, tin, u_out%HydroForceLineMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(u1%PtFairleadDisplacement, u2%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE FEAM_Input_ExtrapInterp1


 SUBROUTINE FEAM_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(FEAM_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(FEAM_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(FEAM_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(FEAM_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FEAM_Input_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(u1%HydroForceLineMesh, u2%HydroForceLineMesh, u3%HydroForceLineMesh, tin, u_out%HydroForceLineMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(u1%PtFairleadDisplacement, u2%PtFairleadDisplacement, u3%PtFairleadDisplacement, tin, u_out%PtFairleadDisplacement, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE FEAM_Input_ExtrapInterp2


 SUBROUTINE FEAM_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FEAM_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL FEAM_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FEAM_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FEAM_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FEAM_Output_ExtrapInterp


 SUBROUTINE FEAM_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FEAM_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
      CALL MeshExtrapInterp1(y1%PtFairleadLoad, y2%PtFairleadLoad, tin, y_out%PtFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(y1%LineMeshPosition, y2%LineMeshPosition, tin, y_out%LineMeshPosition, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE FEAM_Output_ExtrapInterp1


 SUBROUTINE FEAM_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(FEAM_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FEAM_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
      CALL MeshExtrapInterp2(y1%PtFairleadLoad, y2%PtFairleadLoad, y3%PtFairleadLoad, tin, y_out%PtFairleadLoad, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(y1%LineMeshPosition, y2%LineMeshPosition, y3%LineMeshPosition, tin, y_out%LineMeshPosition, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE FEAM_Output_ExtrapInterp2

END MODULE FEAMooring_Types
!ENDOFREGISTRYGENERATEDFILE
