!STARTOFREGISTRYGENERATEDFILE 'SeaState_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! SeaState_Types
!.................................................................................................................................
! This file is part of SeaState.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in SeaState. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE SeaState_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE Current_Types
USE Waves_Types
USE Waves2_Types
USE SeaState_Interp_Types
USE SeaSt_WaveField_Types
USE NWTC_Library
IMPLICIT NONE
! =========  SeaSt_InputFile  =======
  TYPE, PUBLIC :: SeaSt_InputFile
    LOGICAL  :: EchoFlag      !< Echo the input file [-]
    REAL(ReKi)  :: MSL2SWL      !< Mean Sea Level to Still Water Level offset [m]
    REAL(ReKi)  :: X_HalfWidth      !< Half-width of the domain in the X direction [m]
    REAL(ReKi)  :: Y_HalfWidth      !< Half-width of the domain in the Y direction [m]
    REAL(ReKi)  :: Z_Depth      !< Depth of the domain the Z direction [m]
    INTEGER(IntKi)  :: NX      !< Number of nodes in half of the X-direction domain [-]
    INTEGER(IntKi)  :: NY      !< Number of nodes in half of the Y-direction domain [-]
    INTEGER(IntKi)  :: NZ      !< Number of nodes in half of the Z-direction domain [-]
    TYPE(Waves_InitInputType)  :: Waves      !< Initialization data for Waves module [-]
    TYPE(Waves2_InitInputType)  :: Waves2      !< Initialization data for Waves2 module [-]
    TYPE(Current_InitInputType)  :: Current      !< Initialization data for Current module [-]
    LOGICAL  :: Echo      !< Echo the input files to a file with the same name as the input but with a .echo extension [T/F] [-]
    INTEGER(IntKi)  :: NWaveElev      !< Number of user-requested points where the incident wave elevations can be output [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevxi      !< xi-coordinates for points where the incident wave elevations can be output [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevyi      !< yi-coordinates for points where the incident wave elevations can be output [(meters)]
    INTEGER(IntKi)  :: NWaveKin      !< Number of points where the incident wave kinematics will be computed [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinxi      !< xi-coordinates for points where the incident wave kinematics will be computed; these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinyi      !< yi-coordinates for points where the incident wave kinematics will be computed; these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinzi      !< zi-coordinates for points where the incident wave kinematics will be computed; these are relative to the mean sea level [(meters)]
    INTEGER(IntKi)  :: OutSwtch      !< Output requested channels to: [1=SeaState.out 2=GlueCode.out  3=both files] [-]
    LOGICAL  :: OutAll      !< Output all user-specified member and joint loads (only at each member end, not interior locations) [T/F] [-]
    INTEGER(IntKi)  :: NumOuts      !< The number of outputs for this module as requested in the input file [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< The user-requested output channel labels for this modules. This should really be dimensioned with MaxOutPts [-]
    LOGICAL  :: SeaStSum      !< Generate a SeaState summary file [T/F] [-]
    CHARACTER(20)  :: OutFmt      !< Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      !< Output format for header strings [-]
  END TYPE SeaSt_InputFile
! =======================
! =========  SeaSt_InitInputType  =======
  TYPE, PUBLIC :: SeaSt_InitInputType
    CHARACTER(1024)  :: InputFile      !< Supplied by Driver:  full path and filename for the SeaState module [-]
    LOGICAL  :: UseInputFile = .TRUE.      !< Supplied by Driver:  .TRUE. if using a input file, .FALSE. if all inputs are being passed in by the caller [-]
    TYPE(FileInfoType)  :: PassedFileData      !< If we don't use the input file, pass everything through this [-]
    CHARACTER(1024)  :: OutRootName      !< Supplied by Driver:  The name of the root file (without extension) including the full path [-]
    REAL(ReKi)  :: Gravity      !< Supplied by Driver:  Gravitational acceleration [(m/s^2)]
    REAL(ReKi)  :: defWtrDens      !< Default water density from the driver; may be overwritten                       [(kg/m^3)]
    REAL(ReKi)  :: defWtrDpth      !< Default water depth from the driver; may be overwritten                         [m]
    REAL(ReKi)  :: defMSL2SWL      !< Default mean sea level to still water level from the driver; may be overwritten [m]
    REAL(DbKi)  :: TMax      !< Supplied by Driver:  The total simulation time [(sec)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElevXY      !< Supplied by Driver:  X-Y locations for WaveElevation output (for visualization).  First dimension is the X (1) and Y (2) coordinate.  Second dimension is the point number. [m,-]
    INTEGER(IntKi)  :: WaveFieldMod      !< Wave field handling (-) (switch) 0: use individual SeaState inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    REAL(ReKi)  :: PtfmLocationX      !< Supplied by Driver:  X coordinate of platform location in the wave field [m]
    REAL(ReKi)  :: PtfmLocationY      !< Supplied by Driver:  Y coordinate of platform location in the wave field [m]
    INTEGER(IntKi)  :: WrWvKinMod = 0      !< 0,1, or 2 indicating whether we are going to write out kinematics files.  [ignored if WaveMod = 6, if 1 or 2 then files are written using the outrootname] [-]
    LOGICAL  :: HasIce      !< Supplied by Driver:  Whether this simulation has ice loading (flag) [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
  END TYPE SeaSt_InitInputType
! =======================
! =========  SeaSt_InitOutputType  =======
  TYPE, PUBLIC :: SeaSt_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< The is the list of all HD-related output channel header strings (includes all sub-module channels) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< The is the list of all HD-related output channel unit strings (includes all sub-module channels) [-]
    TYPE(ProgDesc)  :: Ver      !< Version of SeaState [-]
    REAL(ReKi)  :: WtrDens      !< Water density, this is necessary to inform glue-code what the module is using for WtrDens (may not be the glue-code's default) [(kg/m^3)]
    REAL(ReKi)  :: WtrDpth      !< Water depth, this is necessary to inform glue-code what the module is using for WtrDpth (may not be the glue-code's default) [(m)]
    REAL(ReKi)  :: MSL2SWL      !< Offset between still-water level and mean sea level, this is necessary to inform glue-code what the module is using for MSL2SWL (may not be the glue-code's default) [(m)]
    REAL(SiKi) , DIMENSION(:,:), POINTER  :: WaveElevC0 => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElevC => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at all grid points.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveDirArr => NULL()      !< Wave direction array.  Each frequency has a unique direction of WaveNDir > 1 [(degrees)]
    REAL(SiKi)  :: WaveDirMin      !< Minimum wave direction. [(degrees)]
    REAL(SiKi)  :: WaveDirMax      !< Maximum wave direction. [(degrees)]
    REAL(SiKi)  :: WaveDir      !< Incident wave propagation heading direction [(degrees)]
    LOGICAL  :: WaveMultiDir      !< Indicates the waves are multidirectional -- set by HydroDyn_Input [-]
    REAL(SiKi)  :: WaveDOmega      !< Frequency step for incident wave calculations [(rad/s)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: WaveDynP => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , accounting for stretching, at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAcc => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAccMCF => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveVel => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKin (grid) points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: PWaveDynP0 => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , at the location (xi,yi,0), at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAcc0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAccMCF0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveVel0 => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKin (grid) points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev1 => NULL()      !< First order wave elevation [-]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev2 => NULL()      !< Second order wave elevation [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveElev0 => NULL()      !< Instantaneous elevation time-series of incident waves at the platform reference point [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Simulation times at which the instantaneous elevation of, velocity of, acceleration of, and loads associated with the incident waves are determined [(sec)]
    REAL(SiKi)  :: RhoXg      !< = WtrDens*Gravity [-]
    INTEGER(IntKi)  :: NStepWave      !< Total number of frequency components = total number of time steps in the incident wave [-]
    INTEGER(IntKi)  :: NStepWave2      !< NStepWave / 2 [-]
    INTEGER(IntKi)  :: WaveMod      !< Incident wave kinematics model {0: none=still water, 1: plane progressive (regular), 2: JONSWAP/Pierson-Moskowitz spectrum (irregular), 3: white-noise spectrum, 4: user-defind spectrum from routine UserWaveSpctrm (irregular), 5: GH BLADED } [-]
    INTEGER(IntKi)  :: WaveStMod      !< Model for stretching incident wave kinematics to instantaneous free surface {0: none=no stretching, 1: vertical stretching, 2: extrapolation stretching, 3: Wheeler stretching} [-]
    INTEGER(IntKi)  :: WaveDirMod      !< Directional wave spreading function {0: none, 1: COS2S} [only used if WaveMod=6] [-]
    REAL(SiKi)  :: WvLowCOff      !< Low cut-off frequency or lower frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WvHiCOff      !< High cut-off frequency or upper frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WvLowCOffD      !< Minimum frequency used in the difference methods [Ignored if all difference methods = 0] [(rad/s)]
    REAL(SiKi)  :: WvHiCOffD      !< Maximum frequency used in the difference methods [Ignored if all difference methods = 0] [(rad/s)]
    REAL(SiKi)  :: WvLowCOffS      !< Minimum frequency used in the sum-QTF method     [Ignored if SumQTF = 0] [(rad/s)]
    REAL(SiKi)  :: WvHiCOffS      !< Maximum frequency used in the sum-QTF method     [Ignored if SumQTF = 0] [(rad/s)]
    LOGICAL  :: InvalidWithSSExctn      !< Whether SeaState configuration is invalid with HydroDyn's state-space excitation (ExctnMod=2) [(-)]
    TYPE(SeaSt_Interp_ParameterType)  :: SeaSt_Interp_p      !< parameter information from the SeaState Interpolation module [-]
    REAL(SiKi)  :: MCFD      !< Diameter of MacCamy-Fuchs member [(meters)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElevSeries      !< Wave elevation time-series at each of the points given by WaveElevXY.  First dimension is the timestep. Second dimension is XY point number corresponding to second dimension of WaveElevXY. [(m)]
    TYPE(SeaSt_WaveFieldType) , POINTER :: WaveField => NULL()      !< Pointer to wave field [-]
  END TYPE SeaSt_InitOutputType
! =======================
! =========  SeaSt_ContinuousStateType  =======
  TYPE, PUBLIC :: SeaSt_ContinuousStateType
    REAL(R8Ki)  :: UnusedStates      !< placeholder for states [-]
  END TYPE SeaSt_ContinuousStateType
! =======================
! =========  SeaSt_DiscreteStateType  =======
  TYPE, PUBLIC :: SeaSt_DiscreteStateType
    REAL(R8Ki)  :: UnusedStates      !< placeholder for states [-]
  END TYPE SeaSt_DiscreteStateType
! =======================
! =========  SeaSt_ConstraintStateType  =======
  TYPE, PUBLIC :: SeaSt_ConstraintStateType
    REAL(R8Ki)  :: UnusedStates      !< placeholder for states [-]
  END TYPE SeaSt_ConstraintStateType
! =======================
! =========  SeaSt_OtherStateType  =======
  TYPE, PUBLIC :: SeaSt_OtherStateType
    REAL(R8Ki)  :: UnusedStates      !< placeholder for states [-]
  END TYPE SeaSt_OtherStateType
! =======================
! =========  SeaSt_MiscVarType  =======
  TYPE, PUBLIC :: SeaSt_MiscVarType
    INTEGER(IntKi)  :: Decimate      !< The output decimation counter [-]
    REAL(DbKi)  :: LastOutTime      !< Last time step which was written to the output file (sec) [-]
    INTEGER(IntKi)  :: LastIndWave      !< The last index used in the wave kinematics arrays, used to optimize interpolation [-]
    TYPE(SeaSt_Interp_MiscVarType)  :: SeaSt_Interp_m      !< misc var information from the SeaState Interpolation module [-]
  END TYPE SeaSt_MiscVarType
! =======================
! =========  SeaSt_ParameterType  =======
  TYPE, PUBLIC :: SeaSt_ParameterType
    TYPE(Waves2_ParameterType)  :: Waves2      !< Parameter data for the Waves2 module [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Array of time samples, (sec) [-]
    REAL(DbKi)  :: WaveDT      !< Wave DT [sec]
    INTEGER(IntKi)  :: NGridPts      !< Number of data points in the wave kinematics grid [-]
    INTEGER(IntKi) , DIMENSION(1:3)  :: NGrid      !< Number of grid entries in x, y, and z [-]
    REAL(ReKi) , DIMENSION(1:3)  :: deltaGrid      !< delta between grid points in x, y, and theta (for z) [m,m,rad]
    REAL(ReKi)  :: X_HalfWidth      !< Half-width of the domain in the X direction [m]
    REAL(ReKi)  :: Y_HalfWidth      !< Half-width of the domain in the Y direction [m]
    REAL(ReKi)  :: Z_Depth      !< Depth of the domain the Z direction [m]
    INTEGER(IntKi)  :: NStepWave      !< Number of user-requested data points in the wave kinematics arrays [-]
    INTEGER(IntKi)  :: NWaveElev      !< Number of wave elevation outputs [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevxi      !< xi-coordinates for points where the incident wave elevations can be output [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElevyi      !< yi-coordinates for points where the incident wave elevations can be output [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev1 => NULL()      !< First order wave elevation [-]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev2 => NULL()      !< Second order wave elevation [-]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: PWaveDynP0 => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , at the location (xi,yi,0), at each of the NWaveKin points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: WaveDynP => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , accounting for stretching, at each of the NWaveKin points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAcc => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKin points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAcc0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKin points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveVel => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKin points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveVel0 => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKin points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAccMCF => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKin points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveDirArr => NULL()      !< Wave direction array.  Each frequency has a unique direction of WaveNDir > 1 [(degrees)]
    REAL(SiKi) , DIMENSION(:,:), POINTER  :: WaveElevC0 => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAccMCF0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKin (grid) points where the incident wave kinematics will be computed [(m/s^2)]
    INTEGER(IntKi)  :: NWaveKin      !< Number of points where the incident wave kinematics can be output [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinxi      !< xi-coordinates for points where the incident wave kinematics can be output; these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinyi      !< yi-coordinates for points where the incident wave kinematics can be output; these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinzi      !< zi-coordinates for points where the incident wave kinematics can be output; these are relative to the mean sea level [(meters)]
    REAL(ReKi)  :: WtrDpth      !< Water depth [(m)]
    REAL(DbKi)  :: DT      !< Time step in seconds for integration of continuous states (if a fixed-step integrator is used) and update of discrete states [-]
    INTEGER(IntKi)  :: WaveStMod      !< Wave stretching model [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !<  [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of SeaState module-level outputs (not the total number including sub-modules [-]
    INTEGER(IntKi)  :: OutSwtch      !< Output requested channels to: [1=SeaState.out 2=GlueCode.out  3=both files] [-]
    CHARACTER(20)  :: OutFmt      !< Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      !< Output format for header strings [-]
    CHARACTER(1)  :: Delim      !< Delimiter string for outputs, defaults to space [-]
    INTEGER(IntKi)  :: UnOutFile      !< File unit for the SeaState outputs [-]
    INTEGER(IntKi)  :: OutDec      !< Write every OutDec time steps [-]
    TYPE(SeaSt_Interp_ParameterType)  :: SeaSt_Interp_p      !< parameter information from the SeaState Interpolation module [-]
    TYPE(SeaSt_WaveFieldType) , POINTER :: WaveField => NULL()      !< Wave field [-]
  END TYPE SeaSt_ParameterType
! =======================
! =========  SeaSt_InputType  =======
  TYPE, PUBLIC :: SeaSt_InputType
    REAL(SiKi)  :: DummyInput      !< Remove this variable if you have inputs [-]
  END TYPE SeaSt_InputType
! =======================
! =========  SeaSt_OutputType  =======
  TYPE, PUBLIC :: SeaSt_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Outputs to be written to the output file(s) [-]
  END TYPE SeaSt_OutputType
! =======================
CONTAINS
 SUBROUTINE SeaSt_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(SeaSt_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%EchoFlag = SrcInputFileData%EchoFlag
    DstInputFileData%MSL2SWL = SrcInputFileData%MSL2SWL
    DstInputFileData%X_HalfWidth = SrcInputFileData%X_HalfWidth
    DstInputFileData%Y_HalfWidth = SrcInputFileData%Y_HalfWidth
    DstInputFileData%Z_Depth = SrcInputFileData%Z_Depth
    DstInputFileData%NX = SrcInputFileData%NX
    DstInputFileData%NY = SrcInputFileData%NY
    DstInputFileData%NZ = SrcInputFileData%NZ
      CALL Waves_CopyInitInput( SrcInputFileData%Waves, DstInputFileData%Waves, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Waves2_CopyInitInput( SrcInputFileData%Waves2, DstInputFileData%Waves2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Current_CopyInitInput( SrcInputFileData%Current, DstInputFileData%Current, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%NWaveElev = SrcInputFileData%NWaveElev
IF (ALLOCATED(SrcInputFileData%WaveElevxi)) THEN
  i1_l = LBOUND(SrcInputFileData%WaveElevxi,1)
  i1_u = UBOUND(SrcInputFileData%WaveElevxi,1)
  IF (.NOT. ALLOCATED(DstInputFileData%WaveElevxi)) THEN 
    ALLOCATE(DstInputFileData%WaveElevxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%WaveElevxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%WaveElevxi = SrcInputFileData%WaveElevxi
ENDIF
IF (ALLOCATED(SrcInputFileData%WaveElevyi)) THEN
  i1_l = LBOUND(SrcInputFileData%WaveElevyi,1)
  i1_u = UBOUND(SrcInputFileData%WaveElevyi,1)
  IF (.NOT. ALLOCATED(DstInputFileData%WaveElevyi)) THEN 
    ALLOCATE(DstInputFileData%WaveElevyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%WaveElevyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%WaveElevyi = SrcInputFileData%WaveElevyi
ENDIF
    DstInputFileData%NWaveKin = SrcInputFileData%NWaveKin
IF (ALLOCATED(SrcInputFileData%WaveKinxi)) THEN
  i1_l = LBOUND(SrcInputFileData%WaveKinxi,1)
  i1_u = UBOUND(SrcInputFileData%WaveKinxi,1)
  IF (.NOT. ALLOCATED(DstInputFileData%WaveKinxi)) THEN 
    ALLOCATE(DstInputFileData%WaveKinxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%WaveKinxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%WaveKinxi = SrcInputFileData%WaveKinxi
ENDIF
IF (ALLOCATED(SrcInputFileData%WaveKinyi)) THEN
  i1_l = LBOUND(SrcInputFileData%WaveKinyi,1)
  i1_u = UBOUND(SrcInputFileData%WaveKinyi,1)
  IF (.NOT. ALLOCATED(DstInputFileData%WaveKinyi)) THEN 
    ALLOCATE(DstInputFileData%WaveKinyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%WaveKinyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%WaveKinyi = SrcInputFileData%WaveKinyi
ENDIF
IF (ALLOCATED(SrcInputFileData%WaveKinzi)) THEN
  i1_l = LBOUND(SrcInputFileData%WaveKinzi,1)
  i1_u = UBOUND(SrcInputFileData%WaveKinzi,1)
  IF (.NOT. ALLOCATED(DstInputFileData%WaveKinzi)) THEN 
    ALLOCATE(DstInputFileData%WaveKinzi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%WaveKinzi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%WaveKinzi = SrcInputFileData%WaveKinzi
ENDIF
    DstInputFileData%OutSwtch = SrcInputFileData%OutSwtch
    DstInputFileData%OutAll = SrcInputFileData%OutAll
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
    DstInputFileData%SeaStSum = SrcInputFileData%SeaStSum
    DstInputFileData%OutFmt = SrcInputFileData%OutFmt
    DstInputFileData%OutSFmt = SrcInputFileData%OutSFmt
 END SUBROUTINE SeaSt_CopyInputFile

 SUBROUTINE SeaSt_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(SeaSt_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL Waves_DestroyInitInput( InputFileData%Waves, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Waves2_DestroyInitInput( InputFileData%Waves2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Current_DestroyInitInput( InputFileData%Current, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InputFileData%WaveElevxi)) THEN
  DEALLOCATE(InputFileData%WaveElevxi)
ENDIF
IF (ALLOCATED(InputFileData%WaveElevyi)) THEN
  DEALLOCATE(InputFileData%WaveElevyi)
ENDIF
IF (ALLOCATED(InputFileData%WaveKinxi)) THEN
  DEALLOCATE(InputFileData%WaveKinxi)
ENDIF
IF (ALLOCATED(InputFileData%WaveKinyi)) THEN
  DEALLOCATE(InputFileData%WaveKinyi)
ENDIF
IF (ALLOCATED(InputFileData%WaveKinzi)) THEN
  DEALLOCATE(InputFileData%WaveKinzi)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
 END SUBROUTINE SeaSt_DestroyInputFile


subroutine SeaSt_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackInputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   ! EchoFlag
   call RegPack(Buf, InData%EchoFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X_HalfWidth
   call RegPack(Buf, InData%X_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y_HalfWidth
   call RegPack(Buf, InData%Y_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegPack(Buf, InData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NX
   call RegPack(Buf, InData%NX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NY
   call RegPack(Buf, InData%NY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NZ
   call RegPack(Buf, InData%NZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Waves
   call Waves_PackInitInput(Buf, InData%Waves) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Waves2
   call Waves2_PackInitInput(Buf, InData%Waves2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Current
   call Current_PackInitInput(Buf, InData%Current) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElev
   call RegPack(Buf, InData%NWaveElev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevxi
   call RegPack(Buf, allocated(InData%WaveElevxi))
   if (allocated(InData%WaveElevxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElevxi), ubound(InData%WaveElevxi))
      call RegPack(Buf, InData%WaveElevxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevyi
   call RegPack(Buf, allocated(InData%WaveElevyi))
   if (allocated(InData%WaveElevyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElevyi), ubound(InData%WaveElevyi))
      call RegPack(Buf, InData%WaveElevyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveKin
   call RegPack(Buf, InData%NWaveKin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinxi
   call RegPack(Buf, allocated(InData%WaveKinxi))
   if (allocated(InData%WaveKinxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinxi), ubound(InData%WaveKinxi))
      call RegPack(Buf, InData%WaveKinxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinyi
   call RegPack(Buf, allocated(InData%WaveKinyi))
   if (allocated(InData%WaveKinyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinyi), ubound(InData%WaveKinyi))
      call RegPack(Buf, InData%WaveKinyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinzi
   call RegPack(Buf, allocated(InData%WaveKinzi))
   if (allocated(InData%WaveKinzi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinzi), ubound(InData%WaveKinzi))
      call RegPack(Buf, InData%WaveKinzi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegPack(Buf, InData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAll
   call RegPack(Buf, InData%OutAll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaStSum
   call RegPack(Buf, InData%SeaStSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegPack(Buf, InData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackInputFile'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! EchoFlag
   call RegUnpack(Buf, OutData%EchoFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X_HalfWidth
   call RegUnpack(Buf, OutData%X_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y_HalfWidth
   call RegUnpack(Buf, OutData%Y_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegUnpack(Buf, OutData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NX
   call RegUnpack(Buf, OutData%NX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NY
   call RegUnpack(Buf, OutData%NY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NZ
   call RegUnpack(Buf, OutData%NZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Waves
   call Waves_UnpackInitInput(Buf, OutData%Waves) ! Waves 
   ! Waves2
   call Waves2_UnpackInitInput(Buf, OutData%Waves2) ! Waves2 
   ! Current
   call Current_UnpackInitInput(Buf, OutData%Current) ! Current 
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElev
   call RegUnpack(Buf, OutData%NWaveElev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevxi
   if (allocated(OutData%WaveElevxi)) deallocate(OutData%WaveElevxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveElevyi
   if (allocated(OutData%WaveElevyi)) deallocate(OutData%WaveElevyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NWaveKin
   call RegUnpack(Buf, OutData%NWaveKin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinxi
   if (allocated(OutData%WaveKinxi)) deallocate(OutData%WaveKinxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveKinyi
   if (allocated(OutData%WaveKinyi)) deallocate(OutData%WaveKinyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveKinzi
   if (allocated(OutData%WaveKinzi)) deallocate(OutData%WaveKinzi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinzi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinzi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinzi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OutSwtch
   call RegUnpack(Buf, OutData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAll
   call RegUnpack(Buf, OutData%OutAll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SeaStSum
   call RegUnpack(Buf, OutData%SeaStSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegUnpack(Buf, OutData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(SeaSt_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%UseInputFile = SrcInitInputData%UseInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedFileData, DstInitInputData%PassedFileData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%OutRootName = SrcInitInputData%OutRootName
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%defWtrDens = SrcInitInputData%defWtrDens
    DstInitInputData%defWtrDpth = SrcInitInputData%defWtrDpth
    DstInitInputData%defMSL2SWL = SrcInitInputData%defMSL2SWL
    DstInitInputData%TMax = SrcInitInputData%TMax
IF (ALLOCATED(SrcInitInputData%WaveElevXY)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveElevXY,1)
  i1_u = UBOUND(SrcInitInputData%WaveElevXY,1)
  i2_l = LBOUND(SrcInitInputData%WaveElevXY,2)
  i2_u = UBOUND(SrcInitInputData%WaveElevXY,2)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveElevXY)) THEN 
    ALLOCATE(DstInitInputData%WaveElevXY(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveElevXY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveElevXY = SrcInitInputData%WaveElevXY
ENDIF
    DstInitInputData%WaveFieldMod = SrcInitInputData%WaveFieldMod
    DstInitInputData%PtfmLocationX = SrcInitInputData%PtfmLocationX
    DstInitInputData%PtfmLocationY = SrcInitInputData%PtfmLocationY
    DstInitInputData%WrWvKinMod = SrcInitInputData%WrWvKinMod
    DstInitInputData%HasIce = SrcInitInputData%HasIce
    DstInitInputData%Linearize = SrcInitInputData%Linearize
 END SUBROUTINE SeaSt_CopyInitInput

 SUBROUTINE SeaSt_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SeaSt_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedFileData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitInputData%WaveElevXY)) THEN
  DEALLOCATE(InitInputData%WaveElevXY)
ENDIF
 END SUBROUTINE SeaSt_DestroyInitInput


subroutine SeaSt_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegPack(Buf, InData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedFileData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedFileData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutRootName
   call RegPack(Buf, InData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defWtrDens
   call RegPack(Buf, InData%defWtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defWtrDpth
   call RegPack(Buf, InData%defWtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defMSL2SWL
   call RegPack(Buf, InData%defMSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMax
   call RegPack(Buf, InData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevXY
   call RegPack(Buf, allocated(InData%WaveElevXY))
   if (allocated(InData%WaveElevXY)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevXY), ubound(InData%WaveElevXY))
      call RegPack(Buf, InData%WaveElevXY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegPack(Buf, InData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationX
   call RegPack(Buf, InData%PtfmLocationX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationY
   call RegPack(Buf, InData%PtfmLocationY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrWvKinMod
   call RegPack(Buf, InData%WrWvKinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HasIce
   call RegPack(Buf, InData%HasIce)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackInitInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegUnpack(Buf, OutData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedFileData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedFileData) ! PassedFileData 
   ! OutRootName
   call RegUnpack(Buf, OutData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defWtrDens
   call RegUnpack(Buf, OutData%defWtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defWtrDpth
   call RegUnpack(Buf, OutData%defWtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! defMSL2SWL
   call RegUnpack(Buf, OutData%defMSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMax
   call RegUnpack(Buf, OutData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevXY
   if (allocated(OutData%WaveElevXY)) deallocate(OutData%WaveElevXY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevXY(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevXY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevXY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveFieldMod
   call RegUnpack(Buf, OutData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationX
   call RegUnpack(Buf, OutData%PtfmLocationX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationY
   call RegUnpack(Buf, OutData%PtfmLocationY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WrWvKinMod
   call RegUnpack(Buf, OutData%WrWvKinMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HasIce
   call RegUnpack(Buf, OutData%HasIce)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SeaSt_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitOutputData%WtrDens = SrcInitOutputData%WtrDens
    DstInitOutputData%WtrDpth = SrcInitOutputData%WtrDpth
    DstInitOutputData%MSL2SWL = SrcInitOutputData%MSL2SWL
    DstInitOutputData%WaveElevC0 => SrcInitOutputData%WaveElevC0
    DstInitOutputData%WaveElevC => SrcInitOutputData%WaveElevC
    DstInitOutputData%WaveDirArr => SrcInitOutputData%WaveDirArr
    DstInitOutputData%WaveDirMin = SrcInitOutputData%WaveDirMin
    DstInitOutputData%WaveDirMax = SrcInitOutputData%WaveDirMax
    DstInitOutputData%WaveDir = SrcInitOutputData%WaveDir
    DstInitOutputData%WaveMultiDir = SrcInitOutputData%WaveMultiDir
    DstInitOutputData%WaveDOmega = SrcInitOutputData%WaveDOmega
    DstInitOutputData%WaveDynP => SrcInitOutputData%WaveDynP
    DstInitOutputData%WaveAcc => SrcInitOutputData%WaveAcc
    DstInitOutputData%WaveAccMCF => SrcInitOutputData%WaveAccMCF
    DstInitOutputData%WaveVel => SrcInitOutputData%WaveVel
    DstInitOutputData%PWaveDynP0 => SrcInitOutputData%PWaveDynP0
    DstInitOutputData%PWaveAcc0 => SrcInitOutputData%PWaveAcc0
    DstInitOutputData%PWaveAccMCF0 => SrcInitOutputData%PWaveAccMCF0
    DstInitOutputData%PWaveVel0 => SrcInitOutputData%PWaveVel0
    DstInitOutputData%WaveElev1 => SrcInitOutputData%WaveElev1
    DstInitOutputData%WaveElev2 => SrcInitOutputData%WaveElev2
    DstInitOutputData%WaveElev0 => SrcInitOutputData%WaveElev0
    DstInitOutputData%WaveTime => SrcInitOutputData%WaveTime
    DstInitOutputData%RhoXg = SrcInitOutputData%RhoXg
    DstInitOutputData%NStepWave = SrcInitOutputData%NStepWave
    DstInitOutputData%NStepWave2 = SrcInitOutputData%NStepWave2
    DstInitOutputData%WaveMod = SrcInitOutputData%WaveMod
    DstInitOutputData%WaveStMod = SrcInitOutputData%WaveStMod
    DstInitOutputData%WaveDirMod = SrcInitOutputData%WaveDirMod
    DstInitOutputData%WvLowCOff = SrcInitOutputData%WvLowCOff
    DstInitOutputData%WvHiCOff = SrcInitOutputData%WvHiCOff
    DstInitOutputData%WvLowCOffD = SrcInitOutputData%WvLowCOffD
    DstInitOutputData%WvHiCOffD = SrcInitOutputData%WvHiCOffD
    DstInitOutputData%WvLowCOffS = SrcInitOutputData%WvLowCOffS
    DstInitOutputData%WvHiCOffS = SrcInitOutputData%WvHiCOffS
    DstInitOutputData%InvalidWithSSExctn = SrcInitOutputData%InvalidWithSSExctn
      CALL SeaSt_Interp_CopyParam( SrcInitOutputData%SeaSt_Interp_p, DstInitOutputData%SeaSt_Interp_p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitOutputData%MCFD = SrcInitOutputData%MCFD
IF (ALLOCATED(SrcInitOutputData%WaveElevSeries)) THEN
  i1_l = LBOUND(SrcInitOutputData%WaveElevSeries,1)
  i1_u = UBOUND(SrcInitOutputData%WaveElevSeries,1)
  i2_l = LBOUND(SrcInitOutputData%WaveElevSeries,2)
  i2_u = UBOUND(SrcInitOutputData%WaveElevSeries,2)
  IF (.NOT. ALLOCATED(DstInitOutputData%WaveElevSeries)) THEN 
    ALLOCATE(DstInitOutputData%WaveElevSeries(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WaveElevSeries.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WaveElevSeries = SrcInitOutputData%WaveElevSeries
ENDIF
    DstInitOutputData%WaveField => SrcInitOutputData%WaveField
 END SUBROUTINE SeaSt_CopyInitOutput

 SUBROUTINE SeaSt_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SeaSt_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
NULLIFY(InitOutputData%WaveElevC0)
NULLIFY(InitOutputData%WaveElevC)
NULLIFY(InitOutputData%WaveDirArr)
NULLIFY(InitOutputData%WaveDynP)
NULLIFY(InitOutputData%WaveAcc)
NULLIFY(InitOutputData%WaveAccMCF)
NULLIFY(InitOutputData%WaveVel)
NULLIFY(InitOutputData%PWaveDynP0)
NULLIFY(InitOutputData%PWaveAcc0)
NULLIFY(InitOutputData%PWaveAccMCF0)
NULLIFY(InitOutputData%PWaveVel0)
NULLIFY(InitOutputData%WaveElev1)
NULLIFY(InitOutputData%WaveElev2)
NULLIFY(InitOutputData%WaveElev0)
NULLIFY(InitOutputData%WaveTime)
  CALL SeaSt_Interp_DestroyParam( InitOutputData%SeaSt_Interp_p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%WaveElevSeries)) THEN
  DEALLOCATE(InitOutputData%WaveElevSeries)
ENDIF
NULLIFY(InitOutputData%WaveField)
 END SUBROUTINE SeaSt_DestroyInitOutput


subroutine SeaSt_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackInitOutput'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC0
   call RegPack(Buf, associated(InData%WaveElevC0))
   if (associated(InData%WaveElevC0)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevC0), ubound(InData%WaveElevC0))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC
   call RegPack(Buf, associated(InData%WaveElevC))
   if (associated(InData%WaveElevC)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElevC), ubound(InData%WaveElevC))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   call RegPack(Buf, associated(InData%WaveDirArr))
   if (associated(InData%WaveDirArr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveDirArr), ubound(InData%WaveDirArr))
      call RegPackPointer(Buf, c_loc(InData%WaveDirArr), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDirArr)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMin
   call RegPack(Buf, InData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegPack(Buf, InData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegPack(Buf, InData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegPack(Buf, InData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegPack(Buf, InData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDynP
   call RegPack(Buf, associated(InData%WaveDynP))
   if (associated(InData%WaveDynP)) then
      call RegPackBounds(Buf, 4, lbound(InData%WaveDynP), ubound(InData%WaveDynP))
      call RegPackPointer(Buf, c_loc(InData%WaveDynP), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDynP)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAcc
   call RegPack(Buf, associated(InData%WaveAcc))
   if (associated(InData%WaveAcc)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveAcc), ubound(InData%WaveAcc))
      call RegPackPointer(Buf, c_loc(InData%WaveAcc), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveAcc)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAccMCF
   call RegPack(Buf, associated(InData%WaveAccMCF))
   if (associated(InData%WaveAccMCF)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveAccMCF), ubound(InData%WaveAccMCF))
      call RegPackPointer(Buf, c_loc(InData%WaveAccMCF), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveAccMCF)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveVel
   call RegPack(Buf, associated(InData%WaveVel))
   if (associated(InData%WaveVel)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveVel), ubound(InData%WaveVel))
      call RegPackPointer(Buf, c_loc(InData%WaveVel), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveVel)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveDynP0
   call RegPack(Buf, associated(InData%PWaveDynP0))
   if (associated(InData%PWaveDynP0)) then
      call RegPackBounds(Buf, 3, lbound(InData%PWaveDynP0), ubound(InData%PWaveDynP0))
      call RegPackPointer(Buf, c_loc(InData%PWaveDynP0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveDynP0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveAcc0
   call RegPack(Buf, associated(InData%PWaveAcc0))
   if (associated(InData%PWaveAcc0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveAcc0), ubound(InData%PWaveAcc0))
      call RegPackPointer(Buf, c_loc(InData%PWaveAcc0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveAcc0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveAccMCF0
   call RegPack(Buf, associated(InData%PWaveAccMCF0))
   if (associated(InData%PWaveAccMCF0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveAccMCF0), ubound(InData%PWaveAccMCF0))
      call RegPackPointer(Buf, c_loc(InData%PWaveAccMCF0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveAccMCF0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveVel0
   call RegPack(Buf, associated(InData%PWaveVel0))
   if (associated(InData%PWaveVel0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveVel0), ubound(InData%PWaveVel0))
      call RegPackPointer(Buf, c_loc(InData%PWaveVel0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveVel0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev1
   call RegPack(Buf, associated(InData%WaveElev1))
   if (associated(InData%WaveElev1)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev1), ubound(InData%WaveElev1))
      call RegPackPointer(Buf, c_loc(InData%WaveElev1), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev1)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev2
   call RegPack(Buf, associated(InData%WaveElev2))
   if (associated(InData%WaveElev2)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev2), ubound(InData%WaveElev2))
      call RegPackPointer(Buf, c_loc(InData%WaveElev2), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev2)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   call RegPack(Buf, associated(InData%WaveElev0))
   if (associated(InData%WaveElev0)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElev0), ubound(InData%WaveElev0))
      call RegPackPointer(Buf, c_loc(InData%WaveElev0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegPack(Buf, InData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegPack(Buf, InData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegPack(Buf, InData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegPack(Buf, InData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMod
   call RegPack(Buf, InData%WaveDirMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegPack(Buf, InData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegPack(Buf, InData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffD
   call RegPack(Buf, InData%WvLowCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffD
   call RegPack(Buf, InData%WvHiCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffS
   call RegPack(Buf, InData%WvLowCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffS
   call RegPack(Buf, InData%WvHiCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvalidWithSSExctn
   call RegPack(Buf, InData%InvalidWithSSExctn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_PackParam(Buf, InData%SeaSt_Interp_p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! MCFD
   call RegPack(Buf, InData%MCFD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevSeries
   call RegPack(Buf, allocated(InData%WaveElevSeries))
   if (allocated(InData%WaveElevSeries)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevSeries), ubound(InData%WaveElevSeries))
      call RegPack(Buf, InData%WaveElevSeries)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveField
   call RegPack(Buf, associated(InData%WaveField))
   if (associated(InData%WaveField)) then
      call RegPackPointer(Buf, c_loc(InData%WaveField), PtrInIndex)
      if (.not. PtrInIndex) then
         call SeaSt_WaveField_PackSeaSt_WaveFieldType(Buf, InData%WaveField) 
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackInitOutput'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC0
   if (associated(OutData%WaveElevC0)) deallocate(OutData%WaveElevC0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC0, UB(1:2)-LB(1:2))
         OutData%WaveElevC0(LB(1):,LB(2):) => OutData%WaveElevC0
      else
         allocate(OutData%WaveElevC0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC0)
         call RegUnpack(Buf, OutData%WaveElevC0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC0 => null()
   end if
   ! WaveElevC
   if (associated(OutData%WaveElevC)) deallocate(OutData%WaveElevC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC, UB(1:3)-LB(1:3))
         OutData%WaveElevC(LB(1):,LB(2):,LB(3):) => OutData%WaveElevC
      else
         allocate(OutData%WaveElevC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC)
         call RegUnpack(Buf, OutData%WaveElevC)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC => null()
   end if
   ! WaveDirArr
   if (associated(OutData%WaveDirArr)) deallocate(OutData%WaveDirArr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDirArr, UB(1:1)-LB(1:1))
         OutData%WaveDirArr(LB(1):) => OutData%WaveDirArr
      else
         allocate(OutData%WaveDirArr(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDirArr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDirArr)
         call RegUnpack(Buf, OutData%WaveDirArr)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDirArr => null()
   end if
   ! WaveDirMin
   call RegUnpack(Buf, OutData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegUnpack(Buf, OutData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegUnpack(Buf, OutData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegUnpack(Buf, OutData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegUnpack(Buf, OutData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDynP
   if (associated(OutData%WaveDynP)) deallocate(OutData%WaveDynP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDynP, UB(1:4)-LB(1:4))
         OutData%WaveDynP(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%WaveDynP
      else
         allocate(OutData%WaveDynP(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDynP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDynP)
         call RegUnpack(Buf, OutData%WaveDynP)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDynP => null()
   end if
   ! WaveAcc
   if (associated(OutData%WaveAcc)) deallocate(OutData%WaveAcc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveAcc, UB(1:5)-LB(1:5))
         OutData%WaveAcc(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveAcc
      else
         allocate(OutData%WaveAcc(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveAcc)
         call RegUnpack(Buf, OutData%WaveAcc)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveAcc => null()
   end if
   ! WaveAccMCF
   if (associated(OutData%WaveAccMCF)) deallocate(OutData%WaveAccMCF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveAccMCF, UB(1:5)-LB(1:5))
         OutData%WaveAccMCF(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveAccMCF
      else
         allocate(OutData%WaveAccMCF(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAccMCF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveAccMCF)
         call RegUnpack(Buf, OutData%WaveAccMCF)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveAccMCF => null()
   end if
   ! WaveVel
   if (associated(OutData%WaveVel)) deallocate(OutData%WaveVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveVel, UB(1:5)-LB(1:5))
         OutData%WaveVel(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveVel
      else
         allocate(OutData%WaveVel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveVel)
         call RegUnpack(Buf, OutData%WaveVel)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveVel => null()
   end if
   ! PWaveDynP0
   if (associated(OutData%PWaveDynP0)) deallocate(OutData%PWaveDynP0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveDynP0, UB(1:3)-LB(1:3))
         OutData%PWaveDynP0(LB(1):,LB(2):,LB(3):) => OutData%PWaveDynP0
      else
         allocate(OutData%PWaveDynP0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveDynP0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveDynP0)
         call RegUnpack(Buf, OutData%PWaveDynP0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveDynP0 => null()
   end if
   ! PWaveAcc0
   if (associated(OutData%PWaveAcc0)) deallocate(OutData%PWaveAcc0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveAcc0, UB(1:4)-LB(1:4))
         OutData%PWaveAcc0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveAcc0
      else
         allocate(OutData%PWaveAcc0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveAcc0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveAcc0)
         call RegUnpack(Buf, OutData%PWaveAcc0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveAcc0 => null()
   end if
   ! PWaveAccMCF0
   if (associated(OutData%PWaveAccMCF0)) deallocate(OutData%PWaveAccMCF0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveAccMCF0, UB(1:4)-LB(1:4))
         OutData%PWaveAccMCF0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveAccMCF0
      else
         allocate(OutData%PWaveAccMCF0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveAccMCF0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveAccMCF0)
         call RegUnpack(Buf, OutData%PWaveAccMCF0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveAccMCF0 => null()
   end if
   ! PWaveVel0
   if (associated(OutData%PWaveVel0)) deallocate(OutData%PWaveVel0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveVel0, UB(1:4)-LB(1:4))
         OutData%PWaveVel0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveVel0
      else
         allocate(OutData%PWaveVel0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveVel0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveVel0)
         call RegUnpack(Buf, OutData%PWaveVel0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveVel0 => null()
   end if
   ! WaveElev1
   if (associated(OutData%WaveElev1)) deallocate(OutData%WaveElev1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev1, UB(1:3)-LB(1:3))
         OutData%WaveElev1(LB(1):,LB(2):,LB(3):) => OutData%WaveElev1
      else
         allocate(OutData%WaveElev1(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev1)
         call RegUnpack(Buf, OutData%WaveElev1)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev1 => null()
   end if
   ! WaveElev2
   if (associated(OutData%WaveElev2)) deallocate(OutData%WaveElev2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev2, UB(1:3)-LB(1:3))
         OutData%WaveElev2(LB(1):,LB(2):,LB(3):) => OutData%WaveElev2
      else
         allocate(OutData%WaveElev2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev2)
         call RegUnpack(Buf, OutData%WaveElev2)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev2 => null()
   end if
   ! WaveElev0
   if (associated(OutData%WaveElev0)) deallocate(OutData%WaveElev0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev0, UB(1:1)-LB(1:1))
         OutData%WaveElev0(LB(1):) => OutData%WaveElev0
      else
         allocate(OutData%WaveElev0(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev0)
         call RegUnpack(Buf, OutData%WaveElev0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev0 => null()
   end if
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! RhoXg
   call RegUnpack(Buf, OutData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegUnpack(Buf, OutData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegUnpack(Buf, OutData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegUnpack(Buf, OutData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMod
   call RegUnpack(Buf, OutData%WaveDirMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegUnpack(Buf, OutData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegUnpack(Buf, OutData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffD
   call RegUnpack(Buf, OutData%WvLowCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffD
   call RegUnpack(Buf, OutData%WvHiCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffS
   call RegUnpack(Buf, OutData%WvLowCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffS
   call RegUnpack(Buf, OutData%WvHiCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvalidWithSSExctn
   call RegUnpack(Buf, OutData%InvalidWithSSExctn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_UnpackParam(Buf, OutData%SeaSt_Interp_p) ! SeaSt_Interp_p 
   ! MCFD
   call RegUnpack(Buf, OutData%MCFD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevSeries
   if (allocated(OutData%WaveElevSeries)) deallocate(OutData%WaveElevSeries)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevSeries(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevSeries.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevSeries)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveField
   if (associated(OutData%WaveField)) deallocate(OutData%WaveField)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveField)
      else
         allocate(OutData%WaveField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveField.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveField)
         call SeaSt_WaveField_UnpackSeaSt_WaveFieldType(Buf, OutData%WaveField) ! WaveField 
      end if
   else
      OutData%WaveField => null()
   end if
end subroutine
 SUBROUTINE SeaSt_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(SeaSt_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%UnusedStates = SrcContStateData%UnusedStates
 END SUBROUTINE SeaSt_CopyContState

 SUBROUTINE SeaSt_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SeaSt_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_DestroyContState


subroutine SeaSt_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! UnusedStates
   call RegPack(Buf, InData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   ! UnusedStates
   call RegUnpack(Buf, OutData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(SeaSt_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%UnusedStates = SrcDiscStateData%UnusedStates
 END SUBROUTINE SeaSt_CopyDiscState

 SUBROUTINE SeaSt_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SeaSt_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_DestroyDiscState


subroutine SeaSt_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! UnusedStates
   call RegPack(Buf, InData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! UnusedStates
   call RegUnpack(Buf, OutData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(SeaSt_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%UnusedStates = SrcConstrStateData%UnusedStates
 END SUBROUTINE SeaSt_CopyConstrState

 SUBROUTINE SeaSt_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SeaSt_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_DestroyConstrState


subroutine SeaSt_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! UnusedStates
   call RegPack(Buf, InData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! UnusedStates
   call RegUnpack(Buf, OutData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(SeaSt_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%UnusedStates = SrcOtherStateData%UnusedStates
 END SUBROUTINE SeaSt_CopyOtherState

 SUBROUTINE SeaSt_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SeaSt_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_DestroyOtherState


subroutine SeaSt_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! UnusedStates
   call RegPack(Buf, InData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! UnusedStates
   call RegUnpack(Buf, OutData%UnusedStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(SeaSt_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%Decimate = SrcMiscData%Decimate
    DstMiscData%LastOutTime = SrcMiscData%LastOutTime
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
      CALL SeaSt_Interp_CopyMisc( SrcMiscData%SeaSt_Interp_m, DstMiscData%SeaSt_Interp_m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SeaSt_CopyMisc

 SUBROUTINE SeaSt_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(SeaSt_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL SeaSt_Interp_DestroyMisc( MiscData%SeaSt_Interp_m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SeaSt_DestroyMisc


subroutine SeaSt_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Decimate
   call RegPack(Buf, InData%Decimate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastOutTime
   call RegPack(Buf, InData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastIndWave
   call RegPack(Buf, InData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_m
   call SeaSt_Interp_PackMisc(Buf, InData%SeaSt_Interp_m) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   ! Decimate
   call RegUnpack(Buf, OutData%Decimate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastOutTime
   call RegUnpack(Buf, OutData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastIndWave
   call RegUnpack(Buf, OutData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_m
   call SeaSt_Interp_UnpackMisc(Buf, OutData%SeaSt_Interp_m) ! SeaSt_Interp_m 
end subroutine
 SUBROUTINE SeaSt_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SeaSt_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL Waves2_CopyParam( SrcParamData%Waves2, DstParamData%Waves2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstParamData%WaveTime => SrcParamData%WaveTime
    DstParamData%WaveDT = SrcParamData%WaveDT
    DstParamData%NGridPts = SrcParamData%NGridPts
    DstParamData%NGrid = SrcParamData%NGrid
    DstParamData%deltaGrid = SrcParamData%deltaGrid
    DstParamData%X_HalfWidth = SrcParamData%X_HalfWidth
    DstParamData%Y_HalfWidth = SrcParamData%Y_HalfWidth
    DstParamData%Z_Depth = SrcParamData%Z_Depth
    DstParamData%NStepWave = SrcParamData%NStepWave
    DstParamData%NWaveElev = SrcParamData%NWaveElev
IF (ALLOCATED(SrcParamData%WaveElevxi)) THEN
  i1_l = LBOUND(SrcParamData%WaveElevxi,1)
  i1_u = UBOUND(SrcParamData%WaveElevxi,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveElevxi)) THEN 
    ALLOCATE(DstParamData%WaveElevxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveElevxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveElevxi = SrcParamData%WaveElevxi
ENDIF
IF (ALLOCATED(SrcParamData%WaveElevyi)) THEN
  i1_l = LBOUND(SrcParamData%WaveElevyi,1)
  i1_u = UBOUND(SrcParamData%WaveElevyi,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveElevyi)) THEN 
    ALLOCATE(DstParamData%WaveElevyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveElevyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveElevyi = SrcParamData%WaveElevyi
ENDIF
    DstParamData%WaveElev1 => SrcParamData%WaveElev1
    DstParamData%WaveElev2 => SrcParamData%WaveElev2
    DstParamData%PWaveDynP0 => SrcParamData%PWaveDynP0
    DstParamData%WaveDynP => SrcParamData%WaveDynP
    DstParamData%WaveAcc => SrcParamData%WaveAcc
    DstParamData%PWaveAcc0 => SrcParamData%PWaveAcc0
    DstParamData%WaveVel => SrcParamData%WaveVel
    DstParamData%PWaveVel0 => SrcParamData%PWaveVel0
    DstParamData%WaveAccMCF => SrcParamData%WaveAccMCF
    DstParamData%WaveDirArr => SrcParamData%WaveDirArr
    DstParamData%WaveElevC0 => SrcParamData%WaveElevC0
    DstParamData%PWaveAccMCF0 => SrcParamData%PWaveAccMCF0
    DstParamData%NWaveKin = SrcParamData%NWaveKin
IF (ALLOCATED(SrcParamData%WaveKinxi)) THEN
  i1_l = LBOUND(SrcParamData%WaveKinxi,1)
  i1_u = UBOUND(SrcParamData%WaveKinxi,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveKinxi)) THEN 
    ALLOCATE(DstParamData%WaveKinxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveKinxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveKinxi = SrcParamData%WaveKinxi
ENDIF
IF (ALLOCATED(SrcParamData%WaveKinyi)) THEN
  i1_l = LBOUND(SrcParamData%WaveKinyi,1)
  i1_u = UBOUND(SrcParamData%WaveKinyi,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveKinyi)) THEN 
    ALLOCATE(DstParamData%WaveKinyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveKinyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveKinyi = SrcParamData%WaveKinyi
ENDIF
IF (ALLOCATED(SrcParamData%WaveKinzi)) THEN
  i1_l = LBOUND(SrcParamData%WaveKinzi,1)
  i1_u = UBOUND(SrcParamData%WaveKinzi,1)
  IF (.NOT. ALLOCATED(DstParamData%WaveKinzi)) THEN 
    ALLOCATE(DstParamData%WaveKinzi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveKinzi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveKinzi = SrcParamData%WaveKinzi
ENDIF
    DstParamData%WtrDpth = SrcParamData%WtrDpth
    DstParamData%DT = SrcParamData%DT
    DstParamData%WaveStMod = SrcParamData%WaveStMod
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%OutSwtch = SrcParamData%OutSwtch
    DstParamData%OutFmt = SrcParamData%OutFmt
    DstParamData%OutSFmt = SrcParamData%OutSFmt
    DstParamData%Delim = SrcParamData%Delim
    DstParamData%UnOutFile = SrcParamData%UnOutFile
    DstParamData%OutDec = SrcParamData%OutDec
      CALL SeaSt_Interp_CopyParam( SrcParamData%SeaSt_Interp_p, DstParamData%SeaSt_Interp_p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ASSOCIATED(SrcParamData%WaveField)) THEN
  IF (.NOT. ASSOCIATED(DstParamData%WaveField)) THEN 
    ALLOCATE(DstParamData%WaveField,STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveField.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
      CALL SeaSt_WaveField_Copyseast_wavefieldtype( SrcParamData%WaveField, DstParamData%WaveField, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
ENDIF
 END SUBROUTINE SeaSt_CopyParam

 SUBROUTINE SeaSt_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SeaSt_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL Waves2_DestroyParam( ParamData%Waves2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
NULLIFY(ParamData%WaveTime)
IF (ALLOCATED(ParamData%WaveElevxi)) THEN
  DEALLOCATE(ParamData%WaveElevxi)
ENDIF
IF (ALLOCATED(ParamData%WaveElevyi)) THEN
  DEALLOCATE(ParamData%WaveElevyi)
ENDIF
NULLIFY(ParamData%WaveElev1)
NULLIFY(ParamData%WaveElev2)
NULLIFY(ParamData%PWaveDynP0)
NULLIFY(ParamData%WaveDynP)
NULLIFY(ParamData%WaveAcc)
NULLIFY(ParamData%PWaveAcc0)
NULLIFY(ParamData%WaveVel)
NULLIFY(ParamData%PWaveVel0)
NULLIFY(ParamData%WaveAccMCF)
NULLIFY(ParamData%WaveDirArr)
NULLIFY(ParamData%WaveElevC0)
NULLIFY(ParamData%PWaveAccMCF0)
IF (ALLOCATED(ParamData%WaveKinxi)) THEN
  DEALLOCATE(ParamData%WaveKinxi)
ENDIF
IF (ALLOCATED(ParamData%WaveKinyi)) THEN
  DEALLOCATE(ParamData%WaveKinyi)
ENDIF
IF (ALLOCATED(ParamData%WaveKinzi)) THEN
  DEALLOCATE(ParamData%WaveKinzi)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( ParamData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
  CALL SeaSt_Interp_DestroyParam( ParamData%SeaSt_Interp_p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ASSOCIATED(ParamData%WaveField)) THEN
  IF (ASSOCIATED(ParamData%WaveField)) THEN
    CALL SeaSt_WaveField_DestroySeaSt_WaveFieldType( ParamData%WaveField, ErrStat2, ErrMsg2 )
       CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  ENDIF
  DEALLOCATE(ParamData%WaveField)
  ParamData%WaveField => NULL()
ENDIF
 END SUBROUTINE SeaSt_DestroyParam


subroutine SeaSt_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackParam'
   integer(IntKi)  :: i1, i2, i3, i4, i5
   integer(IntKi)  :: LB(5), UB(5)
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! Waves2
   call Waves2_PackParam(Buf, InData%Waves2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDT
   call RegPack(Buf, InData%WaveDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NGridPts
   call RegPack(Buf, InData%NGridPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NGrid
   call RegPack(Buf, InData%NGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! deltaGrid
   call RegPack(Buf, InData%deltaGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X_HalfWidth
   call RegPack(Buf, InData%X_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y_HalfWidth
   call RegPack(Buf, InData%Y_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegPack(Buf, InData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElev
   call RegPack(Buf, InData%NWaveElev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevxi
   call RegPack(Buf, allocated(InData%WaveElevxi))
   if (allocated(InData%WaveElevxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElevxi), ubound(InData%WaveElevxi))
      call RegPack(Buf, InData%WaveElevxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevyi
   call RegPack(Buf, allocated(InData%WaveElevyi))
   if (allocated(InData%WaveElevyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElevyi), ubound(InData%WaveElevyi))
      call RegPack(Buf, InData%WaveElevyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev1
   call RegPack(Buf, associated(InData%WaveElev1))
   if (associated(InData%WaveElev1)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev1), ubound(InData%WaveElev1))
      call RegPackPointer(Buf, c_loc(InData%WaveElev1), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev1)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev2
   call RegPack(Buf, associated(InData%WaveElev2))
   if (associated(InData%WaveElev2)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev2), ubound(InData%WaveElev2))
      call RegPackPointer(Buf, c_loc(InData%WaveElev2), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev2)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveDynP0
   call RegPack(Buf, associated(InData%PWaveDynP0))
   if (associated(InData%PWaveDynP0)) then
      call RegPackBounds(Buf, 3, lbound(InData%PWaveDynP0), ubound(InData%PWaveDynP0))
      call RegPackPointer(Buf, c_loc(InData%PWaveDynP0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveDynP0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDynP
   call RegPack(Buf, associated(InData%WaveDynP))
   if (associated(InData%WaveDynP)) then
      call RegPackBounds(Buf, 4, lbound(InData%WaveDynP), ubound(InData%WaveDynP))
      call RegPackPointer(Buf, c_loc(InData%WaveDynP), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDynP)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAcc
   call RegPack(Buf, associated(InData%WaveAcc))
   if (associated(InData%WaveAcc)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveAcc), ubound(InData%WaveAcc))
      call RegPackPointer(Buf, c_loc(InData%WaveAcc), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveAcc)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveAcc0
   call RegPack(Buf, associated(InData%PWaveAcc0))
   if (associated(InData%PWaveAcc0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveAcc0), ubound(InData%PWaveAcc0))
      call RegPackPointer(Buf, c_loc(InData%PWaveAcc0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveAcc0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveVel
   call RegPack(Buf, associated(InData%WaveVel))
   if (associated(InData%WaveVel)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveVel), ubound(InData%WaveVel))
      call RegPackPointer(Buf, c_loc(InData%WaveVel), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveVel)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveVel0
   call RegPack(Buf, associated(InData%PWaveVel0))
   if (associated(InData%PWaveVel0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveVel0), ubound(InData%PWaveVel0))
      call RegPackPointer(Buf, c_loc(InData%PWaveVel0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveVel0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAccMCF
   call RegPack(Buf, associated(InData%WaveAccMCF))
   if (associated(InData%WaveAccMCF)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveAccMCF), ubound(InData%WaveAccMCF))
      call RegPackPointer(Buf, c_loc(InData%WaveAccMCF), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveAccMCF)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   call RegPack(Buf, associated(InData%WaveDirArr))
   if (associated(InData%WaveDirArr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveDirArr), ubound(InData%WaveDirArr))
      call RegPackPointer(Buf, c_loc(InData%WaveDirArr), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDirArr)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC0
   call RegPack(Buf, associated(InData%WaveElevC0))
   if (associated(InData%WaveElevC0)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevC0), ubound(InData%WaveElevC0))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveAccMCF0
   call RegPack(Buf, associated(InData%PWaveAccMCF0))
   if (associated(InData%PWaveAccMCF0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveAccMCF0), ubound(InData%PWaveAccMCF0))
      call RegPackPointer(Buf, c_loc(InData%PWaveAccMCF0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveAccMCF0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveKin
   call RegPack(Buf, InData%NWaveKin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinxi
   call RegPack(Buf, allocated(InData%WaveKinxi))
   if (allocated(InData%WaveKinxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinxi), ubound(InData%WaveKinxi))
      call RegPack(Buf, InData%WaveKinxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinyi
   call RegPack(Buf, allocated(InData%WaveKinyi))
   if (allocated(InData%WaveKinyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinyi), ubound(InData%WaveKinyi))
      call RegPack(Buf, InData%WaveKinyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinzi
   call RegPack(Buf, allocated(InData%WaveKinzi))
   if (allocated(InData%WaveKinzi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinzi), ubound(InData%WaveKinzi))
      call RegPack(Buf, InData%WaveKinzi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegPack(Buf, InData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegPack(Buf, InData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegPack(Buf, InData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnOutFile
   call RegPack(Buf, InData%UnOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDec
   call RegPack(Buf, InData%OutDec)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_PackParam(Buf, InData%SeaSt_Interp_p) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveField
   call RegPack(Buf, associated(InData%WaveField))
   if (associated(InData%WaveField)) then
      call RegPackPointer(Buf, c_loc(InData%WaveField), PtrInIndex)
      if (.not. PtrInIndex) then
         call SeaSt_WaveField_PackSeaSt_WaveFieldType(Buf, InData%WaveField) 
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackParam'
   integer(IntKi)  :: i1, i2, i3, i4, i5
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! Waves2
   call Waves2_UnpackParam(Buf, OutData%Waves2) ! Waves2 
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! WaveDT
   call RegUnpack(Buf, OutData%WaveDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NGridPts
   call RegUnpack(Buf, OutData%NGridPts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NGrid
   call RegUnpack(Buf, OutData%NGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! deltaGrid
   call RegUnpack(Buf, OutData%deltaGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! X_HalfWidth
   call RegUnpack(Buf, OutData%X_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y_HalfWidth
   call RegUnpack(Buf, OutData%Y_HalfWidth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegUnpack(Buf, OutData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElev
   call RegUnpack(Buf, OutData%NWaveElev)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevxi
   if (allocated(OutData%WaveElevxi)) deallocate(OutData%WaveElevxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveElevyi
   if (allocated(OutData%WaveElevyi)) deallocate(OutData%WaveElevyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveElev1
   if (associated(OutData%WaveElev1)) deallocate(OutData%WaveElev1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev1, UB(1:3)-LB(1:3))
         OutData%WaveElev1(LB(1):,LB(2):,LB(3):) => OutData%WaveElev1
      else
         allocate(OutData%WaveElev1(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev1)
         call RegUnpack(Buf, OutData%WaveElev1)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev1 => null()
   end if
   ! WaveElev2
   if (associated(OutData%WaveElev2)) deallocate(OutData%WaveElev2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev2, UB(1:3)-LB(1:3))
         OutData%WaveElev2(LB(1):,LB(2):,LB(3):) => OutData%WaveElev2
      else
         allocate(OutData%WaveElev2(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev2)
         call RegUnpack(Buf, OutData%WaveElev2)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev2 => null()
   end if
   ! PWaveDynP0
   if (associated(OutData%PWaveDynP0)) deallocate(OutData%PWaveDynP0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveDynP0, UB(1:3)-LB(1:3))
         OutData%PWaveDynP0(LB(1):,LB(2):,LB(3):) => OutData%PWaveDynP0
      else
         allocate(OutData%PWaveDynP0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveDynP0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveDynP0)
         call RegUnpack(Buf, OutData%PWaveDynP0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveDynP0 => null()
   end if
   ! WaveDynP
   if (associated(OutData%WaveDynP)) deallocate(OutData%WaveDynP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDynP, UB(1:4)-LB(1:4))
         OutData%WaveDynP(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%WaveDynP
      else
         allocate(OutData%WaveDynP(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDynP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDynP)
         call RegUnpack(Buf, OutData%WaveDynP)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDynP => null()
   end if
   ! WaveAcc
   if (associated(OutData%WaveAcc)) deallocate(OutData%WaveAcc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveAcc, UB(1:5)-LB(1:5))
         OutData%WaveAcc(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveAcc
      else
         allocate(OutData%WaveAcc(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveAcc)
         call RegUnpack(Buf, OutData%WaveAcc)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveAcc => null()
   end if
   ! PWaveAcc0
   if (associated(OutData%PWaveAcc0)) deallocate(OutData%PWaveAcc0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveAcc0, UB(1:4)-LB(1:4))
         OutData%PWaveAcc0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveAcc0
      else
         allocate(OutData%PWaveAcc0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveAcc0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveAcc0)
         call RegUnpack(Buf, OutData%PWaveAcc0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveAcc0 => null()
   end if
   ! WaveVel
   if (associated(OutData%WaveVel)) deallocate(OutData%WaveVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveVel, UB(1:5)-LB(1:5))
         OutData%WaveVel(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveVel
      else
         allocate(OutData%WaveVel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveVel)
         call RegUnpack(Buf, OutData%WaveVel)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveVel => null()
   end if
   ! PWaveVel0
   if (associated(OutData%PWaveVel0)) deallocate(OutData%PWaveVel0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveVel0, UB(1:4)-LB(1:4))
         OutData%PWaveVel0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveVel0
      else
         allocate(OutData%PWaveVel0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveVel0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveVel0)
         call RegUnpack(Buf, OutData%PWaveVel0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveVel0 => null()
   end if
   ! WaveAccMCF
   if (associated(OutData%WaveAccMCF)) deallocate(OutData%WaveAccMCF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveAccMCF, UB(1:5)-LB(1:5))
         OutData%WaveAccMCF(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveAccMCF
      else
         allocate(OutData%WaveAccMCF(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAccMCF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveAccMCF)
         call RegUnpack(Buf, OutData%WaveAccMCF)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveAccMCF => null()
   end if
   ! WaveDirArr
   if (associated(OutData%WaveDirArr)) deallocate(OutData%WaveDirArr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDirArr, UB(1:1)-LB(1:1))
         OutData%WaveDirArr(LB(1):) => OutData%WaveDirArr
      else
         allocate(OutData%WaveDirArr(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDirArr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDirArr)
         call RegUnpack(Buf, OutData%WaveDirArr)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDirArr => null()
   end if
   ! WaveElevC0
   if (associated(OutData%WaveElevC0)) deallocate(OutData%WaveElevC0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC0, UB(1:2)-LB(1:2))
         OutData%WaveElevC0(LB(1):,LB(2):) => OutData%WaveElevC0
      else
         allocate(OutData%WaveElevC0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC0)
         call RegUnpack(Buf, OutData%WaveElevC0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC0 => null()
   end if
   ! PWaveAccMCF0
   if (associated(OutData%PWaveAccMCF0)) deallocate(OutData%PWaveAccMCF0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveAccMCF0, UB(1:4)-LB(1:4))
         OutData%PWaveAccMCF0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveAccMCF0
      else
         allocate(OutData%PWaveAccMCF0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveAccMCF0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveAccMCF0)
         call RegUnpack(Buf, OutData%PWaveAccMCF0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveAccMCF0 => null()
   end if
   ! NWaveKin
   call RegUnpack(Buf, OutData%NWaveKin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinxi
   if (allocated(OutData%WaveKinxi)) deallocate(OutData%WaveKinxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveKinyi
   if (allocated(OutData%WaveKinyi)) deallocate(OutData%WaveKinyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveKinzi
   if (allocated(OutData%WaveKinzi)) deallocate(OutData%WaveKinzi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinzi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinzi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinzi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegUnpack(Buf, OutData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegUnpack(Buf, OutData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegUnpack(Buf, OutData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnOutFile
   call RegUnpack(Buf, OutData%UnOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDec
   call RegUnpack(Buf, OutData%OutDec)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_UnpackParam(Buf, OutData%SeaSt_Interp_p) ! SeaSt_Interp_p 
   ! WaveField
   if (associated(OutData%WaveField)) deallocate(OutData%WaveField)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveField)
      else
         allocate(OutData%WaveField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveField.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveField)
         call SeaSt_WaveField_UnpackSeaSt_WaveFieldType(Buf, OutData%WaveField) ! WaveField 
      end if
   else
      OutData%WaveField => null()
   end if
end subroutine
 SUBROUTINE SeaSt_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_InputType), INTENT(IN) :: SrcInputData
   TYPE(SeaSt_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputData%DummyInput = SrcInputData%DummyInput
 END SUBROUTINE SeaSt_CopyInput

 SUBROUTINE SeaSt_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SeaSt_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_DestroyInput


subroutine SeaSt_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyInput
   call RegPack(Buf, InData%DummyInput)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyInput
   call RegUnpack(Buf, OutData%DummyInput)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(SeaSt_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SeaSt_CopyOutput

 SUBROUTINE SeaSt_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SeaSt_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE SeaSt_DestroyOutput


subroutine SeaSt_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_UnPackOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
END MODULE SeaState_Types
!ENDOFREGISTRYGENERATEDFILE
