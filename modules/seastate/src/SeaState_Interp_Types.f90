!STARTOFREGISTRYGENERATEDFILE 'SeaState_Interp_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! SeaState_Interp_Types
!.................................................................................................................................
! This file is part of SeaState_Interp.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in SeaState_Interp. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE SeaState_Interp_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  SeaSt_Interp_InitInputType  =======
  TYPE, PUBLIC :: SeaSt_Interp_InitInputType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of grid points in the t, x, y, and z directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction (time, x, y, z) [s,m,m,m]
    REAL(ReKi) , DIMENSION(1:4)  :: pZero      !< fixed position of the time-X-Y-Z grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(ReKi)  :: Z_Depth      !< grid depth [m]
  END TYPE SeaSt_Interp_InitInputType
! =======================
! =========  SeaSt_Interp_InitOutputType  =======
  TYPE, PUBLIC :: SeaSt_Interp_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< Version information of this submodule [-]
  END TYPE SeaSt_Interp_InitOutputType
! =======================
! =========  SeaSt_Interp_MiscVarType  =======
  TYPE, PUBLIC :: SeaSt_Interp_MiscVarType
    REAL(SiKi) , DIMENSION(1:8)  :: N3D      !< this is the 3-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    REAL(SiKi) , DIMENSION(1:16)  :: N4D      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    INTEGER(IntKi) , DIMENSION(1:4)  :: Indx_Lo      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    INTEGER(IntKi) , DIMENSION(1:4)  :: Indx_Hi      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt]; it is stored as a miscVar instead of an input so that we don't have 4 copies of a very large field [-]
    LOGICAL  :: FirstWarn_Clamp = .true.      !< used to avoid too many 'Position has been clamped to the grid boundary' warning messages  [-]
  END TYPE SeaSt_Interp_MiscVarType
! =======================
! =========  SeaSt_Interp_ParameterType  =======
  TYPE, PUBLIC :: SeaSt_Interp_ParameterType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of evenly-spaced grid points in the t, x, y, and z directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction [s,m,m,m]
    REAL(ReKi) , DIMENSION(1:4)  :: pZero      !< fixed position of the XYZ grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(ReKi)  :: Z_Depth      !< grid depth [m]
  END TYPE SeaSt_Interp_ParameterType
! =======================
CONTAINS
 SUBROUTINE SeaSt_Interp_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_Interp_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(SeaSt_Interp_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_Interp_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%n = SrcInitInputData%n
    DstInitInputData%delta = SrcInitInputData%delta
    DstInitInputData%pZero = SrcInitInputData%pZero
    DstInitInputData%Z_Depth = SrcInitInputData%Z_Depth
 END SUBROUTINE SeaSt_Interp_CopyInitInput

 SUBROUTINE SeaSt_Interp_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SeaSt_Interp_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_Interp_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_Interp_DestroyInitInput


subroutine SeaSt_Interp_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! n
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegPack(Buf, InData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegPack(Buf, InData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegPack(Buf, InData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackInitInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! n
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegUnpack(Buf, OutData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_Interp_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_Interp_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SeaSt_Interp_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_Interp_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SeaSt_Interp_CopyInitOutput

 SUBROUTINE SeaSt_Interp_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SeaSt_Interp_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_Interp_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SeaSt_Interp_DestroyInitOutput


subroutine SeaSt_Interp_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
end subroutine
 SUBROUTINE SeaSt_Interp_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_Interp_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(SeaSt_Interp_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_Interp_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%N3D = SrcMiscData%N3D
    DstMiscData%N4D = SrcMiscData%N4D
    DstMiscData%Indx_Lo = SrcMiscData%Indx_Lo
    DstMiscData%Indx_Hi = SrcMiscData%Indx_Hi
    DstMiscData%FirstWarn_Clamp = SrcMiscData%FirstWarn_Clamp
 END SUBROUTINE SeaSt_Interp_CopyMisc

 SUBROUTINE SeaSt_Interp_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(SeaSt_Interp_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_Interp_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_Interp_DestroyMisc


subroutine SeaSt_Interp_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! N3D
   call RegPack(Buf, InData%N3D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N4D
   call RegPack(Buf, InData%N4D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Indx_Lo
   call RegPack(Buf, InData%Indx_Lo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Indx_Hi
   call RegPack(Buf, InData%Indx_Hi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstWarn_Clamp
   call RegPack(Buf, InData%FirstWarn_Clamp)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   ! N3D
   call RegUnpack(Buf, OutData%N3D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N4D
   call RegUnpack(Buf, OutData%N4D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Indx_Lo
   call RegUnpack(Buf, OutData%Indx_Lo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Indx_Hi
   call RegUnpack(Buf, OutData%Indx_Hi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FirstWarn_Clamp
   call RegUnpack(Buf, OutData%FirstWarn_Clamp)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SeaSt_Interp_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SeaSt_Interp_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SeaSt_Interp_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SeaSt_Interp_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%n = SrcParamData%n
    DstParamData%delta = SrcParamData%delta
    DstParamData%pZero = SrcParamData%pZero
    DstParamData%Z_Depth = SrcParamData%Z_Depth
 END SUBROUTINE SeaSt_Interp_CopyParam

 SUBROUTINE SeaSt_Interp_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SeaSt_Interp_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SeaSt_Interp_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SeaSt_Interp_DestroyParam


subroutine SeaSt_Interp_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SeaSt_Interp_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SeaSt_Interp_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! n
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegPack(Buf, InData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegPack(Buf, InData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegPack(Buf, InData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SeaSt_Interp_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SeaSt_Interp_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SeaSt_Interp_UnPackParam'
   if (Buf%ErrStat /= ErrID_None) return
   ! n
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z_Depth
   call RegUnpack(Buf, OutData%Z_Depth)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE SeaState_Interp_Types
!ENDOFREGISTRYGENERATEDFILE
