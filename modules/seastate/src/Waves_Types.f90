!STARTOFREGISTRYGENERATEDFILE 'Waves_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Waves_Types
!.................................................................................................................................
! This file is part of Waves.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Waves. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Waves_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  Waves_InitInputType  =======
  TYPE, PUBLIC :: Waves_InitInputType
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    CHARACTER(1024)  :: DirRoot      !< The name of the root file including the full path.  This may be useful if you want this routine to write a permanent record of what it does to be stored with the simulation results: the results should be stored in a file whose name (including path) is generated by appending any suitable extension to DirRoot. [-]
    CHARACTER(1024)  :: WvKinFile      !< The root name of user input wave kinematics files [-]
    REAL(ReKi)  :: Gravity      !< Gravitational acceleration [(m/s^2)]
    INTEGER(IntKi) , DIMENSION(1:3)  :: nGrid      !< Grid dimensions [-]
    REAL(SiKi)  :: WvLowCOff      !< Low cut-off frequency or lower frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WvHiCOff      !< High cut-off frequency or upper frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WaveDir      !< Mean incident wave propagation heading direction [(degrees)]
    INTEGER(IntKi)  :: WaveNDir      !< Number of wave directions [only used if WaveDirMod = 1] [Must be an odd number -- will be adjusted within the waves module] [(-)]
    LOGICAL  :: WaveMultiDir      !< Indicates the waves are multidirectional -- set by HydroDyn_Input [-]
    INTEGER(IntKi)  :: WaveDirMod      !< Directional wave spreading function {0: none, 1: COS2S} [only used if WaveMod=6] [-]
    REAL(SiKi)  :: WaveDirSpread      !< Spreading coefficient [WaveMod=2,3,4 and WaveDirMod=1] [-]
    REAL(SiKi)  :: WaveDirRange      !< Range of wave directions (full range: WaveDir +/- WaveDirRange/2) [only used if WaveMod=6] [(degrees)]
    REAL(DbKi)  :: WaveDT      !< Time step for incident wave calculations [(sec)]
    REAL(SiKi)  :: WaveHs      !< Significant wave height of incident waves [(meters)]
    INTEGER(IntKi)  :: WaveMod      !< Incident wave kinematics model {0: none=still water, 1: plane progressive (regular), 2: JONSWAP/Pierson-Moskowitz spectrum (irregular), 3: white-noise spectrum, 4: user-defind spectrum from routine UserWaveSpctrm (irregular), 5: GH BLADED } [-]
    CHARACTER(80)  :: WaveModChr      !< String to temporarially hold the value of the wave kinematics input line [-]
    LOGICAL  :: WaveNDAmp      !< Flag for normally-distributed amplitudes in incident waves spectrum [flag] [-]
    REAL(SiKi)  :: WavePhase      !< Specified phase for regular waves [(radians)]
    REAL(SiKi)  :: WavePkShp      !< Peak shape parameter of incident wave spectrum [1.0 for Pierson-Moskowitz] [-]
    CHARACTER(80)  :: WavePkShpChr      !< String to temporarially hold value of peak shape parameter input line [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: WaveSeed      !< Random seeds of incident waves [-2147483648 to 2147483647] [-]
    INTEGER(IntKi)  :: WaveStMod      !< Model for stretching incident wave kinematics to instantaneous free surface {0: none=no stretching, 1: vertical stretching, 2: extrapolation stretching, 3: Wheeler stretching} [-]
    REAL(DbKi)  :: WaveTMax      !< Analysis time for incident wave calculations; the actual analysis time may be larger than this value in order for the maintain an effecient FFT [(sec)]
    REAL(SiKi)  :: WaveTp      !< Peak spectral period of incident waves [(sec)]
    REAL(ReKi)  :: WtrDens      !< Water density [(kg/m^3)]
    REAL(ReKi)  :: WtrDpth      !< Water depth [(meters)]
    INTEGER(IntKi)  :: NWaveElevGrid      !< Number of grid points where the incident wave elevations are computed (the XY grid point locations) [-]
    INTEGER(IntKi)  :: NWaveKinGrid      !< Number of grid points where the incident wave kinematics will be computed [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridxi      !< xi-coordinates for grid points where the incident wave kinematics will be computed (grid points); these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridyi      !< yi-coordinates for grid points where the incident wave kinematics will be computed (grid points); these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridzi      !< zi-coordinates for grid points where the incident wave kinematics will be computed (grid points); these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CurrVxi      !< xi-component of the current velocity at elevation i [(m/s)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CurrVyi      !< yi-component of the current velocity at elevation i [(m/s)]
    REAL(SiKi)  :: PCurrVxiPz0      !< xi-component of the partial derivative of the current velocity at elevation near mean sea level [(m/s)]
    REAL(SiKi)  :: PCurrVyiPz0      !< yi-component of the partial derivative of the current velocity at elevation near mean sea level [(m/s)]
    TYPE(NWTC_RandomNumber_ParameterType)  :: RNG      !< Parameters for the pseudo random number generator [-]
    INTEGER(IntKi)  :: ConstWaveMod      !< Mode of the constrained wave [-]
    REAL(SiKi)  :: CrestHmax      !< crest height or double the crest elevation [m]
    REAL(SiKi)  :: CrestTime      !< time of the wave crest [sec]
    REAL(SiKi)  :: CrestXi      !< xi-coordinate for the wave crest [m]
    REAL(SiKi)  :: CrestYi      !< yi-coordinate for the wave crest [m]
    REAL(SiKi)  :: MCFD      !< Diameter of members that will use the MacCamy-Fuchs diffraction model [-]
    INTEGER(IntKi)  :: WaveFieldMod      !< Wave field handling (-) (switch) 0: use individual SeaState inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    REAL(ReKi)  :: PtfmLocationX      !< Supplied by Driver:  X coordinate of platform location in the wave field [m]
    REAL(ReKi)  :: PtfmLocationY      !< Supplied by Driver:  Y coordinate of platform location in the wave field [m]
  END TYPE Waves_InitInputType
! =======================
! =========  Waves_InitOutputType  =======
  TYPE, PUBLIC :: Waves_InitOutputType
    REAL(SiKi) , DIMENSION(:,:), POINTER  :: WaveElevC0 => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveElevC      !< Discrete Fourier transform of the instantaneous elevation of incident waves at all grid points.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveDirArr => NULL()      !< Wave direction array.  Each frequency has a unique direction of WaveNDir > 1 [(degrees)]
    REAL(SiKi)  :: WaveDirMin      !< Minimum wave direction. [(degrees)]
    REAL(SiKi)  :: WaveDirMax      !< Maximum wave direction. [(degrees)]
    INTEGER(IntKi)  :: WaveNDir      !< Number of wave directions [only used if WaveDirMod = 1] [Must be an odd number -- will be adjusted within the waves module] [(-)]
    REAL(SiKi)  :: WaveDOmega      !< Frequency step for incident wave calculations [(rad/s)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: WaveDynP => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAcc => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAccMCF => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveVel => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: PWaveDynP0 => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAcc0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAccMCF0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveVel0 => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev => NULL()      !< Instantaneous elevation time-series of incident waves at each of the  XY grid points [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElev0      !< Instantaneous elevation time-series of incident waves at the platform reference point [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Simulation times at which the instantaneous elevation of, velocity of, acceleration of, and loads associated with the incident waves are determined [(sec)]
    REAL(DbKi)  :: WaveTMax      !< Analysis time for incident wave calculations; the actual analysis time may be larger than this value in order for the maintain an effecient FFT [(sec)]
    REAL(SiKi)  :: RhoXg      !< = WtrDens*Gravity [-]
    INTEGER(IntKi)  :: NStepWave      !< Total number of frequency components = total number of time steps in the incident wave [-]
    INTEGER(IntKi)  :: NStepWave2      !< NStepWave / 2 [-]
  END TYPE Waves_InitOutputType
! =======================
CONTAINS
 SUBROUTINE Waves_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(Waves_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%DirRoot = SrcInitInputData%DirRoot
    DstInitInputData%WvKinFile = SrcInitInputData%WvKinFile
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%nGrid = SrcInitInputData%nGrid
    DstInitInputData%WvLowCOff = SrcInitInputData%WvLowCOff
    DstInitInputData%WvHiCOff = SrcInitInputData%WvHiCOff
    DstInitInputData%WaveDir = SrcInitInputData%WaveDir
    DstInitInputData%WaveNDir = SrcInitInputData%WaveNDir
    DstInitInputData%WaveMultiDir = SrcInitInputData%WaveMultiDir
    DstInitInputData%WaveDirMod = SrcInitInputData%WaveDirMod
    DstInitInputData%WaveDirSpread = SrcInitInputData%WaveDirSpread
    DstInitInputData%WaveDirRange = SrcInitInputData%WaveDirRange
    DstInitInputData%WaveDT = SrcInitInputData%WaveDT
    DstInitInputData%WaveHs = SrcInitInputData%WaveHs
    DstInitInputData%WaveMod = SrcInitInputData%WaveMod
    DstInitInputData%WaveModChr = SrcInitInputData%WaveModChr
    DstInitInputData%WaveNDAmp = SrcInitInputData%WaveNDAmp
    DstInitInputData%WavePhase = SrcInitInputData%WavePhase
    DstInitInputData%WavePkShp = SrcInitInputData%WavePkShp
    DstInitInputData%WavePkShpChr = SrcInitInputData%WavePkShpChr
    DstInitInputData%WaveSeed = SrcInitInputData%WaveSeed
    DstInitInputData%WaveStMod = SrcInitInputData%WaveStMod
    DstInitInputData%WaveTMax = SrcInitInputData%WaveTMax
    DstInitInputData%WaveTp = SrcInitInputData%WaveTp
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%NWaveElevGrid = SrcInitInputData%NWaveElevGrid
    DstInitInputData%NWaveKinGrid = SrcInitInputData%NWaveKinGrid
IF (ALLOCATED(SrcInitInputData%WaveKinGridxi)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveKinGridxi,1)
  i1_u = UBOUND(SrcInitInputData%WaveKinGridxi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveKinGridxi)) THEN 
    ALLOCATE(DstInitInputData%WaveKinGridxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveKinGridxi = SrcInitInputData%WaveKinGridxi
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveKinGridyi)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveKinGridyi,1)
  i1_u = UBOUND(SrcInitInputData%WaveKinGridyi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveKinGridyi)) THEN 
    ALLOCATE(DstInitInputData%WaveKinGridyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveKinGridyi = SrcInitInputData%WaveKinGridyi
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveKinGridzi)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveKinGridzi,1)
  i1_u = UBOUND(SrcInitInputData%WaveKinGridzi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveKinGridzi)) THEN 
    ALLOCATE(DstInitInputData%WaveKinGridzi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridzi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveKinGridzi = SrcInitInputData%WaveKinGridzi
ENDIF
IF (ALLOCATED(SrcInitInputData%CurrVxi)) THEN
  i1_l = LBOUND(SrcInitInputData%CurrVxi,1)
  i1_u = UBOUND(SrcInitInputData%CurrVxi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CurrVxi)) THEN 
    ALLOCATE(DstInitInputData%CurrVxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CurrVxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%CurrVxi = SrcInitInputData%CurrVxi
ENDIF
IF (ALLOCATED(SrcInitInputData%CurrVyi)) THEN
  i1_l = LBOUND(SrcInitInputData%CurrVyi,1)
  i1_u = UBOUND(SrcInitInputData%CurrVyi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CurrVyi)) THEN 
    ALLOCATE(DstInitInputData%CurrVyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CurrVyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%CurrVyi = SrcInitInputData%CurrVyi
ENDIF
    DstInitInputData%PCurrVxiPz0 = SrcInitInputData%PCurrVxiPz0
    DstInitInputData%PCurrVyiPz0 = SrcInitInputData%PCurrVyiPz0
      CALL NWTC_Library_Copynwtc_randomnumber_parametertype( SrcInitInputData%RNG, DstInitInputData%RNG, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%ConstWaveMod = SrcInitInputData%ConstWaveMod
    DstInitInputData%CrestHmax = SrcInitInputData%CrestHmax
    DstInitInputData%CrestTime = SrcInitInputData%CrestTime
    DstInitInputData%CrestXi = SrcInitInputData%CrestXi
    DstInitInputData%CrestYi = SrcInitInputData%CrestYi
    DstInitInputData%MCFD = SrcInitInputData%MCFD
    DstInitInputData%WaveFieldMod = SrcInitInputData%WaveFieldMod
    DstInitInputData%PtfmLocationX = SrcInitInputData%PtfmLocationX
    DstInitInputData%PtfmLocationY = SrcInitInputData%PtfmLocationY
 END SUBROUTINE Waves_CopyInitInput

 SUBROUTINE Waves_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Waves_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Waves_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%WaveKinGridxi)) THEN
  DEALLOCATE(InitInputData%WaveKinGridxi)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinGridyi)) THEN
  DEALLOCATE(InitInputData%WaveKinGridyi)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinGridzi)) THEN
  DEALLOCATE(InitInputData%WaveKinGridzi)
ENDIF
IF (ALLOCATED(InitInputData%CurrVxi)) THEN
  DEALLOCATE(InitInputData%CurrVxi)
ENDIF
IF (ALLOCATED(InitInputData%CurrVyi)) THEN
  DEALLOCATE(InitInputData%CurrVyi)
ENDIF
  CALL NWTC_Library_DestroyNWTC_RandomNumber_ParameterType( InitInputData%RNG, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE Waves_DestroyInitInput


subroutine Waves_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Waves_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Waves_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DirRoot
   call RegPack(Buf, InData%DirRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvKinFile
   call RegPack(Buf, InData%WvKinFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nGrid
   call RegPack(Buf, InData%nGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegPack(Buf, InData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegPack(Buf, InData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegPack(Buf, InData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveNDir
   call RegPack(Buf, InData%WaveNDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegPack(Buf, InData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMod
   call RegPack(Buf, InData%WaveDirMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirSpread
   call RegPack(Buf, InData%WaveDirSpread)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirRange
   call RegPack(Buf, InData%WaveDirRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDT
   call RegPack(Buf, InData%WaveDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveHs
   call RegPack(Buf, InData%WaveHs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegPack(Buf, InData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveModChr
   call RegPack(Buf, InData%WaveModChr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveNDAmp
   call RegPack(Buf, InData%WaveNDAmp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WavePhase
   call RegPack(Buf, InData%WavePhase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WavePkShp
   call RegPack(Buf, InData%WavePkShp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WavePkShpChr
   call RegPack(Buf, InData%WavePkShpChr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveSeed
   call RegPack(Buf, InData%WaveSeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegPack(Buf, InData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTMax
   call RegPack(Buf, InData%WaveTMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTp
   call RegPack(Buf, InData%WaveTp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElevGrid
   call RegPack(Buf, InData%NWaveElevGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveKinGrid
   call RegPack(Buf, InData%NWaveKinGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinGridxi
   call RegPack(Buf, allocated(InData%WaveKinGridxi))
   if (allocated(InData%WaveKinGridxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinGridxi), ubound(InData%WaveKinGridxi))
      call RegPack(Buf, InData%WaveKinGridxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinGridyi
   call RegPack(Buf, allocated(InData%WaveKinGridyi))
   if (allocated(InData%WaveKinGridyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinGridyi), ubound(InData%WaveKinGridyi))
      call RegPack(Buf, InData%WaveKinGridyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinGridzi
   call RegPack(Buf, allocated(InData%WaveKinGridzi))
   if (allocated(InData%WaveKinGridzi)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveKinGridzi), ubound(InData%WaveKinGridzi))
      call RegPack(Buf, InData%WaveKinGridzi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CurrVxi
   call RegPack(Buf, allocated(InData%CurrVxi))
   if (allocated(InData%CurrVxi)) then
      call RegPackBounds(Buf, 1, lbound(InData%CurrVxi), ubound(InData%CurrVxi))
      call RegPack(Buf, InData%CurrVxi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CurrVyi
   call RegPack(Buf, allocated(InData%CurrVyi))
   if (allocated(InData%CurrVyi)) then
      call RegPackBounds(Buf, 1, lbound(InData%CurrVyi), ubound(InData%CurrVyi))
      call RegPack(Buf, InData%CurrVyi)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCurrVxiPz0
   call RegPack(Buf, InData%PCurrVxiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCurrVyiPz0
   call RegPack(Buf, InData%PCurrVyiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RNG
   call NWTC_Library_PackNWTC_RandomNumber_ParameterType(Buf, InData%RNG) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConstWaveMod
   call RegPack(Buf, InData%ConstWaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestHmax
   call RegPack(Buf, InData%CrestHmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestTime
   call RegPack(Buf, InData%CrestTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestXi
   call RegPack(Buf, InData%CrestXi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestYi
   call RegPack(Buf, InData%CrestYi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MCFD
   call RegPack(Buf, InData%MCFD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegPack(Buf, InData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationX
   call RegPack(Buf, InData%PtfmLocationX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationY
   call RegPack(Buf, InData%PtfmLocationY)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Waves_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Waves_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Waves_UnPackInitInput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DirRoot
   call RegUnpack(Buf, OutData%DirRoot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvKinFile
   call RegUnpack(Buf, OutData%WvKinFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nGrid
   call RegUnpack(Buf, OutData%nGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegUnpack(Buf, OutData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegUnpack(Buf, OutData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegUnpack(Buf, OutData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveNDir
   call RegUnpack(Buf, OutData%WaveNDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegUnpack(Buf, OutData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMod
   call RegUnpack(Buf, OutData%WaveDirMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirSpread
   call RegUnpack(Buf, OutData%WaveDirSpread)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirRange
   call RegUnpack(Buf, OutData%WaveDirRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDT
   call RegUnpack(Buf, OutData%WaveDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveHs
   call RegUnpack(Buf, OutData%WaveHs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegUnpack(Buf, OutData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveModChr
   call RegUnpack(Buf, OutData%WaveModChr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveNDAmp
   call RegUnpack(Buf, OutData%WaveNDAmp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WavePhase
   call RegUnpack(Buf, OutData%WavePhase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WavePkShp
   call RegUnpack(Buf, OutData%WavePkShp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WavePkShpChr
   call RegUnpack(Buf, OutData%WavePkShpChr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveSeed
   call RegUnpack(Buf, OutData%WaveSeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegUnpack(Buf, OutData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTMax
   call RegUnpack(Buf, OutData%WaveTMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTp
   call RegUnpack(Buf, OutData%WaveTp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveElevGrid
   call RegUnpack(Buf, OutData%NWaveElevGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NWaveKinGrid
   call RegUnpack(Buf, OutData%NWaveKinGrid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKinGridxi
   if (allocated(OutData%WaveKinGridxi)) deallocate(OutData%WaveKinGridxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinGridxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinGridxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveKinGridyi
   if (allocated(OutData%WaveKinGridyi)) deallocate(OutData%WaveKinGridyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinGridyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinGridyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveKinGridzi
   if (allocated(OutData%WaveKinGridzi)) deallocate(OutData%WaveKinGridzi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveKinGridzi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridzi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveKinGridzi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CurrVxi
   if (allocated(OutData%CurrVxi)) deallocate(OutData%CurrVxi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CurrVxi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CurrVxi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CurrVxi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CurrVyi
   if (allocated(OutData%CurrVyi)) deallocate(OutData%CurrVyi)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CurrVyi(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CurrVyi.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CurrVyi)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PCurrVxiPz0
   call RegUnpack(Buf, OutData%PCurrVxiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PCurrVyiPz0
   call RegUnpack(Buf, OutData%PCurrVyiPz0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RNG
   call NWTC_Library_UnpackNWTC_RandomNumber_ParameterType(Buf, OutData%RNG) ! RNG 
   ! ConstWaveMod
   call RegUnpack(Buf, OutData%ConstWaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestHmax
   call RegUnpack(Buf, OutData%CrestHmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestTime
   call RegUnpack(Buf, OutData%CrestTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestXi
   call RegUnpack(Buf, OutData%CrestXi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CrestYi
   call RegUnpack(Buf, OutData%CrestYi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MCFD
   call RegUnpack(Buf, OutData%MCFD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveFieldMod
   call RegUnpack(Buf, OutData%WaveFieldMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationX
   call RegUnpack(Buf, OutData%PtfmLocationX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationY
   call RegUnpack(Buf, OutData%PtfmLocationY)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Waves_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(Waves_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%WaveElevC0 => SrcInitOutputData%WaveElevC0
IF (ALLOCATED(SrcInitOutputData%WaveElevC)) THEN
  i1_l = LBOUND(SrcInitOutputData%WaveElevC,1)
  i1_u = UBOUND(SrcInitOutputData%WaveElevC,1)
  i2_l = LBOUND(SrcInitOutputData%WaveElevC,2)
  i2_u = UBOUND(SrcInitOutputData%WaveElevC,2)
  i3_l = LBOUND(SrcInitOutputData%WaveElevC,3)
  i3_u = UBOUND(SrcInitOutputData%WaveElevC,3)
  IF (.NOT. ALLOCATED(DstInitOutputData%WaveElevC)) THEN 
    ALLOCATE(DstInitOutputData%WaveElevC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WaveElevC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WaveElevC = SrcInitOutputData%WaveElevC
ENDIF
    DstInitOutputData%WaveDirArr => SrcInitOutputData%WaveDirArr
    DstInitOutputData%WaveDirMin = SrcInitOutputData%WaveDirMin
    DstInitOutputData%WaveDirMax = SrcInitOutputData%WaveDirMax
    DstInitOutputData%WaveNDir = SrcInitOutputData%WaveNDir
    DstInitOutputData%WaveDOmega = SrcInitOutputData%WaveDOmega
    DstInitOutputData%WaveDynP => SrcInitOutputData%WaveDynP
    DstInitOutputData%WaveAcc => SrcInitOutputData%WaveAcc
    DstInitOutputData%WaveAccMCF => SrcInitOutputData%WaveAccMCF
    DstInitOutputData%WaveVel => SrcInitOutputData%WaveVel
    DstInitOutputData%PWaveDynP0 => SrcInitOutputData%PWaveDynP0
    DstInitOutputData%PWaveAcc0 => SrcInitOutputData%PWaveAcc0
    DstInitOutputData%PWaveAccMCF0 => SrcInitOutputData%PWaveAccMCF0
    DstInitOutputData%PWaveVel0 => SrcInitOutputData%PWaveVel0
    DstInitOutputData%WaveElev => SrcInitOutputData%WaveElev
IF (ALLOCATED(SrcInitOutputData%WaveElev0)) THEN
  i1_l = LBOUND(SrcInitOutputData%WaveElev0,1)
  i1_u = UBOUND(SrcInitOutputData%WaveElev0,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WaveElev0)) THEN 
    ALLOCATE(DstInitOutputData%WaveElev0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WaveElev0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WaveElev0 = SrcInitOutputData%WaveElev0
ENDIF
    DstInitOutputData%WaveTime => SrcInitOutputData%WaveTime
    DstInitOutputData%WaveTMax = SrcInitOutputData%WaveTMax
    DstInitOutputData%RhoXg = SrcInitOutputData%RhoXg
    DstInitOutputData%NStepWave = SrcInitOutputData%NStepWave
    DstInitOutputData%NStepWave2 = SrcInitOutputData%NStepWave2
 END SUBROUTINE Waves_CopyInitOutput

 SUBROUTINE Waves_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Waves_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Waves_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

NULLIFY(InitOutputData%WaveElevC0)
IF (ALLOCATED(InitOutputData%WaveElevC)) THEN
  DEALLOCATE(InitOutputData%WaveElevC)
ENDIF
NULLIFY(InitOutputData%WaveDirArr)
NULLIFY(InitOutputData%WaveDynP)
NULLIFY(InitOutputData%WaveAcc)
NULLIFY(InitOutputData%WaveAccMCF)
NULLIFY(InitOutputData%WaveVel)
NULLIFY(InitOutputData%PWaveDynP0)
NULLIFY(InitOutputData%PWaveAcc0)
NULLIFY(InitOutputData%PWaveAccMCF0)
NULLIFY(InitOutputData%PWaveVel0)
NULLIFY(InitOutputData%WaveElev)
IF (ALLOCATED(InitOutputData%WaveElev0)) THEN
  DEALLOCATE(InitOutputData%WaveElev0)
ENDIF
NULLIFY(InitOutputData%WaveTime)
 END SUBROUTINE Waves_DestroyInitOutput


subroutine Waves_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Waves_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Waves_PackInitOutput'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! WaveElevC0
   call RegPack(Buf, associated(InData%WaveElevC0))
   if (associated(InData%WaveElevC0)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevC0), ubound(InData%WaveElevC0))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC
   call RegPack(Buf, allocated(InData%WaveElevC))
   if (allocated(InData%WaveElevC)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElevC), ubound(InData%WaveElevC))
      call RegPack(Buf, InData%WaveElevC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   call RegPack(Buf, associated(InData%WaveDirArr))
   if (associated(InData%WaveDirArr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveDirArr), ubound(InData%WaveDirArr))
      call RegPackPointer(Buf, c_loc(InData%WaveDirArr), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDirArr)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMin
   call RegPack(Buf, InData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegPack(Buf, InData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveNDir
   call RegPack(Buf, InData%WaveNDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegPack(Buf, InData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDynP
   call RegPack(Buf, associated(InData%WaveDynP))
   if (associated(InData%WaveDynP)) then
      call RegPackBounds(Buf, 4, lbound(InData%WaveDynP), ubound(InData%WaveDynP))
      call RegPackPointer(Buf, c_loc(InData%WaveDynP), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDynP)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAcc
   call RegPack(Buf, associated(InData%WaveAcc))
   if (associated(InData%WaveAcc)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveAcc), ubound(InData%WaveAcc))
      call RegPackPointer(Buf, c_loc(InData%WaveAcc), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveAcc)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveAccMCF
   call RegPack(Buf, associated(InData%WaveAccMCF))
   if (associated(InData%WaveAccMCF)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveAccMCF), ubound(InData%WaveAccMCF))
      call RegPackPointer(Buf, c_loc(InData%WaveAccMCF), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveAccMCF)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveVel
   call RegPack(Buf, associated(InData%WaveVel))
   if (associated(InData%WaveVel)) then
      call RegPackBounds(Buf, 5, lbound(InData%WaveVel), ubound(InData%WaveVel))
      call RegPackPointer(Buf, c_loc(InData%WaveVel), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveVel)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveDynP0
   call RegPack(Buf, associated(InData%PWaveDynP0))
   if (associated(InData%PWaveDynP0)) then
      call RegPackBounds(Buf, 3, lbound(InData%PWaveDynP0), ubound(InData%PWaveDynP0))
      call RegPackPointer(Buf, c_loc(InData%PWaveDynP0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveDynP0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveAcc0
   call RegPack(Buf, associated(InData%PWaveAcc0))
   if (associated(InData%PWaveAcc0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveAcc0), ubound(InData%PWaveAcc0))
      call RegPackPointer(Buf, c_loc(InData%PWaveAcc0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveAcc0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveAccMCF0
   call RegPack(Buf, associated(InData%PWaveAccMCF0))
   if (associated(InData%PWaveAccMCF0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveAccMCF0), ubound(InData%PWaveAccMCF0))
      call RegPackPointer(Buf, c_loc(InData%PWaveAccMCF0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveAccMCF0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PWaveVel0
   call RegPack(Buf, associated(InData%PWaveVel0))
   if (associated(InData%PWaveVel0)) then
      call RegPackBounds(Buf, 4, lbound(InData%PWaveVel0), ubound(InData%PWaveVel0))
      call RegPackPointer(Buf, c_loc(InData%PWaveVel0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%PWaveVel0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev
   call RegPack(Buf, associated(InData%WaveElev))
   if (associated(InData%WaveElev)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev), ubound(InData%WaveElev))
      call RegPackPointer(Buf, c_loc(InData%WaveElev), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   call RegPack(Buf, allocated(InData%WaveElev0))
   if (allocated(InData%WaveElev0)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElev0), ubound(InData%WaveElev0))
      call RegPack(Buf, InData%WaveElev0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTMax
   call RegPack(Buf, InData%WaveTMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegPack(Buf, InData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegPack(Buf, InData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Waves_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Waves_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Waves_UnPackInitOutput'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! WaveElevC0
   if (associated(OutData%WaveElevC0)) deallocate(OutData%WaveElevC0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC0, UB(1:2)-LB(1:2))
         OutData%WaveElevC0(LB(1):,LB(2):) => OutData%WaveElevC0
      else
         allocate(OutData%WaveElevC0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC0)
         call RegUnpack(Buf, OutData%WaveElevC0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC0 => null()
   end if
   ! WaveElevC
   if (allocated(OutData%WaveElevC)) deallocate(OutData%WaveElevC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveDirArr
   if (associated(OutData%WaveDirArr)) deallocate(OutData%WaveDirArr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDirArr, UB(1:1)-LB(1:1))
         OutData%WaveDirArr(LB(1):) => OutData%WaveDirArr
      else
         allocate(OutData%WaveDirArr(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDirArr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDirArr)
         call RegUnpack(Buf, OutData%WaveDirArr)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDirArr => null()
   end if
   ! WaveDirMin
   call RegUnpack(Buf, OutData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegUnpack(Buf, OutData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveNDir
   call RegUnpack(Buf, OutData%WaveNDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegUnpack(Buf, OutData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDynP
   if (associated(OutData%WaveDynP)) deallocate(OutData%WaveDynP)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDynP, UB(1:4)-LB(1:4))
         OutData%WaveDynP(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%WaveDynP
      else
         allocate(OutData%WaveDynP(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDynP.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDynP)
         call RegUnpack(Buf, OutData%WaveDynP)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDynP => null()
   end if
   ! WaveAcc
   if (associated(OutData%WaveAcc)) deallocate(OutData%WaveAcc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveAcc, UB(1:5)-LB(1:5))
         OutData%WaveAcc(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveAcc
      else
         allocate(OutData%WaveAcc(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveAcc)
         call RegUnpack(Buf, OutData%WaveAcc)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveAcc => null()
   end if
   ! WaveAccMCF
   if (associated(OutData%WaveAccMCF)) deallocate(OutData%WaveAccMCF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveAccMCF, UB(1:5)-LB(1:5))
         OutData%WaveAccMCF(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveAccMCF
      else
         allocate(OutData%WaveAccMCF(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAccMCF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveAccMCF)
         call RegUnpack(Buf, OutData%WaveAccMCF)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveAccMCF => null()
   end if
   ! WaveVel
   if (associated(OutData%WaveVel)) deallocate(OutData%WaveVel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveVel, UB(1:5)-LB(1:5))
         OutData%WaveVel(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%WaveVel
      else
         allocate(OutData%WaveVel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveVel)
         call RegUnpack(Buf, OutData%WaveVel)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveVel => null()
   end if
   ! PWaveDynP0
   if (associated(OutData%PWaveDynP0)) deallocate(OutData%PWaveDynP0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveDynP0, UB(1:3)-LB(1:3))
         OutData%PWaveDynP0(LB(1):,LB(2):,LB(3):) => OutData%PWaveDynP0
      else
         allocate(OutData%PWaveDynP0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveDynP0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveDynP0)
         call RegUnpack(Buf, OutData%PWaveDynP0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveDynP0 => null()
   end if
   ! PWaveAcc0
   if (associated(OutData%PWaveAcc0)) deallocate(OutData%PWaveAcc0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveAcc0, UB(1:4)-LB(1:4))
         OutData%PWaveAcc0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveAcc0
      else
         allocate(OutData%PWaveAcc0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveAcc0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveAcc0)
         call RegUnpack(Buf, OutData%PWaveAcc0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveAcc0 => null()
   end if
   ! PWaveAccMCF0
   if (associated(OutData%PWaveAccMCF0)) deallocate(OutData%PWaveAccMCF0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveAccMCF0, UB(1:4)-LB(1:4))
         OutData%PWaveAccMCF0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveAccMCF0
      else
         allocate(OutData%PWaveAccMCF0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveAccMCF0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveAccMCF0)
         call RegUnpack(Buf, OutData%PWaveAccMCF0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveAccMCF0 => null()
   end if
   ! PWaveVel0
   if (associated(OutData%PWaveVel0)) deallocate(OutData%PWaveVel0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%PWaveVel0, UB(1:4)-LB(1:4))
         OutData%PWaveVel0(LB(1):,LB(2):,LB(3):,LB(4):) => OutData%PWaveVel0
      else
         allocate(OutData%PWaveVel0(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PWaveVel0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%PWaveVel0)
         call RegUnpack(Buf, OutData%PWaveVel0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%PWaveVel0 => null()
   end if
   ! WaveElev
   if (associated(OutData%WaveElev)) deallocate(OutData%WaveElev)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev, UB(1:3)-LB(1:3))
         OutData%WaveElev(LB(1):,LB(2):,LB(3):) => OutData%WaveElev
      else
         allocate(OutData%WaveElev(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev)
         call RegUnpack(Buf, OutData%WaveElev)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev => null()
   end if
   ! WaveElev0
   if (allocated(OutData%WaveElev0)) deallocate(OutData%WaveElev0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElev0(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElev0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! WaveTMax
   call RegUnpack(Buf, OutData%WaveTMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegUnpack(Buf, OutData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegUnpack(Buf, OutData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE Waves_Types
!ENDOFREGISTRYGENERATEDFILE
