!STARTOFREGISTRYGENERATEDFILE 'Waves_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Waves_Types
!.................................................................................................................................
! This file is part of Waves.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Waves. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Waves_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  Waves_InitInputType  =======
  TYPE, PUBLIC :: Waves_InitInputType
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    CHARACTER(1024)  :: DirRoot      !< The name of the root file including the full path.  This may be useful if you want this routine to write a permanent record of what it does to be stored with the simulation results: the results should be stored in a file whose name (including path) is generated by appending any suitable extension to DirRoot. [-]
    CHARACTER(1024)  :: WvKinFile      !< The root name of user input wave kinematics files [-]
    REAL(ReKi)  :: Gravity      !< Gravitational acceleration [(m/s^2)]
    INTEGER(IntKi) , DIMENSION(1:3)  :: nGrid      !< Grid dimensions [-]
    REAL(SiKi)  :: WvLowCOff      !< Low cut-off frequency or lower frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WvHiCOff      !< High cut-off frequency or upper frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WaveDir      !< Mean incident wave propagation heading direction [(degrees)]
    INTEGER(IntKi)  :: WaveNDir      !< Number of wave directions [only used if WaveDirMod = 1] [Must be an odd number -- will be adjusted within the waves module] [(-)]
    LOGICAL  :: WaveMultiDir      !< Indicates the waves are multidirectional -- set by HydroDyn_Input [-]
    INTEGER(IntKi)  :: WaveDirMod      !< Directional wave spreading function {0: none, 1: COS2S} [only used if WaveMod=6] [-]
    REAL(SiKi)  :: WaveDirSpread      !< Spreading coefficient [WaveMod=2,3,4 and WaveDirMod=1] [-]
    REAL(SiKi)  :: WaveDirRange      !< Range of wave directions (full range: WaveDir +/- WaveDirRange/2) [only used if WaveMod=6] [(degrees)]
    REAL(DbKi)  :: WaveDT      !< Time step for incident wave calculations [(sec)]
    REAL(SiKi)  :: WaveHs      !< Significant wave height of incident waves [(meters)]
    INTEGER(IntKi)  :: WaveMod      !< Incident wave kinematics model {0: none=still water, 1: plane progressive (regular), 2: JONSWAP/Pierson-Moskowitz spectrum (irregular), 3: white-noise spectrum, 4: user-defind spectrum from routine UserWaveSpctrm (irregular), 5: GH BLADED } [-]
    CHARACTER(80)  :: WaveModChr      !< String to temporarially hold the value of the wave kinematics input line [-]
    LOGICAL  :: WaveNDAmp      !< Flag for normally-distributed amplitudes in incident waves spectrum [flag] [-]
    REAL(SiKi)  :: WavePhase      !< Specified phase for regular waves [(radians)]
    REAL(SiKi)  :: WavePkShp      !< Peak shape parameter of incident wave spectrum [1.0 for Pierson-Moskowitz] [-]
    CHARACTER(80)  :: WavePkShpChr      !< String to temporarially hold value of peak shape parameter input line [-]
    INTEGER(IntKi) , DIMENSION(1:2)  :: WaveSeed      !< Random seeds of incident waves [-2147483648 to 2147483647] [-]
    INTEGER(IntKi)  :: WaveStMod      !< Model for stretching incident wave kinematics to instantaneous free surface {0: none=no stretching, 1: vertical stretching, 2: extrapolation stretching, 3: Wheeler stretching} [-]
    REAL(DbKi)  :: WaveTMax      !< Analysis time for incident wave calculations; the actual analysis time may be larger than this value in order for the maintain an effecient FFT [(sec)]
    REAL(SiKi)  :: WaveTp      !< Peak spectral period of incident waves [(sec)]
    REAL(ReKi)  :: WtrDens      !< Water density [(kg/m^3)]
    REAL(ReKi)  :: WtrDpth      !< Water depth [(meters)]
    INTEGER(IntKi)  :: NWaveElevGrid      !< Number of grid points where the incident wave elevations are computed (the XY grid point locations) [-]
    INTEGER(IntKi)  :: NWaveKinGrid      !< Number of grid points where the incident wave kinematics will be computed [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridxi      !< xi-coordinates for grid points where the incident wave kinematics will be computed (grid points); these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridyi      !< yi-coordinates for grid points where the incident wave kinematics will be computed (grid points); these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveKinGridzi      !< zi-coordinates for grid points where the incident wave kinematics will be computed (grid points); these are relative to the mean sea level [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CurrVxi      !< xi-component of the current velocity at elevation i [(m/s)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: CurrVyi      !< yi-component of the current velocity at elevation i [(m/s)]
    REAL(SiKi)  :: PCurrVxiPz0      !< xi-component of the partial derivative of the current velocity at elevation near mean sea level [(m/s)]
    REAL(SiKi)  :: PCurrVyiPz0      !< yi-component of the partial derivative of the current velocity at elevation near mean sea level [(m/s)]
    TYPE(NWTC_RandomNumber_ParameterType)  :: RNG      !< Parameters for the pseudo random number generator [-]
    INTEGER(IntKi)  :: ConstWaveMod      !< Mode of the constrained wave [-]
    REAL(SiKi)  :: CrestHmax      !< crest height or double the crest elevation [m]
    REAL(SiKi)  :: CrestTime      !< time of the wave crest [sec]
    REAL(SiKi)  :: CrestXi      !< xi-coordinate for the wave crest [m]
    REAL(SiKi)  :: CrestYi      !< yi-coordinate for the wave crest [m]
    REAL(SiKi)  :: MCFD      !< Diameter of members that will use the MacCamy-Fuchs diffraction model [-]
    INTEGER(IntKi)  :: WaveFieldMod      !< Wave field handling (-) (switch) 0: use individual SeaState inputs without adjustment, 1: adjust wave phases based on turbine offsets from farm origin [-]
    REAL(ReKi)  :: PtfmLocationX      !< Supplied by Driver:  X coordinate of platform location in the wave field [m]
    REAL(ReKi)  :: PtfmLocationY      !< Supplied by Driver:  Y coordinate of platform location in the wave field [m]
  END TYPE Waves_InitInputType
! =======================
! =========  Waves_InitOutputType  =======
  TYPE, PUBLIC :: Waves_InitOutputType
    REAL(SiKi) , DIMENSION(:,:), POINTER  :: WaveElevC0 => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveElevC      !< Discrete Fourier transform of the instantaneous elevation of incident waves at all grid points.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveDirArr => NULL()      !< Wave direction array.  Each frequency has a unique direction of WaveNDir > 1 [(degrees)]
    REAL(SiKi)  :: WaveDirMin      !< Minimum wave direction. [(degrees)]
    REAL(SiKi)  :: WaveDirMax      !< Maximum wave direction. [(degrees)]
    INTEGER(IntKi)  :: WaveNDir      !< Number of wave directions [only used if WaveDirMod = 1] [Must be an odd number -- will be adjusted within the waves module] [(-)]
    REAL(SiKi)  :: WaveDOmega      !< Frequency step for incident wave calculations [(rad/s)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: WaveDynP => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAcc => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveAccMCF => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: WaveVel => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, accounting for stretching, at each of the NWaveKinGrid points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: PWaveDynP0 => NULL()      !< Instantaneous dynamic pressure of incident waves                                                          , at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(N/m^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAcc0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveAccMCF0 => NULL()      !< Instantaneous acceleration of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed [(m/s^2)]
    REAL(SiKi) , DIMENSION(:,:,:,:), POINTER  :: PWaveVel0 => NULL()      !< Instantaneous velocity     of incident waves in the xi- (1), yi- (2), and zi- (3) directions, respectively, at the location (xi,yi,0), at each of the NWaveKinGrid points where the incident wave kinematics will be computed (The values include both the velocity of incident waves and the velocity of current.) [(m/s)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev => NULL()      !< Instantaneous elevation time-series of incident waves at each of the  XY grid points [(meters)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElev0      !< Instantaneous elevation time-series of incident waves at the platform reference point [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Simulation times at which the instantaneous elevation of, velocity of, acceleration of, and loads associated with the incident waves are determined [(sec)]
    REAL(DbKi)  :: WaveTMax      !< Analysis time for incident wave calculations; the actual analysis time may be larger than this value in order for the maintain an effecient FFT [(sec)]
    REAL(SiKi)  :: RhoXg      !< = WtrDens*Gravity [-]
    INTEGER(IntKi)  :: NStepWave      !< Total number of frequency components = total number of time steps in the incident wave [-]
    INTEGER(IntKi)  :: NStepWave2      !< NStepWave / 2 [-]
  END TYPE Waves_InitOutputType
! =======================
CONTAINS
 SUBROUTINE Waves_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(Waves_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%DirRoot = SrcInitInputData%DirRoot
    DstInitInputData%WvKinFile = SrcInitInputData%WvKinFile
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%nGrid = SrcInitInputData%nGrid
    DstInitInputData%WvLowCOff = SrcInitInputData%WvLowCOff
    DstInitInputData%WvHiCOff = SrcInitInputData%WvHiCOff
    DstInitInputData%WaveDir = SrcInitInputData%WaveDir
    DstInitInputData%WaveNDir = SrcInitInputData%WaveNDir
    DstInitInputData%WaveMultiDir = SrcInitInputData%WaveMultiDir
    DstInitInputData%WaveDirMod = SrcInitInputData%WaveDirMod
    DstInitInputData%WaveDirSpread = SrcInitInputData%WaveDirSpread
    DstInitInputData%WaveDirRange = SrcInitInputData%WaveDirRange
    DstInitInputData%WaveDT = SrcInitInputData%WaveDT
    DstInitInputData%WaveHs = SrcInitInputData%WaveHs
    DstInitInputData%WaveMod = SrcInitInputData%WaveMod
    DstInitInputData%WaveModChr = SrcInitInputData%WaveModChr
    DstInitInputData%WaveNDAmp = SrcInitInputData%WaveNDAmp
    DstInitInputData%WavePhase = SrcInitInputData%WavePhase
    DstInitInputData%WavePkShp = SrcInitInputData%WavePkShp
    DstInitInputData%WavePkShpChr = SrcInitInputData%WavePkShpChr
    DstInitInputData%WaveSeed = SrcInitInputData%WaveSeed
    DstInitInputData%WaveStMod = SrcInitInputData%WaveStMod
    DstInitInputData%WaveTMax = SrcInitInputData%WaveTMax
    DstInitInputData%WaveTp = SrcInitInputData%WaveTp
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%NWaveElevGrid = SrcInitInputData%NWaveElevGrid
    DstInitInputData%NWaveKinGrid = SrcInitInputData%NWaveKinGrid
IF (ALLOCATED(SrcInitInputData%WaveKinGridxi)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveKinGridxi,1)
  i1_u = UBOUND(SrcInitInputData%WaveKinGridxi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveKinGridxi)) THEN 
    ALLOCATE(DstInitInputData%WaveKinGridxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveKinGridxi = SrcInitInputData%WaveKinGridxi
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveKinGridyi)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveKinGridyi,1)
  i1_u = UBOUND(SrcInitInputData%WaveKinGridyi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveKinGridyi)) THEN 
    ALLOCATE(DstInitInputData%WaveKinGridyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveKinGridyi = SrcInitInputData%WaveKinGridyi
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveKinGridzi)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveKinGridzi,1)
  i1_u = UBOUND(SrcInitInputData%WaveKinGridzi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveKinGridzi)) THEN 
    ALLOCATE(DstInitInputData%WaveKinGridzi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveKinGridzi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveKinGridzi = SrcInitInputData%WaveKinGridzi
ENDIF
IF (ALLOCATED(SrcInitInputData%CurrVxi)) THEN
  i1_l = LBOUND(SrcInitInputData%CurrVxi,1)
  i1_u = UBOUND(SrcInitInputData%CurrVxi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CurrVxi)) THEN 
    ALLOCATE(DstInitInputData%CurrVxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CurrVxi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%CurrVxi = SrcInitInputData%CurrVxi
ENDIF
IF (ALLOCATED(SrcInitInputData%CurrVyi)) THEN
  i1_l = LBOUND(SrcInitInputData%CurrVyi,1)
  i1_u = UBOUND(SrcInitInputData%CurrVyi,1)
  IF (.NOT. ALLOCATED(DstInitInputData%CurrVyi)) THEN 
    ALLOCATE(DstInitInputData%CurrVyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%CurrVyi.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%CurrVyi = SrcInitInputData%CurrVyi
ENDIF
    DstInitInputData%PCurrVxiPz0 = SrcInitInputData%PCurrVxiPz0
    DstInitInputData%PCurrVyiPz0 = SrcInitInputData%PCurrVyiPz0
      CALL NWTC_Library_Copynwtc_randomnumber_parametertype( SrcInitInputData%RNG, DstInitInputData%RNG, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%ConstWaveMod = SrcInitInputData%ConstWaveMod
    DstInitInputData%CrestHmax = SrcInitInputData%CrestHmax
    DstInitInputData%CrestTime = SrcInitInputData%CrestTime
    DstInitInputData%CrestXi = SrcInitInputData%CrestXi
    DstInitInputData%CrestYi = SrcInitInputData%CrestYi
    DstInitInputData%MCFD = SrcInitInputData%MCFD
    DstInitInputData%WaveFieldMod = SrcInitInputData%WaveFieldMod
    DstInitInputData%PtfmLocationX = SrcInitInputData%PtfmLocationX
    DstInitInputData%PtfmLocationY = SrcInitInputData%PtfmLocationY
 END SUBROUTINE Waves_CopyInitInput

 SUBROUTINE Waves_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Waves_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Waves_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%WaveKinGridxi)) THEN
  DEALLOCATE(InitInputData%WaveKinGridxi)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinGridyi)) THEN
  DEALLOCATE(InitInputData%WaveKinGridyi)
ENDIF
IF (ALLOCATED(InitInputData%WaveKinGridzi)) THEN
  DEALLOCATE(InitInputData%WaveKinGridzi)
ENDIF
IF (ALLOCATED(InitInputData%CurrVxi)) THEN
  DEALLOCATE(InitInputData%CurrVxi)
ENDIF
IF (ALLOCATED(InitInputData%CurrVyi)) THEN
  DEALLOCATE(InitInputData%CurrVyi)
ENDIF
  CALL NWTC_Library_DestroyNWTC_RandomNumber_ParameterType( InitInputData%RNG, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE Waves_DestroyInitInput

 SUBROUTINE Waves_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%InputFile)  ! InputFile
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%DirRoot)  ! DirRoot
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%WvKinFile)  ! WvKinFile
      Re_BufSz   = Re_BufSz   + 1  ! Gravity
      Int_BufSz  = Int_BufSz  + SIZE(InData%nGrid)  ! nGrid
      Re_BufSz   = Re_BufSz   + 1  ! WvLowCOff
      Re_BufSz   = Re_BufSz   + 1  ! WvHiCOff
      Re_BufSz   = Re_BufSz   + 1  ! WaveDir
      Int_BufSz  = Int_BufSz  + 1  ! WaveNDir
      Int_BufSz  = Int_BufSz  + 1  ! WaveMultiDir
      Int_BufSz  = Int_BufSz  + 1  ! WaveDirMod
      Re_BufSz   = Re_BufSz   + 1  ! WaveDirSpread
      Re_BufSz   = Re_BufSz   + 1  ! WaveDirRange
      Db_BufSz   = Db_BufSz   + 1  ! WaveDT
      Re_BufSz   = Re_BufSz   + 1  ! WaveHs
      Int_BufSz  = Int_BufSz  + 1  ! WaveMod
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%WaveModChr)  ! WaveModChr
      Int_BufSz  = Int_BufSz  + 1  ! WaveNDAmp
      Re_BufSz   = Re_BufSz   + 1  ! WavePhase
      Re_BufSz   = Re_BufSz   + 1  ! WavePkShp
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%WavePkShpChr)  ! WavePkShpChr
      Int_BufSz  = Int_BufSz  + SIZE(InData%WaveSeed)  ! WaveSeed
      Int_BufSz  = Int_BufSz  + 1  ! WaveStMod
      Db_BufSz   = Db_BufSz   + 1  ! WaveTMax
      Re_BufSz   = Re_BufSz   + 1  ! WaveTp
      Re_BufSz   = Re_BufSz   + 1  ! WtrDens
      Re_BufSz   = Re_BufSz   + 1  ! WtrDpth
      Int_BufSz  = Int_BufSz  + 1  ! NWaveElevGrid
      Int_BufSz  = Int_BufSz  + 1  ! NWaveKinGrid
  Int_BufSz   = Int_BufSz   + 1     ! WaveKinGridxi allocated yes/no
  IF ( ALLOCATED(InData%WaveKinGridxi) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveKinGridxi upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveKinGridxi)  ! WaveKinGridxi
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveKinGridyi allocated yes/no
  IF ( ALLOCATED(InData%WaveKinGridyi) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveKinGridyi upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveKinGridyi)  ! WaveKinGridyi
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveKinGridzi allocated yes/no
  IF ( ALLOCATED(InData%WaveKinGridzi) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveKinGridzi upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveKinGridzi)  ! WaveKinGridzi
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CurrVxi allocated yes/no
  IF ( ALLOCATED(InData%CurrVxi) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CurrVxi upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CurrVxi)  ! CurrVxi
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CurrVyi allocated yes/no
  IF ( ALLOCATED(InData%CurrVyi) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! CurrVyi upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CurrVyi)  ! CurrVyi
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! PCurrVxiPz0
      Re_BufSz   = Re_BufSz   + 1  ! PCurrVyiPz0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! RNG: size of buffers for each call to pack subtype
      CALL NWTC_Library_PackNWTC_RandomNumber_ParameterType( Re_Buf, Db_Buf, Int_Buf, InData%RNG, ErrStat2, ErrMsg2, .TRUE. ) ! RNG 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! RNG
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! RNG
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! RNG
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz  = Int_BufSz  + 1  ! ConstWaveMod
      Re_BufSz   = Re_BufSz   + 1  ! CrestHmax
      Re_BufSz   = Re_BufSz   + 1  ! CrestTime
      Re_BufSz   = Re_BufSz   + 1  ! CrestXi
      Re_BufSz   = Re_BufSz   + 1  ! CrestYi
      Re_BufSz   = Re_BufSz   + 1  ! MCFD
      Int_BufSz  = Int_BufSz  + 1  ! WaveFieldMod
      Re_BufSz   = Re_BufSz   + 1  ! PtfmLocationX
      Re_BufSz   = Re_BufSz   + 1  ! PtfmLocationY
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    DO I = 1, LEN(InData%InputFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%InputFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%DirRoot)
      IntKiBuf(Int_Xferred) = ICHAR(InData%DirRoot(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%WvKinFile)
      IntKiBuf(Int_Xferred) = ICHAR(InData%WvKinFile(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    ReKiBuf(Re_Xferred) = InData%Gravity
    Re_Xferred = Re_Xferred + 1
    DO i1 = LBOUND(InData%nGrid,1), UBOUND(InData%nGrid,1)
      IntKiBuf(Int_Xferred) = InData%nGrid(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    ReKiBuf(Re_Xferred) = InData%WvLowCOff
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WvHiCOff
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveDir
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WaveNDir
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = TRANSFER(InData%WaveMultiDir, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WaveDirMod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveDirSpread
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveDirRange
    Re_Xferred = Re_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%WaveDT
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveHs
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WaveMod
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%WaveModChr)
      IntKiBuf(Int_Xferred) = ICHAR(InData%WaveModChr(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = TRANSFER(InData%WaveNDAmp, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WavePhase
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WavePkShp
    Re_Xferred = Re_Xferred + 1
    DO I = 1, LEN(InData%WavePkShpChr)
      IntKiBuf(Int_Xferred) = ICHAR(InData%WavePkShpChr(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO i1 = LBOUND(InData%WaveSeed,1), UBOUND(InData%WaveSeed,1)
      IntKiBuf(Int_Xferred) = InData%WaveSeed(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%WaveStMod
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%WaveTMax
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveTp
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDens
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDpth
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NWaveElevGrid
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NWaveKinGrid
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%WaveKinGridxi) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveKinGridxi,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveKinGridxi,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveKinGridxi,1), UBOUND(InData%WaveKinGridxi,1)
        ReKiBuf(Re_Xferred) = InData%WaveKinGridxi(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveKinGridyi) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveKinGridyi,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveKinGridyi,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveKinGridyi,1), UBOUND(InData%WaveKinGridyi,1)
        ReKiBuf(Re_Xferred) = InData%WaveKinGridyi(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveKinGridzi) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveKinGridzi,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveKinGridzi,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveKinGridzi,1), UBOUND(InData%WaveKinGridzi,1)
        ReKiBuf(Re_Xferred) = InData%WaveKinGridzi(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CurrVxi) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CurrVxi,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CurrVxi,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%CurrVxi,1), UBOUND(InData%CurrVxi,1)
        ReKiBuf(Re_Xferred) = InData%CurrVxi(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CurrVyi) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CurrVyi,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CurrVyi,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%CurrVyi,1), UBOUND(InData%CurrVyi,1)
        ReKiBuf(Re_Xferred) = InData%CurrVyi(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%PCurrVxiPz0
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PCurrVyiPz0
    Re_Xferred = Re_Xferred + 1
      CALL NWTC_Library_PackNWTC_RandomNumber_ParameterType( Re_Buf, Db_Buf, Int_Buf, InData%RNG, ErrStat2, ErrMsg2, OnlySize ) ! RNG 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    IntKiBuf(Int_Xferred) = InData%ConstWaveMod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CrestHmax
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CrestTime
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CrestXi
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CrestYi
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%MCFD
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WaveFieldMod
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PtfmLocationX
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%PtfmLocationY
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Waves_PackInitInput

 SUBROUTINE Waves_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    DO I = 1, LEN(OutData%InputFile)
      OutData%InputFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%DirRoot)
      OutData%DirRoot(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%WvKinFile)
      OutData%WvKinFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%Gravity = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    i1_l = LBOUND(OutData%nGrid,1)
    i1_u = UBOUND(OutData%nGrid,1)
    DO i1 = LBOUND(OutData%nGrid,1), UBOUND(OutData%nGrid,1)
      OutData%nGrid(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%WvLowCOff = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WvHiCOff = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveDir = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveNDir = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WaveMultiDir = TRANSFER(IntKiBuf(Int_Xferred), OutData%WaveMultiDir)
    Int_Xferred = Int_Xferred + 1
    OutData%WaveDirMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WaveDirSpread = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveDirRange = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveDT = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%WaveHs = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%WaveModChr)
      OutData%WaveModChr(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%WaveNDAmp = TRANSFER(IntKiBuf(Int_Xferred), OutData%WaveNDAmp)
    Int_Xferred = Int_Xferred + 1
    OutData%WavePhase = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WavePkShp = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    DO I = 1, LEN(OutData%WavePkShpChr)
      OutData%WavePkShpChr(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    i1_l = LBOUND(OutData%WaveSeed,1)
    i1_u = UBOUND(OutData%WaveSeed,1)
    DO i1 = LBOUND(OutData%WaveSeed,1), UBOUND(OutData%WaveSeed,1)
      OutData%WaveSeed(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%WaveStMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WaveTMax = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%WaveTp = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WtrDens = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WtrDpth = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%NWaveElevGrid = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NWaveKinGrid = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveKinGridxi not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveKinGridxi)) DEALLOCATE(OutData%WaveKinGridxi)
    ALLOCATE(OutData%WaveKinGridxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridxi.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveKinGridxi,1), UBOUND(OutData%WaveKinGridxi,1)
        OutData%WaveKinGridxi(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveKinGridyi not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveKinGridyi)) DEALLOCATE(OutData%WaveKinGridyi)
    ALLOCATE(OutData%WaveKinGridyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridyi.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveKinGridyi,1), UBOUND(OutData%WaveKinGridyi,1)
        OutData%WaveKinGridyi(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveKinGridzi not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveKinGridzi)) DEALLOCATE(OutData%WaveKinGridzi)
    ALLOCATE(OutData%WaveKinGridzi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveKinGridzi.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveKinGridzi,1), UBOUND(OutData%WaveKinGridzi,1)
        OutData%WaveKinGridzi(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CurrVxi not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CurrVxi)) DEALLOCATE(OutData%CurrVxi)
    ALLOCATE(OutData%CurrVxi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CurrVxi.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%CurrVxi,1), UBOUND(OutData%CurrVxi,1)
        OutData%CurrVxi(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CurrVyi not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CurrVyi)) DEALLOCATE(OutData%CurrVyi)
    ALLOCATE(OutData%CurrVyi(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CurrVyi.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%CurrVyi,1), UBOUND(OutData%CurrVyi,1)
        OutData%CurrVyi(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    OutData%PCurrVxiPz0 = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%PCurrVyiPz0 = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_UnpackNWTC_RandomNumber_ParameterType( Re_Buf, Db_Buf, Int_Buf, OutData%RNG, ErrStat2, ErrMsg2 ) ! RNG 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    OutData%ConstWaveMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%CrestHmax = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%CrestTime = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%CrestXi = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%CrestYi = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%MCFD = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveFieldMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%PtfmLocationX = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%PtfmLocationY = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
 END SUBROUTINE Waves_UnPackInitInput

 SUBROUTINE Waves_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Waves_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(Waves_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%WaveElevC0 => SrcInitOutputData%WaveElevC0
IF (ALLOCATED(SrcInitOutputData%WaveElevC)) THEN
  i1_l = LBOUND(SrcInitOutputData%WaveElevC,1)
  i1_u = UBOUND(SrcInitOutputData%WaveElevC,1)
  i2_l = LBOUND(SrcInitOutputData%WaveElevC,2)
  i2_u = UBOUND(SrcInitOutputData%WaveElevC,2)
  i3_l = LBOUND(SrcInitOutputData%WaveElevC,3)
  i3_u = UBOUND(SrcInitOutputData%WaveElevC,3)
  IF (.NOT. ALLOCATED(DstInitOutputData%WaveElevC)) THEN 
    ALLOCATE(DstInitOutputData%WaveElevC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WaveElevC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WaveElevC = SrcInitOutputData%WaveElevC
ENDIF
    DstInitOutputData%WaveDirArr => SrcInitOutputData%WaveDirArr
    DstInitOutputData%WaveDirMin = SrcInitOutputData%WaveDirMin
    DstInitOutputData%WaveDirMax = SrcInitOutputData%WaveDirMax
    DstInitOutputData%WaveNDir = SrcInitOutputData%WaveNDir
    DstInitOutputData%WaveDOmega = SrcInitOutputData%WaveDOmega
    DstInitOutputData%WaveDynP => SrcInitOutputData%WaveDynP
    DstInitOutputData%WaveAcc => SrcInitOutputData%WaveAcc
    DstInitOutputData%WaveAccMCF => SrcInitOutputData%WaveAccMCF
    DstInitOutputData%WaveVel => SrcInitOutputData%WaveVel
    DstInitOutputData%PWaveDynP0 => SrcInitOutputData%PWaveDynP0
    DstInitOutputData%PWaveAcc0 => SrcInitOutputData%PWaveAcc0
    DstInitOutputData%PWaveAccMCF0 => SrcInitOutputData%PWaveAccMCF0
    DstInitOutputData%PWaveVel0 => SrcInitOutputData%PWaveVel0
    DstInitOutputData%WaveElev => SrcInitOutputData%WaveElev
IF (ALLOCATED(SrcInitOutputData%WaveElev0)) THEN
  i1_l = LBOUND(SrcInitOutputData%WaveElev0,1)
  i1_u = UBOUND(SrcInitOutputData%WaveElev0,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WaveElev0)) THEN 
    ALLOCATE(DstInitOutputData%WaveElev0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WaveElev0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WaveElev0 = SrcInitOutputData%WaveElev0
ENDIF
    DstInitOutputData%WaveTime => SrcInitOutputData%WaveTime
    DstInitOutputData%WaveTMax = SrcInitOutputData%WaveTMax
    DstInitOutputData%RhoXg = SrcInitOutputData%RhoXg
    DstInitOutputData%NStepWave = SrcInitOutputData%NStepWave
    DstInitOutputData%NStepWave2 = SrcInitOutputData%NStepWave2
 END SUBROUTINE Waves_CopyInitOutput

 SUBROUTINE Waves_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Waves_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Waves_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

NULLIFY(InitOutputData%WaveElevC0)
IF (ALLOCATED(InitOutputData%WaveElevC)) THEN
  DEALLOCATE(InitOutputData%WaveElevC)
ENDIF
NULLIFY(InitOutputData%WaveDirArr)
NULLIFY(InitOutputData%WaveDynP)
NULLIFY(InitOutputData%WaveAcc)
NULLIFY(InitOutputData%WaveAccMCF)
NULLIFY(InitOutputData%WaveVel)
NULLIFY(InitOutputData%PWaveDynP0)
NULLIFY(InitOutputData%PWaveAcc0)
NULLIFY(InitOutputData%PWaveAccMCF0)
NULLIFY(InitOutputData%PWaveVel0)
NULLIFY(InitOutputData%WaveElev)
IF (ALLOCATED(InitOutputData%WaveElev0)) THEN
  DEALLOCATE(InitOutputData%WaveElev0)
ENDIF
NULLIFY(InitOutputData%WaveTime)
 END SUBROUTINE Waves_DestroyInitOutput

 SUBROUTINE Waves_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Waves_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! WaveElevC allocated yes/no
  IF ( ALLOCATED(InData%WaveElevC) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveElevC upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveElevC)  ! WaveElevC
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! WaveDirMin
      Re_BufSz   = Re_BufSz   + 1  ! WaveDirMax
      Int_BufSz  = Int_BufSz  + 1  ! WaveNDir
      Re_BufSz   = Re_BufSz   + 1  ! WaveDOmega
  Int_BufSz   = Int_BufSz   + 1     ! WaveElev0 allocated yes/no
  IF ( ALLOCATED(InData%WaveElev0) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveElev0 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveElev0)  ! WaveElev0
  END IF
      Db_BufSz   = Db_BufSz   + 1  ! WaveTMax
      Re_BufSz   = Re_BufSz   + 1  ! RhoXg
      Int_BufSz  = Int_BufSz  + 1  ! NStepWave
      Int_BufSz  = Int_BufSz  + 1  ! NStepWave2
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%WaveElevC) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveElevC,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveElevC,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveElevC,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveElevC,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveElevC,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveElevC,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveElevC,3), UBOUND(InData%WaveElevC,3)
        DO i2 = LBOUND(InData%WaveElevC,2), UBOUND(InData%WaveElevC,2)
          DO i1 = LBOUND(InData%WaveElevC,1), UBOUND(InData%WaveElevC,1)
            ReKiBuf(Re_Xferred) = InData%WaveElevC(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    ReKiBuf(Re_Xferred) = InData%WaveDirMin
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveDirMax
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WaveNDir
    Int_Xferred = Int_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WaveDOmega
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%WaveElev0) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveElev0,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveElev0,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveElev0,1), UBOUND(InData%WaveElev0,1)
        ReKiBuf(Re_Xferred) = InData%WaveElev0(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
    DbKiBuf(Db_Xferred) = InData%WaveTMax
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%RhoXg
    Re_Xferred = Re_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NStepWave
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%NStepWave2
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Waves_PackInitOutput

 SUBROUTINE Waves_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Waves_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'Waves_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  NULLIFY(OutData%WaveElevC0)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveElevC not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveElevC)) DEALLOCATE(OutData%WaveElevC)
    ALLOCATE(OutData%WaveElevC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveElevC,3), UBOUND(OutData%WaveElevC,3)
        DO i2 = LBOUND(OutData%WaveElevC,2), UBOUND(OutData%WaveElevC,2)
          DO i1 = LBOUND(OutData%WaveElevC,1), UBOUND(OutData%WaveElevC,1)
            OutData%WaveElevC(i1,i2,i3) = REAL(ReKiBuf(Re_Xferred), SiKi)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  NULLIFY(OutData%WaveDirArr)
    OutData%WaveDirMin = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveDirMax = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%WaveNDir = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WaveDOmega = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
  NULLIFY(OutData%WaveDynP)
  NULLIFY(OutData%WaveAcc)
  NULLIFY(OutData%WaveAccMCF)
  NULLIFY(OutData%WaveVel)
  NULLIFY(OutData%PWaveDynP0)
  NULLIFY(OutData%PWaveAcc0)
  NULLIFY(OutData%PWaveAccMCF0)
  NULLIFY(OutData%PWaveVel0)
  NULLIFY(OutData%WaveElev)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveElev0 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveElev0)) DEALLOCATE(OutData%WaveElev0)
    ALLOCATE(OutData%WaveElev0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveElev0,1), UBOUND(OutData%WaveElev0,1)
        OutData%WaveElev0(i1) = REAL(ReKiBuf(Re_Xferred), SiKi)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  NULLIFY(OutData%WaveTime)
    OutData%WaveTMax = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%RhoXg = REAL(ReKiBuf(Re_Xferred), SiKi)
    Re_Xferred = Re_Xferred + 1
    OutData%NStepWave = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%NStepWave2 = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE Waves_UnPackInitOutput

END MODULE Waves_Types
!ENDOFREGISTRYGENERATEDFILE
