!STARTOFREGISTRYGENERATEDFILE 'MoorDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! MoorDyn_Types
!.................................................................................................................................
! This file is part of MoorDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in MoorDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE MoorDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  MD_InputFileType  =======
  TYPE, PUBLIC :: MD_InputFileType
    REAL(DbKi)  :: DTIC = 0.5      !< convergence check time step for IC generation [[s]]
    REAL(DbKi)  :: TMaxIC = 120      !< maximum time to allow for getting converged ICs [[s]]
    REAL(ReKi)  :: CdScaleIC = 1      !< factor to scale drag coefficients by during dynamic relaxation [[]]
    REAL(ReKi)  :: threshIC = 0.01      !< convergence tolerance for ICs  (0.01 means 1%) [[]]
  END TYPE MD_InputFileType
! =======================
! =========  MD_InitInputType  =======
  TYPE, PUBLIC :: MD_InitInputType
    REAL(ReKi)  :: g = -999.9      !< gravity constant [[m/s^2]]
    REAL(ReKi)  :: rhoW = -999.9      !< sea density [[kg/m^3]]
    REAL(ReKi)  :: WtrDepth = -999.9      !< depth of water [[m]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PtfmInit      !< initial position of platform(s) shape: 6, nTurbines [-]
    INTEGER(IntKi)  :: FarmSize = 0      !< Indicates normal FAST module mode if 0, FAST.Farm coupled mode and =nTurbines if >0 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TurbineRefPos      !< reference position of turbines in farm, shape: 3, nTurbines [-]
    REAL(ReKi)  :: Tmax      !< simulation duration [[s]]
    CHARACTER(1024)  :: FileName      !< MoorDyn input file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    LOGICAL  :: UsePrimaryInputFile = .TRUE.      !< Read input file instead of passed data [-]
    TYPE(FileInfoType)  :: PassedPrimaryInputData      !< Primary input file as FileInfoType (set by driver/glue code) -- String array with metadata [-]
    LOGICAL  :: Echo      !< echo parameter - do we want to echo the header line describing the input file? [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< string containing list of output channels requested in input file [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
  END TYPE MD_InitInputType
! =======================
! =========  MD_LineProp  =======
  TYPE, PUBLIC :: MD_LineProp
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this set of line properties [-]
    CHARACTER(20)  :: name      !< name/identifier of this set of line properties [-]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: w      !< per-length weight in air [[kg/m]]
    REAL(DbKi)  :: EA      !< axial stiffness [[N]]
    REAL(DbKi)  :: EA_D      !< axial stiffness [[N]]
    REAL(DbKi)  :: BA      !< internal damping coefficient times area [[N-s]]
    REAL(DbKi)  :: BA_D      !< internal damping coefficient times area [[N-s]]
    REAL(DbKi)  :: EI      !< bending stiffness [[N-m]]
    REAL(DbKi)  :: Can      !< transverse added mass coefficient [-]
    REAL(DbKi)  :: Cat      !< tangential added mass coefficient [-]
    REAL(DbKi)  :: Cdn      !< transverse drag coefficient [-]
    REAL(DbKi)  :: Cdt      !< tangential drag coefficient [-]
    INTEGER(IntKi)  :: ElasticMod      !< Which elasticity model to use: {0 basic, 1 viscoelastic, 2 future SYCOM}  [-]
    INTEGER(IntKi)  :: nEApoints = 0      !< number of values in stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffXs      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffYs      !< y array for stress-strain lookup table [-]
    INTEGER(IntKi)  :: nBApoints = 0      !< number of values in stress-strainrate lookup table (0 means using constant c) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampXs      !< x array for stress-strainrate lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampYs      !< y array for stress-strainrate lookup table	 [-]
    INTEGER(IntKi)  :: nEIpoints = 0      !< number of values in bending stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffXs      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffYs      !< y array for stress-strain lookup table [-]
  END TYPE MD_LineProp
! =======================
! =========  MD_RodProp  =======
  TYPE, PUBLIC :: MD_RodProp
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this set of rod properties [-]
    CHARACTER(10)  :: name      !< name/identifier of this set of rod properties [-]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: w      !< per-length weight in air [[kg/m]]
    REAL(DbKi)  :: Can      !< transverse added mass coefficient [-]
    REAL(DbKi)  :: Cat      !< tangential added mass coefficient [-]
    REAL(DbKi)  :: Cdn      !< transverse drag coefficient [-]
    REAL(DbKi)  :: Cdt      !< tangential drag coefficient [-]
    REAL(DbKi)  :: CdEnd      !< drag coefficient for rod end [[-]]
    REAL(DbKi)  :: CaEnd      !< added mass coefficient for rod end [[-]]
  END TYPE MD_RodProp
! =======================
! =========  MD_Body  =======
  TYPE, PUBLIC :: MD_Body
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Connection [-]
    INTEGER(IntKi)  :: typeNum      !< integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: AttachedC      !< list of IdNums of connections attached to this body [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: AttachedR      !< list of IdNums of rods attached to this body [-]
    INTEGER(IntKi)  :: nAttachedC = 0      !< number of attached connections [-]
    INTEGER(IntKi)  :: nAttachedR = 0      !< number of attached rods [-]
    REAL(DbKi) , DIMENSION(1:3,1:30)  :: rConnectRel      !< relative position of connection on body [-]
    REAL(DbKi) , DIMENSION(1:6,1:30)  :: r6RodRel      !< relative position and orientation of rod on body [-]
    REAL(DbKi)  :: bodyM      !<  [-]
    REAL(DbKi)  :: bodyV      !<  [-]
    REAL(DbKi) , DIMENSION(1:3)  :: bodyI      !<  [-]
    REAL(DbKi) , DIMENSION(1:6)  :: bodyCdA      !< product of drag force and frontal area of connection point [[m^2]]
    REAL(DbKi) , DIMENSION(1:6)  :: bodyCa      !< added mass coefficient of connection point [-]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi) , DIMENSION(1:6)  :: r6      !< position [-]
    REAL(DbKi) , DIMENSION(1:6)  :: v6      !< velocity [-]
    REAL(DbKi) , DIMENSION(1:6)  :: a6      !< acceleration (only used for coupled bodies) [-]
    REAL(DbKi) , DIMENSION(1:3)  :: U      !< water velocity at ref point [[m/s]]
    REAL(DbKi) , DIMENSION(1:3)  :: Ud      !< water acceleration at ref point [[m/s^2]]
    REAL(DbKi)  :: zeta      !< water surface elevation above ref point [[m]]
    REAL(DbKi) , DIMENSION(1:6)  :: F6net      !< total force and moment on body (excluding inertial loads) [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M6net      !< total mass matrix of Body and any attached objects [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M      !< rotated body 6-dof mass and inertia matrix in global orientation [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M0      !< body 6-dof mass and inertia matrix in its own frame [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: OrMat      !< DCM for body orientation [-]
    REAL(DbKi) , DIMENSION(1:3)  :: rCG      !< vector in body frame from ref point to CG (before rods etc..) [-]
  END TYPE MD_Body
! =======================
! =========  MD_Connect  =======
  TYPE, PUBLIC :: MD_Connect
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Connection [-]
    CHARACTER(10)  :: type      !< type of Connect: fix, vessel, connect [-]
    INTEGER(IntKi)  :: typeNum      !< integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Attached      !< list of IdNums of lines attached to this connection node [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Top      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nAttached = 0      !< number of attached lines [-]
    REAL(DbKi)  :: conM      !<  [-]
    REAL(DbKi)  :: conV      !<  [-]
    REAL(DbKi)  :: conFX      !<  [-]
    REAL(DbKi)  :: conFY      !<  [-]
    REAL(DbKi)  :: conFZ      !<  [-]
    REAL(DbKi)  :: conCa      !< added mass coefficient of connection point [-]
    REAL(DbKi)  :: conCdA      !< product of drag force and frontal area of connection point [[m^2]]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi) , DIMENSION(1:3)  :: r      !< position [-]
    REAL(DbKi) , DIMENSION(1:3)  :: rd      !< velocity [-]
    REAL(DbKi) , DIMENSION(1:3)  :: a      !< acceleration (only used for coupled points) [-]
    REAL(DbKi) , DIMENSION(1:3)  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(1:3)  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi)  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(1:3)  :: Fnet      !< total force on node (excluding inertial loads) [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: M      !< node mass matrix, from attached lines [-]
  END TYPE MD_Connect
! =======================
! =========  MD_Rod  =======
  TYPE, PUBLIC :: MD_Rod
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Line [-]
    CHARACTER(10)  :: type      !< type of Rod.  should match one of RodProp names [-]
    INTEGER(IntKi)  :: PropsIdNum      !< the IdNum of the associated rod properties [-]
    INTEGER(IntKi)  :: typeNum      !< integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: AttachedA      !< list of IdNums of lines attached to end A [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: AttachedB      !< list of IdNums of lines attached to end B [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: TopA      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: TopB      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nAttachedA = 0      !< number of attached lines to Rod end A [-]
    INTEGER(IntKi)  :: nAttachedB = 0      !< number of attached lines to Rod end B [-]
    INTEGER(IntKi) , DIMENSION(1:20)  :: OutFlagList      !< array specifying what line quantities should be output (1 vs 0) [-]
    INTEGER(IntKi)  :: N      !< The number of elements in the line [-]
    INTEGER(IntKi)  :: endTypeA      !< type of connection at end A: 0=pinned to Connection, 1=cantilevered to Rod. [-]
    INTEGER(IntKi)  :: endTypeB      !< type of connection at end B: 0=pinned to Connection, 1=cantilevered to Rod. [-]
    REAL(DbKi)  :: UnstrLen      !< length of the rod [[m]]
    REAL(DbKi)  :: mass      !< mass of the rod [[kg]]
    REAL(DbKi)  :: rho      !< density [[kg/m3]]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: Can      !<  [[-]]
    REAL(DbKi)  :: Cat      !<  [[-]]
    REAL(DbKi)  :: Cdn      !<  [[-]]
    REAL(DbKi)  :: Cdt      !<  [[-]]
    REAL(DbKi)  :: CdEnd      !< drag coefficient for rod end [[-]]
    REAL(DbKi)  :: CaEnd      !< added mass coefficient for rod end [[-]]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi)  :: roll      !< roll relative to vertical [deg]
    REAL(DbKi)  :: pitch      !< pitch relative to vertical [deg]
    REAL(DbKi)  :: h0      !< submerged length of rod axis, distance along rod centerline from end A to the waterplane (0 <= h0 <= L) [m]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: r      !< node positions [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      !< node velocities [-]
    REAL(DbKi) , DIMENSION(1:3)  :: q      !< tangent vector for rod as a whole [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: l      !< segment unstretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: V      !< segment volume [[m^3]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: W      !< weight vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Bo      !< buoyancy force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Pd      !< dynamic pressure force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      !< node drag (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      !< node drag (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      !< node added mass forcing (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      !< node added mass forcing (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: B      !< node bottom contact force [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Fnet      !< total force on node [[N]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      !< node mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(1:3)  :: FextA      !< external forces from attached lines on/about end A  [-]
    REAL(DbKi) , DIMENSION(1:3)  :: FextB      !< external forces from attached lines on/about end A  [-]
    REAL(DbKi) , DIMENSION(1:3)  :: Mext      !< external moment vector holding sum of any externally applied moments i.e. bending lines [-]
    REAL(DbKi) , DIMENSION(1:6)  :: r6      !< 6 DOF position vector [-]
    REAL(DbKi) , DIMENSION(1:6)  :: v6      !< 6 DOF velocity vector [-]
    REAL(DbKi) , DIMENSION(1:6)  :: a6      !< 6 DOF acceleration vector (only used for coupled Rods) [-]
    REAL(DbKi) , DIMENSION(1:6)  :: F6net      !< total force and moment about end A (excluding inertial loads) that Rod may exert on whatever it's attached to [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M6net      !< total mass matrix about end A of Rod and any attached Points [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: OrMat      !< DCM for body orientation [-]
    INTEGER(IntKi)  :: RodUnOut      !< unit number of rod output file [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: RodWrOutput      !< one row of output data for this rod [-]
  END TYPE MD_Rod
! =======================
! =========  MD_Line  =======
  TYPE, PUBLIC :: MD_Line
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Line [-]
    INTEGER(IntKi)  :: PropsIdNum      !< the IdNum of the associated line properties [-]
    INTEGER(IntKi)  :: ElasticMod      !< Which elasticity model to use: {0 basic, 1 viscoelastic, 2 future SYCOM}  [-]
    INTEGER(IntKi) , DIMENSION(1:20)  :: OutFlagList      !< array specifying what line quantities should be output (1 vs 0) [-]
    INTEGER(IntKi)  :: CtrlChan = 0      !< index of control channel that will drive line active tensioning (0 for none) [-]
    INTEGER(IntKi)  :: FairConnect      !< IdNum of Connection at fairlead [-]
    INTEGER(IntKi)  :: AnchConnect      !< IdNum of Connection at anchor [-]
    INTEGER(IntKi)  :: N      !< The number of elements in the line [-]
    INTEGER(IntKi)  :: endTypeA      !< type of connection at end A: 0=pinned to Connection, 1=cantilevered to Rod. [-]
    INTEGER(IntKi)  :: endTypeB      !< type of connection at end B: 0=pinned to Connection, 1=cantilevered to Rod. [-]
    REAL(DbKi)  :: UnstrLen      !< unstretched length of the line [-]
    REAL(DbKi)  :: rho      !< density [[kg/m3]]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: EA = 0      !< stiffness [[N]]
    REAL(DbKi)  :: EA_D = 0      !< dynamic stiffness when using viscoelastic model [[N]]
    REAL(DbKi)  :: BA = 0      !< internal damping coefficient times area for this line only [[N-s]]
    REAL(DbKi)  :: BA_D = 0      !< dynamic internal damping coefficient times area when using viscoelastic model [[N-s]]
    REAL(DbKi)  :: EI = 0      !< bending stiffness [[N-m]]
    REAL(DbKi)  :: Can      !<  [[-]]
    REAL(DbKi)  :: Cat      !<  [[-]]
    REAL(DbKi)  :: Cdn      !<  [[-]]
    REAL(DbKi)  :: Cdt      !<  [[-]]
    INTEGER(IntKi)  :: nEApoints = 0      !< number of values in stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffXs      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffYs      !< y array for stress-strain lookup table [-]
    INTEGER(IntKi)  :: nBApoints = 0      !< number of values in stress-strainrate lookup table (0 means using constant c) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampXs      !< x array for stress-strainrate lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampYs      !< y array for stress-strainrate lookup table	 [-]
    INTEGER(IntKi)  :: nEIpoints = 0      !< number of values in bending stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffXs      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffYs      !< y array for stress-strain lookup table [-]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: r      !< node positions [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      !< node velocities [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: q      !< node tangent vectors [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: qs      !< segment tangent vectors [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: l      !< segment unstretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: ld      !< segment unstretched length rate of change (used in active tensioning) [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: lstr      !< segment stretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: lstrd      !< segment change in stretched length [[m/s]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Kurv      !< curvature at each node point [[1/m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: dl_1      !< segment stretch attributed to static stiffness portion [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: V      !< segment volume [[m^3]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: T      !< segment tension vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Td      !< segment internal damping force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: W      !< weight/buoyancy vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      !< node drag (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      !< node drag (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      !< node added mass forcing (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      !< node added mass forcing (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: B      !< node bottom contact force [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Bs      !< node force due to bending moments [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Fnet      !< total force on node [[N]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: S      !< node inverse mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      !< node mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(1:3)  :: EndMomentA      !< vector of end moments due to bending at line end A [[N-m]]
    REAL(DbKi) , DIMENSION(1:3)  :: EndMomentB      !< vector of end moments due to bending at line end B [[N-m]]
    INTEGER(IntKi)  :: LineUnOut      !< unit number of line output file [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: LineWrOutput      !< one row of output data for this line [-]
  END TYPE MD_Line
! =======================
! =========  MD_Fail  =======
  TYPE, PUBLIC :: MD_Fail
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this failure [-]
  END TYPE MD_Fail
! =======================
! =========  MD_OutParmType  =======
  TYPE, PUBLIC :: MD_OutParmType
    CHARACTER(10)  :: Name      !< name of output channel [-]
    CHARACTER(10)  :: Units      !< units string [-]
    INTEGER(IntKi)  :: QType      !< type of quantity - 0=tension, 1=x, 2=y, 3=z... [-]
    INTEGER(IntKi)  :: OType      !< type of object - 0=line, 1=connect [-]
    INTEGER(IntKi)  :: NodeID      !< node number if OType=0.  0=anchor, -1=N=Fairlead [-]
    INTEGER(IntKi)  :: ObjID      !< number of Connect or Line object [-]
  END TYPE MD_OutParmType
! =======================
! =========  MD_InitOutputType  =======
  TYPE, PUBLIC :: MD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: writeOutputHdr      !< first line output file contents: output variable names [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: writeOutputUnt      !< second line of output file contents: units [-]
    TYPE(ProgDesc)  :: Ver      !< this module's name, version, and date [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: CableCChanRqst      !< flag indicating control channel for drive line active tensioning is requested [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the continuous states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Flag that tells FAST/MBC3 if the outputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Flag that tells FAST/MBC3 if the continuous states used in linearization are in the rotating frame (not used for glue) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
  END TYPE MD_InitOutputType
! =======================
! =========  MD_ContinuousStateType  =======
  TYPE, PUBLIC :: MD_ContinuousStateType
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: states      !< state vector of mooring system, e.g. node coordinates and velocities []
  END TYPE MD_ContinuousStateType
! =======================
! =========  MD_DiscreteStateType  =======
  TYPE, PUBLIC :: MD_DiscreteStateType
    REAL(SiKi)  :: dummy      !< Remove this variable if you have discrete states [-]
  END TYPE MD_DiscreteStateType
! =======================
! =========  MD_ConstraintStateType  =======
  TYPE, PUBLIC :: MD_ConstraintStateType
    REAL(SiKi)  :: dummy      !< Remove this variable if you have constraint states [-]
  END TYPE MD_ConstraintStateType
! =======================
! =========  MD_OtherStateType  =======
  TYPE, PUBLIC :: MD_OtherStateType
    REAL(SiKi)  :: dummy      !< Remove this variable if you have other states [-]
  END TYPE MD_OtherStateType
! =======================
! =========  MD_MiscVarType  =======
  TYPE, PUBLIC :: MD_MiscVarType
    TYPE(MD_LineProp) , DIMENSION(:), ALLOCATABLE  :: LineTypeList      !< array of properties for each line type [-]
    TYPE(MD_RodProp) , DIMENSION(:), ALLOCATABLE  :: RodTypeList      !< array of properties for each rod type [-]
    TYPE(MD_Body)  :: GroundBody      !< the single ground body which is the parent of all stationary connections [-]
    TYPE(MD_Body) , DIMENSION(:), ALLOCATABLE  :: BodyList      !< array of body objects [-]
    TYPE(MD_Rod) , DIMENSION(:), ALLOCATABLE  :: RodList      !< array of rod objects [-]
    TYPE(MD_Connect) , DIMENSION(:), ALLOCATABLE  :: ConnectList      !< array of connection objects [-]
    TYPE(MD_Line) , DIMENSION(:), ALLOCATABLE  :: LineList      !< array of line objects [-]
    TYPE(MD_Fail) , DIMENSION(:), ALLOCATABLE  :: FailList      !< array of line objects [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FreeConIs      !< array of free connection indices in ConnectList vector []
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CpldConIs      !< array of coupled/fairlead connection indices in ConnectList vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FreeRodIs      !< array of free rod indices in RodList vector []
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CpldRodIs      !< array of coupled/fairlead rod indices in RodList vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FreeBodyIs      !< array of free body indices in BodyList vector []
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CpldBodyIs      !< array of coupled body indices in BodyList vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LineStateIs1      !< starting index of each line's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LineStateIsN      !< ending index of each line's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ConStateIs1      !< starting index of each line's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ConStateIsN      !< ending index of each line's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RodStateIs1      !< starting index of each rod's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RodStateIsN      !< ending index of each rod's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BodyStateIs1      !< starting index of each body's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BodyStateIsN      !< ending index of each body's states in state vector []
    INTEGER(IntKi)  :: Nx      !< number of states and size of state vector []
    INTEGER(IntKi)  :: WaveTi      !< current interpolation index for wave time series data []
    TYPE(MD_ContinuousStateType)  :: xTemp      !< contains temporary state vector used in integration (put here so it's only allocated once) [-]
    TYPE(MD_ContinuousStateType)  :: xdTemp      !< contains temporary state derivative vector used in integration (put here so it's only allocated once) [-]
    REAL(DbKi) , DIMENSION(1:6)  :: zeros6      !< array of zeros for convenience [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: MDWrOutput      !< Data from time step to be written to a MoorDyn output file [-]
    REAL(DbKi)  :: LastOutTime      !< Time of last writing to MD output files [-]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit      !< initial position of platform for an individual (non-farm) MD instance [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: BathymetryGrid      !< matrix describing the bathymetry in a grid of x's and y's [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: BathGrid_Xs      !< array of x-coordinates in the bathymetry grid [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: BathGrid_Ys      !< array of y-coordinates in the bathymetry grid [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BathGrid_npoints      !< number of grid points to describe the bathymetry grid [-]
  END TYPE MD_MiscVarType
! =======================
! =========  MD_ParameterType  =======
  TYPE, PUBLIC :: MD_ParameterType
    INTEGER(IntKi)  :: nLineTypes = 0      !< number of line types []
    INTEGER(IntKi)  :: nRodTypes = 0      !< number of rod types []
    INTEGER(IntKi)  :: nConnects = 0      !< number of Connection objects []
    INTEGER(IntKi)  :: nConnectsExtra = 0      !< number of Connection objects including space for extra ones that could arise from line failures []
    INTEGER(IntKi)  :: nBodies = 0      !< number of Body objects []
    INTEGER(IntKi)  :: nRods = 0      !< number of Rod objects []
    INTEGER(IntKi)  :: nLines = 0      !< number of Line objects []
    INTEGER(IntKi)  :: nCtrlChans = 0      !< number of distinct control channels specified for use as inputs []
    INTEGER(IntKi)  :: nFails = 0      !< number of failure conditions []
    INTEGER(IntKi)  :: nFreeBodies = 0      !<  []
    INTEGER(IntKi)  :: nFreeRods = 0      !<  []
    INTEGER(IntKi)  :: nFreeCons = 0      !<  []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nCpldBodies      !< number of coupled bodies (for FAST.Farm, size>1 with an entry for each turbine) []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nCpldRods      !< number of coupled rods (for FAST.Farm, size>1 with an entry for each turbine) []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nCpldCons      !< number of coupled points (for FAST.Farm, size>1 with an entry for each turbine) []
    INTEGER(IntKi)  :: NConns = 0      !< number of Connect type Connections - not to be confused with NConnects []
    INTEGER(IntKi)  :: NAnchs = 0      !< number of Anchor type Connections []
    REAL(DbKi)  :: Tmax      !< simulation duration [[s]]
    REAL(DbKi)  :: g = 9.81      !< gravitational constant (positive) [[m/s^2]]
    REAL(DbKi)  :: rhoW = 1025      !< density of seawater [[kg/m^3]]
    REAL(DbKi)  :: WtrDpth      !< water depth [[m]]
    REAL(DbKi)  :: kBot      !< bottom stiffness [[Pa/m]]
    REAL(DbKi)  :: cBot      !< bottom damping [[Pa-s/m]]
    REAL(DbKi)  :: dtM0      !< desired mooring model time step [[s]]
    REAL(DbKi)  :: dtCoupling      !< coupling time step that MoorDyn should expect [[s]]
    INTEGER(IntKi)  :: NumOuts      !< Number of parameters in the output list (number of outputs requested) [-]
    REAL(DbKi)  :: dtOut      !< interval for writing output file lines [[s]]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(MD_OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      !< Column delimiter for output text files [-]
    INTEGER(IntKi)  :: MDUnOut      !< Unit number of main output file [-]
    CHARACTER(1024)  :: PriPath      !< The path to the primary MoorDyn input file, used if looking for additional input files [-]
    INTEGER(IntKi)  :: writeLog = -1      !< Switch for level of log file output [-]
    INTEGER(IntKi)  :: UnLog = -1      !< Unit number of log file [-]
    INTEGER(IntKi)  :: WaveKin      !< Flag for whether or how to consider water kinematics [-]
    INTEGER(IntKi)  :: Current      !< Flag for whether or how to consider water kinematics [-]
    INTEGER(IntKi)  :: nTurbines      !< Number of turbines if MoorDyn is performing an array-level simulation with FAST.Farm, otherwise 0 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TurbineRefPos      !< reference position of turbines in farm, shape: 3, nTurbines [-]
    REAL(DbKi)  :: mu_kT      !< transverse kinetic friction coefficient [(-)]
    REAL(DbKi)  :: mu_kA      !< axial kinetic friction coefficient [(-)]
    REAL(DbKi)  :: mc      !< ratio of the static friction coefficient to the kinetic friction coefficient [(-)]
    REAL(DbKi)  :: cv      !< saturated damping coefficient [(-)]
    INTEGER(IntKi)  :: nxWave      !< number of x wave grid points [-]
    INTEGER(IntKi)  :: nyWave      !< number of y wave grid points [-]
    INTEGER(IntKi)  :: nzWave      !< number of z wave grid points [-]
    INTEGER(IntKi)  :: ntWave      !< number of wave time steps [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pxWave      !< x location of wave grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pyWave      !< y location of wave grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pzWave      !< z location of wave grid points [-]
    REAL(SiKi)  :: dtWave      !< wave data time step [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uxWave      !< wave velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uyWave      !< wave velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uzWave      !< wave velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: axWave      !< wave accelerations time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: ayWave      !< wave accelerations time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: azWave      !< wave accelerations time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: PDyn      !< wave dynamic pressure time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: zeta      !< wave surface elevations time series at each surface grid point [-]
    INTEGER(IntKi)  :: nzCurrent      !< number of z current grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pzCurrent      !< z location of current grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: uxCurrent      !< current velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: uyCurrent      !< current velocities time series at each grid point [-]
    INTEGER(IntKi)  :: Nx0      !< copy of initial size of system state vector, for linearization routines [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
    INTEGER(IntKi)  :: Jac_ny      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: Jac_nx      !< number of continuous states in jacobian matrix [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: dxIdx_map2_xStateIdx      !< Mapping array from index of dX array to corresponding state index [-]
  END TYPE MD_ParameterType
! =======================
! =========  MD_InputType  =======
  TYPE, PUBLIC :: MD_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: CoupledKinematics      !< array of meshes for each coupling point (6 DOF info used for rods and bodies) [[m, m/s]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DeltaL      !< change in line length command for each channel [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DeltaLdot      !< rate of change of line length command for each channel [[m]]
  END TYPE MD_InputType
! =======================
! =========  MD_OutputType  =======
  TYPE, PUBLIC :: MD_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: CoupledLoads      !< array of point meshes for mooring reaction forces (and moments) at coupling points [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< output vector returned to glue code []
  END TYPE MD_OutputType
! =======================
CONTAINS
 SUBROUTINE MD_CopyInputFileType( SrcInputFileTypeData, DstInputFileTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InputFileType), INTENT(IN) :: SrcInputFileTypeData
   TYPE(MD_InputFileType), INTENT(INOUT) :: DstInputFileTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyInputFileType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileTypeData%DTIC = SrcInputFileTypeData%DTIC
    DstInputFileTypeData%TMaxIC = SrcInputFileTypeData%TMaxIC
    DstInputFileTypeData%CdScaleIC = SrcInputFileTypeData%CdScaleIC
    DstInputFileTypeData%threshIC = SrcInputFileTypeData%threshIC
 END SUBROUTINE MD_CopyInputFileType

 SUBROUTINE MD_DestroyInputFileType( InputFileTypeData, ErrStat, ErrMsg )
  TYPE(MD_InputFileType), INTENT(INOUT) :: InputFileTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyInputFileType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyInputFileType


subroutine MD_PackInputFileType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_InputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInputFileType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DTIC
   call RegPack(Buf, InData%DTIC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMaxIC
   call RegPack(Buf, InData%TMaxIC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CdScaleIC
   call RegPack(Buf, InData%CdScaleIC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! threshIC
   call RegPack(Buf, InData%threshIC)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackInputFileType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_InputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInputFileType'
   if (Buf%ErrStat /= ErrID_None) return
   ! DTIC
   call RegUnpack(Buf, OutData%DTIC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMaxIC
   call RegUnpack(Buf, OutData%TMaxIC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CdScaleIC
   call RegUnpack(Buf, OutData%CdScaleIC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! threshIC
   call RegUnpack(Buf, OutData%threshIC)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(MD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%g = SrcInitInputData%g
    DstInitInputData%rhoW = SrcInitInputData%rhoW
    DstInitInputData%WtrDepth = SrcInitInputData%WtrDepth
IF (ALLOCATED(SrcInitInputData%PtfmInit)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmInit,1)
  i1_u = UBOUND(SrcInitInputData%PtfmInit,1)
  i2_l = LBOUND(SrcInitInputData%PtfmInit,2)
  i2_u = UBOUND(SrcInitInputData%PtfmInit,2)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmInit)) THEN 
    ALLOCATE(DstInitInputData%PtfmInit(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmInit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
ENDIF
    DstInitInputData%FarmSize = SrcInitInputData%FarmSize
IF (ALLOCATED(SrcInitInputData%TurbineRefPos)) THEN
  i1_l = LBOUND(SrcInitInputData%TurbineRefPos,1)
  i1_u = UBOUND(SrcInitInputData%TurbineRefPos,1)
  i2_l = LBOUND(SrcInitInputData%TurbineRefPos,2)
  i2_u = UBOUND(SrcInitInputData%TurbineRefPos,2)
  IF (.NOT. ALLOCATED(DstInitInputData%TurbineRefPos)) THEN 
    ALLOCATE(DstInitInputData%TurbineRefPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%TurbineRefPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%TurbineRefPos = SrcInitInputData%TurbineRefPos
ENDIF
    DstInitInputData%Tmax = SrcInitInputData%Tmax
    DstInitInputData%FileName = SrcInitInputData%FileName
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%UsePrimaryInputFile = SrcInitInputData%UsePrimaryInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedPrimaryInputData, DstInitInputData%PassedPrimaryInputData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%Echo = SrcInitInputData%Echo
IF (ALLOCATED(SrcInitInputData%OutList)) THEN
  i1_l = LBOUND(SrcInitInputData%OutList,1)
  i1_u = UBOUND(SrcInitInputData%OutList,1)
  IF (.NOT. ALLOCATED(DstInitInputData%OutList)) THEN 
    ALLOCATE(DstInitInputData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%OutList = SrcInitInputData%OutList
ENDIF
    DstInitInputData%Linearize = SrcInitInputData%Linearize
 END SUBROUTINE MD_CopyInitInput

 SUBROUTINE MD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%PtfmInit)) THEN
  DEALLOCATE(InitInputData%PtfmInit)
ENDIF
IF (ALLOCATED(InitInputData%TurbineRefPos)) THEN
  DEALLOCATE(InitInputData%TurbineRefPos)
ENDIF
  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedPrimaryInputData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitInputData%OutList)) THEN
  DEALLOCATE(InitInputData%OutList)
ENDIF
 END SUBROUTINE MD_DestroyInitInput


subroutine MD_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! g
   call RegPack(Buf, InData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rhoW
   call RegPack(Buf, InData%rhoW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDepth
   call RegPack(Buf, InData%WtrDepth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmInit
   call RegPack(Buf, allocated(InData%PtfmInit))
   if (allocated(InData%PtfmInit)) then
      call RegPackBounds(Buf, 2, lbound(InData%PtfmInit), ubound(InData%PtfmInit))
      call RegPack(Buf, InData%PtfmInit)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FarmSize
   call RegPack(Buf, InData%FarmSize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineRefPos
   call RegPack(Buf, allocated(InData%TurbineRefPos))
   if (allocated(InData%TurbineRefPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%TurbineRefPos), ubound(InData%TurbineRefPos))
      call RegPack(Buf, InData%TurbineRefPos)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegPack(Buf, InData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileName
   call RegPack(Buf, InData%FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsePrimaryInputFile
   call RegPack(Buf, InData%UsePrimaryInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedPrimaryInputData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInitInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! g
   call RegUnpack(Buf, OutData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rhoW
   call RegUnpack(Buf, OutData%rhoW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDepth
   call RegUnpack(Buf, OutData%WtrDepth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmInit
   if (allocated(OutData%PtfmInit)) deallocate(OutData%PtfmInit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmInit(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmInit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmInit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FarmSize
   call RegUnpack(Buf, OutData%FarmSize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineRefPos
   if (allocated(OutData%TurbineRefPos)) deallocate(OutData%TurbineRefPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TurbineRefPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TurbineRefPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TurbineRefPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Tmax
   call RegUnpack(Buf, OutData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FileName
   call RegUnpack(Buf, OutData%FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UsePrimaryInputFile
   call RegUnpack(Buf, OutData%UsePrimaryInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedPrimaryInputData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedPrimaryInputData) ! PassedPrimaryInputData 
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyLineProp( SrcLinePropData, DstLinePropData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_LineProp), INTENT(IN) :: SrcLinePropData
   TYPE(MD_LineProp), INTENT(INOUT) :: DstLinePropData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyLineProp'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstLinePropData%IdNum = SrcLinePropData%IdNum
    DstLinePropData%name = SrcLinePropData%name
    DstLinePropData%d = SrcLinePropData%d
    DstLinePropData%w = SrcLinePropData%w
    DstLinePropData%EA = SrcLinePropData%EA
    DstLinePropData%EA_D = SrcLinePropData%EA_D
    DstLinePropData%BA = SrcLinePropData%BA
    DstLinePropData%BA_D = SrcLinePropData%BA_D
    DstLinePropData%EI = SrcLinePropData%EI
    DstLinePropData%Can = SrcLinePropData%Can
    DstLinePropData%Cat = SrcLinePropData%Cat
    DstLinePropData%Cdn = SrcLinePropData%Cdn
    DstLinePropData%Cdt = SrcLinePropData%Cdt
    DstLinePropData%ElasticMod = SrcLinePropData%ElasticMod
    DstLinePropData%nEApoints = SrcLinePropData%nEApoints
    DstLinePropData%stiffXs = SrcLinePropData%stiffXs
    DstLinePropData%stiffYs = SrcLinePropData%stiffYs
    DstLinePropData%nBApoints = SrcLinePropData%nBApoints
    DstLinePropData%dampXs = SrcLinePropData%dampXs
    DstLinePropData%dampYs = SrcLinePropData%dampYs
    DstLinePropData%nEIpoints = SrcLinePropData%nEIpoints
    DstLinePropData%bstiffXs = SrcLinePropData%bstiffXs
    DstLinePropData%bstiffYs = SrcLinePropData%bstiffYs
 END SUBROUTINE MD_CopyLineProp

 SUBROUTINE MD_DestroyLineProp( LinePropData, ErrStat, ErrMsg )
  TYPE(MD_LineProp), INTENT(INOUT) :: LinePropData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyLineProp'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyLineProp


subroutine MD_PackLineProp(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_LineProp), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackLineProp'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! name
   call RegPack(Buf, InData%name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegPack(Buf, InData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! w
   call RegPack(Buf, InData%w)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA
   call RegPack(Buf, InData%EA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA_D
   call RegPack(Buf, InData%EA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA
   call RegPack(Buf, InData%BA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA_D
   call RegPack(Buf, InData%BA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EI
   call RegPack(Buf, InData%EI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegPack(Buf, InData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegPack(Buf, InData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegPack(Buf, InData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegPack(Buf, InData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElasticMod
   call RegPack(Buf, InData%ElasticMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEApoints
   call RegPack(Buf, InData%nEApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffXs
   call RegPack(Buf, InData%stiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffYs
   call RegPack(Buf, InData%stiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBApoints
   call RegPack(Buf, InData%nBApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampXs
   call RegPack(Buf, InData%dampXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampYs
   call RegPack(Buf, InData%dampYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEIpoints
   call RegPack(Buf, InData%nEIpoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffXs
   call RegPack(Buf, InData%bstiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffYs
   call RegPack(Buf, InData%bstiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackLineProp(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_LineProp), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackLineProp'
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! name
   call RegUnpack(Buf, OutData%name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegUnpack(Buf, OutData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! w
   call RegUnpack(Buf, OutData%w)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA
   call RegUnpack(Buf, OutData%EA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA_D
   call RegUnpack(Buf, OutData%EA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA
   call RegUnpack(Buf, OutData%BA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA_D
   call RegUnpack(Buf, OutData%BA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EI
   call RegUnpack(Buf, OutData%EI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegUnpack(Buf, OutData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegUnpack(Buf, OutData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegUnpack(Buf, OutData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegUnpack(Buf, OutData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElasticMod
   call RegUnpack(Buf, OutData%ElasticMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEApoints
   call RegUnpack(Buf, OutData%nEApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffXs
   call RegUnpack(Buf, OutData%stiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffYs
   call RegUnpack(Buf, OutData%stiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBApoints
   call RegUnpack(Buf, OutData%nBApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampXs
   call RegUnpack(Buf, OutData%dampXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampYs
   call RegUnpack(Buf, OutData%dampYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEIpoints
   call RegUnpack(Buf, OutData%nEIpoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffXs
   call RegUnpack(Buf, OutData%bstiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffYs
   call RegUnpack(Buf, OutData%bstiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyRodProp( SrcRodPropData, DstRodPropData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_RodProp), INTENT(IN) :: SrcRodPropData
   TYPE(MD_RodProp), INTENT(INOUT) :: DstRodPropData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyRodProp'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRodPropData%IdNum = SrcRodPropData%IdNum
    DstRodPropData%name = SrcRodPropData%name
    DstRodPropData%d = SrcRodPropData%d
    DstRodPropData%w = SrcRodPropData%w
    DstRodPropData%Can = SrcRodPropData%Can
    DstRodPropData%Cat = SrcRodPropData%Cat
    DstRodPropData%Cdn = SrcRodPropData%Cdn
    DstRodPropData%Cdt = SrcRodPropData%Cdt
    DstRodPropData%CdEnd = SrcRodPropData%CdEnd
    DstRodPropData%CaEnd = SrcRodPropData%CaEnd
 END SUBROUTINE MD_CopyRodProp

 SUBROUTINE MD_DestroyRodProp( RodPropData, ErrStat, ErrMsg )
  TYPE(MD_RodProp), INTENT(INOUT) :: RodPropData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyRodProp'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyRodProp


subroutine MD_PackRodProp(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_RodProp), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackRodProp'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! name
   call RegPack(Buf, InData%name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegPack(Buf, InData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! w
   call RegPack(Buf, InData%w)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegPack(Buf, InData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegPack(Buf, InData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegPack(Buf, InData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegPack(Buf, InData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CdEnd
   call RegPack(Buf, InData%CdEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CaEnd
   call RegPack(Buf, InData%CaEnd)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackRodProp(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_RodProp), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackRodProp'
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! name
   call RegUnpack(Buf, OutData%name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegUnpack(Buf, OutData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! w
   call RegUnpack(Buf, OutData%w)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegUnpack(Buf, OutData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegUnpack(Buf, OutData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegUnpack(Buf, OutData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegUnpack(Buf, OutData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CdEnd
   call RegUnpack(Buf, OutData%CdEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CaEnd
   call RegUnpack(Buf, OutData%CaEnd)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyBody( SrcBodyData, DstBodyData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Body), INTENT(IN) :: SrcBodyData
   TYPE(MD_Body), INTENT(INOUT) :: DstBodyData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyBody'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBodyData%IdNum = SrcBodyData%IdNum
    DstBodyData%typeNum = SrcBodyData%typeNum
    DstBodyData%AttachedC = SrcBodyData%AttachedC
    DstBodyData%AttachedR = SrcBodyData%AttachedR
    DstBodyData%nAttachedC = SrcBodyData%nAttachedC
    DstBodyData%nAttachedR = SrcBodyData%nAttachedR
    DstBodyData%rConnectRel = SrcBodyData%rConnectRel
    DstBodyData%r6RodRel = SrcBodyData%r6RodRel
    DstBodyData%bodyM = SrcBodyData%bodyM
    DstBodyData%bodyV = SrcBodyData%bodyV
    DstBodyData%bodyI = SrcBodyData%bodyI
    DstBodyData%bodyCdA = SrcBodyData%bodyCdA
    DstBodyData%bodyCa = SrcBodyData%bodyCa
    DstBodyData%time = SrcBodyData%time
    DstBodyData%r6 = SrcBodyData%r6
    DstBodyData%v6 = SrcBodyData%v6
    DstBodyData%a6 = SrcBodyData%a6
    DstBodyData%U = SrcBodyData%U
    DstBodyData%Ud = SrcBodyData%Ud
    DstBodyData%zeta = SrcBodyData%zeta
    DstBodyData%F6net = SrcBodyData%F6net
    DstBodyData%M6net = SrcBodyData%M6net
    DstBodyData%M = SrcBodyData%M
    DstBodyData%M0 = SrcBodyData%M0
    DstBodyData%OrMat = SrcBodyData%OrMat
    DstBodyData%rCG = SrcBodyData%rCG
 END SUBROUTINE MD_CopyBody

 SUBROUTINE MD_DestroyBody( BodyData, ErrStat, ErrMsg )
  TYPE(MD_Body), INTENT(INOUT) :: BodyData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyBody'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyBody


subroutine MD_PackBody(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_Body), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackBody'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! typeNum
   call RegPack(Buf, InData%typeNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedC
   call RegPack(Buf, InData%AttachedC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedR
   call RegPack(Buf, InData%AttachedR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedC
   call RegPack(Buf, InData%nAttachedC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedR
   call RegPack(Buf, InData%nAttachedR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rConnectRel
   call RegPack(Buf, InData%rConnectRel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r6RodRel
   call RegPack(Buf, InData%r6RodRel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyM
   call RegPack(Buf, InData%bodyM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyV
   call RegPack(Buf, InData%bodyV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyI
   call RegPack(Buf, InData%bodyI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyCdA
   call RegPack(Buf, InData%bodyCdA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyCa
   call RegPack(Buf, InData%bodyCa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegPack(Buf, InData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r6
   call RegPack(Buf, InData%r6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! v6
   call RegPack(Buf, InData%v6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a6
   call RegPack(Buf, InData%a6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegPack(Buf, InData%U)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ud
   call RegPack(Buf, InData%Ud)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegPack(Buf, InData%zeta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F6net
   call RegPack(Buf, InData%F6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M6net
   call RegPack(Buf, InData%M6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegPack(Buf, InData%M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M0
   call RegPack(Buf, InData%M0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OrMat
   call RegPack(Buf, InData%OrMat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rCG
   call RegPack(Buf, InData%rCG)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackBody(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_Body), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackBody'
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! typeNum
   call RegUnpack(Buf, OutData%typeNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedC
   call RegUnpack(Buf, OutData%AttachedC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedR
   call RegUnpack(Buf, OutData%AttachedR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedC
   call RegUnpack(Buf, OutData%nAttachedC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedR
   call RegUnpack(Buf, OutData%nAttachedR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rConnectRel
   call RegUnpack(Buf, OutData%rConnectRel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r6RodRel
   call RegUnpack(Buf, OutData%r6RodRel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyM
   call RegUnpack(Buf, OutData%bodyM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyV
   call RegUnpack(Buf, OutData%bodyV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyI
   call RegUnpack(Buf, OutData%bodyI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyCdA
   call RegUnpack(Buf, OutData%bodyCdA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bodyCa
   call RegUnpack(Buf, OutData%bodyCa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegUnpack(Buf, OutData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r6
   call RegUnpack(Buf, OutData%r6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! v6
   call RegUnpack(Buf, OutData%v6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a6
   call RegUnpack(Buf, OutData%a6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegUnpack(Buf, OutData%U)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ud
   call RegUnpack(Buf, OutData%Ud)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegUnpack(Buf, OutData%zeta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F6net
   call RegUnpack(Buf, OutData%F6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M6net
   call RegUnpack(Buf, OutData%M6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegUnpack(Buf, OutData%M)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M0
   call RegUnpack(Buf, OutData%M0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OrMat
   call RegUnpack(Buf, OutData%OrMat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rCG
   call RegUnpack(Buf, OutData%rCG)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyConnect( SrcConnectData, DstConnectData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Connect), INTENT(IN) :: SrcConnectData
   TYPE(MD_Connect), INTENT(INOUT) :: DstConnectData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyConnect'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConnectData%IdNum = SrcConnectData%IdNum
    DstConnectData%type = SrcConnectData%type
    DstConnectData%typeNum = SrcConnectData%typeNum
    DstConnectData%Attached = SrcConnectData%Attached
    DstConnectData%Top = SrcConnectData%Top
    DstConnectData%nAttached = SrcConnectData%nAttached
    DstConnectData%conM = SrcConnectData%conM
    DstConnectData%conV = SrcConnectData%conV
    DstConnectData%conFX = SrcConnectData%conFX
    DstConnectData%conFY = SrcConnectData%conFY
    DstConnectData%conFZ = SrcConnectData%conFZ
    DstConnectData%conCa = SrcConnectData%conCa
    DstConnectData%conCdA = SrcConnectData%conCdA
    DstConnectData%time = SrcConnectData%time
    DstConnectData%r = SrcConnectData%r
    DstConnectData%rd = SrcConnectData%rd
    DstConnectData%a = SrcConnectData%a
    DstConnectData%U = SrcConnectData%U
    DstConnectData%Ud = SrcConnectData%Ud
    DstConnectData%zeta = SrcConnectData%zeta
IF (ALLOCATED(SrcConnectData%PDyn)) THEN
  i1_l = LBOUND(SrcConnectData%PDyn,1)
  i1_u = UBOUND(SrcConnectData%PDyn,1)
  IF (.NOT. ALLOCATED(DstConnectData%PDyn)) THEN 
    ALLOCATE(DstConnectData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConnectData%PDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstConnectData%PDyn = SrcConnectData%PDyn
ENDIF
    DstConnectData%Fnet = SrcConnectData%Fnet
    DstConnectData%M = SrcConnectData%M
 END SUBROUTINE MD_CopyConnect

 SUBROUTINE MD_DestroyConnect( ConnectData, ErrStat, ErrMsg )
  TYPE(MD_Connect), INTENT(INOUT) :: ConnectData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyConnect'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ConnectData%PDyn)) THEN
  DEALLOCATE(ConnectData%PDyn)
ENDIF
 END SUBROUTINE MD_DestroyConnect


subroutine MD_PackConnect(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_Connect), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackConnect'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! type
   call RegPack(Buf, InData%type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! typeNum
   call RegPack(Buf, InData%typeNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Attached
   call RegPack(Buf, InData%Attached)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Top
   call RegPack(Buf, InData%Top)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttached
   call RegPack(Buf, InData%nAttached)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conM
   call RegPack(Buf, InData%conM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conV
   call RegPack(Buf, InData%conV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conFX
   call RegPack(Buf, InData%conFX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conFY
   call RegPack(Buf, InData%conFY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conFZ
   call RegPack(Buf, InData%conFZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conCa
   call RegPack(Buf, InData%conCa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conCdA
   call RegPack(Buf, InData%conCdA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegPack(Buf, InData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   call RegPack(Buf, InData%r)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rd
   call RegPack(Buf, InData%rd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a
   call RegPack(Buf, InData%a)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegPack(Buf, InData%U)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ud
   call RegPack(Buf, InData%Ud)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegPack(Buf, InData%zeta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PDyn
   call RegPack(Buf, allocated(InData%PDyn))
   if (allocated(InData%PDyn)) then
      call RegPackBounds(Buf, 1, lbound(InData%PDyn), ubound(InData%PDyn))
      call RegPack(Buf, InData%PDyn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fnet
   call RegPack(Buf, InData%Fnet)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegPack(Buf, InData%M)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackConnect(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_Connect), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackConnect'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! type
   call RegUnpack(Buf, OutData%type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! typeNum
   call RegUnpack(Buf, OutData%typeNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Attached
   call RegUnpack(Buf, OutData%Attached)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Top
   call RegUnpack(Buf, OutData%Top)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttached
   call RegUnpack(Buf, OutData%nAttached)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conM
   call RegUnpack(Buf, OutData%conM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conV
   call RegUnpack(Buf, OutData%conV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conFX
   call RegUnpack(Buf, OutData%conFX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conFY
   call RegUnpack(Buf, OutData%conFY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conFZ
   call RegUnpack(Buf, OutData%conFZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conCa
   call RegUnpack(Buf, OutData%conCa)
   if (RegCheckErr(Buf, RoutineName)) return
   ! conCdA
   call RegUnpack(Buf, OutData%conCdA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegUnpack(Buf, OutData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   call RegUnpack(Buf, OutData%r)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rd
   call RegUnpack(Buf, OutData%rd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a
   call RegUnpack(Buf, OutData%a)
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegUnpack(Buf, OutData%U)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ud
   call RegUnpack(Buf, OutData%Ud)
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegUnpack(Buf, OutData%zeta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PDyn
   if (allocated(OutData%PDyn)) deallocate(OutData%PDyn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PDyn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PDyn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Fnet
   call RegUnpack(Buf, OutData%Fnet)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegUnpack(Buf, OutData%M)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyRod( SrcRodData, DstRodData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Rod), INTENT(IN) :: SrcRodData
   TYPE(MD_Rod), INTENT(INOUT) :: DstRodData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyRod'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRodData%IdNum = SrcRodData%IdNum
    DstRodData%type = SrcRodData%type
    DstRodData%PropsIdNum = SrcRodData%PropsIdNum
    DstRodData%typeNum = SrcRodData%typeNum
    DstRodData%AttachedA = SrcRodData%AttachedA
    DstRodData%AttachedB = SrcRodData%AttachedB
    DstRodData%TopA = SrcRodData%TopA
    DstRodData%TopB = SrcRodData%TopB
    DstRodData%nAttachedA = SrcRodData%nAttachedA
    DstRodData%nAttachedB = SrcRodData%nAttachedB
    DstRodData%OutFlagList = SrcRodData%OutFlagList
    DstRodData%N = SrcRodData%N
    DstRodData%endTypeA = SrcRodData%endTypeA
    DstRodData%endTypeB = SrcRodData%endTypeB
    DstRodData%UnstrLen = SrcRodData%UnstrLen
    DstRodData%mass = SrcRodData%mass
    DstRodData%rho = SrcRodData%rho
    DstRodData%d = SrcRodData%d
    DstRodData%Can = SrcRodData%Can
    DstRodData%Cat = SrcRodData%Cat
    DstRodData%Cdn = SrcRodData%Cdn
    DstRodData%Cdt = SrcRodData%Cdt
    DstRodData%CdEnd = SrcRodData%CdEnd
    DstRodData%CaEnd = SrcRodData%CaEnd
    DstRodData%time = SrcRodData%time
    DstRodData%roll = SrcRodData%roll
    DstRodData%pitch = SrcRodData%pitch
    DstRodData%h0 = SrcRodData%h0
IF (ALLOCATED(SrcRodData%r)) THEN
  i1_l = LBOUND(SrcRodData%r,1)
  i1_u = UBOUND(SrcRodData%r,1)
  i2_l = LBOUND(SrcRodData%r,2)
  i2_u = UBOUND(SrcRodData%r,2)
  IF (.NOT. ALLOCATED(DstRodData%r)) THEN 
    ALLOCATE(DstRodData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%r.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%r = SrcRodData%r
ENDIF
IF (ALLOCATED(SrcRodData%rd)) THEN
  i1_l = LBOUND(SrcRodData%rd,1)
  i1_u = UBOUND(SrcRodData%rd,1)
  i2_l = LBOUND(SrcRodData%rd,2)
  i2_u = UBOUND(SrcRodData%rd,2)
  IF (.NOT. ALLOCATED(DstRodData%rd)) THEN 
    ALLOCATE(DstRodData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%rd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%rd = SrcRodData%rd
ENDIF
    DstRodData%q = SrcRodData%q
IF (ALLOCATED(SrcRodData%l)) THEN
  i1_l = LBOUND(SrcRodData%l,1)
  i1_u = UBOUND(SrcRodData%l,1)
  IF (.NOT. ALLOCATED(DstRodData%l)) THEN 
    ALLOCATE(DstRodData%l(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%l.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%l = SrcRodData%l
ENDIF
IF (ALLOCATED(SrcRodData%V)) THEN
  i1_l = LBOUND(SrcRodData%V,1)
  i1_u = UBOUND(SrcRodData%V,1)
  IF (.NOT. ALLOCATED(DstRodData%V)) THEN 
    ALLOCATE(DstRodData%V(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%V.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%V = SrcRodData%V
ENDIF
IF (ALLOCATED(SrcRodData%U)) THEN
  i1_l = LBOUND(SrcRodData%U,1)
  i1_u = UBOUND(SrcRodData%U,1)
  i2_l = LBOUND(SrcRodData%U,2)
  i2_u = UBOUND(SrcRodData%U,2)
  IF (.NOT. ALLOCATED(DstRodData%U)) THEN 
    ALLOCATE(DstRodData%U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%U.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%U = SrcRodData%U
ENDIF
IF (ALLOCATED(SrcRodData%Ud)) THEN
  i1_l = LBOUND(SrcRodData%Ud,1)
  i1_u = UBOUND(SrcRodData%Ud,1)
  i2_l = LBOUND(SrcRodData%Ud,2)
  i2_u = UBOUND(SrcRodData%Ud,2)
  IF (.NOT. ALLOCATED(DstRodData%Ud)) THEN 
    ALLOCATE(DstRodData%Ud(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Ud.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Ud = SrcRodData%Ud
ENDIF
IF (ALLOCATED(SrcRodData%zeta)) THEN
  i1_l = LBOUND(SrcRodData%zeta,1)
  i1_u = UBOUND(SrcRodData%zeta,1)
  IF (.NOT. ALLOCATED(DstRodData%zeta)) THEN 
    ALLOCATE(DstRodData%zeta(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%zeta.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%zeta = SrcRodData%zeta
ENDIF
IF (ALLOCATED(SrcRodData%PDyn)) THEN
  i1_l = LBOUND(SrcRodData%PDyn,1)
  i1_u = UBOUND(SrcRodData%PDyn,1)
  IF (.NOT. ALLOCATED(DstRodData%PDyn)) THEN 
    ALLOCATE(DstRodData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%PDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%PDyn = SrcRodData%PDyn
ENDIF
IF (ALLOCATED(SrcRodData%W)) THEN
  i1_l = LBOUND(SrcRodData%W,1)
  i1_u = UBOUND(SrcRodData%W,1)
  i2_l = LBOUND(SrcRodData%W,2)
  i2_u = UBOUND(SrcRodData%W,2)
  IF (.NOT. ALLOCATED(DstRodData%W)) THEN 
    ALLOCATE(DstRodData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%W = SrcRodData%W
ENDIF
IF (ALLOCATED(SrcRodData%Bo)) THEN
  i1_l = LBOUND(SrcRodData%Bo,1)
  i1_u = UBOUND(SrcRodData%Bo,1)
  i2_l = LBOUND(SrcRodData%Bo,2)
  i2_u = UBOUND(SrcRodData%Bo,2)
  IF (.NOT. ALLOCATED(DstRodData%Bo)) THEN 
    ALLOCATE(DstRodData%Bo(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Bo.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Bo = SrcRodData%Bo
ENDIF
IF (ALLOCATED(SrcRodData%Pd)) THEN
  i1_l = LBOUND(SrcRodData%Pd,1)
  i1_u = UBOUND(SrcRodData%Pd,1)
  i2_l = LBOUND(SrcRodData%Pd,2)
  i2_u = UBOUND(SrcRodData%Pd,2)
  IF (.NOT. ALLOCATED(DstRodData%Pd)) THEN 
    ALLOCATE(DstRodData%Pd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Pd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Pd = SrcRodData%Pd
ENDIF
IF (ALLOCATED(SrcRodData%Dp)) THEN
  i1_l = LBOUND(SrcRodData%Dp,1)
  i1_u = UBOUND(SrcRodData%Dp,1)
  i2_l = LBOUND(SrcRodData%Dp,2)
  i2_u = UBOUND(SrcRodData%Dp,2)
  IF (.NOT. ALLOCATED(DstRodData%Dp)) THEN 
    ALLOCATE(DstRodData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Dp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Dp = SrcRodData%Dp
ENDIF
IF (ALLOCATED(SrcRodData%Dq)) THEN
  i1_l = LBOUND(SrcRodData%Dq,1)
  i1_u = UBOUND(SrcRodData%Dq,1)
  i2_l = LBOUND(SrcRodData%Dq,2)
  i2_u = UBOUND(SrcRodData%Dq,2)
  IF (.NOT. ALLOCATED(DstRodData%Dq)) THEN 
    ALLOCATE(DstRodData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Dq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Dq = SrcRodData%Dq
ENDIF
IF (ALLOCATED(SrcRodData%Ap)) THEN
  i1_l = LBOUND(SrcRodData%Ap,1)
  i1_u = UBOUND(SrcRodData%Ap,1)
  i2_l = LBOUND(SrcRodData%Ap,2)
  i2_u = UBOUND(SrcRodData%Ap,2)
  IF (.NOT. ALLOCATED(DstRodData%Ap)) THEN 
    ALLOCATE(DstRodData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Ap.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Ap = SrcRodData%Ap
ENDIF
IF (ALLOCATED(SrcRodData%Aq)) THEN
  i1_l = LBOUND(SrcRodData%Aq,1)
  i1_u = UBOUND(SrcRodData%Aq,1)
  i2_l = LBOUND(SrcRodData%Aq,2)
  i2_u = UBOUND(SrcRodData%Aq,2)
  IF (.NOT. ALLOCATED(DstRodData%Aq)) THEN 
    ALLOCATE(DstRodData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Aq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Aq = SrcRodData%Aq
ENDIF
IF (ALLOCATED(SrcRodData%B)) THEN
  i1_l = LBOUND(SrcRodData%B,1)
  i1_u = UBOUND(SrcRodData%B,1)
  i2_l = LBOUND(SrcRodData%B,2)
  i2_u = UBOUND(SrcRodData%B,2)
  IF (.NOT. ALLOCATED(DstRodData%B)) THEN 
    ALLOCATE(DstRodData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%B = SrcRodData%B
ENDIF
IF (ALLOCATED(SrcRodData%Fnet)) THEN
  i1_l = LBOUND(SrcRodData%Fnet,1)
  i1_u = UBOUND(SrcRodData%Fnet,1)
  i2_l = LBOUND(SrcRodData%Fnet,2)
  i2_u = UBOUND(SrcRodData%Fnet,2)
  IF (.NOT. ALLOCATED(DstRodData%Fnet)) THEN 
    ALLOCATE(DstRodData%Fnet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Fnet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Fnet = SrcRodData%Fnet
ENDIF
IF (ALLOCATED(SrcRodData%M)) THEN
  i1_l = LBOUND(SrcRodData%M,1)
  i1_u = UBOUND(SrcRodData%M,1)
  i2_l = LBOUND(SrcRodData%M,2)
  i2_u = UBOUND(SrcRodData%M,2)
  i3_l = LBOUND(SrcRodData%M,3)
  i3_u = UBOUND(SrcRodData%M,3)
  IF (.NOT. ALLOCATED(DstRodData%M)) THEN 
    ALLOCATE(DstRodData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%M = SrcRodData%M
ENDIF
    DstRodData%FextA = SrcRodData%FextA
    DstRodData%FextB = SrcRodData%FextB
    DstRodData%Mext = SrcRodData%Mext
    DstRodData%r6 = SrcRodData%r6
    DstRodData%v6 = SrcRodData%v6
    DstRodData%a6 = SrcRodData%a6
    DstRodData%F6net = SrcRodData%F6net
    DstRodData%M6net = SrcRodData%M6net
    DstRodData%OrMat = SrcRodData%OrMat
    DstRodData%RodUnOut = SrcRodData%RodUnOut
IF (ALLOCATED(SrcRodData%RodWrOutput)) THEN
  i1_l = LBOUND(SrcRodData%RodWrOutput,1)
  i1_u = UBOUND(SrcRodData%RodWrOutput,1)
  IF (.NOT. ALLOCATED(DstRodData%RodWrOutput)) THEN 
    ALLOCATE(DstRodData%RodWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%RodWrOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%RodWrOutput = SrcRodData%RodWrOutput
ENDIF
 END SUBROUTINE MD_CopyRod

 SUBROUTINE MD_DestroyRod( RodData, ErrStat, ErrMsg )
  TYPE(MD_Rod), INTENT(INOUT) :: RodData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyRod'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(RodData%r)) THEN
  DEALLOCATE(RodData%r)
ENDIF
IF (ALLOCATED(RodData%rd)) THEN
  DEALLOCATE(RodData%rd)
ENDIF
IF (ALLOCATED(RodData%l)) THEN
  DEALLOCATE(RodData%l)
ENDIF
IF (ALLOCATED(RodData%V)) THEN
  DEALLOCATE(RodData%V)
ENDIF
IF (ALLOCATED(RodData%U)) THEN
  DEALLOCATE(RodData%U)
ENDIF
IF (ALLOCATED(RodData%Ud)) THEN
  DEALLOCATE(RodData%Ud)
ENDIF
IF (ALLOCATED(RodData%zeta)) THEN
  DEALLOCATE(RodData%zeta)
ENDIF
IF (ALLOCATED(RodData%PDyn)) THEN
  DEALLOCATE(RodData%PDyn)
ENDIF
IF (ALLOCATED(RodData%W)) THEN
  DEALLOCATE(RodData%W)
ENDIF
IF (ALLOCATED(RodData%Bo)) THEN
  DEALLOCATE(RodData%Bo)
ENDIF
IF (ALLOCATED(RodData%Pd)) THEN
  DEALLOCATE(RodData%Pd)
ENDIF
IF (ALLOCATED(RodData%Dp)) THEN
  DEALLOCATE(RodData%Dp)
ENDIF
IF (ALLOCATED(RodData%Dq)) THEN
  DEALLOCATE(RodData%Dq)
ENDIF
IF (ALLOCATED(RodData%Ap)) THEN
  DEALLOCATE(RodData%Ap)
ENDIF
IF (ALLOCATED(RodData%Aq)) THEN
  DEALLOCATE(RodData%Aq)
ENDIF
IF (ALLOCATED(RodData%B)) THEN
  DEALLOCATE(RodData%B)
ENDIF
IF (ALLOCATED(RodData%Fnet)) THEN
  DEALLOCATE(RodData%Fnet)
ENDIF
IF (ALLOCATED(RodData%M)) THEN
  DEALLOCATE(RodData%M)
ENDIF
IF (ALLOCATED(RodData%RodWrOutput)) THEN
  DEALLOCATE(RodData%RodWrOutput)
ENDIF
 END SUBROUTINE MD_DestroyRod


subroutine MD_PackRod(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_Rod), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackRod'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! type
   call RegPack(Buf, InData%type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsIdNum
   call RegPack(Buf, InData%PropsIdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! typeNum
   call RegPack(Buf, InData%typeNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedA
   call RegPack(Buf, InData%AttachedA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedB
   call RegPack(Buf, InData%AttachedB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TopA
   call RegPack(Buf, InData%TopA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TopB
   call RegPack(Buf, InData%TopB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedA
   call RegPack(Buf, InData%nAttachedA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedB
   call RegPack(Buf, InData%nAttachedB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFlagList
   call RegPack(Buf, InData%OutFlagList)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N
   call RegPack(Buf, InData%N)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeA
   call RegPack(Buf, InData%endTypeA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeB
   call RegPack(Buf, InData%endTypeB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnstrLen
   call RegPack(Buf, InData%UnstrLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! mass
   call RegPack(Buf, InData%mass)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho
   call RegPack(Buf, InData%rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegPack(Buf, InData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegPack(Buf, InData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegPack(Buf, InData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegPack(Buf, InData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegPack(Buf, InData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CdEnd
   call RegPack(Buf, InData%CdEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CaEnd
   call RegPack(Buf, InData%CaEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegPack(Buf, InData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! roll
   call RegPack(Buf, InData%roll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pitch
   call RegPack(Buf, InData%pitch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! h0
   call RegPack(Buf, InData%h0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   call RegPack(Buf, allocated(InData%r))
   if (allocated(InData%r)) then
      call RegPackBounds(Buf, 2, lbound(InData%r), ubound(InData%r))
      call RegPack(Buf, InData%r)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rd
   call RegPack(Buf, allocated(InData%rd))
   if (allocated(InData%rd)) then
      call RegPackBounds(Buf, 2, lbound(InData%rd), ubound(InData%rd))
      call RegPack(Buf, InData%rd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! q
   call RegPack(Buf, InData%q)
   if (RegCheckErr(Buf, RoutineName)) return
   ! l
   call RegPack(Buf, allocated(InData%l))
   if (allocated(InData%l)) then
      call RegPackBounds(Buf, 1, lbound(InData%l), ubound(InData%l))
      call RegPack(Buf, InData%l)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! V
   call RegPack(Buf, allocated(InData%V))
   if (allocated(InData%V)) then
      call RegPackBounds(Buf, 1, lbound(InData%V), ubound(InData%V))
      call RegPack(Buf, InData%V)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegPack(Buf, allocated(InData%U))
   if (allocated(InData%U)) then
      call RegPackBounds(Buf, 2, lbound(InData%U), ubound(InData%U))
      call RegPack(Buf, InData%U)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ud
   call RegPack(Buf, allocated(InData%Ud))
   if (allocated(InData%Ud)) then
      call RegPackBounds(Buf, 2, lbound(InData%Ud), ubound(InData%Ud))
      call RegPack(Buf, InData%Ud)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegPack(Buf, allocated(InData%zeta))
   if (allocated(InData%zeta)) then
      call RegPackBounds(Buf, 1, lbound(InData%zeta), ubound(InData%zeta))
      call RegPack(Buf, InData%zeta)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PDyn
   call RegPack(Buf, allocated(InData%PDyn))
   if (allocated(InData%PDyn)) then
      call RegPackBounds(Buf, 1, lbound(InData%PDyn), ubound(InData%PDyn))
      call RegPack(Buf, InData%PDyn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 2, lbound(InData%W), ubound(InData%W))
      call RegPack(Buf, InData%W)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Bo
   call RegPack(Buf, allocated(InData%Bo))
   if (allocated(InData%Bo)) then
      call RegPackBounds(Buf, 2, lbound(InData%Bo), ubound(InData%Bo))
      call RegPack(Buf, InData%Bo)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Pd
   call RegPack(Buf, allocated(InData%Pd))
   if (allocated(InData%Pd)) then
      call RegPackBounds(Buf, 2, lbound(InData%Pd), ubound(InData%Pd))
      call RegPack(Buf, InData%Pd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Dp
   call RegPack(Buf, allocated(InData%Dp))
   if (allocated(InData%Dp)) then
      call RegPackBounds(Buf, 2, lbound(InData%Dp), ubound(InData%Dp))
      call RegPack(Buf, InData%Dp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Dq
   call RegPack(Buf, allocated(InData%Dq))
   if (allocated(InData%Dq)) then
      call RegPackBounds(Buf, 2, lbound(InData%Dq), ubound(InData%Dq))
      call RegPack(Buf, InData%Dq)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ap
   call RegPack(Buf, allocated(InData%Ap))
   if (allocated(InData%Ap)) then
      call RegPackBounds(Buf, 2, lbound(InData%Ap), ubound(InData%Ap))
      call RegPack(Buf, InData%Ap)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Aq
   call RegPack(Buf, allocated(InData%Aq))
   if (allocated(InData%Aq)) then
      call RegPackBounds(Buf, 2, lbound(InData%Aq), ubound(InData%Aq))
      call RegPack(Buf, InData%Aq)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! B
   call RegPack(Buf, allocated(InData%B))
   if (allocated(InData%B)) then
      call RegPackBounds(Buf, 2, lbound(InData%B), ubound(InData%B))
      call RegPack(Buf, InData%B)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fnet
   call RegPack(Buf, allocated(InData%Fnet))
   if (allocated(InData%Fnet)) then
      call RegPackBounds(Buf, 2, lbound(InData%Fnet), ubound(InData%Fnet))
      call RegPack(Buf, InData%Fnet)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegPack(Buf, allocated(InData%M))
   if (allocated(InData%M)) then
      call RegPackBounds(Buf, 3, lbound(InData%M), ubound(InData%M))
      call RegPack(Buf, InData%M)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FextA
   call RegPack(Buf, InData%FextA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FextB
   call RegPack(Buf, InData%FextB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mext
   call RegPack(Buf, InData%Mext)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r6
   call RegPack(Buf, InData%r6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! v6
   call RegPack(Buf, InData%v6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a6
   call RegPack(Buf, InData%a6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F6net
   call RegPack(Buf, InData%F6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M6net
   call RegPack(Buf, InData%M6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OrMat
   call RegPack(Buf, InData%OrMat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodUnOut
   call RegPack(Buf, InData%RodUnOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodWrOutput
   call RegPack(Buf, allocated(InData%RodWrOutput))
   if (allocated(InData%RodWrOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%RodWrOutput), ubound(InData%RodWrOutput))
      call RegPack(Buf, InData%RodWrOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackRod(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_Rod), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackRod'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! type
   call RegUnpack(Buf, OutData%type)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsIdNum
   call RegUnpack(Buf, OutData%PropsIdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! typeNum
   call RegUnpack(Buf, OutData%typeNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedA
   call RegUnpack(Buf, OutData%AttachedA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AttachedB
   call RegUnpack(Buf, OutData%AttachedB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TopA
   call RegUnpack(Buf, OutData%TopA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TopB
   call RegUnpack(Buf, OutData%TopB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedA
   call RegUnpack(Buf, OutData%nAttachedA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nAttachedB
   call RegUnpack(Buf, OutData%nAttachedB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFlagList
   call RegUnpack(Buf, OutData%OutFlagList)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N
   call RegUnpack(Buf, OutData%N)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeA
   call RegUnpack(Buf, OutData%endTypeA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeB
   call RegUnpack(Buf, OutData%endTypeB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnstrLen
   call RegUnpack(Buf, OutData%UnstrLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! mass
   call RegUnpack(Buf, OutData%mass)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho
   call RegUnpack(Buf, OutData%rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegUnpack(Buf, OutData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegUnpack(Buf, OutData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegUnpack(Buf, OutData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegUnpack(Buf, OutData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegUnpack(Buf, OutData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CdEnd
   call RegUnpack(Buf, OutData%CdEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CaEnd
   call RegUnpack(Buf, OutData%CaEnd)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegUnpack(Buf, OutData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! roll
   call RegUnpack(Buf, OutData%roll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pitch
   call RegUnpack(Buf, OutData%pitch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! h0
   call RegUnpack(Buf, OutData%h0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   if (allocated(OutData%r)) deallocate(OutData%r)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rd
   if (allocated(OutData%rd)) deallocate(OutData%rd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! q
   call RegUnpack(Buf, OutData%q)
   if (RegCheckErr(Buf, RoutineName)) return
   ! l
   if (allocated(OutData%l)) deallocate(OutData%l)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%l(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%l.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%l)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! V
   if (allocated(OutData%V)) deallocate(OutData%V)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%V(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%V.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%V)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U
   if (allocated(OutData%U)) deallocate(OutData%U)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ud
   if (allocated(OutData%Ud)) deallocate(OutData%Ud)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ud(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ud.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ud)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! zeta
   if (allocated(OutData%zeta)) deallocate(OutData%zeta)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zeta(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zeta.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zeta)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PDyn
   if (allocated(OutData%PDyn)) deallocate(OutData%PDyn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PDyn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PDyn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%W)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Bo
   if (allocated(OutData%Bo)) deallocate(OutData%Bo)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Bo(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bo.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Bo)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Pd
   if (allocated(OutData%Pd)) deallocate(OutData%Pd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Pd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Pd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Pd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Dp
   if (allocated(OutData%Dp)) deallocate(OutData%Dp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Dp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Dp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Dq
   if (allocated(OutData%Dq)) deallocate(OutData%Dq)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Dq(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dq.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Dq)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ap
   if (allocated(OutData%Ap)) deallocate(OutData%Ap)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ap(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ap.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ap)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Aq
   if (allocated(OutData%Aq)) deallocate(OutData%Aq)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Aq(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Aq.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Aq)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! B
   if (allocated(OutData%B)) deallocate(OutData%B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%B)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Fnet
   if (allocated(OutData%Fnet)) deallocate(OutData%Fnet)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Fnet(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fnet.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Fnet)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! M
   if (allocated(OutData%M)) deallocate(OutData%M)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%M(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%M)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FextA
   call RegUnpack(Buf, OutData%FextA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FextB
   call RegUnpack(Buf, OutData%FextB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Mext
   call RegUnpack(Buf, OutData%Mext)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r6
   call RegUnpack(Buf, OutData%r6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! v6
   call RegUnpack(Buf, OutData%v6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! a6
   call RegUnpack(Buf, OutData%a6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F6net
   call RegUnpack(Buf, OutData%F6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! M6net
   call RegUnpack(Buf, OutData%M6net)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OrMat
   call RegUnpack(Buf, OutData%OrMat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodUnOut
   call RegUnpack(Buf, OutData%RodUnOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodWrOutput
   if (allocated(OutData%RodWrOutput)) deallocate(OutData%RodWrOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RodWrOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodWrOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RodWrOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyLine( SrcLineData, DstLineData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Line), INTENT(IN) :: SrcLineData
   TYPE(MD_Line), INTENT(INOUT) :: DstLineData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyLine'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstLineData%IdNum = SrcLineData%IdNum
    DstLineData%PropsIdNum = SrcLineData%PropsIdNum
    DstLineData%ElasticMod = SrcLineData%ElasticMod
    DstLineData%OutFlagList = SrcLineData%OutFlagList
    DstLineData%CtrlChan = SrcLineData%CtrlChan
    DstLineData%FairConnect = SrcLineData%FairConnect
    DstLineData%AnchConnect = SrcLineData%AnchConnect
    DstLineData%N = SrcLineData%N
    DstLineData%endTypeA = SrcLineData%endTypeA
    DstLineData%endTypeB = SrcLineData%endTypeB
    DstLineData%UnstrLen = SrcLineData%UnstrLen
    DstLineData%rho = SrcLineData%rho
    DstLineData%d = SrcLineData%d
    DstLineData%EA = SrcLineData%EA
    DstLineData%EA_D = SrcLineData%EA_D
    DstLineData%BA = SrcLineData%BA
    DstLineData%BA_D = SrcLineData%BA_D
    DstLineData%EI = SrcLineData%EI
    DstLineData%Can = SrcLineData%Can
    DstLineData%Cat = SrcLineData%Cat
    DstLineData%Cdn = SrcLineData%Cdn
    DstLineData%Cdt = SrcLineData%Cdt
    DstLineData%nEApoints = SrcLineData%nEApoints
    DstLineData%stiffXs = SrcLineData%stiffXs
    DstLineData%stiffYs = SrcLineData%stiffYs
    DstLineData%nBApoints = SrcLineData%nBApoints
    DstLineData%dampXs = SrcLineData%dampXs
    DstLineData%dampYs = SrcLineData%dampYs
    DstLineData%nEIpoints = SrcLineData%nEIpoints
    DstLineData%bstiffXs = SrcLineData%bstiffXs
    DstLineData%bstiffYs = SrcLineData%bstiffYs
    DstLineData%time = SrcLineData%time
IF (ALLOCATED(SrcLineData%r)) THEN
  i1_l = LBOUND(SrcLineData%r,1)
  i1_u = UBOUND(SrcLineData%r,1)
  i2_l = LBOUND(SrcLineData%r,2)
  i2_u = UBOUND(SrcLineData%r,2)
  IF (.NOT. ALLOCATED(DstLineData%r)) THEN 
    ALLOCATE(DstLineData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%r.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%r = SrcLineData%r
ENDIF
IF (ALLOCATED(SrcLineData%rd)) THEN
  i1_l = LBOUND(SrcLineData%rd,1)
  i1_u = UBOUND(SrcLineData%rd,1)
  i2_l = LBOUND(SrcLineData%rd,2)
  i2_u = UBOUND(SrcLineData%rd,2)
  IF (.NOT. ALLOCATED(DstLineData%rd)) THEN 
    ALLOCATE(DstLineData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%rd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%rd = SrcLineData%rd
ENDIF
IF (ALLOCATED(SrcLineData%q)) THEN
  i1_l = LBOUND(SrcLineData%q,1)
  i1_u = UBOUND(SrcLineData%q,1)
  i2_l = LBOUND(SrcLineData%q,2)
  i2_u = UBOUND(SrcLineData%q,2)
  IF (.NOT. ALLOCATED(DstLineData%q)) THEN 
    ALLOCATE(DstLineData%q(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%q.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%q = SrcLineData%q
ENDIF
IF (ALLOCATED(SrcLineData%qs)) THEN
  i1_l = LBOUND(SrcLineData%qs,1)
  i1_u = UBOUND(SrcLineData%qs,1)
  i2_l = LBOUND(SrcLineData%qs,2)
  i2_u = UBOUND(SrcLineData%qs,2)
  IF (.NOT. ALLOCATED(DstLineData%qs)) THEN 
    ALLOCATE(DstLineData%qs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%qs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%qs = SrcLineData%qs
ENDIF
IF (ALLOCATED(SrcLineData%l)) THEN
  i1_l = LBOUND(SrcLineData%l,1)
  i1_u = UBOUND(SrcLineData%l,1)
  IF (.NOT. ALLOCATED(DstLineData%l)) THEN 
    ALLOCATE(DstLineData%l(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%l.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%l = SrcLineData%l
ENDIF
IF (ALLOCATED(SrcLineData%ld)) THEN
  i1_l = LBOUND(SrcLineData%ld,1)
  i1_u = UBOUND(SrcLineData%ld,1)
  IF (.NOT. ALLOCATED(DstLineData%ld)) THEN 
    ALLOCATE(DstLineData%ld(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%ld.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%ld = SrcLineData%ld
ENDIF
IF (ALLOCATED(SrcLineData%lstr)) THEN
  i1_l = LBOUND(SrcLineData%lstr,1)
  i1_u = UBOUND(SrcLineData%lstr,1)
  IF (.NOT. ALLOCATED(DstLineData%lstr)) THEN 
    ALLOCATE(DstLineData%lstr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%lstr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%lstr = SrcLineData%lstr
ENDIF
IF (ALLOCATED(SrcLineData%lstrd)) THEN
  i1_l = LBOUND(SrcLineData%lstrd,1)
  i1_u = UBOUND(SrcLineData%lstrd,1)
  IF (.NOT. ALLOCATED(DstLineData%lstrd)) THEN 
    ALLOCATE(DstLineData%lstrd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%lstrd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%lstrd = SrcLineData%lstrd
ENDIF
IF (ALLOCATED(SrcLineData%Kurv)) THEN
  i1_l = LBOUND(SrcLineData%Kurv,1)
  i1_u = UBOUND(SrcLineData%Kurv,1)
  IF (.NOT. ALLOCATED(DstLineData%Kurv)) THEN 
    ALLOCATE(DstLineData%Kurv(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Kurv.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Kurv = SrcLineData%Kurv
ENDIF
IF (ALLOCATED(SrcLineData%dl_1)) THEN
  i1_l = LBOUND(SrcLineData%dl_1,1)
  i1_u = UBOUND(SrcLineData%dl_1,1)
  IF (.NOT. ALLOCATED(DstLineData%dl_1)) THEN 
    ALLOCATE(DstLineData%dl_1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%dl_1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%dl_1 = SrcLineData%dl_1
ENDIF
IF (ALLOCATED(SrcLineData%V)) THEN
  i1_l = LBOUND(SrcLineData%V,1)
  i1_u = UBOUND(SrcLineData%V,1)
  IF (.NOT. ALLOCATED(DstLineData%V)) THEN 
    ALLOCATE(DstLineData%V(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%V.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%V = SrcLineData%V
ENDIF
IF (ALLOCATED(SrcLineData%U)) THEN
  i1_l = LBOUND(SrcLineData%U,1)
  i1_u = UBOUND(SrcLineData%U,1)
  i2_l = LBOUND(SrcLineData%U,2)
  i2_u = UBOUND(SrcLineData%U,2)
  IF (.NOT. ALLOCATED(DstLineData%U)) THEN 
    ALLOCATE(DstLineData%U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%U.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%U = SrcLineData%U
ENDIF
IF (ALLOCATED(SrcLineData%Ud)) THEN
  i1_l = LBOUND(SrcLineData%Ud,1)
  i1_u = UBOUND(SrcLineData%Ud,1)
  i2_l = LBOUND(SrcLineData%Ud,2)
  i2_u = UBOUND(SrcLineData%Ud,2)
  IF (.NOT. ALLOCATED(DstLineData%Ud)) THEN 
    ALLOCATE(DstLineData%Ud(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Ud.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Ud = SrcLineData%Ud
ENDIF
IF (ALLOCATED(SrcLineData%zeta)) THEN
  i1_l = LBOUND(SrcLineData%zeta,1)
  i1_u = UBOUND(SrcLineData%zeta,1)
  IF (.NOT. ALLOCATED(DstLineData%zeta)) THEN 
    ALLOCATE(DstLineData%zeta(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%zeta.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%zeta = SrcLineData%zeta
ENDIF
IF (ALLOCATED(SrcLineData%PDyn)) THEN
  i1_l = LBOUND(SrcLineData%PDyn,1)
  i1_u = UBOUND(SrcLineData%PDyn,1)
  IF (.NOT. ALLOCATED(DstLineData%PDyn)) THEN 
    ALLOCATE(DstLineData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%PDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%PDyn = SrcLineData%PDyn
ENDIF
IF (ALLOCATED(SrcLineData%T)) THEN
  i1_l = LBOUND(SrcLineData%T,1)
  i1_u = UBOUND(SrcLineData%T,1)
  i2_l = LBOUND(SrcLineData%T,2)
  i2_u = UBOUND(SrcLineData%T,2)
  IF (.NOT. ALLOCATED(DstLineData%T)) THEN 
    ALLOCATE(DstLineData%T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%T = SrcLineData%T
ENDIF
IF (ALLOCATED(SrcLineData%Td)) THEN
  i1_l = LBOUND(SrcLineData%Td,1)
  i1_u = UBOUND(SrcLineData%Td,1)
  i2_l = LBOUND(SrcLineData%Td,2)
  i2_u = UBOUND(SrcLineData%Td,2)
  IF (.NOT. ALLOCATED(DstLineData%Td)) THEN 
    ALLOCATE(DstLineData%Td(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Td.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Td = SrcLineData%Td
ENDIF
IF (ALLOCATED(SrcLineData%W)) THEN
  i1_l = LBOUND(SrcLineData%W,1)
  i1_u = UBOUND(SrcLineData%W,1)
  i2_l = LBOUND(SrcLineData%W,2)
  i2_u = UBOUND(SrcLineData%W,2)
  IF (.NOT. ALLOCATED(DstLineData%W)) THEN 
    ALLOCATE(DstLineData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%W = SrcLineData%W
ENDIF
IF (ALLOCATED(SrcLineData%Dp)) THEN
  i1_l = LBOUND(SrcLineData%Dp,1)
  i1_u = UBOUND(SrcLineData%Dp,1)
  i2_l = LBOUND(SrcLineData%Dp,2)
  i2_u = UBOUND(SrcLineData%Dp,2)
  IF (.NOT. ALLOCATED(DstLineData%Dp)) THEN 
    ALLOCATE(DstLineData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Dp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Dp = SrcLineData%Dp
ENDIF
IF (ALLOCATED(SrcLineData%Dq)) THEN
  i1_l = LBOUND(SrcLineData%Dq,1)
  i1_u = UBOUND(SrcLineData%Dq,1)
  i2_l = LBOUND(SrcLineData%Dq,2)
  i2_u = UBOUND(SrcLineData%Dq,2)
  IF (.NOT. ALLOCATED(DstLineData%Dq)) THEN 
    ALLOCATE(DstLineData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Dq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Dq = SrcLineData%Dq
ENDIF
IF (ALLOCATED(SrcLineData%Ap)) THEN
  i1_l = LBOUND(SrcLineData%Ap,1)
  i1_u = UBOUND(SrcLineData%Ap,1)
  i2_l = LBOUND(SrcLineData%Ap,2)
  i2_u = UBOUND(SrcLineData%Ap,2)
  IF (.NOT. ALLOCATED(DstLineData%Ap)) THEN 
    ALLOCATE(DstLineData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Ap.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Ap = SrcLineData%Ap
ENDIF
IF (ALLOCATED(SrcLineData%Aq)) THEN
  i1_l = LBOUND(SrcLineData%Aq,1)
  i1_u = UBOUND(SrcLineData%Aq,1)
  i2_l = LBOUND(SrcLineData%Aq,2)
  i2_u = UBOUND(SrcLineData%Aq,2)
  IF (.NOT. ALLOCATED(DstLineData%Aq)) THEN 
    ALLOCATE(DstLineData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Aq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Aq = SrcLineData%Aq
ENDIF
IF (ALLOCATED(SrcLineData%B)) THEN
  i1_l = LBOUND(SrcLineData%B,1)
  i1_u = UBOUND(SrcLineData%B,1)
  i2_l = LBOUND(SrcLineData%B,2)
  i2_u = UBOUND(SrcLineData%B,2)
  IF (.NOT. ALLOCATED(DstLineData%B)) THEN 
    ALLOCATE(DstLineData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%B = SrcLineData%B
ENDIF
IF (ALLOCATED(SrcLineData%Bs)) THEN
  i1_l = LBOUND(SrcLineData%Bs,1)
  i1_u = UBOUND(SrcLineData%Bs,1)
  i2_l = LBOUND(SrcLineData%Bs,2)
  i2_u = UBOUND(SrcLineData%Bs,2)
  IF (.NOT. ALLOCATED(DstLineData%Bs)) THEN 
    ALLOCATE(DstLineData%Bs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Bs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Bs = SrcLineData%Bs
ENDIF
IF (ALLOCATED(SrcLineData%Fnet)) THEN
  i1_l = LBOUND(SrcLineData%Fnet,1)
  i1_u = UBOUND(SrcLineData%Fnet,1)
  i2_l = LBOUND(SrcLineData%Fnet,2)
  i2_u = UBOUND(SrcLineData%Fnet,2)
  IF (.NOT. ALLOCATED(DstLineData%Fnet)) THEN 
    ALLOCATE(DstLineData%Fnet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Fnet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%Fnet = SrcLineData%Fnet
ENDIF
IF (ALLOCATED(SrcLineData%S)) THEN
  i1_l = LBOUND(SrcLineData%S,1)
  i1_u = UBOUND(SrcLineData%S,1)
  i2_l = LBOUND(SrcLineData%S,2)
  i2_u = UBOUND(SrcLineData%S,2)
  i3_l = LBOUND(SrcLineData%S,3)
  i3_u = UBOUND(SrcLineData%S,3)
  IF (.NOT. ALLOCATED(DstLineData%S)) THEN 
    ALLOCATE(DstLineData%S(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%S.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%S = SrcLineData%S
ENDIF
IF (ALLOCATED(SrcLineData%M)) THEN
  i1_l = LBOUND(SrcLineData%M,1)
  i1_u = UBOUND(SrcLineData%M,1)
  i2_l = LBOUND(SrcLineData%M,2)
  i2_u = UBOUND(SrcLineData%M,2)
  i3_l = LBOUND(SrcLineData%M,3)
  i3_u = UBOUND(SrcLineData%M,3)
  IF (.NOT. ALLOCATED(DstLineData%M)) THEN 
    ALLOCATE(DstLineData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%M = SrcLineData%M
ENDIF
    DstLineData%EndMomentA = SrcLineData%EndMomentA
    DstLineData%EndMomentB = SrcLineData%EndMomentB
    DstLineData%LineUnOut = SrcLineData%LineUnOut
IF (ALLOCATED(SrcLineData%LineWrOutput)) THEN
  i1_l = LBOUND(SrcLineData%LineWrOutput,1)
  i1_u = UBOUND(SrcLineData%LineWrOutput,1)
  IF (.NOT. ALLOCATED(DstLineData%LineWrOutput)) THEN 
    ALLOCATE(DstLineData%LineWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%LineWrOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstLineData%LineWrOutput = SrcLineData%LineWrOutput
ENDIF
 END SUBROUTINE MD_CopyLine

 SUBROUTINE MD_DestroyLine( LineData, ErrStat, ErrMsg )
  TYPE(MD_Line), INTENT(INOUT) :: LineData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyLine'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(LineData%r)) THEN
  DEALLOCATE(LineData%r)
ENDIF
IF (ALLOCATED(LineData%rd)) THEN
  DEALLOCATE(LineData%rd)
ENDIF
IF (ALLOCATED(LineData%q)) THEN
  DEALLOCATE(LineData%q)
ENDIF
IF (ALLOCATED(LineData%qs)) THEN
  DEALLOCATE(LineData%qs)
ENDIF
IF (ALLOCATED(LineData%l)) THEN
  DEALLOCATE(LineData%l)
ENDIF
IF (ALLOCATED(LineData%ld)) THEN
  DEALLOCATE(LineData%ld)
ENDIF
IF (ALLOCATED(LineData%lstr)) THEN
  DEALLOCATE(LineData%lstr)
ENDIF
IF (ALLOCATED(LineData%lstrd)) THEN
  DEALLOCATE(LineData%lstrd)
ENDIF
IF (ALLOCATED(LineData%Kurv)) THEN
  DEALLOCATE(LineData%Kurv)
ENDIF
IF (ALLOCATED(LineData%dl_1)) THEN
  DEALLOCATE(LineData%dl_1)
ENDIF
IF (ALLOCATED(LineData%V)) THEN
  DEALLOCATE(LineData%V)
ENDIF
IF (ALLOCATED(LineData%U)) THEN
  DEALLOCATE(LineData%U)
ENDIF
IF (ALLOCATED(LineData%Ud)) THEN
  DEALLOCATE(LineData%Ud)
ENDIF
IF (ALLOCATED(LineData%zeta)) THEN
  DEALLOCATE(LineData%zeta)
ENDIF
IF (ALLOCATED(LineData%PDyn)) THEN
  DEALLOCATE(LineData%PDyn)
ENDIF
IF (ALLOCATED(LineData%T)) THEN
  DEALLOCATE(LineData%T)
ENDIF
IF (ALLOCATED(LineData%Td)) THEN
  DEALLOCATE(LineData%Td)
ENDIF
IF (ALLOCATED(LineData%W)) THEN
  DEALLOCATE(LineData%W)
ENDIF
IF (ALLOCATED(LineData%Dp)) THEN
  DEALLOCATE(LineData%Dp)
ENDIF
IF (ALLOCATED(LineData%Dq)) THEN
  DEALLOCATE(LineData%Dq)
ENDIF
IF (ALLOCATED(LineData%Ap)) THEN
  DEALLOCATE(LineData%Ap)
ENDIF
IF (ALLOCATED(LineData%Aq)) THEN
  DEALLOCATE(LineData%Aq)
ENDIF
IF (ALLOCATED(LineData%B)) THEN
  DEALLOCATE(LineData%B)
ENDIF
IF (ALLOCATED(LineData%Bs)) THEN
  DEALLOCATE(LineData%Bs)
ENDIF
IF (ALLOCATED(LineData%Fnet)) THEN
  DEALLOCATE(LineData%Fnet)
ENDIF
IF (ALLOCATED(LineData%S)) THEN
  DEALLOCATE(LineData%S)
ENDIF
IF (ALLOCATED(LineData%M)) THEN
  DEALLOCATE(LineData%M)
ENDIF
IF (ALLOCATED(LineData%LineWrOutput)) THEN
  DEALLOCATE(LineData%LineWrOutput)
ENDIF
 END SUBROUTINE MD_DestroyLine


subroutine MD_PackLine(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_Line), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackLine'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsIdNum
   call RegPack(Buf, InData%PropsIdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElasticMod
   call RegPack(Buf, InData%ElasticMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFlagList
   call RegPack(Buf, InData%OutFlagList)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CtrlChan
   call RegPack(Buf, InData%CtrlChan)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FairConnect
   call RegPack(Buf, InData%FairConnect)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AnchConnect
   call RegPack(Buf, InData%AnchConnect)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N
   call RegPack(Buf, InData%N)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeA
   call RegPack(Buf, InData%endTypeA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeB
   call RegPack(Buf, InData%endTypeB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnstrLen
   call RegPack(Buf, InData%UnstrLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho
   call RegPack(Buf, InData%rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegPack(Buf, InData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA
   call RegPack(Buf, InData%EA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA_D
   call RegPack(Buf, InData%EA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA
   call RegPack(Buf, InData%BA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA_D
   call RegPack(Buf, InData%BA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EI
   call RegPack(Buf, InData%EI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegPack(Buf, InData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegPack(Buf, InData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegPack(Buf, InData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegPack(Buf, InData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEApoints
   call RegPack(Buf, InData%nEApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffXs
   call RegPack(Buf, InData%stiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffYs
   call RegPack(Buf, InData%stiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBApoints
   call RegPack(Buf, InData%nBApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampXs
   call RegPack(Buf, InData%dampXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampYs
   call RegPack(Buf, InData%dampYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEIpoints
   call RegPack(Buf, InData%nEIpoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffXs
   call RegPack(Buf, InData%bstiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffYs
   call RegPack(Buf, InData%bstiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegPack(Buf, InData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   call RegPack(Buf, allocated(InData%r))
   if (allocated(InData%r)) then
      call RegPackBounds(Buf, 2, lbound(InData%r), ubound(InData%r))
      call RegPack(Buf, InData%r)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! rd
   call RegPack(Buf, allocated(InData%rd))
   if (allocated(InData%rd)) then
      call RegPackBounds(Buf, 2, lbound(InData%rd), ubound(InData%rd))
      call RegPack(Buf, InData%rd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! q
   call RegPack(Buf, allocated(InData%q))
   if (allocated(InData%q)) then
      call RegPackBounds(Buf, 2, lbound(InData%q), ubound(InData%q))
      call RegPack(Buf, InData%q)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! qs
   call RegPack(Buf, allocated(InData%qs))
   if (allocated(InData%qs)) then
      call RegPackBounds(Buf, 2, lbound(InData%qs), ubound(InData%qs))
      call RegPack(Buf, InData%qs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! l
   call RegPack(Buf, allocated(InData%l))
   if (allocated(InData%l)) then
      call RegPackBounds(Buf, 1, lbound(InData%l), ubound(InData%l))
      call RegPack(Buf, InData%l)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ld
   call RegPack(Buf, allocated(InData%ld))
   if (allocated(InData%ld)) then
      call RegPackBounds(Buf, 1, lbound(InData%ld), ubound(InData%ld))
      call RegPack(Buf, InData%ld)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! lstr
   call RegPack(Buf, allocated(InData%lstr))
   if (allocated(InData%lstr)) then
      call RegPackBounds(Buf, 1, lbound(InData%lstr), ubound(InData%lstr))
      call RegPack(Buf, InData%lstr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! lstrd
   call RegPack(Buf, allocated(InData%lstrd))
   if (allocated(InData%lstrd)) then
      call RegPackBounds(Buf, 1, lbound(InData%lstrd), ubound(InData%lstrd))
      call RegPack(Buf, InData%lstrd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Kurv
   call RegPack(Buf, allocated(InData%Kurv))
   if (allocated(InData%Kurv)) then
      call RegPackBounds(Buf, 1, lbound(InData%Kurv), ubound(InData%Kurv))
      call RegPack(Buf, InData%Kurv)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dl_1
   call RegPack(Buf, allocated(InData%dl_1))
   if (allocated(InData%dl_1)) then
      call RegPackBounds(Buf, 1, lbound(InData%dl_1), ubound(InData%dl_1))
      call RegPack(Buf, InData%dl_1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! V
   call RegPack(Buf, allocated(InData%V))
   if (allocated(InData%V)) then
      call RegPackBounds(Buf, 1, lbound(InData%V), ubound(InData%V))
      call RegPack(Buf, InData%V)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U
   call RegPack(Buf, allocated(InData%U))
   if (allocated(InData%U)) then
      call RegPackBounds(Buf, 2, lbound(InData%U), ubound(InData%U))
      call RegPack(Buf, InData%U)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ud
   call RegPack(Buf, allocated(InData%Ud))
   if (allocated(InData%Ud)) then
      call RegPackBounds(Buf, 2, lbound(InData%Ud), ubound(InData%Ud))
      call RegPack(Buf, InData%Ud)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegPack(Buf, allocated(InData%zeta))
   if (allocated(InData%zeta)) then
      call RegPackBounds(Buf, 1, lbound(InData%zeta), ubound(InData%zeta))
      call RegPack(Buf, InData%zeta)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PDyn
   call RegPack(Buf, allocated(InData%PDyn))
   if (allocated(InData%PDyn)) then
      call RegPackBounds(Buf, 1, lbound(InData%PDyn), ubound(InData%PDyn))
      call RegPack(Buf, InData%PDyn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! T
   call RegPack(Buf, allocated(InData%T))
   if (allocated(InData%T)) then
      call RegPackBounds(Buf, 2, lbound(InData%T), ubound(InData%T))
      call RegPack(Buf, InData%T)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Td
   call RegPack(Buf, allocated(InData%Td))
   if (allocated(InData%Td)) then
      call RegPackBounds(Buf, 2, lbound(InData%Td), ubound(InData%Td))
      call RegPack(Buf, InData%Td)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! W
   call RegPack(Buf, allocated(InData%W))
   if (allocated(InData%W)) then
      call RegPackBounds(Buf, 2, lbound(InData%W), ubound(InData%W))
      call RegPack(Buf, InData%W)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Dp
   call RegPack(Buf, allocated(InData%Dp))
   if (allocated(InData%Dp)) then
      call RegPackBounds(Buf, 2, lbound(InData%Dp), ubound(InData%Dp))
      call RegPack(Buf, InData%Dp)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Dq
   call RegPack(Buf, allocated(InData%Dq))
   if (allocated(InData%Dq)) then
      call RegPackBounds(Buf, 2, lbound(InData%Dq), ubound(InData%Dq))
      call RegPack(Buf, InData%Dq)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ap
   call RegPack(Buf, allocated(InData%Ap))
   if (allocated(InData%Ap)) then
      call RegPackBounds(Buf, 2, lbound(InData%Ap), ubound(InData%Ap))
      call RegPack(Buf, InData%Ap)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Aq
   call RegPack(Buf, allocated(InData%Aq))
   if (allocated(InData%Aq)) then
      call RegPackBounds(Buf, 2, lbound(InData%Aq), ubound(InData%Aq))
      call RegPack(Buf, InData%Aq)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! B
   call RegPack(Buf, allocated(InData%B))
   if (allocated(InData%B)) then
      call RegPackBounds(Buf, 2, lbound(InData%B), ubound(InData%B))
      call RegPack(Buf, InData%B)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Bs
   call RegPack(Buf, allocated(InData%Bs))
   if (allocated(InData%Bs)) then
      call RegPackBounds(Buf, 2, lbound(InData%Bs), ubound(InData%Bs))
      call RegPack(Buf, InData%Bs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fnet
   call RegPack(Buf, allocated(InData%Fnet))
   if (allocated(InData%Fnet)) then
      call RegPackBounds(Buf, 2, lbound(InData%Fnet), ubound(InData%Fnet))
      call RegPack(Buf, InData%Fnet)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! S
   call RegPack(Buf, allocated(InData%S))
   if (allocated(InData%S)) then
      call RegPackBounds(Buf, 3, lbound(InData%S), ubound(InData%S))
      call RegPack(Buf, InData%S)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegPack(Buf, allocated(InData%M))
   if (allocated(InData%M)) then
      call RegPackBounds(Buf, 3, lbound(InData%M), ubound(InData%M))
      call RegPack(Buf, InData%M)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! EndMomentA
   call RegPack(Buf, InData%EndMomentA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EndMomentB
   call RegPack(Buf, InData%EndMomentB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineUnOut
   call RegPack(Buf, InData%LineUnOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineWrOutput
   call RegPack(Buf, allocated(InData%LineWrOutput))
   if (allocated(InData%LineWrOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineWrOutput), ubound(InData%LineWrOutput))
      call RegPack(Buf, InData%LineWrOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackLine(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_Line), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackLine'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsIdNum
   call RegUnpack(Buf, OutData%PropsIdNum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElasticMod
   call RegUnpack(Buf, OutData%ElasticMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFlagList
   call RegUnpack(Buf, OutData%OutFlagList)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CtrlChan
   call RegUnpack(Buf, OutData%CtrlChan)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FairConnect
   call RegUnpack(Buf, OutData%FairConnect)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AnchConnect
   call RegUnpack(Buf, OutData%AnchConnect)
   if (RegCheckErr(Buf, RoutineName)) return
   ! N
   call RegUnpack(Buf, OutData%N)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeA
   call RegUnpack(Buf, OutData%endTypeA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! endTypeB
   call RegUnpack(Buf, OutData%endTypeB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnstrLen
   call RegUnpack(Buf, OutData%UnstrLen)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rho
   call RegUnpack(Buf, OutData%rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! d
   call RegUnpack(Buf, OutData%d)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA
   call RegUnpack(Buf, OutData%EA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EA_D
   call RegUnpack(Buf, OutData%EA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA
   call RegUnpack(Buf, OutData%BA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BA_D
   call RegUnpack(Buf, OutData%BA_D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EI
   call RegUnpack(Buf, OutData%EI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Can
   call RegUnpack(Buf, OutData%Can)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cat
   call RegUnpack(Buf, OutData%Cat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdn
   call RegUnpack(Buf, OutData%Cdn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Cdt
   call RegUnpack(Buf, OutData%Cdt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEApoints
   call RegUnpack(Buf, OutData%nEApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffXs
   call RegUnpack(Buf, OutData%stiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! stiffYs
   call RegUnpack(Buf, OutData%stiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBApoints
   call RegUnpack(Buf, OutData%nBApoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampXs
   call RegUnpack(Buf, OutData%dampXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dampYs
   call RegUnpack(Buf, OutData%dampYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nEIpoints
   call RegUnpack(Buf, OutData%nEIpoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffXs
   call RegUnpack(Buf, OutData%bstiffXs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! bstiffYs
   call RegUnpack(Buf, OutData%bstiffYs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! time
   call RegUnpack(Buf, OutData%time)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r
   if (allocated(OutData%r)) deallocate(OutData%r)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%r(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%r.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%r)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! rd
   if (allocated(OutData%rd)) deallocate(OutData%rd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%rd(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%rd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%rd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! q
   if (allocated(OutData%q)) deallocate(OutData%q)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%q(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%q.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%q)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! qs
   if (allocated(OutData%qs)) deallocate(OutData%qs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%qs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%qs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%qs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! l
   if (allocated(OutData%l)) deallocate(OutData%l)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%l(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%l.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%l)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ld
   if (allocated(OutData%ld)) deallocate(OutData%ld)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ld(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ld.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ld)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! lstr
   if (allocated(OutData%lstr)) deallocate(OutData%lstr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%lstr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%lstr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%lstr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! lstrd
   if (allocated(OutData%lstrd)) deallocate(OutData%lstrd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%lstrd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%lstrd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%lstrd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Kurv
   if (allocated(OutData%Kurv)) deallocate(OutData%Kurv)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Kurv(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Kurv.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Kurv)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dl_1
   if (allocated(OutData%dl_1)) deallocate(OutData%dl_1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dl_1(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dl_1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dl_1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! V
   if (allocated(OutData%V)) deallocate(OutData%V)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%V(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%V.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%V)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U
   if (allocated(OutData%U)) deallocate(OutData%U)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ud
   if (allocated(OutData%Ud)) deallocate(OutData%Ud)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ud(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ud.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ud)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! zeta
   if (allocated(OutData%zeta)) deallocate(OutData%zeta)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zeta(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zeta.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zeta)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PDyn
   if (allocated(OutData%PDyn)) deallocate(OutData%PDyn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PDyn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PDyn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! T
   if (allocated(OutData%T)) deallocate(OutData%T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%T(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%T)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Td
   if (allocated(OutData%Td)) deallocate(OutData%Td)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Td(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Td.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Td)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! W
   if (allocated(OutData%W)) deallocate(OutData%W)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%W(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%W)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Dp
   if (allocated(OutData%Dp)) deallocate(OutData%Dp)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Dp(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dp.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Dp)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Dq
   if (allocated(OutData%Dq)) deallocate(OutData%Dq)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Dq(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dq.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Dq)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ap
   if (allocated(OutData%Ap)) deallocate(OutData%Ap)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ap(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ap.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ap)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Aq
   if (allocated(OutData%Aq)) deallocate(OutData%Aq)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Aq(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Aq.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Aq)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! B
   if (allocated(OutData%B)) deallocate(OutData%B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%B)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Bs
   if (allocated(OutData%Bs)) deallocate(OutData%Bs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Bs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Bs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Fnet
   if (allocated(OutData%Fnet)) deallocate(OutData%Fnet)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Fnet(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fnet.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Fnet)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! S
   if (allocated(OutData%S)) deallocate(OutData%S)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%S(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%S.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%S)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! M
   if (allocated(OutData%M)) deallocate(OutData%M)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%M(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%M)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! EndMomentA
   call RegUnpack(Buf, OutData%EndMomentA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! EndMomentB
   call RegUnpack(Buf, OutData%EndMomentB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineUnOut
   call RegUnpack(Buf, OutData%LineUnOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineWrOutput
   if (allocated(OutData%LineWrOutput)) deallocate(OutData%LineWrOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineWrOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineWrOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineWrOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyFail( SrcFailData, DstFailData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Fail), INTENT(IN) :: SrcFailData
   TYPE(MD_Fail), INTENT(INOUT) :: DstFailData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyFail'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFailData%IdNum = SrcFailData%IdNum
 END SUBROUTINE MD_CopyFail

 SUBROUTINE MD_DestroyFail( FailData, ErrStat, ErrMsg )
  TYPE(MD_Fail), INTENT(INOUT) :: FailData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyFail'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyFail


subroutine MD_PackFail(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_Fail), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackFail'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IdNum
   call RegPack(Buf, InData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackFail(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_Fail), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackFail'
   if (Buf%ErrStat /= ErrID_None) return
   ! IdNum
   call RegUnpack(Buf, OutData%IdNum)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyOutParmType( SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OutParmType), INTENT(IN) :: SrcOutParmTypeData
   TYPE(MD_OutParmType), INTENT(INOUT) :: DstOutParmTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyOutParmType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOutParmTypeData%Name = SrcOutParmTypeData%Name
    DstOutParmTypeData%Units = SrcOutParmTypeData%Units
    DstOutParmTypeData%QType = SrcOutParmTypeData%QType
    DstOutParmTypeData%OType = SrcOutParmTypeData%OType
    DstOutParmTypeData%NodeID = SrcOutParmTypeData%NodeID
    DstOutParmTypeData%ObjID = SrcOutParmTypeData%ObjID
 END SUBROUTINE MD_CopyOutParmType

 SUBROUTINE MD_DestroyOutParmType( OutParmTypeData, ErrStat, ErrMsg )
  TYPE(MD_OutParmType), INTENT(INOUT) :: OutParmTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyOutParmType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyOutParmType


subroutine MD_PackOutParmType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackOutParmType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Name
   call RegPack(Buf, InData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Units
   call RegPack(Buf, InData%Units)
   if (RegCheckErr(Buf, RoutineName)) return
   ! QType
   call RegPack(Buf, InData%QType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OType
   call RegPack(Buf, InData%OType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeID
   call RegPack(Buf, InData%NodeID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ObjID
   call RegPack(Buf, InData%ObjID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackOutParmType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackOutParmType'
   if (Buf%ErrStat /= ErrID_None) return
   ! Name
   call RegUnpack(Buf, OutData%Name)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Units
   call RegUnpack(Buf, OutData%Units)
   if (RegCheckErr(Buf, RoutineName)) return
   ! QType
   call RegUnpack(Buf, OutData%QType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OType
   call RegUnpack(Buf, OutData%OType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeID
   call RegUnpack(Buf, OutData%NodeID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ObjID
   call RegUnpack(Buf, OutData%ObjID)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(MD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%writeOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%writeOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%writeOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%writeOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%writeOutputHdr = SrcInitOutputData%writeOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%writeOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%writeOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%writeOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%writeOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%writeOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%writeOutputUnt = SrcInitOutputData%writeOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%CableCChanRqst)) THEN
  i1_l = LBOUND(SrcInitOutputData%CableCChanRqst,1)
  i1_u = UBOUND(SrcInitOutputData%CableCChanRqst,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%CableCChanRqst)) THEN 
    ALLOCATE(DstInitOutputData%CableCChanRqst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%CableCChanRqst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%CableCChanRqst = SrcInitOutputData%CableCChanRqst
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_y,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_y)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_y = SrcInitOutputData%LinNames_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_x,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_x)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_x = SrcInitOutputData%LinNames_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_u,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_u)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_u = SrcInitOutputData%LinNames_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_y,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_y)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_y = SrcInitOutputData%RotFrame_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_x,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_x)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_x = SrcInitOutputData%RotFrame_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_u,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_u)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_u = SrcInitOutputData%RotFrame_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%IsLoad_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%IsLoad_u,1)
  i1_u = UBOUND(SrcInitOutputData%IsLoad_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%IsLoad_u)) THEN 
    ALLOCATE(DstInitOutputData%IsLoad_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%IsLoad_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%IsLoad_u = SrcInitOutputData%IsLoad_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%DerivOrder_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%DerivOrder_x,1)
  i1_u = UBOUND(SrcInitOutputData%DerivOrder_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%DerivOrder_x)) THEN 
    ALLOCATE(DstInitOutputData%DerivOrder_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%DerivOrder_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%DerivOrder_x = SrcInitOutputData%DerivOrder_x
ENDIF
 END SUBROUTINE MD_CopyInitOutput

 SUBROUTINE MD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(MD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%writeOutputHdr)) THEN
  DEALLOCATE(InitOutputData%writeOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%writeOutputUnt)) THEN
  DEALLOCATE(InitOutputData%writeOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%CableCChanRqst)) THEN
  DEALLOCATE(InitOutputData%CableCChanRqst)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_y)) THEN
  DEALLOCATE(InitOutputData%LinNames_y)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_x)) THEN
  DEALLOCATE(InitOutputData%LinNames_x)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_u)) THEN
  DEALLOCATE(InitOutputData%LinNames_u)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_y)) THEN
  DEALLOCATE(InitOutputData%RotFrame_y)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_x)) THEN
  DEALLOCATE(InitOutputData%RotFrame_x)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_u)) THEN
  DEALLOCATE(InitOutputData%RotFrame_u)
ENDIF
IF (ALLOCATED(InitOutputData%IsLoad_u)) THEN
  DEALLOCATE(InitOutputData%IsLoad_u)
ENDIF
IF (ALLOCATED(InitOutputData%DerivOrder_x)) THEN
  DEALLOCATE(InitOutputData%DerivOrder_x)
ENDIF
 END SUBROUTINE MD_DestroyInitOutput


subroutine MD_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! writeOutputHdr
   call RegPack(Buf, allocated(InData%writeOutputHdr))
   if (allocated(InData%writeOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%writeOutputHdr), ubound(InData%writeOutputHdr))
      call RegPack(Buf, InData%writeOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! writeOutputUnt
   call RegPack(Buf, allocated(InData%writeOutputUnt))
   if (allocated(InData%writeOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%writeOutputUnt), ubound(InData%writeOutputUnt))
      call RegPack(Buf, InData%writeOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableCChanRqst
   call RegPack(Buf, allocated(InData%CableCChanRqst))
   if (allocated(InData%CableCChanRqst)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableCChanRqst), ubound(InData%CableCChanRqst))
      call RegPack(Buf, InData%CableCChanRqst)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_y
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_x
   call RegPack(Buf, allocated(InData%LinNames_x))
   if (allocated(InData%LinNames_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_x), ubound(InData%LinNames_x))
      call RegPack(Buf, InData%LinNames_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_u
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_y
   call RegPack(Buf, allocated(InData%RotFrame_y))
   if (allocated(InData%RotFrame_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_y), ubound(InData%RotFrame_y))
      call RegPack(Buf, InData%RotFrame_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_x
   call RegPack(Buf, allocated(InData%RotFrame_x))
   if (allocated(InData%RotFrame_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_x), ubound(InData%RotFrame_x))
      call RegPack(Buf, InData%RotFrame_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_u
   call RegPack(Buf, allocated(InData%RotFrame_u))
   if (allocated(InData%RotFrame_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_u), ubound(InData%RotFrame_u))
      call RegPack(Buf, InData%RotFrame_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsLoad_u
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DerivOrder_x
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! writeOutputHdr
   if (allocated(OutData%writeOutputHdr)) deallocate(OutData%writeOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%writeOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%writeOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%writeOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! writeOutputUnt
   if (allocated(OutData%writeOutputUnt)) deallocate(OutData%writeOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%writeOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%writeOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%writeOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! CableCChanRqst
   if (allocated(OutData%CableCChanRqst)) deallocate(OutData%CableCChanRqst)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableCChanRqst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableCChanRqst.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableCChanRqst)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_y
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_x
   if (allocated(OutData%LinNames_x)) deallocate(OutData%LinNames_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_u
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_y
   if (allocated(OutData%RotFrame_y)) deallocate(OutData%RotFrame_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_x
   if (allocated(OutData%RotFrame_x)) deallocate(OutData%RotFrame_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_u
   if (allocated(OutData%RotFrame_u)) deallocate(OutData%RotFrame_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsLoad_u
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DerivOrder_x
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(MD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%states)) THEN
  i1_l = LBOUND(SrcContStateData%states,1)
  i1_u = UBOUND(SrcContStateData%states,1)
  IF (.NOT. ALLOCATED(DstContStateData%states)) THEN 
    ALLOCATE(DstContStateData%states(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%states.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%states = SrcContStateData%states
ENDIF
 END SUBROUTINE MD_CopyContState

 SUBROUTINE MD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(MD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%states)) THEN
  DEALLOCATE(ContStateData%states)
ENDIF
 END SUBROUTINE MD_DestroyContState


subroutine MD_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! states
   call RegPack(Buf, allocated(InData%states))
   if (allocated(InData%states)) then
      call RegPackBounds(Buf, 1, lbound(InData%states), ubound(InData%states))
      call RegPack(Buf, InData%states)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackContState'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! states
   if (allocated(OutData%states)) deallocate(OutData%states)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%states(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%states.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%states)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(MD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%dummy = SrcDiscStateData%dummy
 END SUBROUTINE MD_CopyDiscState

 SUBROUTINE MD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(MD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyDiscState


subroutine MD_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dummy
   call RegPack(Buf, InData%dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! dummy
   call RegUnpack(Buf, OutData%dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(MD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%dummy = SrcConstrStateData%dummy
 END SUBROUTINE MD_CopyConstrState

 SUBROUTINE MD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(MD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyConstrState


subroutine MD_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dummy
   call RegPack(Buf, InData%dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! dummy
   call RegUnpack(Buf, OutData%dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(MD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%dummy = SrcOtherStateData%dummy
 END SUBROUTINE MD_CopyOtherState

 SUBROUTINE MD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(MD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE MD_DestroyOtherState


subroutine MD_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! dummy
   call RegPack(Buf, InData%dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! dummy
   call RegUnpack(Buf, OutData%dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE MD_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(MD_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%LineTypeList)) THEN
  i1_l = LBOUND(SrcMiscData%LineTypeList,1)
  i1_u = UBOUND(SrcMiscData%LineTypeList,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineTypeList)) THEN 
    ALLOCATE(DstMiscData%LineTypeList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineTypeList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%LineTypeList,1), UBOUND(SrcMiscData%LineTypeList,1)
      CALL MD_Copylineprop( SrcMiscData%LineTypeList(i1), DstMiscData%LineTypeList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%RodTypeList)) THEN
  i1_l = LBOUND(SrcMiscData%RodTypeList,1)
  i1_u = UBOUND(SrcMiscData%RodTypeList,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodTypeList)) THEN 
    ALLOCATE(DstMiscData%RodTypeList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodTypeList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%RodTypeList,1), UBOUND(SrcMiscData%RodTypeList,1)
      CALL MD_Copyrodprop( SrcMiscData%RodTypeList(i1), DstMiscData%RodTypeList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MD_Copybody( SrcMiscData%GroundBody, DstMiscData%GroundBody, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMiscData%BodyList)) THEN
  i1_l = LBOUND(SrcMiscData%BodyList,1)
  i1_u = UBOUND(SrcMiscData%BodyList,1)
  IF (.NOT. ALLOCATED(DstMiscData%BodyList)) THEN 
    ALLOCATE(DstMiscData%BodyList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%BodyList,1), UBOUND(SrcMiscData%BodyList,1)
      CALL MD_Copybody( SrcMiscData%BodyList(i1), DstMiscData%BodyList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%RodList)) THEN
  i1_l = LBOUND(SrcMiscData%RodList,1)
  i1_u = UBOUND(SrcMiscData%RodList,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodList)) THEN 
    ALLOCATE(DstMiscData%RodList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%RodList,1), UBOUND(SrcMiscData%RodList,1)
      CALL MD_Copyrod( SrcMiscData%RodList(i1), DstMiscData%RodList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%ConnectList)) THEN
  i1_l = LBOUND(SrcMiscData%ConnectList,1)
  i1_u = UBOUND(SrcMiscData%ConnectList,1)
  IF (.NOT. ALLOCATED(DstMiscData%ConnectList)) THEN 
    ALLOCATE(DstMiscData%ConnectList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ConnectList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%ConnectList,1), UBOUND(SrcMiscData%ConnectList,1)
      CALL MD_Copyconnect( SrcMiscData%ConnectList(i1), DstMiscData%ConnectList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%LineList)) THEN
  i1_l = LBOUND(SrcMiscData%LineList,1)
  i1_u = UBOUND(SrcMiscData%LineList,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineList)) THEN 
    ALLOCATE(DstMiscData%LineList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%LineList,1), UBOUND(SrcMiscData%LineList,1)
      CALL MD_Copyline( SrcMiscData%LineList(i1), DstMiscData%LineList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%FailList)) THEN
  i1_l = LBOUND(SrcMiscData%FailList,1)
  i1_u = UBOUND(SrcMiscData%FailList,1)
  IF (.NOT. ALLOCATED(DstMiscData%FailList)) THEN 
    ALLOCATE(DstMiscData%FailList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FailList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%FailList,1), UBOUND(SrcMiscData%FailList,1)
      CALL MD_Copyfail( SrcMiscData%FailList(i1), DstMiscData%FailList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%FreeConIs)) THEN
  i1_l = LBOUND(SrcMiscData%FreeConIs,1)
  i1_u = UBOUND(SrcMiscData%FreeConIs,1)
  IF (.NOT. ALLOCATED(DstMiscData%FreeConIs)) THEN 
    ALLOCATE(DstMiscData%FreeConIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeConIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FreeConIs = SrcMiscData%FreeConIs
ENDIF
IF (ALLOCATED(SrcMiscData%CpldConIs)) THEN
  i1_l = LBOUND(SrcMiscData%CpldConIs,1)
  i1_u = UBOUND(SrcMiscData%CpldConIs,1)
  i2_l = LBOUND(SrcMiscData%CpldConIs,2)
  i2_u = UBOUND(SrcMiscData%CpldConIs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CpldConIs)) THEN 
    ALLOCATE(DstMiscData%CpldConIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldConIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CpldConIs = SrcMiscData%CpldConIs
ENDIF
IF (ALLOCATED(SrcMiscData%FreeRodIs)) THEN
  i1_l = LBOUND(SrcMiscData%FreeRodIs,1)
  i1_u = UBOUND(SrcMiscData%FreeRodIs,1)
  IF (.NOT. ALLOCATED(DstMiscData%FreeRodIs)) THEN 
    ALLOCATE(DstMiscData%FreeRodIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeRodIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FreeRodIs = SrcMiscData%FreeRodIs
ENDIF
IF (ALLOCATED(SrcMiscData%CpldRodIs)) THEN
  i1_l = LBOUND(SrcMiscData%CpldRodIs,1)
  i1_u = UBOUND(SrcMiscData%CpldRodIs,1)
  i2_l = LBOUND(SrcMiscData%CpldRodIs,2)
  i2_u = UBOUND(SrcMiscData%CpldRodIs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CpldRodIs)) THEN 
    ALLOCATE(DstMiscData%CpldRodIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldRodIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CpldRodIs = SrcMiscData%CpldRodIs
ENDIF
IF (ALLOCATED(SrcMiscData%FreeBodyIs)) THEN
  i1_l = LBOUND(SrcMiscData%FreeBodyIs,1)
  i1_u = UBOUND(SrcMiscData%FreeBodyIs,1)
  IF (.NOT. ALLOCATED(DstMiscData%FreeBodyIs)) THEN 
    ALLOCATE(DstMiscData%FreeBodyIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeBodyIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FreeBodyIs = SrcMiscData%FreeBodyIs
ENDIF
IF (ALLOCATED(SrcMiscData%CpldBodyIs)) THEN
  i1_l = LBOUND(SrcMiscData%CpldBodyIs,1)
  i1_u = UBOUND(SrcMiscData%CpldBodyIs,1)
  i2_l = LBOUND(SrcMiscData%CpldBodyIs,2)
  i2_u = UBOUND(SrcMiscData%CpldBodyIs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CpldBodyIs)) THEN 
    ALLOCATE(DstMiscData%CpldBodyIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldBodyIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CpldBodyIs = SrcMiscData%CpldBodyIs
ENDIF
IF (ALLOCATED(SrcMiscData%LineStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%LineStateIs1,1)
  i1_u = UBOUND(SrcMiscData%LineStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineStateIs1)) THEN 
    ALLOCATE(DstMiscData%LineStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LineStateIs1 = SrcMiscData%LineStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%LineStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%LineStateIsN,1)
  i1_u = UBOUND(SrcMiscData%LineStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineStateIsN)) THEN 
    ALLOCATE(DstMiscData%LineStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LineStateIsN = SrcMiscData%LineStateIsN
ENDIF
IF (ALLOCATED(SrcMiscData%ConStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%ConStateIs1,1)
  i1_u = UBOUND(SrcMiscData%ConStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%ConStateIs1)) THEN 
    ALLOCATE(DstMiscData%ConStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ConStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%ConStateIs1 = SrcMiscData%ConStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%ConStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%ConStateIsN,1)
  i1_u = UBOUND(SrcMiscData%ConStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%ConStateIsN)) THEN 
    ALLOCATE(DstMiscData%ConStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%ConStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%ConStateIsN = SrcMiscData%ConStateIsN
ENDIF
IF (ALLOCATED(SrcMiscData%RodStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%RodStateIs1,1)
  i1_u = UBOUND(SrcMiscData%RodStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodStateIs1)) THEN 
    ALLOCATE(DstMiscData%RodStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%RodStateIs1 = SrcMiscData%RodStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%RodStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%RodStateIsN,1)
  i1_u = UBOUND(SrcMiscData%RodStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodStateIsN)) THEN 
    ALLOCATE(DstMiscData%RodStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%RodStateIsN = SrcMiscData%RodStateIsN
ENDIF
IF (ALLOCATED(SrcMiscData%BodyStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%BodyStateIs1,1)
  i1_u = UBOUND(SrcMiscData%BodyStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%BodyStateIs1)) THEN 
    ALLOCATE(DstMiscData%BodyStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BodyStateIs1 = SrcMiscData%BodyStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%BodyStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%BodyStateIsN,1)
  i1_u = UBOUND(SrcMiscData%BodyStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%BodyStateIsN)) THEN 
    ALLOCATE(DstMiscData%BodyStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BodyStateIsN = SrcMiscData%BodyStateIsN
ENDIF
    DstMiscData%Nx = SrcMiscData%Nx
    DstMiscData%WaveTi = SrcMiscData%WaveTi
      CALL MD_CopyContState( SrcMiscData%xTemp, DstMiscData%xTemp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyContState( SrcMiscData%xdTemp, DstMiscData%xdTemp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%zeros6 = SrcMiscData%zeros6
IF (ALLOCATED(SrcMiscData%MDWrOutput)) THEN
  i1_l = LBOUND(SrcMiscData%MDWrOutput,1)
  i1_u = UBOUND(SrcMiscData%MDWrOutput,1)
  IF (.NOT. ALLOCATED(DstMiscData%MDWrOutput)) THEN 
    ALLOCATE(DstMiscData%MDWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%MDWrOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%MDWrOutput = SrcMiscData%MDWrOutput
ENDIF
    DstMiscData%LastOutTime = SrcMiscData%LastOutTime
    DstMiscData%PtfmInit = SrcMiscData%PtfmInit
IF (ALLOCATED(SrcMiscData%BathymetryGrid)) THEN
  i1_l = LBOUND(SrcMiscData%BathymetryGrid,1)
  i1_u = UBOUND(SrcMiscData%BathymetryGrid,1)
  i2_l = LBOUND(SrcMiscData%BathymetryGrid,2)
  i2_u = UBOUND(SrcMiscData%BathymetryGrid,2)
  IF (.NOT. ALLOCATED(DstMiscData%BathymetryGrid)) THEN 
    ALLOCATE(DstMiscData%BathymetryGrid(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathymetryGrid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathymetryGrid = SrcMiscData%BathymetryGrid
ENDIF
IF (ALLOCATED(SrcMiscData%BathGrid_Xs)) THEN
  i1_l = LBOUND(SrcMiscData%BathGrid_Xs,1)
  i1_u = UBOUND(SrcMiscData%BathGrid_Xs,1)
  IF (.NOT. ALLOCATED(DstMiscData%BathGrid_Xs)) THEN 
    ALLOCATE(DstMiscData%BathGrid_Xs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_Xs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathGrid_Xs = SrcMiscData%BathGrid_Xs
ENDIF
IF (ALLOCATED(SrcMiscData%BathGrid_Ys)) THEN
  i1_l = LBOUND(SrcMiscData%BathGrid_Ys,1)
  i1_u = UBOUND(SrcMiscData%BathGrid_Ys,1)
  IF (.NOT. ALLOCATED(DstMiscData%BathGrid_Ys)) THEN 
    ALLOCATE(DstMiscData%BathGrid_Ys(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_Ys.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathGrid_Ys = SrcMiscData%BathGrid_Ys
ENDIF
IF (ALLOCATED(SrcMiscData%BathGrid_npoints)) THEN
  i1_l = LBOUND(SrcMiscData%BathGrid_npoints,1)
  i1_u = UBOUND(SrcMiscData%BathGrid_npoints,1)
  IF (.NOT. ALLOCATED(DstMiscData%BathGrid_npoints)) THEN 
    ALLOCATE(DstMiscData%BathGrid_npoints(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_npoints.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathGrid_npoints = SrcMiscData%BathGrid_npoints
ENDIF
 END SUBROUTINE MD_CopyMisc

 SUBROUTINE MD_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(MD_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%LineTypeList)) THEN
DO i1 = LBOUND(MiscData%LineTypeList,1), UBOUND(MiscData%LineTypeList,1)
  CALL MD_DestroyLineProp( MiscData%LineTypeList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%LineTypeList)
ENDIF
IF (ALLOCATED(MiscData%RodTypeList)) THEN
DO i1 = LBOUND(MiscData%RodTypeList,1), UBOUND(MiscData%RodTypeList,1)
  CALL MD_DestroyRodProp( MiscData%RodTypeList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%RodTypeList)
ENDIF
  CALL MD_DestroyBody( MiscData%GroundBody, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%BodyList)) THEN
DO i1 = LBOUND(MiscData%BodyList,1), UBOUND(MiscData%BodyList,1)
  CALL MD_DestroyBody( MiscData%BodyList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%BodyList)
ENDIF
IF (ALLOCATED(MiscData%RodList)) THEN
DO i1 = LBOUND(MiscData%RodList,1), UBOUND(MiscData%RodList,1)
  CALL MD_DestroyRod( MiscData%RodList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%RodList)
ENDIF
IF (ALLOCATED(MiscData%ConnectList)) THEN
DO i1 = LBOUND(MiscData%ConnectList,1), UBOUND(MiscData%ConnectList,1)
  CALL MD_DestroyConnect( MiscData%ConnectList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%ConnectList)
ENDIF
IF (ALLOCATED(MiscData%LineList)) THEN
DO i1 = LBOUND(MiscData%LineList,1), UBOUND(MiscData%LineList,1)
  CALL MD_DestroyLine( MiscData%LineList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%LineList)
ENDIF
IF (ALLOCATED(MiscData%FailList)) THEN
DO i1 = LBOUND(MiscData%FailList,1), UBOUND(MiscData%FailList,1)
  CALL MD_DestroyFail( MiscData%FailList(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%FailList)
ENDIF
IF (ALLOCATED(MiscData%FreeConIs)) THEN
  DEALLOCATE(MiscData%FreeConIs)
ENDIF
IF (ALLOCATED(MiscData%CpldConIs)) THEN
  DEALLOCATE(MiscData%CpldConIs)
ENDIF
IF (ALLOCATED(MiscData%FreeRodIs)) THEN
  DEALLOCATE(MiscData%FreeRodIs)
ENDIF
IF (ALLOCATED(MiscData%CpldRodIs)) THEN
  DEALLOCATE(MiscData%CpldRodIs)
ENDIF
IF (ALLOCATED(MiscData%FreeBodyIs)) THEN
  DEALLOCATE(MiscData%FreeBodyIs)
ENDIF
IF (ALLOCATED(MiscData%CpldBodyIs)) THEN
  DEALLOCATE(MiscData%CpldBodyIs)
ENDIF
IF (ALLOCATED(MiscData%LineStateIs1)) THEN
  DEALLOCATE(MiscData%LineStateIs1)
ENDIF
IF (ALLOCATED(MiscData%LineStateIsN)) THEN
  DEALLOCATE(MiscData%LineStateIsN)
ENDIF
IF (ALLOCATED(MiscData%ConStateIs1)) THEN
  DEALLOCATE(MiscData%ConStateIs1)
ENDIF
IF (ALLOCATED(MiscData%ConStateIsN)) THEN
  DEALLOCATE(MiscData%ConStateIsN)
ENDIF
IF (ALLOCATED(MiscData%RodStateIs1)) THEN
  DEALLOCATE(MiscData%RodStateIs1)
ENDIF
IF (ALLOCATED(MiscData%RodStateIsN)) THEN
  DEALLOCATE(MiscData%RodStateIsN)
ENDIF
IF (ALLOCATED(MiscData%BodyStateIs1)) THEN
  DEALLOCATE(MiscData%BodyStateIs1)
ENDIF
IF (ALLOCATED(MiscData%BodyStateIsN)) THEN
  DEALLOCATE(MiscData%BodyStateIsN)
ENDIF
  CALL MD_DestroyContState( MiscData%xTemp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyContState( MiscData%xdTemp, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%MDWrOutput)) THEN
  DEALLOCATE(MiscData%MDWrOutput)
ENDIF
IF (ALLOCATED(MiscData%BathymetryGrid)) THEN
  DEALLOCATE(MiscData%BathymetryGrid)
ENDIF
IF (ALLOCATED(MiscData%BathGrid_Xs)) THEN
  DEALLOCATE(MiscData%BathGrid_Xs)
ENDIF
IF (ALLOCATED(MiscData%BathGrid_Ys)) THEN
  DEALLOCATE(MiscData%BathGrid_Ys)
ENDIF
IF (ALLOCATED(MiscData%BathGrid_npoints)) THEN
  DEALLOCATE(MiscData%BathGrid_npoints)
ENDIF
 END SUBROUTINE MD_DestroyMisc


subroutine MD_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! LineTypeList
   call RegPack(Buf, allocated(InData%LineTypeList))
   if (allocated(InData%LineTypeList)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineTypeList), ubound(InData%LineTypeList))
      LB(1:1) = lbound(InData%LineTypeList)
      UB(1:1) = ubound(InData%LineTypeList)
      do i1 = LB(1), UB(1)
         call MD_PackLineProp(Buf, InData%LineTypeList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodTypeList
   call RegPack(Buf, allocated(InData%RodTypeList))
   if (allocated(InData%RodTypeList)) then
      call RegPackBounds(Buf, 1, lbound(InData%RodTypeList), ubound(InData%RodTypeList))
      LB(1:1) = lbound(InData%RodTypeList)
      UB(1:1) = ubound(InData%RodTypeList)
      do i1 = LB(1), UB(1)
         call MD_PackRodProp(Buf, InData%RodTypeList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GroundBody
   call MD_PackBody(Buf, InData%GroundBody) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BodyList
   call RegPack(Buf, allocated(InData%BodyList))
   if (allocated(InData%BodyList)) then
      call RegPackBounds(Buf, 1, lbound(InData%BodyList), ubound(InData%BodyList))
      LB(1:1) = lbound(InData%BodyList)
      UB(1:1) = ubound(InData%BodyList)
      do i1 = LB(1), UB(1)
         call MD_PackBody(Buf, InData%BodyList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodList
   call RegPack(Buf, allocated(InData%RodList))
   if (allocated(InData%RodList)) then
      call RegPackBounds(Buf, 1, lbound(InData%RodList), ubound(InData%RodList))
      LB(1:1) = lbound(InData%RodList)
      UB(1:1) = ubound(InData%RodList)
      do i1 = LB(1), UB(1)
         call MD_PackRod(Buf, InData%RodList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConnectList
   call RegPack(Buf, allocated(InData%ConnectList))
   if (allocated(InData%ConnectList)) then
      call RegPackBounds(Buf, 1, lbound(InData%ConnectList), ubound(InData%ConnectList))
      LB(1:1) = lbound(InData%ConnectList)
      UB(1:1) = ubound(InData%ConnectList)
      do i1 = LB(1), UB(1)
         call MD_PackConnect(Buf, InData%ConnectList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineList
   call RegPack(Buf, allocated(InData%LineList))
   if (allocated(InData%LineList)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineList), ubound(InData%LineList))
      LB(1:1) = lbound(InData%LineList)
      UB(1:1) = ubound(InData%LineList)
      do i1 = LB(1), UB(1)
         call MD_PackLine(Buf, InData%LineList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FailList
   call RegPack(Buf, allocated(InData%FailList))
   if (allocated(InData%FailList)) then
      call RegPackBounds(Buf, 1, lbound(InData%FailList), ubound(InData%FailList))
      LB(1:1) = lbound(InData%FailList)
      UB(1:1) = ubound(InData%FailList)
      do i1 = LB(1), UB(1)
         call MD_PackFail(Buf, InData%FailList(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeConIs
   call RegPack(Buf, allocated(InData%FreeConIs))
   if (allocated(InData%FreeConIs)) then
      call RegPackBounds(Buf, 1, lbound(InData%FreeConIs), ubound(InData%FreeConIs))
      call RegPack(Buf, InData%FreeConIs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CpldConIs
   call RegPack(Buf, allocated(InData%CpldConIs))
   if (allocated(InData%CpldConIs)) then
      call RegPackBounds(Buf, 2, lbound(InData%CpldConIs), ubound(InData%CpldConIs))
      call RegPack(Buf, InData%CpldConIs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeRodIs
   call RegPack(Buf, allocated(InData%FreeRodIs))
   if (allocated(InData%FreeRodIs)) then
      call RegPackBounds(Buf, 1, lbound(InData%FreeRodIs), ubound(InData%FreeRodIs))
      call RegPack(Buf, InData%FreeRodIs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CpldRodIs
   call RegPack(Buf, allocated(InData%CpldRodIs))
   if (allocated(InData%CpldRodIs)) then
      call RegPackBounds(Buf, 2, lbound(InData%CpldRodIs), ubound(InData%CpldRodIs))
      call RegPack(Buf, InData%CpldRodIs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FreeBodyIs
   call RegPack(Buf, allocated(InData%FreeBodyIs))
   if (allocated(InData%FreeBodyIs)) then
      call RegPackBounds(Buf, 1, lbound(InData%FreeBodyIs), ubound(InData%FreeBodyIs))
      call RegPack(Buf, InData%FreeBodyIs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CpldBodyIs
   call RegPack(Buf, allocated(InData%CpldBodyIs))
   if (allocated(InData%CpldBodyIs)) then
      call RegPackBounds(Buf, 2, lbound(InData%CpldBodyIs), ubound(InData%CpldBodyIs))
      call RegPack(Buf, InData%CpldBodyIs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineStateIs1
   call RegPack(Buf, allocated(InData%LineStateIs1))
   if (allocated(InData%LineStateIs1)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineStateIs1), ubound(InData%LineStateIs1))
      call RegPack(Buf, InData%LineStateIs1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LineStateIsN
   call RegPack(Buf, allocated(InData%LineStateIsN))
   if (allocated(InData%LineStateIsN)) then
      call RegPackBounds(Buf, 1, lbound(InData%LineStateIsN), ubound(InData%LineStateIsN))
      call RegPack(Buf, InData%LineStateIsN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConStateIs1
   call RegPack(Buf, allocated(InData%ConStateIs1))
   if (allocated(InData%ConStateIs1)) then
      call RegPackBounds(Buf, 1, lbound(InData%ConStateIs1), ubound(InData%ConStateIs1))
      call RegPack(Buf, InData%ConStateIs1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConStateIsN
   call RegPack(Buf, allocated(InData%ConStateIsN))
   if (allocated(InData%ConStateIsN)) then
      call RegPackBounds(Buf, 1, lbound(InData%ConStateIsN), ubound(InData%ConStateIsN))
      call RegPack(Buf, InData%ConStateIsN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodStateIs1
   call RegPack(Buf, allocated(InData%RodStateIs1))
   if (allocated(InData%RodStateIs1)) then
      call RegPackBounds(Buf, 1, lbound(InData%RodStateIs1), ubound(InData%RodStateIs1))
      call RegPack(Buf, InData%RodStateIs1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RodStateIsN
   call RegPack(Buf, allocated(InData%RodStateIsN))
   if (allocated(InData%RodStateIsN)) then
      call RegPackBounds(Buf, 1, lbound(InData%RodStateIsN), ubound(InData%RodStateIsN))
      call RegPack(Buf, InData%RodStateIsN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BodyStateIs1
   call RegPack(Buf, allocated(InData%BodyStateIs1))
   if (allocated(InData%BodyStateIs1)) then
      call RegPackBounds(Buf, 1, lbound(InData%BodyStateIs1), ubound(InData%BodyStateIs1))
      call RegPack(Buf, InData%BodyStateIs1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BodyStateIsN
   call RegPack(Buf, allocated(InData%BodyStateIsN))
   if (allocated(InData%BodyStateIsN)) then
      call RegPackBounds(Buf, 1, lbound(InData%BodyStateIsN), ubound(InData%BodyStateIsN))
      call RegPack(Buf, InData%BodyStateIsN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nx
   call RegPack(Buf, InData%Nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTi
   call RegPack(Buf, InData%WaveTi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xTemp
   call MD_PackContState(Buf, InData%xTemp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! xdTemp
   call MD_PackContState(Buf, InData%xdTemp) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeros6
   call RegPack(Buf, InData%zeros6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MDWrOutput
   call RegPack(Buf, allocated(InData%MDWrOutput))
   if (allocated(InData%MDWrOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%MDWrOutput), ubound(InData%MDWrOutput))
      call RegPack(Buf, InData%MDWrOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastOutTime
   call RegPack(Buf, InData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmInit
   call RegPack(Buf, InData%PtfmInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BathymetryGrid
   call RegPack(Buf, allocated(InData%BathymetryGrid))
   if (allocated(InData%BathymetryGrid)) then
      call RegPackBounds(Buf, 2, lbound(InData%BathymetryGrid), ubound(InData%BathymetryGrid))
      call RegPack(Buf, InData%BathymetryGrid)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BathGrid_Xs
   call RegPack(Buf, allocated(InData%BathGrid_Xs))
   if (allocated(InData%BathGrid_Xs)) then
      call RegPackBounds(Buf, 1, lbound(InData%BathGrid_Xs), ubound(InData%BathGrid_Xs))
      call RegPack(Buf, InData%BathGrid_Xs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BathGrid_Ys
   call RegPack(Buf, allocated(InData%BathGrid_Ys))
   if (allocated(InData%BathGrid_Ys)) then
      call RegPackBounds(Buf, 1, lbound(InData%BathGrid_Ys), ubound(InData%BathGrid_Ys))
      call RegPack(Buf, InData%BathGrid_Ys)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! BathGrid_npoints
   call RegPack(Buf, allocated(InData%BathGrid_npoints))
   if (allocated(InData%BathGrid_npoints)) then
      call RegPackBounds(Buf, 1, lbound(InData%BathGrid_npoints), ubound(InData%BathGrid_npoints))
      call RegPack(Buf, InData%BathGrid_npoints)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackMisc'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LineTypeList
   if (allocated(OutData%LineTypeList)) deallocate(OutData%LineTypeList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineTypeList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineTypeList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackLineProp(Buf, OutData%LineTypeList(i1)) ! LineTypeList 
      end do
   end if
   ! RodTypeList
   if (allocated(OutData%RodTypeList)) deallocate(OutData%RodTypeList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RodTypeList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodTypeList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackRodProp(Buf, OutData%RodTypeList(i1)) ! RodTypeList 
      end do
   end if
   ! GroundBody
   call MD_UnpackBody(Buf, OutData%GroundBody) ! GroundBody 
   ! BodyList
   if (allocated(OutData%BodyList)) deallocate(OutData%BodyList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BodyList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackBody(Buf, OutData%BodyList(i1)) ! BodyList 
      end do
   end if
   ! RodList
   if (allocated(OutData%RodList)) deallocate(OutData%RodList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RodList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackRod(Buf, OutData%RodList(i1)) ! RodList 
      end do
   end if
   ! ConnectList
   if (allocated(OutData%ConnectList)) deallocate(OutData%ConnectList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ConnectList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ConnectList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackConnect(Buf, OutData%ConnectList(i1)) ! ConnectList 
      end do
   end if
   ! LineList
   if (allocated(OutData%LineList)) deallocate(OutData%LineList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackLine(Buf, OutData%LineList(i1)) ! LineList 
      end do
   end if
   ! FailList
   if (allocated(OutData%FailList)) deallocate(OutData%FailList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FailList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FailList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackFail(Buf, OutData%FailList(i1)) ! FailList 
      end do
   end if
   ! FreeConIs
   if (allocated(OutData%FreeConIs)) deallocate(OutData%FreeConIs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FreeConIs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FreeConIs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FreeConIs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CpldConIs
   if (allocated(OutData%CpldConIs)) deallocate(OutData%CpldConIs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CpldConIs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CpldConIs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CpldConIs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FreeRodIs
   if (allocated(OutData%FreeRodIs)) deallocate(OutData%FreeRodIs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FreeRodIs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FreeRodIs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FreeRodIs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CpldRodIs
   if (allocated(OutData%CpldRodIs)) deallocate(OutData%CpldRodIs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CpldRodIs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CpldRodIs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CpldRodIs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FreeBodyIs
   if (allocated(OutData%FreeBodyIs)) deallocate(OutData%FreeBodyIs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FreeBodyIs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FreeBodyIs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FreeBodyIs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CpldBodyIs
   if (allocated(OutData%CpldBodyIs)) deallocate(OutData%CpldBodyIs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CpldBodyIs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CpldBodyIs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CpldBodyIs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LineStateIs1
   if (allocated(OutData%LineStateIs1)) deallocate(OutData%LineStateIs1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineStateIs1(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineStateIs1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineStateIs1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LineStateIsN
   if (allocated(OutData%LineStateIsN)) deallocate(OutData%LineStateIsN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LineStateIsN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineStateIsN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LineStateIsN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ConStateIs1
   if (allocated(OutData%ConStateIs1)) deallocate(OutData%ConStateIs1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ConStateIs1(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ConStateIs1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ConStateIs1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ConStateIsN
   if (allocated(OutData%ConStateIsN)) deallocate(OutData%ConStateIsN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ConStateIsN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ConStateIsN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ConStateIsN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RodStateIs1
   if (allocated(OutData%RodStateIs1)) deallocate(OutData%RodStateIs1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RodStateIs1(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodStateIs1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RodStateIs1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RodStateIsN
   if (allocated(OutData%RodStateIsN)) deallocate(OutData%RodStateIsN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RodStateIsN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodStateIsN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RodStateIsN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BodyStateIs1
   if (allocated(OutData%BodyStateIs1)) deallocate(OutData%BodyStateIs1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BodyStateIs1(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyStateIs1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BodyStateIs1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BodyStateIsN
   if (allocated(OutData%BodyStateIsN)) deallocate(OutData%BodyStateIsN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BodyStateIsN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyStateIsN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BodyStateIsN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Nx
   call RegUnpack(Buf, OutData%Nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTi
   call RegUnpack(Buf, OutData%WaveTi)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xTemp
   call MD_UnpackContState(Buf, OutData%xTemp) ! xTemp 
   ! xdTemp
   call MD_UnpackContState(Buf, OutData%xdTemp) ! xdTemp 
   ! zeros6
   call RegUnpack(Buf, OutData%zeros6)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MDWrOutput
   if (allocated(OutData%MDWrOutput)) deallocate(OutData%MDWrOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MDWrOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MDWrOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MDWrOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LastOutTime
   call RegUnpack(Buf, OutData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmInit
   call RegUnpack(Buf, OutData%PtfmInit)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BathymetryGrid
   if (allocated(OutData%BathymetryGrid)) deallocate(OutData%BathymetryGrid)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BathymetryGrid(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathymetryGrid.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BathymetryGrid)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BathGrid_Xs
   if (allocated(OutData%BathGrid_Xs)) deallocate(OutData%BathGrid_Xs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BathGrid_Xs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathGrid_Xs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BathGrid_Xs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BathGrid_Ys
   if (allocated(OutData%BathGrid_Ys)) deallocate(OutData%BathGrid_Ys)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BathGrid_Ys(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathGrid_Ys.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BathGrid_Ys)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! BathGrid_npoints
   if (allocated(OutData%BathGrid_npoints)) deallocate(OutData%BathGrid_npoints)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BathGrid_npoints(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathGrid_npoints.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BathGrid_npoints)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(MD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%nLineTypes = SrcParamData%nLineTypes
    DstParamData%nRodTypes = SrcParamData%nRodTypes
    DstParamData%nConnects = SrcParamData%nConnects
    DstParamData%nConnectsExtra = SrcParamData%nConnectsExtra
    DstParamData%nBodies = SrcParamData%nBodies
    DstParamData%nRods = SrcParamData%nRods
    DstParamData%nLines = SrcParamData%nLines
    DstParamData%nCtrlChans = SrcParamData%nCtrlChans
    DstParamData%nFails = SrcParamData%nFails
    DstParamData%nFreeBodies = SrcParamData%nFreeBodies
    DstParamData%nFreeRods = SrcParamData%nFreeRods
    DstParamData%nFreeCons = SrcParamData%nFreeCons
IF (ALLOCATED(SrcParamData%nCpldBodies)) THEN
  i1_l = LBOUND(SrcParamData%nCpldBodies,1)
  i1_u = UBOUND(SrcParamData%nCpldBodies,1)
  IF (.NOT. ALLOCATED(DstParamData%nCpldBodies)) THEN 
    ALLOCATE(DstParamData%nCpldBodies(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nCpldBodies.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%nCpldBodies = SrcParamData%nCpldBodies
ENDIF
IF (ALLOCATED(SrcParamData%nCpldRods)) THEN
  i1_l = LBOUND(SrcParamData%nCpldRods,1)
  i1_u = UBOUND(SrcParamData%nCpldRods,1)
  IF (.NOT. ALLOCATED(DstParamData%nCpldRods)) THEN 
    ALLOCATE(DstParamData%nCpldRods(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nCpldRods.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%nCpldRods = SrcParamData%nCpldRods
ENDIF
IF (ALLOCATED(SrcParamData%nCpldCons)) THEN
  i1_l = LBOUND(SrcParamData%nCpldCons,1)
  i1_u = UBOUND(SrcParamData%nCpldCons,1)
  IF (.NOT. ALLOCATED(DstParamData%nCpldCons)) THEN 
    ALLOCATE(DstParamData%nCpldCons(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nCpldCons.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%nCpldCons = SrcParamData%nCpldCons
ENDIF
    DstParamData%NConns = SrcParamData%NConns
    DstParamData%NAnchs = SrcParamData%NAnchs
    DstParamData%Tmax = SrcParamData%Tmax
    DstParamData%g = SrcParamData%g
    DstParamData%rhoW = SrcParamData%rhoW
    DstParamData%WtrDpth = SrcParamData%WtrDpth
    DstParamData%kBot = SrcParamData%kBot
    DstParamData%cBot = SrcParamData%cBot
    DstParamData%dtM0 = SrcParamData%dtM0
    DstParamData%dtCoupling = SrcParamData%dtCoupling
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%dtOut = SrcParamData%dtOut
    DstParamData%RootName = SrcParamData%RootName
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL MD_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%Delim = SrcParamData%Delim
    DstParamData%MDUnOut = SrcParamData%MDUnOut
    DstParamData%PriPath = SrcParamData%PriPath
    DstParamData%writeLog = SrcParamData%writeLog
    DstParamData%UnLog = SrcParamData%UnLog
    DstParamData%WaveKin = SrcParamData%WaveKin
    DstParamData%Current = SrcParamData%Current
    DstParamData%nTurbines = SrcParamData%nTurbines
IF (ALLOCATED(SrcParamData%TurbineRefPos)) THEN
  i1_l = LBOUND(SrcParamData%TurbineRefPos,1)
  i1_u = UBOUND(SrcParamData%TurbineRefPos,1)
  i2_l = LBOUND(SrcParamData%TurbineRefPos,2)
  i2_u = UBOUND(SrcParamData%TurbineRefPos,2)
  IF (.NOT. ALLOCATED(DstParamData%TurbineRefPos)) THEN 
    ALLOCATE(DstParamData%TurbineRefPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TurbineRefPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%TurbineRefPos = SrcParamData%TurbineRefPos
ENDIF
    DstParamData%mu_kT = SrcParamData%mu_kT
    DstParamData%mu_kA = SrcParamData%mu_kA
    DstParamData%mc = SrcParamData%mc
    DstParamData%cv = SrcParamData%cv
    DstParamData%nxWave = SrcParamData%nxWave
    DstParamData%nyWave = SrcParamData%nyWave
    DstParamData%nzWave = SrcParamData%nzWave
    DstParamData%ntWave = SrcParamData%ntWave
IF (ALLOCATED(SrcParamData%pxWave)) THEN
  i1_l = LBOUND(SrcParamData%pxWave,1)
  i1_u = UBOUND(SrcParamData%pxWave,1)
  IF (.NOT. ALLOCATED(DstParamData%pxWave)) THEN 
    ALLOCATE(DstParamData%pxWave(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pxWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%pxWave = SrcParamData%pxWave
ENDIF
IF (ALLOCATED(SrcParamData%pyWave)) THEN
  i1_l = LBOUND(SrcParamData%pyWave,1)
  i1_u = UBOUND(SrcParamData%pyWave,1)
  IF (.NOT. ALLOCATED(DstParamData%pyWave)) THEN 
    ALLOCATE(DstParamData%pyWave(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pyWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%pyWave = SrcParamData%pyWave
ENDIF
IF (ALLOCATED(SrcParamData%pzWave)) THEN
  i1_l = LBOUND(SrcParamData%pzWave,1)
  i1_u = UBOUND(SrcParamData%pzWave,1)
  IF (.NOT. ALLOCATED(DstParamData%pzWave)) THEN 
    ALLOCATE(DstParamData%pzWave(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pzWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%pzWave = SrcParamData%pzWave
ENDIF
    DstParamData%dtWave = SrcParamData%dtWave
IF (ALLOCATED(SrcParamData%uxWave)) THEN
  i1_l = LBOUND(SrcParamData%uxWave,1)
  i1_u = UBOUND(SrcParamData%uxWave,1)
  i2_l = LBOUND(SrcParamData%uxWave,2)
  i2_u = UBOUND(SrcParamData%uxWave,2)
  i3_l = LBOUND(SrcParamData%uxWave,3)
  i3_u = UBOUND(SrcParamData%uxWave,3)
  i4_l = LBOUND(SrcParamData%uxWave,4)
  i4_u = UBOUND(SrcParamData%uxWave,4)
  IF (.NOT. ALLOCATED(DstParamData%uxWave)) THEN 
    ALLOCATE(DstParamData%uxWave(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uxWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%uxWave = SrcParamData%uxWave
ENDIF
IF (ALLOCATED(SrcParamData%uyWave)) THEN
  i1_l = LBOUND(SrcParamData%uyWave,1)
  i1_u = UBOUND(SrcParamData%uyWave,1)
  i2_l = LBOUND(SrcParamData%uyWave,2)
  i2_u = UBOUND(SrcParamData%uyWave,2)
  i3_l = LBOUND(SrcParamData%uyWave,3)
  i3_u = UBOUND(SrcParamData%uyWave,3)
  i4_l = LBOUND(SrcParamData%uyWave,4)
  i4_u = UBOUND(SrcParamData%uyWave,4)
  IF (.NOT. ALLOCATED(DstParamData%uyWave)) THEN 
    ALLOCATE(DstParamData%uyWave(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uyWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%uyWave = SrcParamData%uyWave
ENDIF
IF (ALLOCATED(SrcParamData%uzWave)) THEN
  i1_l = LBOUND(SrcParamData%uzWave,1)
  i1_u = UBOUND(SrcParamData%uzWave,1)
  i2_l = LBOUND(SrcParamData%uzWave,2)
  i2_u = UBOUND(SrcParamData%uzWave,2)
  i3_l = LBOUND(SrcParamData%uzWave,3)
  i3_u = UBOUND(SrcParamData%uzWave,3)
  i4_l = LBOUND(SrcParamData%uzWave,4)
  i4_u = UBOUND(SrcParamData%uzWave,4)
  IF (.NOT. ALLOCATED(DstParamData%uzWave)) THEN 
    ALLOCATE(DstParamData%uzWave(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uzWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%uzWave = SrcParamData%uzWave
ENDIF
IF (ALLOCATED(SrcParamData%axWave)) THEN
  i1_l = LBOUND(SrcParamData%axWave,1)
  i1_u = UBOUND(SrcParamData%axWave,1)
  i2_l = LBOUND(SrcParamData%axWave,2)
  i2_u = UBOUND(SrcParamData%axWave,2)
  i3_l = LBOUND(SrcParamData%axWave,3)
  i3_u = UBOUND(SrcParamData%axWave,3)
  i4_l = LBOUND(SrcParamData%axWave,4)
  i4_u = UBOUND(SrcParamData%axWave,4)
  IF (.NOT. ALLOCATED(DstParamData%axWave)) THEN 
    ALLOCATE(DstParamData%axWave(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%axWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%axWave = SrcParamData%axWave
ENDIF
IF (ALLOCATED(SrcParamData%ayWave)) THEN
  i1_l = LBOUND(SrcParamData%ayWave,1)
  i1_u = UBOUND(SrcParamData%ayWave,1)
  i2_l = LBOUND(SrcParamData%ayWave,2)
  i2_u = UBOUND(SrcParamData%ayWave,2)
  i3_l = LBOUND(SrcParamData%ayWave,3)
  i3_u = UBOUND(SrcParamData%ayWave,3)
  i4_l = LBOUND(SrcParamData%ayWave,4)
  i4_u = UBOUND(SrcParamData%ayWave,4)
  IF (.NOT. ALLOCATED(DstParamData%ayWave)) THEN 
    ALLOCATE(DstParamData%ayWave(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ayWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ayWave = SrcParamData%ayWave
ENDIF
IF (ALLOCATED(SrcParamData%azWave)) THEN
  i1_l = LBOUND(SrcParamData%azWave,1)
  i1_u = UBOUND(SrcParamData%azWave,1)
  i2_l = LBOUND(SrcParamData%azWave,2)
  i2_u = UBOUND(SrcParamData%azWave,2)
  i3_l = LBOUND(SrcParamData%azWave,3)
  i3_u = UBOUND(SrcParamData%azWave,3)
  i4_l = LBOUND(SrcParamData%azWave,4)
  i4_u = UBOUND(SrcParamData%azWave,4)
  IF (.NOT. ALLOCATED(DstParamData%azWave)) THEN 
    ALLOCATE(DstParamData%azWave(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%azWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%azWave = SrcParamData%azWave
ENDIF
IF (ALLOCATED(SrcParamData%PDyn)) THEN
  i1_l = LBOUND(SrcParamData%PDyn,1)
  i1_u = UBOUND(SrcParamData%PDyn,1)
  i2_l = LBOUND(SrcParamData%PDyn,2)
  i2_u = UBOUND(SrcParamData%PDyn,2)
  i3_l = LBOUND(SrcParamData%PDyn,3)
  i3_u = UBOUND(SrcParamData%PDyn,3)
  i4_l = LBOUND(SrcParamData%PDyn,4)
  i4_u = UBOUND(SrcParamData%PDyn,4)
  IF (.NOT. ALLOCATED(DstParamData%PDyn)) THEN 
    ALLOCATE(DstParamData%PDyn(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PDyn = SrcParamData%PDyn
ENDIF
IF (ALLOCATED(SrcParamData%zeta)) THEN
  i1_l = LBOUND(SrcParamData%zeta,1)
  i1_u = UBOUND(SrcParamData%zeta,1)
  i2_l = LBOUND(SrcParamData%zeta,2)
  i2_u = UBOUND(SrcParamData%zeta,2)
  i3_l = LBOUND(SrcParamData%zeta,3)
  i3_u = UBOUND(SrcParamData%zeta,3)
  IF (.NOT. ALLOCATED(DstParamData%zeta)) THEN 
    ALLOCATE(DstParamData%zeta(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%zeta.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%zeta = SrcParamData%zeta
ENDIF
    DstParamData%nzCurrent = SrcParamData%nzCurrent
IF (ALLOCATED(SrcParamData%pzCurrent)) THEN
  i1_l = LBOUND(SrcParamData%pzCurrent,1)
  i1_u = UBOUND(SrcParamData%pzCurrent,1)
  IF (.NOT. ALLOCATED(DstParamData%pzCurrent)) THEN 
    ALLOCATE(DstParamData%pzCurrent(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pzCurrent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%pzCurrent = SrcParamData%pzCurrent
ENDIF
IF (ALLOCATED(SrcParamData%uxCurrent)) THEN
  i1_l = LBOUND(SrcParamData%uxCurrent,1)
  i1_u = UBOUND(SrcParamData%uxCurrent,1)
  IF (.NOT. ALLOCATED(DstParamData%uxCurrent)) THEN 
    ALLOCATE(DstParamData%uxCurrent(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uxCurrent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%uxCurrent = SrcParamData%uxCurrent
ENDIF
IF (ALLOCATED(SrcParamData%uyCurrent)) THEN
  i1_l = LBOUND(SrcParamData%uyCurrent,1)
  i1_u = UBOUND(SrcParamData%uyCurrent,1)
  IF (.NOT. ALLOCATED(DstParamData%uyCurrent)) THEN 
    ALLOCATE(DstParamData%uyCurrent(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uyCurrent.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%uyCurrent = SrcParamData%uyCurrent
ENDIF
    DstParamData%Nx0 = SrcParamData%Nx0
IF (ALLOCATED(SrcParamData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcParamData%Jac_u_indx,1)
  i1_u = UBOUND(SrcParamData%Jac_u_indx,1)
  i2_l = LBOUND(SrcParamData%Jac_u_indx,2)
  i2_u = UBOUND(SrcParamData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_u_indx)) THEN 
    ALLOCATE(DstParamData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_u_indx = SrcParamData%Jac_u_indx
ENDIF
IF (ALLOCATED(SrcParamData%du)) THEN
  i1_l = LBOUND(SrcParamData%du,1)
  i1_u = UBOUND(SrcParamData%du,1)
  IF (.NOT. ALLOCATED(DstParamData%du)) THEN 
    ALLOCATE(DstParamData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%du.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%du = SrcParamData%du
ENDIF
IF (ALLOCATED(SrcParamData%dx)) THEN
  i1_l = LBOUND(SrcParamData%dx,1)
  i1_u = UBOUND(SrcParamData%dx,1)
  IF (.NOT. ALLOCATED(DstParamData%dx)) THEN 
    ALLOCATE(DstParamData%dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dx = SrcParamData%dx
ENDIF
    DstParamData%Jac_ny = SrcParamData%Jac_ny
    DstParamData%Jac_nx = SrcParamData%Jac_nx
IF (ALLOCATED(SrcParamData%dxIdx_map2_xStateIdx)) THEN
  i1_l = LBOUND(SrcParamData%dxIdx_map2_xStateIdx,1)
  i1_u = UBOUND(SrcParamData%dxIdx_map2_xStateIdx,1)
  IF (.NOT. ALLOCATED(DstParamData%dxIdx_map2_xStateIdx)) THEN 
    ALLOCATE(DstParamData%dxIdx_map2_xStateIdx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dxIdx_map2_xStateIdx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dxIdx_map2_xStateIdx = SrcParamData%dxIdx_map2_xStateIdx
ENDIF
 END SUBROUTINE MD_CopyParam

 SUBROUTINE MD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(MD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%nCpldBodies)) THEN
  DEALLOCATE(ParamData%nCpldBodies)
ENDIF
IF (ALLOCATED(ParamData%nCpldRods)) THEN
  DEALLOCATE(ParamData%nCpldRods)
ENDIF
IF (ALLOCATED(ParamData%nCpldCons)) THEN
  DEALLOCATE(ParamData%nCpldCons)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL MD_DestroyOutParmType( ParamData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
IF (ALLOCATED(ParamData%TurbineRefPos)) THEN
  DEALLOCATE(ParamData%TurbineRefPos)
ENDIF
IF (ALLOCATED(ParamData%pxWave)) THEN
  DEALLOCATE(ParamData%pxWave)
ENDIF
IF (ALLOCATED(ParamData%pyWave)) THEN
  DEALLOCATE(ParamData%pyWave)
ENDIF
IF (ALLOCATED(ParamData%pzWave)) THEN
  DEALLOCATE(ParamData%pzWave)
ENDIF
IF (ALLOCATED(ParamData%uxWave)) THEN
  DEALLOCATE(ParamData%uxWave)
ENDIF
IF (ALLOCATED(ParamData%uyWave)) THEN
  DEALLOCATE(ParamData%uyWave)
ENDIF
IF (ALLOCATED(ParamData%uzWave)) THEN
  DEALLOCATE(ParamData%uzWave)
ENDIF
IF (ALLOCATED(ParamData%axWave)) THEN
  DEALLOCATE(ParamData%axWave)
ENDIF
IF (ALLOCATED(ParamData%ayWave)) THEN
  DEALLOCATE(ParamData%ayWave)
ENDIF
IF (ALLOCATED(ParamData%azWave)) THEN
  DEALLOCATE(ParamData%azWave)
ENDIF
IF (ALLOCATED(ParamData%PDyn)) THEN
  DEALLOCATE(ParamData%PDyn)
ENDIF
IF (ALLOCATED(ParamData%zeta)) THEN
  DEALLOCATE(ParamData%zeta)
ENDIF
IF (ALLOCATED(ParamData%pzCurrent)) THEN
  DEALLOCATE(ParamData%pzCurrent)
ENDIF
IF (ALLOCATED(ParamData%uxCurrent)) THEN
  DEALLOCATE(ParamData%uxCurrent)
ENDIF
IF (ALLOCATED(ParamData%uyCurrent)) THEN
  DEALLOCATE(ParamData%uyCurrent)
ENDIF
IF (ALLOCATED(ParamData%Jac_u_indx)) THEN
  DEALLOCATE(ParamData%Jac_u_indx)
ENDIF
IF (ALLOCATED(ParamData%du)) THEN
  DEALLOCATE(ParamData%du)
ENDIF
IF (ALLOCATED(ParamData%dx)) THEN
  DEALLOCATE(ParamData%dx)
ENDIF
IF (ALLOCATED(ParamData%dxIdx_map2_xStateIdx)) THEN
  DEALLOCATE(ParamData%dxIdx_map2_xStateIdx)
ENDIF
 END SUBROUTINE MD_DestroyParam


subroutine MD_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackParam'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   if (Buf%ErrStat >= AbortErrLev) return
   ! nLineTypes
   call RegPack(Buf, InData%nLineTypes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nRodTypes
   call RegPack(Buf, InData%nRodTypes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nConnects
   call RegPack(Buf, InData%nConnects)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nConnectsExtra
   call RegPack(Buf, InData%nConnectsExtra)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBodies
   call RegPack(Buf, InData%nBodies)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nRods
   call RegPack(Buf, InData%nRods)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nLines
   call RegPack(Buf, InData%nLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nCtrlChans
   call RegPack(Buf, InData%nCtrlChans)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFails
   call RegPack(Buf, InData%nFails)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFreeBodies
   call RegPack(Buf, InData%nFreeBodies)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFreeRods
   call RegPack(Buf, InData%nFreeRods)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFreeCons
   call RegPack(Buf, InData%nFreeCons)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nCpldBodies
   call RegPack(Buf, allocated(InData%nCpldBodies))
   if (allocated(InData%nCpldBodies)) then
      call RegPackBounds(Buf, 1, lbound(InData%nCpldBodies), ubound(InData%nCpldBodies))
      call RegPack(Buf, InData%nCpldBodies)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nCpldRods
   call RegPack(Buf, allocated(InData%nCpldRods))
   if (allocated(InData%nCpldRods)) then
      call RegPackBounds(Buf, 1, lbound(InData%nCpldRods), ubound(InData%nCpldRods))
      call RegPack(Buf, InData%nCpldRods)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nCpldCons
   call RegPack(Buf, allocated(InData%nCpldCons))
   if (allocated(InData%nCpldCons)) then
      call RegPackBounds(Buf, 1, lbound(InData%nCpldCons), ubound(InData%nCpldCons))
      call RegPack(Buf, InData%nCpldCons)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NConns
   call RegPack(Buf, InData%NConns)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NAnchs
   call RegPack(Buf, InData%NAnchs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegPack(Buf, InData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! g
   call RegPack(Buf, InData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rhoW
   call RegPack(Buf, InData%rhoW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! kBot
   call RegPack(Buf, InData%kBot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! cBot
   call RegPack(Buf, InData%cBot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtM0
   call RegPack(Buf, InData%dtM0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtCoupling
   call RegPack(Buf, InData%dtCoupling)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtOut
   call RegPack(Buf, InData%dtOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call MD_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MDUnOut
   call RegPack(Buf, InData%MDUnOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PriPath
   call RegPack(Buf, InData%PriPath)
   if (RegCheckErr(Buf, RoutineName)) return
   ! writeLog
   call RegPack(Buf, InData%writeLog)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnLog
   call RegPack(Buf, InData%UnLog)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKin
   call RegPack(Buf, InData%WaveKin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Current
   call RegPack(Buf, InData%Current)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nTurbines
   call RegPack(Buf, InData%nTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineRefPos
   call RegPack(Buf, allocated(InData%TurbineRefPos))
   if (allocated(InData%TurbineRefPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%TurbineRefPos), ubound(InData%TurbineRefPos))
      call RegPack(Buf, InData%TurbineRefPos)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! mu_kT
   call RegPack(Buf, InData%mu_kT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! mu_kA
   call RegPack(Buf, InData%mu_kA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! mc
   call RegPack(Buf, InData%mc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! cv
   call RegPack(Buf, InData%cv)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nxWave
   call RegPack(Buf, InData%nxWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nyWave
   call RegPack(Buf, InData%nyWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nzWave
   call RegPack(Buf, InData%nzWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ntWave
   call RegPack(Buf, InData%ntWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pxWave
   call RegPack(Buf, allocated(InData%pxWave))
   if (allocated(InData%pxWave)) then
      call RegPackBounds(Buf, 1, lbound(InData%pxWave), ubound(InData%pxWave))
      call RegPack(Buf, InData%pxWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! pyWave
   call RegPack(Buf, allocated(InData%pyWave))
   if (allocated(InData%pyWave)) then
      call RegPackBounds(Buf, 1, lbound(InData%pyWave), ubound(InData%pyWave))
      call RegPack(Buf, InData%pyWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! pzWave
   call RegPack(Buf, allocated(InData%pzWave))
   if (allocated(InData%pzWave)) then
      call RegPackBounds(Buf, 1, lbound(InData%pzWave), ubound(InData%pzWave))
      call RegPack(Buf, InData%pzWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtWave
   call RegPack(Buf, InData%dtWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! uxWave
   call RegPack(Buf, allocated(InData%uxWave))
   if (allocated(InData%uxWave)) then
      call RegPackBounds(Buf, 4, lbound(InData%uxWave), ubound(InData%uxWave))
      call RegPack(Buf, InData%uxWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! uyWave
   call RegPack(Buf, allocated(InData%uyWave))
   if (allocated(InData%uyWave)) then
      call RegPackBounds(Buf, 4, lbound(InData%uyWave), ubound(InData%uyWave))
      call RegPack(Buf, InData%uyWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! uzWave
   call RegPack(Buf, allocated(InData%uzWave))
   if (allocated(InData%uzWave)) then
      call RegPackBounds(Buf, 4, lbound(InData%uzWave), ubound(InData%uzWave))
      call RegPack(Buf, InData%uzWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! axWave
   call RegPack(Buf, allocated(InData%axWave))
   if (allocated(InData%axWave)) then
      call RegPackBounds(Buf, 4, lbound(InData%axWave), ubound(InData%axWave))
      call RegPack(Buf, InData%axWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ayWave
   call RegPack(Buf, allocated(InData%ayWave))
   if (allocated(InData%ayWave)) then
      call RegPackBounds(Buf, 4, lbound(InData%ayWave), ubound(InData%ayWave))
      call RegPack(Buf, InData%ayWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! azWave
   call RegPack(Buf, allocated(InData%azWave))
   if (allocated(InData%azWave)) then
      call RegPackBounds(Buf, 4, lbound(InData%azWave), ubound(InData%azWave))
      call RegPack(Buf, InData%azWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PDyn
   call RegPack(Buf, allocated(InData%PDyn))
   if (allocated(InData%PDyn)) then
      call RegPackBounds(Buf, 4, lbound(InData%PDyn), ubound(InData%PDyn))
      call RegPack(Buf, InData%PDyn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! zeta
   call RegPack(Buf, allocated(InData%zeta))
   if (allocated(InData%zeta)) then
      call RegPackBounds(Buf, 3, lbound(InData%zeta), ubound(InData%zeta))
      call RegPack(Buf, InData%zeta)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nzCurrent
   call RegPack(Buf, InData%nzCurrent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pzCurrent
   call RegPack(Buf, allocated(InData%pzCurrent))
   if (allocated(InData%pzCurrent)) then
      call RegPackBounds(Buf, 1, lbound(InData%pzCurrent), ubound(InData%pzCurrent))
      call RegPack(Buf, InData%pzCurrent)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! uxCurrent
   call RegPack(Buf, allocated(InData%uxCurrent))
   if (allocated(InData%uxCurrent)) then
      call RegPackBounds(Buf, 1, lbound(InData%uxCurrent), ubound(InData%uxCurrent))
      call RegPack(Buf, InData%uxCurrent)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! uyCurrent
   call RegPack(Buf, allocated(InData%uyCurrent))
   if (allocated(InData%uyCurrent)) then
      call RegPackBounds(Buf, 1, lbound(InData%uyCurrent), ubound(InData%uyCurrent))
      call RegPack(Buf, InData%uyCurrent)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nx0
   call RegPack(Buf, InData%Nx0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! du
   call RegPack(Buf, allocated(InData%du))
   if (allocated(InData%du)) then
      call RegPackBounds(Buf, 1, lbound(InData%du), ubound(InData%du))
      call RegPack(Buf, InData%du)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegPack(Buf, allocated(InData%dx))
   if (allocated(InData%dx)) then
      call RegPackBounds(Buf, 1, lbound(InData%dx), ubound(InData%dx))
      call RegPack(Buf, InData%dx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegPack(Buf, InData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nx
   call RegPack(Buf, InData%Jac_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dxIdx_map2_xStateIdx
   call RegPack(Buf, allocated(InData%dxIdx_map2_xStateIdx))
   if (allocated(InData%dxIdx_map2_xStateIdx)) then
      call RegPackBounds(Buf, 1, lbound(InData%dxIdx_map2_xStateIdx), ubound(InData%dxIdx_map2_xStateIdx))
      call RegPack(Buf, InData%dxIdx_map2_xStateIdx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackParam'
   integer(IntKi)  :: i1, i2, i3, i4
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! nLineTypes
   call RegUnpack(Buf, OutData%nLineTypes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nRodTypes
   call RegUnpack(Buf, OutData%nRodTypes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nConnects
   call RegUnpack(Buf, OutData%nConnects)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nConnectsExtra
   call RegUnpack(Buf, OutData%nConnectsExtra)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nBodies
   call RegUnpack(Buf, OutData%nBodies)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nRods
   call RegUnpack(Buf, OutData%nRods)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nLines
   call RegUnpack(Buf, OutData%nLines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nCtrlChans
   call RegUnpack(Buf, OutData%nCtrlChans)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFails
   call RegUnpack(Buf, OutData%nFails)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFreeBodies
   call RegUnpack(Buf, OutData%nFreeBodies)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFreeRods
   call RegUnpack(Buf, OutData%nFreeRods)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nFreeCons
   call RegUnpack(Buf, OutData%nFreeCons)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nCpldBodies
   if (allocated(OutData%nCpldBodies)) deallocate(OutData%nCpldBodies)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%nCpldBodies(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%nCpldBodies.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%nCpldBodies)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nCpldRods
   if (allocated(OutData%nCpldRods)) deallocate(OutData%nCpldRods)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%nCpldRods(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%nCpldRods.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%nCpldRods)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nCpldCons
   if (allocated(OutData%nCpldCons)) deallocate(OutData%nCpldCons)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%nCpldCons(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%nCpldCons.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%nCpldCons)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NConns
   call RegUnpack(Buf, OutData%NConns)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NAnchs
   call RegUnpack(Buf, OutData%NAnchs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegUnpack(Buf, OutData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! g
   call RegUnpack(Buf, OutData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! rhoW
   call RegUnpack(Buf, OutData%rhoW)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! kBot
   call RegUnpack(Buf, OutData%kBot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! cBot
   call RegUnpack(Buf, OutData%cBot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtM0
   call RegUnpack(Buf, OutData%dtM0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtCoupling
   call RegUnpack(Buf, OutData%dtCoupling)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dtOut
   call RegUnpack(Buf, OutData%dtOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MDUnOut
   call RegUnpack(Buf, OutData%MDUnOut)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PriPath
   call RegUnpack(Buf, OutData%PriPath)
   if (RegCheckErr(Buf, RoutineName)) return
   ! writeLog
   call RegUnpack(Buf, OutData%writeLog)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnLog
   call RegUnpack(Buf, OutData%UnLog)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveKin
   call RegUnpack(Buf, OutData%WaveKin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Current
   call RegUnpack(Buf, OutData%Current)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nTurbines
   call RegUnpack(Buf, OutData%nTurbines)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineRefPos
   if (allocated(OutData%TurbineRefPos)) deallocate(OutData%TurbineRefPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TurbineRefPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TurbineRefPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TurbineRefPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! mu_kT
   call RegUnpack(Buf, OutData%mu_kT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! mu_kA
   call RegUnpack(Buf, OutData%mu_kA)
   if (RegCheckErr(Buf, RoutineName)) return
   ! mc
   call RegUnpack(Buf, OutData%mc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! cv
   call RegUnpack(Buf, OutData%cv)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nxWave
   call RegUnpack(Buf, OutData%nxWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nyWave
   call RegUnpack(Buf, OutData%nyWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nzWave
   call RegUnpack(Buf, OutData%nzWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ntWave
   call RegUnpack(Buf, OutData%ntWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pxWave
   if (allocated(OutData%pxWave)) deallocate(OutData%pxWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%pxWave(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%pxWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%pxWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! pyWave
   if (allocated(OutData%pyWave)) deallocate(OutData%pyWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%pyWave(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%pyWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%pyWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! pzWave
   if (allocated(OutData%pzWave)) deallocate(OutData%pzWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%pzWave(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%pzWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%pzWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dtWave
   call RegUnpack(Buf, OutData%dtWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! uxWave
   if (allocated(OutData%uxWave)) deallocate(OutData%uxWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%uxWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%uxWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%uxWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! uyWave
   if (allocated(OutData%uyWave)) deallocate(OutData%uyWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%uyWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%uyWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%uyWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! uzWave
   if (allocated(OutData%uzWave)) deallocate(OutData%uzWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%uzWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%uzWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%uzWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! axWave
   if (allocated(OutData%axWave)) deallocate(OutData%axWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%axWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%axWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%axWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ayWave
   if (allocated(OutData%ayWave)) deallocate(OutData%ayWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ayWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ayWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ayWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! azWave
   if (allocated(OutData%azWave)) deallocate(OutData%azWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%azWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%azWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%azWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PDyn
   if (allocated(OutData%PDyn)) deallocate(OutData%PDyn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PDyn(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PDyn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! zeta
   if (allocated(OutData%zeta)) deallocate(OutData%zeta)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%zeta(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%zeta.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%zeta)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nzCurrent
   call RegUnpack(Buf, OutData%nzCurrent)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pzCurrent
   if (allocated(OutData%pzCurrent)) deallocate(OutData%pzCurrent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%pzCurrent(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%pzCurrent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%pzCurrent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! uxCurrent
   if (allocated(OutData%uxCurrent)) deallocate(OutData%uxCurrent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%uxCurrent(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%uxCurrent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%uxCurrent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! uyCurrent
   if (allocated(OutData%uyCurrent)) deallocate(OutData%uyCurrent)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%uyCurrent(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%uyCurrent.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%uyCurrent)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Nx0
   call RegUnpack(Buf, OutData%Nx0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! du
   if (allocated(OutData%du)) deallocate(OutData%du)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%du(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%du)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dx
   if (allocated(OutData%dx)) deallocate(OutData%dx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_ny
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nx
   call RegUnpack(Buf, OutData%Jac_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dxIdx_map2_xStateIdx
   if (allocated(OutData%dxIdx_map2_xStateIdx)) deallocate(OutData%dxIdx_map2_xStateIdx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dxIdx_map2_xStateIdx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dxIdx_map2_xStateIdx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dxIdx_map2_xStateIdx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(MD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%CoupledKinematics)) THEN
  i1_l = LBOUND(SrcInputData%CoupledKinematics,1)
  i1_u = UBOUND(SrcInputData%CoupledKinematics,1)
  IF (.NOT. ALLOCATED(DstInputData%CoupledKinematics)) THEN 
    ALLOCATE(DstInputData%CoupledKinematics(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CoupledKinematics.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%CoupledKinematics,1), UBOUND(SrcInputData%CoupledKinematics,1)
      CALL MeshCopy( SrcInputData%CoupledKinematics(i1), DstInputData%CoupledKinematics(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%DeltaL)) THEN
  i1_l = LBOUND(SrcInputData%DeltaL,1)
  i1_u = UBOUND(SrcInputData%DeltaL,1)
  IF (.NOT. ALLOCATED(DstInputData%DeltaL)) THEN 
    ALLOCATE(DstInputData%DeltaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%DeltaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%DeltaL = SrcInputData%DeltaL
ENDIF
IF (ALLOCATED(SrcInputData%DeltaLdot)) THEN
  i1_l = LBOUND(SrcInputData%DeltaLdot,1)
  i1_u = UBOUND(SrcInputData%DeltaLdot,1)
  IF (.NOT. ALLOCATED(DstInputData%DeltaLdot)) THEN 
    ALLOCATE(DstInputData%DeltaLdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%DeltaLdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%DeltaLdot = SrcInputData%DeltaLdot
ENDIF
 END SUBROUTINE MD_CopyInput

 SUBROUTINE MD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(MD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%CoupledKinematics)) THEN
DO i1 = LBOUND(InputData%CoupledKinematics,1), UBOUND(InputData%CoupledKinematics,1)
  CALL MeshDestroy( InputData%CoupledKinematics(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(InputData%CoupledKinematics)
ENDIF
IF (ALLOCATED(InputData%DeltaL)) THEN
  DEALLOCATE(InputData%DeltaL)
ENDIF
IF (ALLOCATED(InputData%DeltaLdot)) THEN
  DEALLOCATE(InputData%DeltaLdot)
ENDIF
 END SUBROUTINE MD_DestroyInput


subroutine MD_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! CoupledKinematics
   call RegPack(Buf, allocated(InData%CoupledKinematics))
   if (allocated(InData%CoupledKinematics)) then
      call RegPackBounds(Buf, 1, lbound(InData%CoupledKinematics), ubound(InData%CoupledKinematics))
      LB(1:1) = lbound(InData%CoupledKinematics)
      UB(1:1) = ubound(InData%CoupledKinematics)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%CoupledKinematics(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DeltaL
   call RegPack(Buf, allocated(InData%DeltaL))
   if (allocated(InData%DeltaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%DeltaL), ubound(InData%DeltaL))
      call RegPack(Buf, InData%DeltaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DeltaLdot
   call RegPack(Buf, allocated(InData%DeltaLdot))
   if (allocated(InData%DeltaLdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%DeltaLdot), ubound(InData%DeltaLdot))
      call RegPack(Buf, InData%DeltaLdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! CoupledKinematics
   if (allocated(OutData%CoupledKinematics)) deallocate(OutData%CoupledKinematics)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CoupledKinematics(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoupledKinematics.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%CoupledKinematics(i1)) ! CoupledKinematics 
      end do
   end if
   ! DeltaL
   if (allocated(OutData%DeltaL)) deallocate(OutData%DeltaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DeltaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DeltaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DeltaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DeltaLdot
   if (allocated(OutData%DeltaLdot)) deallocate(OutData%DeltaLdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DeltaLdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DeltaLdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DeltaLdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE MD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(MD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%CoupledLoads)) THEN
  i1_l = LBOUND(SrcOutputData%CoupledLoads,1)
  i1_u = UBOUND(SrcOutputData%CoupledLoads,1)
  IF (.NOT. ALLOCATED(DstOutputData%CoupledLoads)) THEN 
    ALLOCATE(DstOutputData%CoupledLoads(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%CoupledLoads.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%CoupledLoads,1), UBOUND(SrcOutputData%CoupledLoads,1)
      CALL MeshCopy( SrcOutputData%CoupledLoads(i1), DstOutputData%CoupledLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE MD_CopyOutput

 SUBROUTINE MD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(MD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%CoupledLoads)) THEN
DO i1 = LBOUND(OutputData%CoupledLoads,1), UBOUND(OutputData%CoupledLoads,1)
  CALL MeshDestroy( OutputData%CoupledLoads(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%CoupledLoads)
ENDIF
IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE MD_DestroyOutput


subroutine MD_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! CoupledLoads
   call RegPack(Buf, allocated(InData%CoupledLoads))
   if (allocated(InData%CoupledLoads)) then
      call RegPackBounds(Buf, 1, lbound(InData%CoupledLoads), ubound(InData%CoupledLoads))
      LB(1:1) = lbound(InData%CoupledLoads)
      UB(1:1) = ubound(InData%CoupledLoads)
      do i1 = LB(1), UB(1)
         call MeshPack(Buf, InData%CoupledLoads(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine MD_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! CoupledLoads
   if (allocated(OutData%CoupledLoads)) deallocate(OutData%CoupledLoads)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CoupledLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoupledLoads.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(Buf, OutData%CoupledLoads(i1)) ! CoupledLoads 
      end do
   end if
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE MD_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MD_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(MD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'MD_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL MD_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL MD_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL MD_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE MD_Input_ExtrapInterp


 SUBROUTINE MD_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(MD_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(MD_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(MD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'MD_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%CoupledKinematics) .AND. ALLOCATED(u1%CoupledKinematics)) THEN
  DO i1 = LBOUND(u_out%CoupledKinematics,1),UBOUND(u_out%CoupledKinematics,1)
      CALL MeshExtrapInterp1(u1%CoupledKinematics(i1), u2%CoupledKinematics(i1), tin, u_out%CoupledKinematics(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%DeltaL) .AND. ALLOCATED(u1%DeltaL)) THEN
  DO i1 = LBOUND(u_out%DeltaL,1),UBOUND(u_out%DeltaL,1)
    b = -(u1%DeltaL(i1) - u2%DeltaL(i1))
    u_out%DeltaL(i1) = u1%DeltaL(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%DeltaLdot) .AND. ALLOCATED(u1%DeltaLdot)) THEN
  DO i1 = LBOUND(u_out%DeltaLdot,1),UBOUND(u_out%DeltaLdot,1)
    b = -(u1%DeltaLdot(i1) - u2%DeltaLdot(i1))
    u_out%DeltaLdot(i1) = u1%DeltaLdot(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE MD_Input_ExtrapInterp1


 SUBROUTINE MD_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(MD_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(MD_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(MD_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(MD_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'MD_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%CoupledKinematics) .AND. ALLOCATED(u1%CoupledKinematics)) THEN
  DO i1 = LBOUND(u_out%CoupledKinematics,1),UBOUND(u_out%CoupledKinematics,1)
      CALL MeshExtrapInterp2(u1%CoupledKinematics(i1), u2%CoupledKinematics(i1), u3%CoupledKinematics(i1), tin, u_out%CoupledKinematics(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%DeltaL) .AND. ALLOCATED(u1%DeltaL)) THEN
  DO i1 = LBOUND(u_out%DeltaL,1),UBOUND(u_out%DeltaL,1)
    b = (t(3)**2*(u1%DeltaL(i1) - u2%DeltaL(i1)) + t(2)**2*(-u1%DeltaL(i1) + u3%DeltaL(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%DeltaL(i1) + t(3)*u2%DeltaL(i1) - t(2)*u3%DeltaL(i1) ) * scaleFactor
    u_out%DeltaL(i1) = u1%DeltaL(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(u_out%DeltaLdot) .AND. ALLOCATED(u1%DeltaLdot)) THEN
  DO i1 = LBOUND(u_out%DeltaLdot,1),UBOUND(u_out%DeltaLdot,1)
    b = (t(3)**2*(u1%DeltaLdot(i1) - u2%DeltaLdot(i1)) + t(2)**2*(-u1%DeltaLdot(i1) + u3%DeltaLdot(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%DeltaLdot(i1) + t(3)*u2%DeltaLdot(i1) - t(2)*u3%DeltaLdot(i1) ) * scaleFactor
    u_out%DeltaLdot(i1) = u1%DeltaLdot(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE MD_Input_ExtrapInterp2


 SUBROUTINE MD_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(MD_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(MD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'MD_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL MD_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL MD_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL MD_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE MD_Output_ExtrapInterp


 SUBROUTINE MD_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(MD_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(MD_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(MD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'MD_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%CoupledLoads) .AND. ALLOCATED(y1%CoupledLoads)) THEN
  DO i1 = LBOUND(y_out%CoupledLoads,1),UBOUND(y_out%CoupledLoads,1)
      CALL MeshExtrapInterp1(y1%CoupledLoads(i1), y2%CoupledLoads(i1), tin, y_out%CoupledLoads(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE MD_Output_ExtrapInterp1


 SUBROUTINE MD_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(MD_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(MD_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(MD_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(MD_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'MD_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%CoupledLoads) .AND. ALLOCATED(y1%CoupledLoads)) THEN
  DO i1 = LBOUND(y_out%CoupledLoads,1),UBOUND(y_out%CoupledLoads,1)
      CALL MeshExtrapInterp2(y1%CoupledLoads(i1), y2%CoupledLoads(i1), y3%CoupledLoads(i1), tin, y_out%CoupledLoads(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE MD_Output_ExtrapInterp2

END MODULE MoorDyn_Types
!ENDOFREGISTRYGENERATEDFILE
