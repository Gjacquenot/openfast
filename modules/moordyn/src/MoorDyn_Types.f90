!STARTOFREGISTRYGENERATEDFILE 'MoorDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! MoorDyn_Types
!.................................................................................................................................
! This file is part of MoorDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in MoorDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE MoorDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  MD_InputFileType  =======
  TYPE, PUBLIC :: MD_InputFileType
    REAL(DbKi)  :: DTIC = 0.5      !< convergence check time step for IC generation [[s]]
    REAL(DbKi)  :: TMaxIC = 120      !< maximum time to allow for getting converged ICs [[s]]
    REAL(ReKi)  :: CdScaleIC = 1      !< factor to scale drag coefficients by during dynamic relaxation [[]]
    REAL(ReKi)  :: threshIC = 0.01      !< convergence tolerance for ICs  (0.01 means 1%) [[]]
  END TYPE MD_InputFileType
! =======================
! =========  MD_InitInputType  =======
  TYPE, PUBLIC :: MD_InitInputType
    REAL(ReKi)  :: g = -999.9      !< gravity constant [[m/s^2]]
    REAL(ReKi)  :: rhoW = -999.9      !< sea density [[kg/m^3]]
    REAL(ReKi)  :: WtrDepth = -999.9      !< depth of water [[m]]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PtfmInit      !< initial position of platform(s) shape: 6, nTurbines [-]
    INTEGER(IntKi)  :: FarmSize = 0      !< Indicates normal FAST module mode if 0, FAST.Farm coupled mode and =nTurbines if >0 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TurbineRefPos      !< reference position of turbines in farm, shape: 3, nTurbines [-]
    REAL(ReKi)  :: Tmax = 0.0_ReKi      !< simulation duration [[s]]
    CHARACTER(1024)  :: FileName      !< MoorDyn input file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    LOGICAL  :: UsePrimaryInputFile = .TRUE.      !< Read input file instead of passed data [-]
    TYPE(FileInfoType)  :: PassedPrimaryInputData      !< Primary input file as FileInfoType (set by driver/glue code) -- String array with metadata [-]
    LOGICAL  :: Echo = .false.      !< echo parameter - do we want to echo the header line describing the input file? [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< string containing list of output channels requested in input file [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
    LOGICAL  :: VisMeshes = .FALSE.      !< Glue code requesting visualization meshes [-]
  END TYPE MD_InitInputType
! =======================
! =========  MD_LineProp  =======
  TYPE, PUBLIC :: MD_LineProp
    INTEGER(IntKi)  :: IdNum = 0_IntKi      !< integer identifier of this set of line properties [-]
    CHARACTER(20)  :: name      !< name/identifier of this set of line properties [-]
    REAL(DbKi)  :: d = 0.0_R8Ki      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: w = 0.0_R8Ki      !< per-length weight in air [[kg/m]]
    REAL(DbKi)  :: EA = 0.0_R8Ki      !< axial stiffness [[N]]
    REAL(DbKi)  :: EA_D = 0.0_R8Ki      !< axial stiffness [[N]]
    REAL(DbKi)  :: BA = 0.0_R8Ki      !< internal damping coefficient times area [[N-s]]
    REAL(DbKi)  :: BA_D = 0.0_R8Ki      !< internal damping coefficient times area [[N-s]]
    REAL(DbKi)  :: EI = 0.0_R8Ki      !< bending stiffness [[N-m]]
    REAL(DbKi)  :: Can = 0.0_R8Ki      !< transverse added mass coefficient [-]
    REAL(DbKi)  :: Cat = 0.0_R8Ki      !< tangential added mass coefficient [-]
    REAL(DbKi)  :: Cdn = 0.0_R8Ki      !< transverse drag coefficient [-]
    REAL(DbKi)  :: Cdt = 0.0_R8Ki      !< tangential drag coefficient [-]
    INTEGER(IntKi)  :: ElasticMod = 0_IntKi      !< Which elasticity model to use: {0 basic, 1 viscoelastic, 2 future SYCOM}  [-]
    INTEGER(IntKi)  :: nEApoints = 0      !< number of values in stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffXs = 0.0_R8Ki      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffYs = 0.0_R8Ki      !< y array for stress-strain lookup table [-]
    INTEGER(IntKi)  :: nBApoints = 0      !< number of values in stress-strainrate lookup table (0 means using constant c) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampXs = 0.0_R8Ki      !< x array for stress-strainrate lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampYs = 0.0_R8Ki      !< y array for stress-strainrate lookup table	 [-]
    INTEGER(IntKi)  :: nEIpoints = 0      !< number of values in bending stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffXs = 0.0_R8Ki      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffYs = 0.0_R8Ki      !< y array for stress-strain lookup table [-]
  END TYPE MD_LineProp
! =======================
! =========  MD_RodProp  =======
  TYPE, PUBLIC :: MD_RodProp
    INTEGER(IntKi)  :: IdNum = 0_IntKi      !< integer identifier of this set of rod properties [-]
    CHARACTER(10)  :: name      !< name/identifier of this set of rod properties [-]
    REAL(DbKi)  :: d = 0.0_R8Ki      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: w = 0.0_R8Ki      !< per-length weight in air [[kg/m]]
    REAL(DbKi)  :: Can = 0.0_R8Ki      !< transverse added mass coefficient [-]
    REAL(DbKi)  :: Cat = 0.0_R8Ki      !< tangential added mass coefficient [-]
    REAL(DbKi)  :: Cdn = 0.0_R8Ki      !< transverse drag coefficient [-]
    REAL(DbKi)  :: Cdt = 0.0_R8Ki      !< tangential drag coefficient [-]
    REAL(DbKi)  :: CdEnd = 0.0_R8Ki      !< drag coefficient for rod end [[-]]
    REAL(DbKi)  :: CaEnd = 0.0_R8Ki      !< added mass coefficient for rod end [[-]]
  END TYPE MD_RodProp
! =======================
! =========  MD_Body  =======
  TYPE, PUBLIC :: MD_Body
    INTEGER(IntKi)  :: IdNum = 0_IntKi      !< integer identifier of this Point [-]
    INTEGER(IntKi)  :: typeNum = 0_IntKi      !< integer identifying the type.  0=free, 1=fixed, -1=coupled, 2=coupledpinned [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: AttachedC = 0_IntKi      !< list of IdNums of points attached to this body [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: AttachedR = 0_IntKi      !< list of IdNums of rods attached to this body [-]
    INTEGER(IntKi)  :: nAttachedC = 0      !< number of attached points [-]
    INTEGER(IntKi)  :: nAttachedR = 0      !< number of attached rods [-]
    REAL(DbKi) , DIMENSION(1:3,1:30)  :: rPointRel = 0.0_R8Ki      !< relative position of point on body [-]
    REAL(DbKi) , DIMENSION(1:6,1:30)  :: r6RodRel = 0.0_R8Ki      !< relative position and orientation of rod on body [-]
    REAL(DbKi)  :: bodyM = 0.0_R8Ki      !< body mass (seperate from attached objects) [[kg]]
    REAL(DbKi)  :: bodyV = 0.0_R8Ki      !< body volume (for buoyancy calculation) [[m^3]]
    REAL(DbKi) , DIMENSION(1:3)  :: bodyI = 0.0_R8Ki      !< body 3x3 inertia matrix diagonals [[kg-m^2]]
    REAL(DbKi) , DIMENSION(1:6)  :: bodyCdA = 0.0_R8Ki      !< product of drag force and frontal area of body [[m^2]]
    REAL(DbKi) , DIMENSION(1:6)  :: bodyCa = 0.0_R8Ki      !< added mass coefficient of body [-]
    REAL(DbKi)  :: time = 0.0_R8Ki      !< current time [[s]]
    REAL(DbKi) , DIMENSION(1:6)  :: r6 = 0.0_R8Ki      !< position [-]
    REAL(DbKi) , DIMENSION(1:6)  :: v6 = 0.0_R8Ki      !< velocity [-]
    REAL(DbKi) , DIMENSION(1:6)  :: a6 = 0.0_R8Ki      !< acceleration (only used for coupled bodies) [-]
    REAL(DbKi) , DIMENSION(1:3)  :: U = 0.0_R8Ki      !< water velocity at ref point [[m/s]]
    REAL(DbKi) , DIMENSION(1:3)  :: Ud = 0.0_R8Ki      !< water acceleration at ref point [[m/s^2]]
    REAL(DbKi)  :: zeta = 0.0_R8Ki      !< water surface elevation above ref point [[m]]
    REAL(DbKi) , DIMENSION(1:6)  :: F6net = 0.0_R8Ki      !< total force and moment on body (excluding inertial loads) [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M6net = 0.0_R8Ki      !< total mass matrix of Body and any attached objects [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M = 0.0_R8Ki      !< rotated body 6-dof mass and inertia matrix in global orientation [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M0 = 0.0_R8Ki      !< body 6-dof mass and inertia matrix in its own frame [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: OrMat = 0.0_R8Ki      !< DCM for body orientation [-]
    REAL(DbKi) , DIMENSION(1:3)  :: rCG = 0.0_R8Ki      !< vector in body frame from ref point to CG (before rods etc..) [-]
  END TYPE MD_Body
! =======================
! =========  MD_Point  =======
  TYPE, PUBLIC :: MD_Point
    INTEGER(IntKi)  :: IdNum = 0_IntKi      !< integer identifier of this point [-]
    CHARACTER(10)  :: type      !< type of point: fix, vessel, point [-]
    INTEGER(IntKi)  :: typeNum = 0_IntKi      !< integer identifying the type.  1=fixed, -1=coupled, 0=free [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Attached = 0_IntKi      !< list of IdNums of lines attached to this point node [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Top = 0_IntKi      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nAttached = 0      !< number of attached lines [-]
    REAL(DbKi)  :: pointM = 0.0_R8Ki      !< point mass [[kg]]
    REAL(DbKi)  :: pointV = 0.0_R8Ki      !< point volume [[m^3]]
    REAL(DbKi)  :: pointFX = 0.0_R8Ki      !<  [-]
    REAL(DbKi)  :: pointFY = 0.0_R8Ki      !<  [-]
    REAL(DbKi)  :: pointFZ = 0.0_R8Ki      !<  [-]
    REAL(DbKi)  :: pointCa = 0.0_R8Ki      !< added mass coefficient of point [-]
    REAL(DbKi)  :: pointCdA = 0.0_R8Ki      !< product of drag force and frontal area of point [[m^2]]
    REAL(DbKi)  :: time = 0.0_R8Ki      !< current time [[s]]
    REAL(DbKi) , DIMENSION(1:3)  :: r = 0.0_R8Ki      !< position [-]
    REAL(DbKi) , DIMENSION(1:3)  :: rd = 0.0_R8Ki      !< velocity [-]
    REAL(DbKi) , DIMENSION(1:3)  :: a = 0.0_R8Ki      !< acceleration (only used for coupled points) [-]
    REAL(DbKi) , DIMENSION(1:3)  :: U = 0.0_R8Ki      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(1:3)  :: Ud = 0.0_R8Ki      !< water acceleration at node [[m/s^2]]
    REAL(DbKi)  :: zeta = 0.0_R8Ki      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(1:3)  :: Fnet = 0.0_R8Ki      !< total force on node (excluding inertial loads) [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: M = 0.0_R8Ki      !< node mass matrix, from attached lines [-]
  END TYPE MD_Point
! =======================
! =========  MD_Rod  =======
  TYPE, PUBLIC :: MD_Rod
    INTEGER(IntKi)  :: IdNum = 0_IntKi      !< integer identifier of this Line [-]
    CHARACTER(10)  :: type      !< type of Rod.  should match one of RodProp names [-]
    INTEGER(IntKi)  :: PropsIdNum = 0_IntKi      !< the IdNum of the associated rod properties [-]
    INTEGER(IntKi)  :: typeNum = 0_IntKi      !< integer identifying the type.  0=free, 1=pinned, 2=fixed, -1=coupledpinned, -2=coupled [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: AttachedA = 0_IntKi      !< list of IdNums of lines attached to end A [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: AttachedB = 0_IntKi      !< list of IdNums of lines attached to end B [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: TopA = 0_IntKi      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: TopB = 0_IntKi      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nAttachedA = 0      !< number of attached lines to Rod end A [-]
    INTEGER(IntKi)  :: nAttachedB = 0      !< number of attached lines to Rod end B [-]
    INTEGER(IntKi) , DIMENSION(1:20)  :: OutFlagList = 0_IntKi      !< array specifying what line quantities should be output (1 vs 0) [-]
    INTEGER(IntKi)  :: N = 0_IntKi      !< The number of elements in the line [-]
    INTEGER(IntKi)  :: endTypeA = 0_IntKi      !< type of point at end A: 0=pinned to Point, 1=cantilevered to Rod. [-]
    INTEGER(IntKi)  :: endTypeB = 0_IntKi      !< type of point at end B: 0=pinned to Point, 1=cantilevered to Rod. [-]
    REAL(DbKi)  :: UnstrLen = 0.0_R8Ki      !< length of the rod [[m]]
    REAL(DbKi)  :: mass = 0.0_R8Ki      !< mass of the rod [[kg]]
    REAL(DbKi)  :: rho = 0.0_R8Ki      !< density [[kg/m3]]
    REAL(DbKi)  :: d = 0.0_R8Ki      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: Can = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: Cat = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: Cdn = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: Cdt = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: CdEnd = 0.0_R8Ki      !< drag coefficient for rod end [[-]]
    REAL(DbKi)  :: CaEnd = 0.0_R8Ki      !< added mass coefficient for rod end [[-]]
    REAL(DbKi)  :: time = 0.0_R8Ki      !< current time [[s]]
    REAL(DbKi)  :: roll = 0.0_R8Ki      !< roll relative to vertical [[rad]]
    REAL(DbKi)  :: pitch = 0.0_R8Ki      !< pitch relative to vertical [[rad]]
    REAL(DbKi)  :: h0 = 0.0_R8Ki      !< submerged length of rod axis, distance along rod centerline from end A to the waterplane (0 <= h0 <= L) [m]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: r      !< node positions [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      !< node velocities [-]
    REAL(DbKi) , DIMENSION(1:3)  :: q = 0.0_R8Ki      !< tangent vector for rod as a whole [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: l      !< segment unstretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: V      !< segment volume [[m^3]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: W      !< weight vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Bo      !< buoyancy force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Pd      !< dynamic pressure force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      !< node drag (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      !< node drag (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      !< node added mass forcing (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      !< node added mass forcing (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: B      !< node bottom contact force [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Fnet      !< total force on node [[N]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      !< node mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(1:3)  :: FextA = 0.0_R8Ki      !< external forces from attached lines on/about end A  [-]
    REAL(DbKi) , DIMENSION(1:3)  :: FextB = 0.0_R8Ki      !< external forces from attached lines on/about end A  [-]
    REAL(DbKi) , DIMENSION(1:3)  :: Mext = 0.0_R8Ki      !< external moment vector holding sum of any externally applied moments i.e. bending lines [-]
    REAL(DbKi) , DIMENSION(1:6)  :: r6 = 0.0_R8Ki      !< 6 DOF position vector [-]
    REAL(DbKi) , DIMENSION(1:6)  :: v6 = 0.0_R8Ki      !< 6 DOF velocity vector [-]
    REAL(DbKi) , DIMENSION(1:6)  :: a6 = 0.0_R8Ki      !< 6 DOF acceleration vector (only used for coupled Rods) [-]
    REAL(DbKi) , DIMENSION(1:6)  :: F6net = 0.0_R8Ki      !< total force and moment about end A (excluding inertial loads) that Rod may exert on whatever it's attached to [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M6net = 0.0_R8Ki      !< total mass matrix about end A of Rod and any attached Points [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: OrMat = 0.0_R8Ki      !< DCM for body orientation [-]
    INTEGER(IntKi)  :: RodUnOut = 0_IntKi      !< unit number of rod output file [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: RodWrOutput      !< one row of output data for this rod [-]
  END TYPE MD_Rod
! =======================
! =========  MD_Line  =======
  TYPE, PUBLIC :: MD_Line
    INTEGER(IntKi)  :: IdNum = 0_IntKi      !< integer identifier of this Line [-]
    INTEGER(IntKi)  :: PropsIdNum = 0_IntKi      !< the IdNum of the associated line properties [-]
    INTEGER(IntKi)  :: ElasticMod = 0_IntKi      !< Which elasticity model to use: {0 basic, 1 viscoelastic, 2 future SYCOM}  [-]
    INTEGER(IntKi) , DIMENSION(1:20)  :: OutFlagList = 0_IntKi      !< array specifying what line quantities should be output (1 vs 0) [-]
    INTEGER(IntKi)  :: CtrlChan = 0      !< index of control channel that will drive line active tensioning (0 for none) [-]
    INTEGER(IntKi)  :: FairPoint = 0_IntKi      !< IdNum of Point at fairlead [-]
    INTEGER(IntKi)  :: AnchPoint = 0_IntKi      !< IdNum of Point at anchor [-]
    INTEGER(IntKi)  :: N = 0_IntKi      !< The number of elements in the line [-]
    INTEGER(IntKi)  :: endTypeA = 0_IntKi      !< type of connection at end A: 0=pinned to Point, 1=cantilevered to Rod. [-]
    INTEGER(IntKi)  :: endTypeB = 0_IntKi      !< type of connection at end B: 0=pinned to Point, 1=cantilevered to Rod. [-]
    REAL(DbKi)  :: UnstrLen = 0.0_R8Ki      !< unstretched length of the line [-]
    REAL(DbKi)  :: rho = 0.0_R8Ki      !< density [[kg/m3]]
    REAL(DbKi)  :: d = 0.0_R8Ki      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: EA = 0      !< stiffness [[N]]
    REAL(DbKi)  :: EA_D = 0      !< dynamic stiffness when using viscoelastic model [[N]]
    REAL(DbKi)  :: BA = 0      !< internal damping coefficient times area for this line only [[N-s]]
    REAL(DbKi)  :: BA_D = 0      !< dynamic internal damping coefficient times area when using viscoelastic model [[N-s]]
    REAL(DbKi)  :: EI = 0      !< bending stiffness [[N-m]]
    REAL(DbKi)  :: Can = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: Cat = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: Cdn = 0.0_R8Ki      !<  [[-]]
    REAL(DbKi)  :: Cdt = 0.0_R8Ki      !<  [[-]]
    INTEGER(IntKi)  :: nEApoints = 0      !< number of values in stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffXs = 0.0_R8Ki      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffYs = 0.0_R8Ki      !< y array for stress-strain lookup table [-]
    INTEGER(IntKi)  :: nBApoints = 0      !< number of values in stress-strainrate lookup table (0 means using constant c) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampXs = 0.0_R8Ki      !< x array for stress-strainrate lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampYs = 0.0_R8Ki      !< y array for stress-strainrate lookup table	 [-]
    INTEGER(IntKi)  :: nEIpoints = 0      !< number of values in bending stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffXs = 0.0_R8Ki      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffYs = 0.0_R8Ki      !< y array for stress-strain lookup table [-]
    REAL(DbKi)  :: time = 0.0_R8Ki      !< current time [[s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: r      !< node positions [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      !< node velocities [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: q      !< node tangent vectors [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: qs      !< segment tangent vectors [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: l      !< segment unstretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: ld      !< segment unstretched length rate of change (used in active tensioning) [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: lstr      !< segment stretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: lstrd      !< segment change in stretched length [[m/s]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Kurv      !< curvature at each node point [[1/m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: dl_1      !< segment stretch attributed to static stiffness portion [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: V      !< segment volume [[m^3]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: T      !< segment tension vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Td      !< segment internal damping force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: W      !< weight/buoyancy vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      !< node drag (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      !< node drag (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      !< node added mass forcing (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      !< node added mass forcing (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: B      !< node bottom contact force [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Bs      !< node force due to bending moments [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Fnet      !< total force on node [[N]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: S      !< node inverse mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      !< node mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(1:3)  :: EndMomentA = 0.0_R8Ki      !< vector of end moments due to bending at line end A [[N-m]]
    REAL(DbKi) , DIMENSION(1:3)  :: EndMomentB = 0.0_R8Ki      !< vector of end moments due to bending at line end B [[N-m]]
    INTEGER(IntKi)  :: LineUnOut = 0_IntKi      !< unit number of line output file [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: LineWrOutput      !< one row of output data for this line [-]
  END TYPE MD_Line
! =======================
! =========  MD_Fail  =======
  TYPE, PUBLIC :: MD_Fail
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this failure [-]
    INTEGER(IntKi)  :: attachID      !< ID of connection or Rod the lines are attached to [-]
    INTEGER(IntKi)  :: isRod      !< 1 Rod end A, 2 Rod end B, 0 if point [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: lineIDs      !< array of one or more lines to detach (starting from 1...) [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: lineTops      !< an array that will be FILLED IN to return which end of each line was disconnected ... 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nLinesToDetach      !< how many lines to dettach [-]
    REAL(DbKi)  :: failTime      !< time of failure [s]
    REAL(DbKi)  :: failTen      !< tension threshold of failure [N]
    INTEGER(IntKi)  :: failStatus      !< 0 not failed yet, 1 failed, 2 invalid [-]
  END TYPE MD_Fail
! =======================
! =========  MD_OutParmType  =======
  TYPE, PUBLIC :: MD_OutParmType
    CHARACTER(10)  :: Name      !< name of output channel [-]
    CHARACTER(10)  :: Units      !< units string [-]
    INTEGER(IntKi)  :: QType = 0_IntKi      !< type of quantity - 0=tension, 1=x, 2=y, 3=z... [-]
    INTEGER(IntKi)  :: OType = 0_IntKi      !< type of object - 0=line, 1=point [-]
    INTEGER(IntKi)  :: NodeID = 0_IntKi      !< node number if OType=0.  0=anchor, -1=whole object [-]
    INTEGER(IntKi)  :: ObjID = 0_IntKi      !< number of Point or Line object [-]
  END TYPE MD_OutParmType
! =======================
! =========  VisDiam  =======
  TYPE, PUBLIC :: VisDiam
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: Diam      !< Diameter for visualization [-]
  END TYPE VisDiam
! =======================
! =========  MD_InitOutputType  =======
  TYPE, PUBLIC :: MD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: writeOutputHdr      !< first line output file contents: output variable names [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: writeOutputUnt      !< second line of output file contents: units [-]
    TYPE(ProgDesc)  :: Ver      !< this module's name, version, and date [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: CableCChanRqst      !< flag indicating control channel for drive line active tensioning is requested [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the continuous states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Flag that tells FAST/MBC3 if the outputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Flag that tells FAST/MBC3 if the continuous states used in linearization are in the rotating frame (not used for glue) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
  END TYPE MD_InitOutputType
! =======================
! =========  MD_ContinuousStateType  =======
  TYPE, PUBLIC :: MD_ContinuousStateType
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: states      !< state vector of mooring system, e.g. node coordinates and velocities []
  END TYPE MD_ContinuousStateType
! =======================
! =========  MD_DiscreteStateType  =======
  TYPE, PUBLIC :: MD_DiscreteStateType
    REAL(SiKi)  :: dummy = 0.0_R4Ki      !< Remove this variable if you have discrete states [-]
  END TYPE MD_DiscreteStateType
! =======================
! =========  MD_ConstraintStateType  =======
  TYPE, PUBLIC :: MD_ConstraintStateType
    REAL(SiKi)  :: dummy = 0.0_R4Ki      !< Remove this variable if you have constraint states [-]
  END TYPE MD_ConstraintStateType
! =======================
! =========  MD_OtherStateType  =======
  TYPE, PUBLIC :: MD_OtherStateType
    REAL(SiKi)  :: dummy = 0.0_R4Ki      !< Remove this variable if you have other states [-]
  END TYPE MD_OtherStateType
! =======================
! =========  MD_MiscVarType  =======
  TYPE, PUBLIC :: MD_MiscVarType
    TYPE(MD_LineProp) , DIMENSION(:), ALLOCATABLE  :: LineTypeList      !< array of properties for each line type [-]
    TYPE(MD_RodProp) , DIMENSION(:), ALLOCATABLE  :: RodTypeList      !< array of properties for each rod type [-]
    TYPE(MD_Body)  :: GroundBody      !< the single ground body which is the parent of all stationary points [-]
    TYPE(MD_Body) , DIMENSION(:), ALLOCATABLE  :: BodyList      !< array of body objects [-]
    TYPE(MD_Rod) , DIMENSION(:), ALLOCATABLE  :: RodList      !< array of rod objects [-]
    TYPE(MD_Point) , DIMENSION(:), ALLOCATABLE  :: PointList      !< array of point objects [-]
    TYPE(MD_Line) , DIMENSION(:), ALLOCATABLE  :: LineList      !< array of line objects [-]
    TYPE(MD_Fail) , DIMENSION(:), ALLOCATABLE  :: FailList      !< array of line objects [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FreePointIs      !< array of free point indices in PointList vector []
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CpldPointIs      !< array of coupled/fairlead point indices in PointList vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FreeRodIs      !< array of free rod indices in RodList vector []
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CpldRodIs      !< array of coupled/fairlead rod indices in RodList vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: FreeBodyIs      !< array of free body indices in BodyList vector []
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CpldBodyIs      !< array of coupled body indices in BodyList vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LineStateIs1      !< starting index of each line's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LineStateIsN      !< ending index of each line's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: PointStateIs1      !< starting index of each point's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: PointStateIsN      !< ending index of each point's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RodStateIs1      !< starting index of each rod's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: RodStateIsN      !< ending index of each rod's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BodyStateIs1      !< starting index of each body's states in state vector []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BodyStateIsN      !< ending index of each body's states in state vector []
    INTEGER(IntKi)  :: Nx      !< number of states and size of state vector []
    INTEGER(IntKi)  :: Nxtra      !< number of states and size of state vector including points for potential line failures []
    INTEGER(IntKi)  :: WaveTi      !< current interpolation index for wave time series data []
    TYPE(MD_ContinuousStateType)  :: xTemp      !< contains temporary state vector used in integration (put here so it's only allocated once) [-]
    TYPE(MD_ContinuousStateType)  :: xdTemp      !< contains temporary state derivative vector used in integration (put here so it's only allocated once) [-]
    REAL(DbKi) , DIMENSION(1:6)  :: zeros6 = 0.0_R8Ki      !< array of zeros for convenience [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: MDWrOutput      !< Data from time step to be written to a MoorDyn output file [-]
    REAL(DbKi)  :: LastOutTime = 0.0_R8Ki      !< Time of last writing to MD output files [-]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit = 0.0_ReKi      !< initial position of platform for an individual (non-farm) MD instance [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: BathymetryGrid      !< matrix describing the bathymetry in a grid of x's and y's [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: BathGrid_Xs      !< array of x-coordinates in the bathymetry grid [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: BathGrid_Ys      !< array of y-coordinates in the bathymetry grid [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BathGrid_npoints      !< number of grid points to describe the bathymetry grid [-]
  END TYPE MD_MiscVarType
! =======================
! =========  MD_ParameterType  =======
  TYPE, PUBLIC :: MD_ParameterType
    INTEGER(IntKi)  :: nLineTypes = 0      !< number of line types []
    INTEGER(IntKi)  :: nRodTypes = 0      !< number of rod types []
    INTEGER(IntKi)  :: nPoints = 0      !< number of Point objects []
    INTEGER(IntKi)  :: nPointsExtra = 0      !< number of Point objects including space for extra ones that could arise from line failures []
    INTEGER(IntKi)  :: nBodies = 0      !< number of Body objects []
    INTEGER(IntKi)  :: nRods = 0      !< number of Rod objects []
    INTEGER(IntKi)  :: nLines = 0      !< number of Line objects []
    INTEGER(IntKi)  :: nCtrlChans = 0      !< number of distinct control channels specified for use as inputs []
    INTEGER(IntKi)  :: nFails = 0      !< number of failure conditions []
    INTEGER(IntKi)  :: nFreeBodies = 0      !<  []
    INTEGER(IntKi)  :: nFreeRods = 0      !<  []
    INTEGER(IntKi)  :: nFreePoints = 0      !<  []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nCpldBodies      !< number of coupled bodies (for FAST.Farm, size>1 with an entry for each turbine) []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nCpldRods      !< number of coupled rods (for FAST.Farm, size>1 with an entry for each turbine) []
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: nCpldPoints      !< number of coupled points (for FAST.Farm, size>1 with an entry for each turbine) []
    INTEGER(IntKi)  :: NConns = 0      !< number of Connect type Points - not to be confused with NPoints []
    INTEGER(IntKi)  :: NAnchs = 0      !< number of Anchor type Points []
    REAL(DbKi)  :: Tmax = 0.0_R8Ki      !< simulation duration [[s]]
    REAL(DbKi)  :: g = 9.81      !< gravitational constant (positive) [[m/s^2]]
    REAL(DbKi)  :: rhoW = 1025      !< density of seawater [[kg/m^3]]
    REAL(DbKi)  :: WtrDpth = 0.0_R8Ki      !< water depth [[m]]
    REAL(DbKi)  :: kBot = 0.0_R8Ki      !< bottom stiffness [[Pa/m]]
    REAL(DbKi)  :: cBot = 0.0_R8Ki      !< bottom damping [[Pa-s/m]]
    REAL(DbKi)  :: dtM0 = 0.0_R8Ki      !< desired mooring model time step [[s]]
    REAL(DbKi)  :: dtCoupling = 0.0_R8Ki      !< coupling time step that MoorDyn should expect [[s]]
    INTEGER(IntKi)  :: NumOuts = 0_IntKi      !< Number of parameters in the output list (number of outputs requested) [-]
    REAL(DbKi)  :: dtOut = 0.0_R8Ki      !< interval for writing output file lines [[s]]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    TYPE(MD_OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< Names and units (and other characteristics) of all requested output parameters [-]
    CHARACTER(1)  :: Delim      !< Column delimiter for output text files [-]
    INTEGER(IntKi)  :: MDUnOut = 0_IntKi      !< Unit number of main output file [-]
    CHARACTER(1024)  :: PriPath      !< The path to the primary MoorDyn input file, used if looking for additional input files [-]
    INTEGER(IntKi)  :: writeLog = -1      !< Switch for level of log file output [-]
    INTEGER(IntKi)  :: UnLog = -1      !< Unit number of log file [-]
    INTEGER(IntKi)  :: WaveKin = 0_IntKi      !< Flag for whether or how to consider water kinematics [-]
    INTEGER(IntKi)  :: Current = 0_IntKi      !< Flag for whether or how to consider water kinematics [-]
    INTEGER(IntKi)  :: nTurbines = 0_IntKi      !< Number of turbines if MoorDyn is performing an array-level simulation with FAST.Farm, otherwise 0 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TurbineRefPos      !< reference position of turbines in farm, shape: 3, nTurbines [-]
    REAL(DbKi)  :: mu_kT = 0.0_R8Ki      !< transverse kinetic friction coefficient [(-)]
    REAL(DbKi)  :: mu_kA = 0.0_R8Ki      !< axial kinetic friction coefficient [(-)]
    REAL(DbKi)  :: mc = 0.0_R8Ki      !< ratio of the static friction coefficient to the kinetic friction coefficient [(-)]
    REAL(DbKi)  :: cv = 0.0_R8Ki      !< saturated damping coefficient [(-)]
    INTEGER(IntKi)  :: inertialF = 0      !< Indicates MoorDyn returning inertial moments for coupled 6DOF objects. 1 if yes, 0 if no [-]
    INTEGER(IntKi)  :: nxWave = 0_IntKi      !< number of x wave grid points [-]
    INTEGER(IntKi)  :: nyWave = 0_IntKi      !< number of y wave grid points [-]
    INTEGER(IntKi)  :: nzWave = 0_IntKi      !< number of z wave grid points [-]
    INTEGER(IntKi)  :: ntWave = 0_IntKi      !< number of wave time steps [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pxWave      !< x location of wave grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pyWave      !< y location of wave grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pzWave      !< z location of wave grid points [-]
    REAL(SiKi)  :: dtWave = 0.0_R4Ki      !< wave data time step [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uxWave      !< wave velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uyWave      !< wave velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: uzWave      !< wave velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: axWave      !< wave accelerations time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: ayWave      !< wave accelerations time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: azWave      !< wave accelerations time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: PDyn      !< wave dynamic pressure time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: zeta      !< wave surface elevations time series at each surface grid point [-]
    INTEGER(IntKi)  :: nzCurrent = 0_IntKi      !< number of z current grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: pzCurrent      !< z location of current grid points [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: uxCurrent      !< current velocities time series at each grid point [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: uyCurrent      !< current velocities time series at each grid point [-]
    INTEGER(IntKi)  :: Nx0 = 0_IntKi      !< copy of initial size of system state vector, for linearization routines [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
    INTEGER(IntKi)  :: Jac_ny = 0_IntKi      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: Jac_nx = 0_IntKi      !< number of continuous states in jacobian matrix [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: dxIdx_map2_xStateIdx      !< Mapping array from index of dX array to corresponding state index [-]
    LOGICAL  :: VisMeshes = .false.      !< Using visualization meshes as requested by glue code [-]
    TYPE(VisDiam) , DIMENSION(:), ALLOCATABLE  :: VisRodsDiam      !< Diameters for visualization of rods [-]
  END TYPE MD_ParameterType
! =======================
! =========  MD_InputType  =======
  TYPE, PUBLIC :: MD_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: CoupledKinematics      !< array of meshes for each coupling point (6 DOF info used for rods and bodies) [[m, m/s]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DeltaL      !< change in line length command for each channel [[m]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DeltaLdot      !< rate of change of line length command for each channel [[m]]
  END TYPE MD_InputType
! =======================
! =========  MD_OutputType  =======
  TYPE, PUBLIC :: MD_OutputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: CoupledLoads      !< array of point meshes for mooring reaction forces (and moments) at coupling points [[N]]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< output vector returned to glue code []
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: VisLinesMesh      !< Line2 mesh for visualizing mooring lines [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: VisRodsMesh      !< Line2 mesh for visualizing mooring rods [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: VisBodiesMesh      !< Point mesh for visualizing mooring bodies [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: VisAnchsMesh      !< Point mesh for visualizing mooring anchors [-]
  END TYPE MD_OutputType
! =======================
CONTAINS

subroutine MD_CopyInputFileType(SrcInputFileTypeData, DstInputFileTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MD_InputFileType), intent(in) :: SrcInputFileTypeData
   type(MD_InputFileType), intent(inout) :: DstInputFileTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyInputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInputFileTypeData%DTIC = SrcInputFileTypeData%DTIC
   DstInputFileTypeData%TMaxIC = SrcInputFileTypeData%TMaxIC
   DstInputFileTypeData%CdScaleIC = SrcInputFileTypeData%CdScaleIC
   DstInputFileTypeData%threshIC = SrcInputFileTypeData%threshIC
end subroutine

subroutine MD_DestroyInputFileType(InputFileTypeData, ErrStat, ErrMsg)
   type(MD_InputFileType), intent(inout) :: InputFileTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyInputFileType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackInputFileType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_InputFileType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInputFileType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%DTIC)
   call RegPack(RF, InData%TMaxIC)
   call RegPack(RF, InData%CdScaleIC)
   call RegPack(RF, InData%threshIC)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackInputFileType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_InputFileType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInputFileType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%DTIC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TMaxIC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CdScaleIC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%threshIC); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyInitInput(SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg)
   type(MD_InitInputType), intent(in) :: SrcInitInputData
   type(MD_InitInputType), intent(inout) :: DstInitInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_CopyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstInitInputData%g = SrcInitInputData%g
   DstInitInputData%rhoW = SrcInitInputData%rhoW
   DstInitInputData%WtrDepth = SrcInitInputData%WtrDepth
   if (allocated(SrcInitInputData%PtfmInit)) then
      LB(1:2) = lbound(SrcInitInputData%PtfmInit, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%PtfmInit, kind=B8Ki)
      if (.not. allocated(DstInitInputData%PtfmInit)) then
         allocate(DstInitInputData%PtfmInit(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmInit.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
   end if
   DstInitInputData%FarmSize = SrcInitInputData%FarmSize
   if (allocated(SrcInitInputData%TurbineRefPos)) then
      LB(1:2) = lbound(SrcInitInputData%TurbineRefPos, kind=B8Ki)
      UB(1:2) = ubound(SrcInitInputData%TurbineRefPos, kind=B8Ki)
      if (.not. allocated(DstInitInputData%TurbineRefPos)) then
         allocate(DstInitInputData%TurbineRefPos(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%TurbineRefPos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%TurbineRefPos = SrcInitInputData%TurbineRefPos
   end if
   DstInitInputData%Tmax = SrcInitInputData%Tmax
   DstInitInputData%FileName = SrcInitInputData%FileName
   DstInitInputData%RootName = SrcInitInputData%RootName
   DstInitInputData%UsePrimaryInputFile = SrcInitInputData%UsePrimaryInputFile
   call NWTC_Library_CopyFileInfoType(SrcInitInputData%PassedPrimaryInputData, DstInitInputData%PassedPrimaryInputData, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstInitInputData%Echo = SrcInitInputData%Echo
   if (allocated(SrcInitInputData%OutList)) then
      LB(1:1) = lbound(SrcInitInputData%OutList, kind=B8Ki)
      UB(1:1) = ubound(SrcInitInputData%OutList, kind=B8Ki)
      if (.not. allocated(DstInitInputData%OutList)) then
         allocate(DstInitInputData%OutList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%OutList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitInputData%OutList = SrcInitInputData%OutList
   end if
   DstInitInputData%Linearize = SrcInitInputData%Linearize
   DstInitInputData%VisMeshes = SrcInitInputData%VisMeshes
end subroutine

subroutine MD_DestroyInitInput(InitInputData, ErrStat, ErrMsg)
   type(MD_InitInputType), intent(inout) :: InitInputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_DestroyInitInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitInputData%PtfmInit)) then
      deallocate(InitInputData%PtfmInit)
   end if
   if (allocated(InitInputData%TurbineRefPos)) then
      deallocate(InitInputData%TurbineRefPos)
   end if
   call NWTC_Library_DestroyFileInfoType(InitInputData%PassedPrimaryInputData, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InitInputData%OutList)) then
      deallocate(InitInputData%OutList)
   end if
end subroutine

subroutine MD_PackInitInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInitInput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%g)
   call RegPack(RF, InData%rhoW)
   call RegPack(RF, InData%WtrDepth)
   call RegPackAlloc(RF, InData%PtfmInit)
   call RegPack(RF, InData%FarmSize)
   call RegPackAlloc(RF, InData%TurbineRefPos)
   call RegPack(RF, InData%Tmax)
   call RegPack(RF, InData%FileName)
   call RegPack(RF, InData%RootName)
   call RegPack(RF, InData%UsePrimaryInputFile)
   call NWTC_Library_PackFileInfoType(RF, InData%PassedPrimaryInputData) 
   call RegPack(RF, InData%Echo)
   call RegPackAlloc(RF, InData%OutList)
   call RegPack(RF, InData%Linearize)
   call RegPack(RF, InData%VisMeshes)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackInitInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInitInput'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%g); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rhoW); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDepth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PtfmInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FarmSize); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TurbineRefPos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Tmax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FileName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RootName); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UsePrimaryInputFile); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackFileInfoType(RF, OutData%PassedPrimaryInputData) ! PassedPrimaryInputData 
   call RegUnpack(RF, OutData%Echo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%OutList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Linearize); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VisMeshes); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyLineProp(SrcLinePropData, DstLinePropData, CtrlCode, ErrStat, ErrMsg)
   type(MD_LineProp), intent(in) :: SrcLinePropData
   type(MD_LineProp), intent(inout) :: DstLinePropData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyLineProp'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLinePropData%IdNum = SrcLinePropData%IdNum
   DstLinePropData%name = SrcLinePropData%name
   DstLinePropData%d = SrcLinePropData%d
   DstLinePropData%w = SrcLinePropData%w
   DstLinePropData%EA = SrcLinePropData%EA
   DstLinePropData%EA_D = SrcLinePropData%EA_D
   DstLinePropData%BA = SrcLinePropData%BA
   DstLinePropData%BA_D = SrcLinePropData%BA_D
   DstLinePropData%EI = SrcLinePropData%EI
   DstLinePropData%Can = SrcLinePropData%Can
   DstLinePropData%Cat = SrcLinePropData%Cat
   DstLinePropData%Cdn = SrcLinePropData%Cdn
   DstLinePropData%Cdt = SrcLinePropData%Cdt
   DstLinePropData%ElasticMod = SrcLinePropData%ElasticMod
   DstLinePropData%nEApoints = SrcLinePropData%nEApoints
   DstLinePropData%stiffXs = SrcLinePropData%stiffXs
   DstLinePropData%stiffYs = SrcLinePropData%stiffYs
   DstLinePropData%nBApoints = SrcLinePropData%nBApoints
   DstLinePropData%dampXs = SrcLinePropData%dampXs
   DstLinePropData%dampYs = SrcLinePropData%dampYs
   DstLinePropData%nEIpoints = SrcLinePropData%nEIpoints
   DstLinePropData%bstiffXs = SrcLinePropData%bstiffXs
   DstLinePropData%bstiffYs = SrcLinePropData%bstiffYs
end subroutine

subroutine MD_DestroyLineProp(LinePropData, ErrStat, ErrMsg)
   type(MD_LineProp), intent(inout) :: LinePropData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyLineProp'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackLineProp(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_LineProp), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackLineProp'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   call RegPack(RF, InData%name)
   call RegPack(RF, InData%d)
   call RegPack(RF, InData%w)
   call RegPack(RF, InData%EA)
   call RegPack(RF, InData%EA_D)
   call RegPack(RF, InData%BA)
   call RegPack(RF, InData%BA_D)
   call RegPack(RF, InData%EI)
   call RegPack(RF, InData%Can)
   call RegPack(RF, InData%Cat)
   call RegPack(RF, InData%Cdn)
   call RegPack(RF, InData%Cdt)
   call RegPack(RF, InData%ElasticMod)
   call RegPack(RF, InData%nEApoints)
   call RegPack(RF, InData%stiffXs)
   call RegPack(RF, InData%stiffYs)
   call RegPack(RF, InData%nBApoints)
   call RegPack(RF, InData%dampXs)
   call RegPack(RF, InData%dampYs)
   call RegPack(RF, InData%nEIpoints)
   call RegPack(RF, InData%bstiffXs)
   call RegPack(RF, InData%bstiffYs)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackLineProp(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_LineProp), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackLineProp'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%d); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%w); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EA_D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BA_D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Can); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ElasticMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nEApoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%stiffXs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%stiffYs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nBApoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dampXs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dampYs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nEIpoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bstiffXs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bstiffYs); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyRodProp(SrcRodPropData, DstRodPropData, CtrlCode, ErrStat, ErrMsg)
   type(MD_RodProp), intent(in) :: SrcRodPropData
   type(MD_RodProp), intent(inout) :: DstRodPropData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyRodProp'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRodPropData%IdNum = SrcRodPropData%IdNum
   DstRodPropData%name = SrcRodPropData%name
   DstRodPropData%d = SrcRodPropData%d
   DstRodPropData%w = SrcRodPropData%w
   DstRodPropData%Can = SrcRodPropData%Can
   DstRodPropData%Cat = SrcRodPropData%Cat
   DstRodPropData%Cdn = SrcRodPropData%Cdn
   DstRodPropData%Cdt = SrcRodPropData%Cdt
   DstRodPropData%CdEnd = SrcRodPropData%CdEnd
   DstRodPropData%CaEnd = SrcRodPropData%CaEnd
end subroutine

subroutine MD_DestroyRodProp(RodPropData, ErrStat, ErrMsg)
   type(MD_RodProp), intent(inout) :: RodPropData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyRodProp'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackRodProp(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_RodProp), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackRodProp'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   call RegPack(RF, InData%name)
   call RegPack(RF, InData%d)
   call RegPack(RF, InData%w)
   call RegPack(RF, InData%Can)
   call RegPack(RF, InData%Cat)
   call RegPack(RF, InData%Cdn)
   call RegPack(RF, InData%Cdt)
   call RegPack(RF, InData%CdEnd)
   call RegPack(RF, InData%CaEnd)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackRodProp(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_RodProp), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackRodProp'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%d); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%w); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Can); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CdEnd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CaEnd); if (RegCheckErr(RF, RoutineName)) return
end subroutine

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(LineData%r)) THEN
  DEALLOCATE(LineData%r)
ENDIF
IF (ALLOCATED(LineData%rd)) THEN
  DEALLOCATE(LineData%rd)
ENDIF
IF (ALLOCATED(LineData%q)) THEN
  DEALLOCATE(LineData%q)
ENDIF
IF (ALLOCATED(LineData%qs)) THEN
  DEALLOCATE(LineData%qs)
ENDIF
IF (ALLOCATED(LineData%l)) THEN
  DEALLOCATE(LineData%l)
ENDIF
IF (ALLOCATED(LineData%ld)) THEN
  DEALLOCATE(LineData%ld)
ENDIF
IF (ALLOCATED(LineData%lstr)) THEN
  DEALLOCATE(LineData%lstr)
ENDIF
IF (ALLOCATED(LineData%lstrd)) THEN
  DEALLOCATE(LineData%lstrd)
ENDIF
IF (ALLOCATED(LineData%Kurv)) THEN
  DEALLOCATE(LineData%Kurv)
ENDIF
IF (ALLOCATED(LineData%dl_1)) THEN
  DEALLOCATE(LineData%dl_1)
ENDIF
IF (ALLOCATED(LineData%V)) THEN
  DEALLOCATE(LineData%V)
ENDIF
IF (ALLOCATED(LineData%U)) THEN
  DEALLOCATE(LineData%U)
ENDIF
IF (ALLOCATED(LineData%Ud)) THEN
  DEALLOCATE(LineData%Ud)
ENDIF
IF (ALLOCATED(LineData%zeta)) THEN
  DEALLOCATE(LineData%zeta)
ENDIF
IF (ALLOCATED(LineData%PDyn)) THEN
  DEALLOCATE(LineData%PDyn)
ENDIF
IF (ALLOCATED(LineData%T)) THEN
  DEALLOCATE(LineData%T)
ENDIF
IF (ALLOCATED(LineData%Td)) THEN
  DEALLOCATE(LineData%Td)
ENDIF
IF (ALLOCATED(LineData%W)) THEN
  DEALLOCATE(LineData%W)
ENDIF
IF (ALLOCATED(LineData%Dp)) THEN
  DEALLOCATE(LineData%Dp)
ENDIF
IF (ALLOCATED(LineData%Dq)) THEN
  DEALLOCATE(LineData%Dq)
ENDIF
IF (ALLOCATED(LineData%Ap)) THEN
  DEALLOCATE(LineData%Ap)
ENDIF
IF (ALLOCATED(LineData%Aq)) THEN
  DEALLOCATE(LineData%Aq)
ENDIF
IF (ALLOCATED(LineData%B)) THEN
  DEALLOCATE(LineData%B)
ENDIF
IF (ALLOCATED(LineData%Bs)) THEN
  DEALLOCATE(LineData%Bs)
ENDIF
IF (ALLOCATED(LineData%Fnet)) THEN
  DEALLOCATE(LineData%Fnet)
ENDIF
IF (ALLOCATED(LineData%S)) THEN
  DEALLOCATE(LineData%S)
ENDIF
IF (ALLOCATED(LineData%M)) THEN
  DEALLOCATE(LineData%M)
ENDIF
IF (ALLOCATED(LineData%LineWrOutput)) THEN
  DEALLOCATE(LineData%LineWrOutput)
ENDIF
 END SUBROUTINE MD_DestroyLine

 SUBROUTINE MD_PackLine( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Line),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackLine'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1  ! PropsIdNum
      Int_BufSz  = Int_BufSz  + 1  ! ElasticMod
      Int_BufSz  = Int_BufSz  + SIZE(InData%OutFlagList)  ! OutFlagList
      Int_BufSz  = Int_BufSz  + 1  ! CtrlChan
      Int_BufSz  = Int_BufSz  + 1  ! FairPoint
      Int_BufSz  = Int_BufSz  + 1  ! AnchPoint
      Int_BufSz  = Int_BufSz  + 1  ! N
      Int_BufSz  = Int_BufSz  + 1  ! endTypeA
      Int_BufSz  = Int_BufSz  + 1  ! endTypeB
      Db_BufSz   = Db_BufSz   + 1  ! UnstrLen
      Db_BufSz   = Db_BufSz   + 1  ! rho
      Db_BufSz   = Db_BufSz   + 1  ! d
      Db_BufSz   = Db_BufSz   + 1  ! EA
      Db_BufSz   = Db_BufSz   + 1  ! EA_D
      Db_BufSz   = Db_BufSz   + 1  ! BA
      Db_BufSz   = Db_BufSz   + 1  ! BA_D
      Db_BufSz   = Db_BufSz   + 1  ! EI
      Db_BufSz   = Db_BufSz   + 1  ! Can
      Db_BufSz   = Db_BufSz   + 1  ! Cat
      Db_BufSz   = Db_BufSz   + 1  ! Cdn
      Db_BufSz   = Db_BufSz   + 1  ! Cdt
      Int_BufSz  = Int_BufSz  + 1  ! nEApoints
      Db_BufSz   = Db_BufSz   + SIZE(InData%stiffXs)  ! stiffXs
      Db_BufSz   = Db_BufSz   + SIZE(InData%stiffYs)  ! stiffYs
      Int_BufSz  = Int_BufSz  + 1  ! nBApoints
      Db_BufSz   = Db_BufSz   + SIZE(InData%dampXs)  ! dampXs
      Db_BufSz   = Db_BufSz   + SIZE(InData%dampYs)  ! dampYs
      Int_BufSz  = Int_BufSz  + 1  ! nEIpoints
      Db_BufSz   = Db_BufSz   + SIZE(InData%bstiffXs)  ! bstiffXs
      Db_BufSz   = Db_BufSz   + SIZE(InData%bstiffYs)  ! bstiffYs
      Db_BufSz   = Db_BufSz   + 1  ! time
  Int_BufSz   = Int_BufSz   + 1     ! r allocated yes/no
  IF ( ALLOCATED(InData%r) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! r upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%r)  ! r
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! rd allocated yes/no
  IF ( ALLOCATED(InData%rd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! rd upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%rd)  ! rd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! q allocated yes/no
  IF ( ALLOCATED(InData%q) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! q upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%q)  ! q
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! qs allocated yes/no
  IF ( ALLOCATED(InData%qs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! qs upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%qs)  ! qs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! l allocated yes/no
  IF ( ALLOCATED(InData%l) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! l upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%l)  ! l
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ld allocated yes/no
  IF ( ALLOCATED(InData%ld) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ld upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%ld)  ! ld
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! lstr allocated yes/no
  IF ( ALLOCATED(InData%lstr) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! lstr upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%lstr)  ! lstr
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! lstrd allocated yes/no
  IF ( ALLOCATED(InData%lstrd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! lstrd upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%lstrd)  ! lstrd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Kurv allocated yes/no
  IF ( ALLOCATED(InData%Kurv) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Kurv upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Kurv)  ! Kurv
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! dl_1 allocated yes/no
  IF ( ALLOCATED(InData%dl_1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! dl_1 upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%dl_1)  ! dl_1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! V allocated yes/no
  IF ( ALLOCATED(InData%V) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! V upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%V)  ! V
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! U allocated yes/no
  IF ( ALLOCATED(InData%U) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! U upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%U)  ! U
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Ud allocated yes/no
  IF ( ALLOCATED(InData%Ud) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Ud upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Ud)  ! Ud
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! zeta allocated yes/no
  IF ( ALLOCATED(InData%zeta) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! zeta upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%zeta)  ! zeta
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PDyn allocated yes/no
  IF ( ALLOCATED(InData%PDyn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PDyn upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%PDyn)  ! PDyn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! T allocated yes/no
  IF ( ALLOCATED(InData%T) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! T upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%T)  ! T
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Td allocated yes/no
  IF ( ALLOCATED(InData%Td) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Td upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Td)  ! Td
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! W allocated yes/no
  IF ( ALLOCATED(InData%W) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! W upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%W)  ! W
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Dp allocated yes/no
  IF ( ALLOCATED(InData%Dp) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Dp upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Dp)  ! Dp
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Dq allocated yes/no
  IF ( ALLOCATED(InData%Dq) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Dq upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Dq)  ! Dq
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Ap allocated yes/no
  IF ( ALLOCATED(InData%Ap) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Ap upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Ap)  ! Ap
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Aq allocated yes/no
  IF ( ALLOCATED(InData%Aq) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Aq upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Aq)  ! Aq
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! B allocated yes/no
  IF ( ALLOCATED(InData%B) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! B upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%B)  ! B
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Bs allocated yes/no
  IF ( ALLOCATED(InData%Bs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Bs upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Bs)  ! Bs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Fnet allocated yes/no
  IF ( ALLOCATED(InData%Fnet) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Fnet upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Fnet)  ! Fnet
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! S allocated yes/no
  IF ( ALLOCATED(InData%S) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! S upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%S)  ! S
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! M allocated yes/no
  IF ( ALLOCATED(InData%M) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! M upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%M)  ! M
  END IF
      Db_BufSz   = Db_BufSz   + SIZE(InData%EndMomentA)  ! EndMomentA
      Db_BufSz   = Db_BufSz   + SIZE(InData%EndMomentB)  ! EndMomentB
      Int_BufSz  = Int_BufSz  + 1  ! LineUnOut
  Int_BufSz   = Int_BufSz   + 1     ! LineWrOutput allocated yes/no
  IF ( ALLOCATED(InData%LineWrOutput) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! LineWrOutput upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%LineWrOutput)  ! LineWrOutput
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%PropsIdNum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%ElasticMod
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%OutFlagList,1), UBOUND(InData%OutFlagList,1)
      IntKiBuf(Int_Xferred) = InData%OutFlagList(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%CtrlChan
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%FairPoint
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%AnchPoint
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%N
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%endTypeA
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%endTypeB
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%UnstrLen
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%rho
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%d
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%EA
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%EA_D
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%BA
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%BA_D
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%EI
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Can
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cat
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdn
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdt
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nEApoints
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%stiffXs,1), UBOUND(InData%stiffXs,1)
      DbKiBuf(Db_Xferred) = InData%stiffXs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%stiffYs,1), UBOUND(InData%stiffYs,1)
      DbKiBuf(Db_Xferred) = InData%stiffYs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nBApoints
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%dampXs,1), UBOUND(InData%dampXs,1)
      DbKiBuf(Db_Xferred) = InData%dampXs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%dampYs,1), UBOUND(InData%dampYs,1)
      DbKiBuf(Db_Xferred) = InData%dampYs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nEIpoints
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%bstiffXs,1), UBOUND(InData%bstiffXs,1)
      DbKiBuf(Db_Xferred) = InData%bstiffXs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%bstiffYs,1), UBOUND(InData%bstiffYs,1)
      DbKiBuf(Db_Xferred) = InData%bstiffYs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DbKiBuf(Db_Xferred) = InData%time
    Db_Xferred = Db_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%r) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%r,2), UBOUND(InData%r,2)
        DO i1 = LBOUND(InData%r,1), UBOUND(InData%r,1)
          DbKiBuf(Db_Xferred) = InData%r(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%rd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rd,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rd,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rd,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%rd,2), UBOUND(InData%rd,2)
        DO i1 = LBOUND(InData%rd,1), UBOUND(InData%rd,1)
          DbKiBuf(Db_Xferred) = InData%rd(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%q) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%q,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%q,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%q,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%q,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%q,2), UBOUND(InData%q,2)
        DO i1 = LBOUND(InData%q,1), UBOUND(InData%q,1)
          DbKiBuf(Db_Xferred) = InData%q(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%qs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%qs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%qs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%qs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%qs,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%qs,2), UBOUND(InData%qs,2)
        DO i1 = LBOUND(InData%qs,1), UBOUND(InData%qs,1)
          DbKiBuf(Db_Xferred) = InData%qs(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%l) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%l,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%l,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%l,1), UBOUND(InData%l,1)
        DbKiBuf(Db_Xferred) = InData%l(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%ld) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ld,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ld,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ld,1), UBOUND(InData%ld,1)
        DbKiBuf(Db_Xferred) = InData%ld(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%lstr) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%lstr,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%lstr,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%lstr,1), UBOUND(InData%lstr,1)
        DbKiBuf(Db_Xferred) = InData%lstr(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%lstrd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%lstrd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%lstrd,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%lstrd,1), UBOUND(InData%lstrd,1)
        DbKiBuf(Db_Xferred) = InData%lstrd(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Kurv) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Kurv,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Kurv,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Kurv,1), UBOUND(InData%Kurv,1)
        DbKiBuf(Db_Xferred) = InData%Kurv(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%dl_1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl_1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl_1,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%dl_1,1), UBOUND(InData%dl_1,1)
        DbKiBuf(Db_Xferred) = InData%dl_1(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%V) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%V,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%V,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%V,1), UBOUND(InData%V,1)
        DbKiBuf(Db_Xferred) = InData%V(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%U) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%U,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%U,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%U,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%U,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%U,2), UBOUND(InData%U,2)
        DO i1 = LBOUND(InData%U,1), UBOUND(InData%U,1)
          DbKiBuf(Db_Xferred) = InData%U(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Ud) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ud,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ud,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ud,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ud,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Ud,2), UBOUND(InData%Ud,2)
        DO i1 = LBOUND(InData%Ud,1), UBOUND(InData%Ud,1)
          DbKiBuf(Db_Xferred) = InData%Ud(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%zeta) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zeta,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zeta,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%zeta,1), UBOUND(InData%zeta,1)
        DbKiBuf(Db_Xferred) = InData%zeta(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%PDyn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PDyn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PDyn,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%PDyn,1), UBOUND(InData%PDyn,1)
        DbKiBuf(Db_Xferred) = InData%PDyn(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%T) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%T,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%T,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%T,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%T,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%T,2), UBOUND(InData%T,2)
        DO i1 = LBOUND(InData%T,1), UBOUND(InData%T,1)
          DbKiBuf(Db_Xferred) = InData%T(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Td) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Td,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Td,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Td,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Td,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Td,2), UBOUND(InData%Td,2)
        DO i1 = LBOUND(InData%Td,1), UBOUND(InData%Td,1)
          DbKiBuf(Db_Xferred) = InData%Td(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%W) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%W,2), UBOUND(InData%W,2)
        DO i1 = LBOUND(InData%W,1), UBOUND(InData%W,1)
          DbKiBuf(Db_Xferred) = InData%W(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Dp) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dp,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dp,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dp,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dp,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Dp,2), UBOUND(InData%Dp,2)
        DO i1 = LBOUND(InData%Dp,1), UBOUND(InData%Dp,1)
          DbKiBuf(Db_Xferred) = InData%Dp(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Dq) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dq,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dq,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dq,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dq,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Dq,2), UBOUND(InData%Dq,2)
        DO i1 = LBOUND(InData%Dq,1), UBOUND(InData%Dq,1)
          DbKiBuf(Db_Xferred) = InData%Dq(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Ap) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ap,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ap,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ap,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ap,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Ap,2), UBOUND(InData%Ap,2)
        DO i1 = LBOUND(InData%Ap,1), UBOUND(InData%Ap,1)
          DbKiBuf(Db_Xferred) = InData%Ap(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Aq) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Aq,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Aq,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Aq,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Aq,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Aq,2), UBOUND(InData%Aq,2)
        DO i1 = LBOUND(InData%Aq,1), UBOUND(InData%Aq,1)
          DbKiBuf(Db_Xferred) = InData%Aq(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%B) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%B,2), UBOUND(InData%B,2)
        DO i1 = LBOUND(InData%B,1), UBOUND(InData%B,1)
          DbKiBuf(Db_Xferred) = InData%B(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Bs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Bs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Bs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Bs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Bs,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Bs,2), UBOUND(InData%Bs,2)
        DO i1 = LBOUND(InData%Bs,1), UBOUND(InData%Bs,1)
          DbKiBuf(Db_Xferred) = InData%Bs(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Fnet) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Fnet,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Fnet,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Fnet,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Fnet,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Fnet,2), UBOUND(InData%Fnet,2)
        DO i1 = LBOUND(InData%Fnet,1), UBOUND(InData%Fnet,1)
          DbKiBuf(Db_Xferred) = InData%Fnet(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%S) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%S,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%S,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%S,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%S,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%S,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%S,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%S,3), UBOUND(InData%S,3)
        DO i2 = LBOUND(InData%S,2), UBOUND(InData%S,2)
          DO i1 = LBOUND(InData%S,1), UBOUND(InData%S,1)
            DbKiBuf(Db_Xferred) = InData%S(i1,i2,i3)
            Db_Xferred = Db_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%M) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%M,3), UBOUND(InData%M,3)
        DO i2 = LBOUND(InData%M,2), UBOUND(InData%M,2)
          DO i1 = LBOUND(InData%M,1), UBOUND(InData%M,1)
            DbKiBuf(Db_Xferred) = InData%M(i1,i2,i3)
            Db_Xferred = Db_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    DO i1 = LBOUND(InData%EndMomentA,1), UBOUND(InData%EndMomentA,1)
      DbKiBuf(Db_Xferred) = InData%EndMomentA(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%EndMomentB,1), UBOUND(InData%EndMomentB,1)
      DbKiBuf(Db_Xferred) = InData%EndMomentB(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%LineUnOut
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%LineWrOutput) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LineWrOutput,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LineWrOutput,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%LineWrOutput,1), UBOUND(InData%LineWrOutput,1)
        DbKiBuf(Db_Xferred) = InData%LineWrOutput(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_PackLine

 SUBROUTINE MD_UnPackLine( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Line), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackLine'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%PropsIdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%ElasticMod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%OutFlagList,1)
    i1_u = UBOUND(OutData%OutFlagList,1)
    DO i1 = LBOUND(OutData%OutFlagList,1), UBOUND(OutData%OutFlagList,1)
      OutData%OutFlagList(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%CtrlChan = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FairPoint = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%AnchPoint = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%N = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%endTypeA = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%endTypeB = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%UnstrLen = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%rho = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%d = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%EA = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%EA_D = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%BA = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%BA_D = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%EI = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Can = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cat = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdn = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdt = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%nEApoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%stiffXs,1)
    i1_u = UBOUND(OutData%stiffXs,1)
    DO i1 = LBOUND(OutData%stiffXs,1), UBOUND(OutData%stiffXs,1)
      OutData%stiffXs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%stiffYs,1)
    i1_u = UBOUND(OutData%stiffYs,1)
    DO i1 = LBOUND(OutData%stiffYs,1), UBOUND(OutData%stiffYs,1)
      OutData%stiffYs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%nBApoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%dampXs,1)
    i1_u = UBOUND(OutData%dampXs,1)
    DO i1 = LBOUND(OutData%dampXs,1), UBOUND(OutData%dampXs,1)
      OutData%dampXs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%dampYs,1)
    i1_u = UBOUND(OutData%dampYs,1)
    DO i1 = LBOUND(OutData%dampYs,1), UBOUND(OutData%dampYs,1)
      OutData%dampYs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%nEIpoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%bstiffXs,1)
    i1_u = UBOUND(OutData%bstiffXs,1)
    DO i1 = LBOUND(OutData%bstiffXs,1), UBOUND(OutData%bstiffXs,1)
      OutData%bstiffXs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%bstiffYs,1)
    i1_u = UBOUND(OutData%bstiffYs,1)
    DO i1 = LBOUND(OutData%bstiffYs,1), UBOUND(OutData%bstiffYs,1)
      OutData%bstiffYs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%time = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r)) DEALLOCATE(OutData%r)
    ALLOCATE(OutData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%r,2), UBOUND(OutData%r,2)
        DO i1 = LBOUND(OutData%r,1), UBOUND(OutData%r,1)
          OutData%r(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! rd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%rd)) DEALLOCATE(OutData%rd)
    ALLOCATE(OutData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%rd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%rd,2), UBOUND(OutData%rd,2)
        DO i1 = LBOUND(OutData%rd,1), UBOUND(OutData%rd,1)
          OutData%rd(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! q not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%q)) DEALLOCATE(OutData%q)
    ALLOCATE(OutData%q(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%q.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%q,2), UBOUND(OutData%q,2)
        DO i1 = LBOUND(OutData%q,1), UBOUND(OutData%q,1)
          OutData%q(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! qs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%qs)) DEALLOCATE(OutData%qs)
    ALLOCATE(OutData%qs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%qs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%qs,2), UBOUND(OutData%qs,2)
        DO i1 = LBOUND(OutData%qs,1), UBOUND(OutData%qs,1)
          OutData%qs(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! l not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%l)) DEALLOCATE(OutData%l)
    ALLOCATE(OutData%l(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%l.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%l,1), UBOUND(OutData%l,1)
        OutData%l(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ld not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ld)) DEALLOCATE(OutData%ld)
    ALLOCATE(OutData%ld(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ld.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ld,1), UBOUND(OutData%ld,1)
        OutData%ld(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! lstr not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%lstr)) DEALLOCATE(OutData%lstr)
    ALLOCATE(OutData%lstr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%lstr.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%lstr,1), UBOUND(OutData%lstr,1)
        OutData%lstr(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! lstrd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%lstrd)) DEALLOCATE(OutData%lstrd)
    ALLOCATE(OutData%lstrd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%lstrd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%lstrd,1), UBOUND(OutData%lstrd,1)
        OutData%lstrd(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Kurv not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Kurv)) DEALLOCATE(OutData%Kurv)
    ALLOCATE(OutData%Kurv(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Kurv.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Kurv,1), UBOUND(OutData%Kurv,1)
        OutData%Kurv(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! dl_1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%dl_1)) DEALLOCATE(OutData%dl_1)
    ALLOCATE(OutData%dl_1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%dl_1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%dl_1,1), UBOUND(OutData%dl_1,1)
        OutData%dl_1(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! V not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%V)) DEALLOCATE(OutData%V)
    ALLOCATE(OutData%V(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%V.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%V,1), UBOUND(OutData%V,1)
        OutData%V(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! U not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%U)) DEALLOCATE(OutData%U)
    ALLOCATE(OutData%U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%U.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%U,2), UBOUND(OutData%U,2)
        DO i1 = LBOUND(OutData%U,1), UBOUND(OutData%U,1)
          OutData%U(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Ud not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Ud)) DEALLOCATE(OutData%Ud)
    ALLOCATE(OutData%Ud(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ud.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Ud,2), UBOUND(OutData%Ud,2)
        DO i1 = LBOUND(OutData%Ud,1), UBOUND(OutData%Ud,1)
          OutData%Ud(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zeta not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zeta)) DEALLOCATE(OutData%zeta)
    ALLOCATE(OutData%zeta(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zeta.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%zeta,1), UBOUND(OutData%zeta,1)
        OutData%zeta(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PDyn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PDyn)) DEALLOCATE(OutData%PDyn)
    ALLOCATE(OutData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%PDyn,1), UBOUND(OutData%PDyn,1)
        OutData%PDyn(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! T not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%T)) DEALLOCATE(OutData%T)
    ALLOCATE(OutData%T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%T.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%T,2), UBOUND(OutData%T,2)
        DO i1 = LBOUND(OutData%T,1), UBOUND(OutData%T,1)
          OutData%T(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Td not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Td)) DEALLOCATE(OutData%Td)
    ALLOCATE(OutData%Td(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Td.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Td,2), UBOUND(OutData%Td,2)
        DO i1 = LBOUND(OutData%Td,1), UBOUND(OutData%Td,1)
          OutData%Td(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! W not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%W)) DEALLOCATE(OutData%W)
    ALLOCATE(OutData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%W,2), UBOUND(OutData%W,2)
        DO i1 = LBOUND(OutData%W,1), UBOUND(OutData%W,1)
          OutData%W(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Dp not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Dp)) DEALLOCATE(OutData%Dp)
    ALLOCATE(OutData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dp.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Dp,2), UBOUND(OutData%Dp,2)
        DO i1 = LBOUND(OutData%Dp,1), UBOUND(OutData%Dp,1)
          OutData%Dp(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Dq not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Dq)) DEALLOCATE(OutData%Dq)
    ALLOCATE(OutData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dq.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Dq,2), UBOUND(OutData%Dq,2)
        DO i1 = LBOUND(OutData%Dq,1), UBOUND(OutData%Dq,1)
          OutData%Dq(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Ap not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Ap)) DEALLOCATE(OutData%Ap)
    ALLOCATE(OutData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ap.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Ap,2), UBOUND(OutData%Ap,2)
        DO i1 = LBOUND(OutData%Ap,1), UBOUND(OutData%Ap,1)
          OutData%Ap(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Aq not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Aq)) DEALLOCATE(OutData%Aq)
    ALLOCATE(OutData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Aq.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Aq,2), UBOUND(OutData%Aq,2)
        DO i1 = LBOUND(OutData%Aq,1), UBOUND(OutData%Aq,1)
          OutData%Aq(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! B not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%B)) DEALLOCATE(OutData%B)
    ALLOCATE(OutData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%B.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%B,2), UBOUND(OutData%B,2)
        DO i1 = LBOUND(OutData%B,1), UBOUND(OutData%B,1)
          OutData%B(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Bs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Bs)) DEALLOCATE(OutData%Bs)
    ALLOCATE(OutData%Bs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Bs,2), UBOUND(OutData%Bs,2)
        DO i1 = LBOUND(OutData%Bs,1), UBOUND(OutData%Bs,1)
          OutData%Bs(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Fnet not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Fnet)) DEALLOCATE(OutData%Fnet)
    ALLOCATE(OutData%Fnet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fnet.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Fnet,2), UBOUND(OutData%Fnet,2)
        DO i1 = LBOUND(OutData%Fnet,1), UBOUND(OutData%Fnet,1)
          OutData%Fnet(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! S not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%S)) DEALLOCATE(OutData%S)
    ALLOCATE(OutData%S(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%S.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%S,3), UBOUND(OutData%S,3)
        DO i2 = LBOUND(OutData%S,2), UBOUND(OutData%S,2)
          DO i1 = LBOUND(OutData%S,1), UBOUND(OutData%S,1)
            OutData%S(i1,i2,i3) = DbKiBuf(Db_Xferred)
            Db_Xferred = Db_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! M not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%M)) DEALLOCATE(OutData%M)
    ALLOCATE(OutData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%M,3), UBOUND(OutData%M,3)
        DO i2 = LBOUND(OutData%M,2), UBOUND(OutData%M,2)
          DO i1 = LBOUND(OutData%M,1), UBOUND(OutData%M,1)
            OutData%M(i1,i2,i3) = DbKiBuf(Db_Xferred)
            Db_Xferred = Db_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%EndMomentA,1)
    i1_u = UBOUND(OutData%EndMomentA,1)
    DO i1 = LBOUND(OutData%EndMomentA,1), UBOUND(OutData%EndMomentA,1)
      OutData%EndMomentA(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%EndMomentB,1)
    i1_u = UBOUND(OutData%EndMomentB,1)
    DO i1 = LBOUND(OutData%EndMomentB,1), UBOUND(OutData%EndMomentB,1)
      OutData%EndMomentB(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%LineUnOut = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LineWrOutput not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LineWrOutput)) DEALLOCATE(OutData%LineWrOutput)
    ALLOCATE(OutData%LineWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineWrOutput.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%LineWrOutput,1), UBOUND(OutData%LineWrOutput,1)
        OutData%LineWrOutput(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_UnPackLine

 SUBROUTINE MD_CopyFail( SrcFailData, DstFailData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Fail), INTENT(IN) :: SrcFailData
   TYPE(MD_Fail), INTENT(INOUT) :: DstFailData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyFail'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFailData%IdNum = SrcFailData%IdNum
    DstFailData%attachID = SrcFailData%attachID
    DstFailData%isRod = SrcFailData%isRod
    DstFailData%lineIDs = SrcFailData%lineIDs
    DstFailData%lineTops = SrcFailData%lineTops
    DstFailData%nLinesToDetach = SrcFailData%nLinesToDetach
    DstFailData%failTime = SrcFailData%failTime
    DstFailData%failTen = SrcFailData%failTen
    DstFailData%failStatus = SrcFailData%failStatus
 END SUBROUTINE MD_CopyFail

 SUBROUTINE MD_DestroyFail( FailData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(MD_Fail), INTENT(INOUT) :: FailData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyFail'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
 END SUBROUTINE MD_DestroyFail

 SUBROUTINE MD_PackFail( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Fail),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackFail'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1  ! attachID
      Int_BufSz  = Int_BufSz  + 1  ! isRod
      Int_BufSz  = Int_BufSz  + SIZE(InData%lineIDs)  ! lineIDs
      Int_BufSz  = Int_BufSz  + SIZE(InData%lineTops)  ! lineTops
      Int_BufSz  = Int_BufSz  + 1  ! nLinesToDetach
      Db_BufSz   = Db_BufSz   + 1  ! failTime
      Db_BufSz   = Db_BufSz   + 1  ! failTen
      Int_BufSz  = Int_BufSz  + 1  ! failStatus
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%attachID
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%isRod
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%lineIDs,1), UBOUND(InData%lineIDs,1)
      IntKiBuf(Int_Xferred) = InData%lineIDs(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%lineTops,1), UBOUND(InData%lineTops,1)
      IntKiBuf(Int_Xferred) = InData%lineTops(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nLinesToDetach
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%failTime
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%failTen
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%failStatus
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE MD_PackFail

 SUBROUTINE MD_UnPackFail( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Fail), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackFail'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%attachID = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%isRod = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%lineIDs,1)
    i1_u = UBOUND(OutData%lineIDs,1)
    DO i1 = LBOUND(OutData%lineIDs,1), UBOUND(OutData%lineIDs,1)
      OutData%lineIDs(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%lineTops,1)
    i1_u = UBOUND(OutData%lineTops,1)
    DO i1 = LBOUND(OutData%lineTops,1), UBOUND(OutData%lineTops,1)
      OutData%lineTops(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%nLinesToDetach = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%failTime = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%failTen = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%failStatus = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE MD_UnPackFail

 SUBROUTINE MD_CopyOutParmType( SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_OutParmType), INTENT(IN) :: SrcOutParmTypeData
   TYPE(MD_OutParmType), INTENT(INOUT) :: DstOutParmTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyOutParmType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackBody(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_Body), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackBody'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   call RegPack(RF, InData%typeNum)
   call RegPack(RF, InData%AttachedC)
   call RegPack(RF, InData%AttachedR)
   call RegPack(RF, InData%nAttachedC)
   call RegPack(RF, InData%nAttachedR)
   call RegPack(RF, InData%rPointRel)
   call RegPack(RF, InData%r6RodRel)
   call RegPack(RF, InData%bodyM)
   call RegPack(RF, InData%bodyV)
   call RegPack(RF, InData%bodyI)
   call RegPack(RF, InData%bodyCdA)
   call RegPack(RF, InData%bodyCa)
   call RegPack(RF, InData%time)
   call RegPack(RF, InData%r6)
   call RegPack(RF, InData%v6)
   call RegPack(RF, InData%a6)
   call RegPack(RF, InData%U)
   call RegPack(RF, InData%Ud)
   call RegPack(RF, InData%zeta)
   call RegPack(RF, InData%F6net)
   call RegPack(RF, InData%M6net)
   call RegPack(RF, InData%M)
   call RegPack(RF, InData%M0)
   call RegPack(RF, InData%OrMat)
   call RegPack(RF, InData%rCG)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackBody(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_Body), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackBody'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%typeNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AttachedC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AttachedR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nAttachedC); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nAttachedR); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rPointRel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%r6RodRel); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bodyM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bodyV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bodyI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bodyCdA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bodyCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%r6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%v6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%a6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%U); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ud); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%zeta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%F6net); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%M6net); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%M); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%M0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OrMat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rCG); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyPoint(SrcPointData, DstPointData, CtrlCode, ErrStat, ErrMsg)
   type(MD_Point), intent(in) :: SrcPointData
   type(MD_Point), intent(inout) :: DstPointData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MD_CopyPoint'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstPointData%IdNum = SrcPointData%IdNum
   DstPointData%type = SrcPointData%type
   DstPointData%typeNum = SrcPointData%typeNum
   DstPointData%Attached = SrcPointData%Attached
   DstPointData%Top = SrcPointData%Top
   DstPointData%nAttached = SrcPointData%nAttached
   DstPointData%pointM = SrcPointData%pointM
   DstPointData%pointV = SrcPointData%pointV
   DstPointData%pointFX = SrcPointData%pointFX
   DstPointData%pointFY = SrcPointData%pointFY
   DstPointData%pointFZ = SrcPointData%pointFZ
   DstPointData%pointCa = SrcPointData%pointCa
   DstPointData%pointCdA = SrcPointData%pointCdA
   DstPointData%time = SrcPointData%time
   DstPointData%r = SrcPointData%r
   DstPointData%rd = SrcPointData%rd
   DstPointData%a = SrcPointData%a
   DstPointData%U = SrcPointData%U
   DstPointData%Ud = SrcPointData%Ud
   DstPointData%zeta = SrcPointData%zeta
   if (allocated(SrcPointData%PDyn)) then
      LB(1:1) = lbound(SrcPointData%PDyn, kind=B8Ki)
      UB(1:1) = ubound(SrcPointData%PDyn, kind=B8Ki)
      if (.not. allocated(DstPointData%PDyn)) then
         allocate(DstPointData%PDyn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstPointData%PDyn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstPointData%PDyn = SrcPointData%PDyn
   end if
   DstPointData%Fnet = SrcPointData%Fnet
   DstPointData%M = SrcPointData%M
end subroutine

subroutine MD_DestroyPoint(PointData, ErrStat, ErrMsg)
   type(MD_Point), intent(inout) :: PointData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyPoint'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(PointData%PDyn)) then
      deallocate(PointData%PDyn)
   end if
end subroutine

subroutine MD_PackPoint(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_Point), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackPoint'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   call RegPack(RF, InData%type)
   call RegPack(RF, InData%typeNum)
   call RegPack(RF, InData%Attached)
   call RegPack(RF, InData%Top)
   call RegPack(RF, InData%nAttached)
   call RegPack(RF, InData%pointM)
   call RegPack(RF, InData%pointV)
   call RegPack(RF, InData%pointFX)
   call RegPack(RF, InData%pointFY)
   call RegPack(RF, InData%pointFZ)
   call RegPack(RF, InData%pointCa)
   call RegPack(RF, InData%pointCdA)
   call RegPack(RF, InData%time)
   call RegPack(RF, InData%r)
   call RegPack(RF, InData%rd)
   call RegPack(RF, InData%a)
   call RegPack(RF, InData%U)
   call RegPack(RF, InData%Ud)
   call RegPack(RF, InData%zeta)
   call RegPackAlloc(RF, InData%PDyn)
   call RegPack(RF, InData%Fnet)
   call RegPack(RF, InData%M)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackPoint(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_Point), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackPoint'
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%type); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%typeNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Attached); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Top); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nAttached); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointM); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointV); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointFX); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointFY); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointFZ); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointCa); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pointCdA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%r); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%a); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%U); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Ud); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%zeta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PDyn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Fnet); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%M); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyRod(SrcRodData, DstRodData, CtrlCode, ErrStat, ErrMsg)
   type(MD_Rod), intent(in) :: SrcRodData
   type(MD_Rod), intent(inout) :: DstRodData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MD_CopyRod'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstRodData%IdNum = SrcRodData%IdNum
   DstRodData%type = SrcRodData%type
   DstRodData%PropsIdNum = SrcRodData%PropsIdNum
   DstRodData%typeNum = SrcRodData%typeNum
   DstRodData%AttachedA = SrcRodData%AttachedA
   DstRodData%AttachedB = SrcRodData%AttachedB
   DstRodData%TopA = SrcRodData%TopA
   DstRodData%TopB = SrcRodData%TopB
   DstRodData%nAttachedA = SrcRodData%nAttachedA
   DstRodData%nAttachedB = SrcRodData%nAttachedB
   DstRodData%OutFlagList = SrcRodData%OutFlagList
   DstRodData%N = SrcRodData%N
   DstRodData%endTypeA = SrcRodData%endTypeA
   DstRodData%endTypeB = SrcRodData%endTypeB
   DstRodData%UnstrLen = SrcRodData%UnstrLen
   DstRodData%mass = SrcRodData%mass
   DstRodData%rho = SrcRodData%rho
   DstRodData%d = SrcRodData%d
   DstRodData%Can = SrcRodData%Can
   DstRodData%Cat = SrcRodData%Cat
   DstRodData%Cdn = SrcRodData%Cdn
   DstRodData%Cdt = SrcRodData%Cdt
   DstRodData%CdEnd = SrcRodData%CdEnd
   DstRodData%CaEnd = SrcRodData%CaEnd
   DstRodData%time = SrcRodData%time
   DstRodData%roll = SrcRodData%roll
   DstRodData%pitch = SrcRodData%pitch
   DstRodData%h0 = SrcRodData%h0
   if (allocated(SrcRodData%r)) then
      LB(1:2) = lbound(SrcRodData%r, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%r, kind=B8Ki)
      if (.not. allocated(DstRodData%r)) then
         allocate(DstRodData%r(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%r.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%r = SrcRodData%r
   end if
   if (allocated(SrcRodData%rd)) then
      LB(1:2) = lbound(SrcRodData%rd, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%rd, kind=B8Ki)
      if (.not. allocated(DstRodData%rd)) then
         allocate(DstRodData%rd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%rd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%rd = SrcRodData%rd
   end if
   DstRodData%q = SrcRodData%q
   if (allocated(SrcRodData%l)) then
      LB(1:1) = lbound(SrcRodData%l, kind=B8Ki)
      UB(1:1) = ubound(SrcRodData%l, kind=B8Ki)
      if (.not. allocated(DstRodData%l)) then
         allocate(DstRodData%l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%l = SrcRodData%l
   end if
   if (allocated(SrcRodData%V)) then
      LB(1:1) = lbound(SrcRodData%V, kind=B8Ki)
      UB(1:1) = ubound(SrcRodData%V, kind=B8Ki)
      if (.not. allocated(DstRodData%V)) then
         allocate(DstRodData%V(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%V.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%V = SrcRodData%V
   end if
   if (allocated(SrcRodData%U)) then
      LB(1:2) = lbound(SrcRodData%U, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%U, kind=B8Ki)
      if (.not. allocated(DstRodData%U)) then
         allocate(DstRodData%U(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%U.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%U = SrcRodData%U
   end if
   if (allocated(SrcRodData%Ud)) then
      LB(1:2) = lbound(SrcRodData%Ud, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Ud, kind=B8Ki)
      if (.not. allocated(DstRodData%Ud)) then
         allocate(DstRodData%Ud(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Ud.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Ud = SrcRodData%Ud
   end if
   if (allocated(SrcRodData%zeta)) then
      LB(1:1) = lbound(SrcRodData%zeta, kind=B8Ki)
      UB(1:1) = ubound(SrcRodData%zeta, kind=B8Ki)
      if (.not. allocated(DstRodData%zeta)) then
         allocate(DstRodData%zeta(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%zeta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%zeta = SrcRodData%zeta
   end if
   if (allocated(SrcRodData%PDyn)) then
      LB(1:1) = lbound(SrcRodData%PDyn, kind=B8Ki)
      UB(1:1) = ubound(SrcRodData%PDyn, kind=B8Ki)
      if (.not. allocated(DstRodData%PDyn)) then
         allocate(DstRodData%PDyn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%PDyn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%PDyn = SrcRodData%PDyn
   end if
   if (allocated(SrcRodData%W)) then
      LB(1:2) = lbound(SrcRodData%W, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%W, kind=B8Ki)
      if (.not. allocated(DstRodData%W)) then
         allocate(DstRodData%W(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%W.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%W = SrcRodData%W
   end if
   if (allocated(SrcRodData%Bo)) then
      LB(1:2) = lbound(SrcRodData%Bo, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Bo, kind=B8Ki)
      if (.not. allocated(DstRodData%Bo)) then
         allocate(DstRodData%Bo(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Bo.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Bo = SrcRodData%Bo
   end if
   if (allocated(SrcRodData%Pd)) then
      LB(1:2) = lbound(SrcRodData%Pd, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Pd, kind=B8Ki)
      if (.not. allocated(DstRodData%Pd)) then
         allocate(DstRodData%Pd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Pd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Pd = SrcRodData%Pd
   end if
   if (allocated(SrcRodData%Dp)) then
      LB(1:2) = lbound(SrcRodData%Dp, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Dp, kind=B8Ki)
      if (.not. allocated(DstRodData%Dp)) then
         allocate(DstRodData%Dp(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Dp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Dp = SrcRodData%Dp
   end if
   if (allocated(SrcRodData%Dq)) then
      LB(1:2) = lbound(SrcRodData%Dq, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Dq, kind=B8Ki)
      if (.not. allocated(DstRodData%Dq)) then
         allocate(DstRodData%Dq(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Dq.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Dq = SrcRodData%Dq
   end if
   if (allocated(SrcRodData%Ap)) then
      LB(1:2) = lbound(SrcRodData%Ap, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Ap, kind=B8Ki)
      if (.not. allocated(DstRodData%Ap)) then
         allocate(DstRodData%Ap(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Ap.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Ap = SrcRodData%Ap
   end if
   if (allocated(SrcRodData%Aq)) then
      LB(1:2) = lbound(SrcRodData%Aq, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Aq, kind=B8Ki)
      if (.not. allocated(DstRodData%Aq)) then
         allocate(DstRodData%Aq(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Aq.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Aq = SrcRodData%Aq
   end if
   if (allocated(SrcRodData%B)) then
      LB(1:2) = lbound(SrcRodData%B, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%B, kind=B8Ki)
      if (.not. allocated(DstRodData%B)) then
         allocate(DstRodData%B(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%B.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%B = SrcRodData%B
   end if
   if (allocated(SrcRodData%Fnet)) then
      LB(1:2) = lbound(SrcRodData%Fnet, kind=B8Ki)
      UB(1:2) = ubound(SrcRodData%Fnet, kind=B8Ki)
      if (.not. allocated(DstRodData%Fnet)) then
         allocate(DstRodData%Fnet(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Fnet.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%Fnet = SrcRodData%Fnet
   end if
   if (allocated(SrcRodData%M)) then
      LB(1:3) = lbound(SrcRodData%M, kind=B8Ki)
      UB(1:3) = ubound(SrcRodData%M, kind=B8Ki)
      if (.not. allocated(DstRodData%M)) then
         allocate(DstRodData%M(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%M.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%M = SrcRodData%M
   end if
   DstRodData%FextA = SrcRodData%FextA
   DstRodData%FextB = SrcRodData%FextB
   DstRodData%Mext = SrcRodData%Mext
   DstRodData%r6 = SrcRodData%r6
   DstRodData%v6 = SrcRodData%v6
   DstRodData%a6 = SrcRodData%a6
   DstRodData%F6net = SrcRodData%F6net
   DstRodData%M6net = SrcRodData%M6net
   DstRodData%OrMat = SrcRodData%OrMat
   DstRodData%RodUnOut = SrcRodData%RodUnOut
   if (allocated(SrcRodData%RodWrOutput)) then
      LB(1:1) = lbound(SrcRodData%RodWrOutput, kind=B8Ki)
      UB(1:1) = ubound(SrcRodData%RodWrOutput, kind=B8Ki)
      if (.not. allocated(DstRodData%RodWrOutput)) then
         allocate(DstRodData%RodWrOutput(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%RodWrOutput.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstRodData%RodWrOutput = SrcRodData%RodWrOutput
   end if
end subroutine

subroutine MD_DestroyRod(RodData, ErrStat, ErrMsg)
   type(MD_Rod), intent(inout) :: RodData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyRod'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(RodData%r)) then
      deallocate(RodData%r)
   end if
   if (allocated(RodData%rd)) then
      deallocate(RodData%rd)
   end if
   if (allocated(RodData%l)) then
      deallocate(RodData%l)
   end if
   if (allocated(RodData%V)) then
      deallocate(RodData%V)
   end if
   if (allocated(RodData%U)) then
      deallocate(RodData%U)
   end if
   if (allocated(RodData%Ud)) then
      deallocate(RodData%Ud)
   end if
   if (allocated(RodData%zeta)) then
      deallocate(RodData%zeta)
   end if
   if (allocated(RodData%PDyn)) then
      deallocate(RodData%PDyn)
   end if
   if (allocated(RodData%W)) then
      deallocate(RodData%W)
   end if
   if (allocated(RodData%Bo)) then
      deallocate(RodData%Bo)
   end if
   if (allocated(RodData%Pd)) then
      deallocate(RodData%Pd)
   end if
   if (allocated(RodData%Dp)) then
      deallocate(RodData%Dp)
   end if
   if (allocated(RodData%Dq)) then
      deallocate(RodData%Dq)
   end if
   if (allocated(RodData%Ap)) then
      deallocate(RodData%Ap)
   end if
   if (allocated(RodData%Aq)) then
      deallocate(RodData%Aq)
   end if
   if (allocated(RodData%B)) then
      deallocate(RodData%B)
   end if
   if (allocated(RodData%Fnet)) then
      deallocate(RodData%Fnet)
   end if
   if (allocated(RodData%M)) then
      deallocate(RodData%M)
   end if
   if (allocated(RodData%RodWrOutput)) then
      deallocate(RodData%RodWrOutput)
   end if
end subroutine

subroutine MD_PackRod(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_Rod), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackRod'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   call RegPack(RF, InData%type)
   call RegPack(RF, InData%PropsIdNum)
   call RegPack(RF, InData%typeNum)
   call RegPack(RF, InData%AttachedA)
   call RegPack(RF, InData%AttachedB)
   call RegPack(RF, InData%TopA)
   call RegPack(RF, InData%TopB)
   call RegPack(RF, InData%nAttachedA)
   call RegPack(RF, InData%nAttachedB)
   call RegPack(RF, InData%OutFlagList)
   call RegPack(RF, InData%N)
   call RegPack(RF, InData%endTypeA)
   call RegPack(RF, InData%endTypeB)
   call RegPack(RF, InData%UnstrLen)
   call RegPack(RF, InData%mass)
   call RegPack(RF, InData%rho)
   call RegPack(RF, InData%d)
   call RegPack(RF, InData%Can)
   call RegPack(RF, InData%Cat)
   call RegPack(RF, InData%Cdn)
   call RegPack(RF, InData%Cdt)
   call RegPack(RF, InData%CdEnd)
   call RegPack(RF, InData%CaEnd)
   call RegPack(RF, InData%time)
   call RegPack(RF, InData%roll)
   call RegPack(RF, InData%pitch)
   call RegPack(RF, InData%h0)
   call RegPackAlloc(RF, InData%r)
   call RegPackAlloc(RF, InData%rd)
   call RegPack(RF, InData%q)
   call RegPackAlloc(RF, InData%l)
   call RegPackAlloc(RF, InData%V)
   call RegPackAlloc(RF, InData%U)
   call RegPackAlloc(RF, InData%Ud)
   call RegPackAlloc(RF, InData%zeta)
   call RegPackAlloc(RF, InData%PDyn)
   call RegPackAlloc(RF, InData%W)
   call RegPackAlloc(RF, InData%Bo)
   call RegPackAlloc(RF, InData%Pd)
   call RegPackAlloc(RF, InData%Dp)
   call RegPackAlloc(RF, InData%Dq)
   call RegPackAlloc(RF, InData%Ap)
   call RegPackAlloc(RF, InData%Aq)
   call RegPackAlloc(RF, InData%B)
   call RegPackAlloc(RF, InData%Fnet)
   call RegPackAlloc(RF, InData%M)
   call RegPack(RF, InData%FextA)
   call RegPack(RF, InData%FextB)
   call RegPack(RF, InData%Mext)
   call RegPack(RF, InData%r6)
   call RegPack(RF, InData%v6)
   call RegPack(RF, InData%a6)
   call RegPack(RF, InData%F6net)
   call RegPack(RF, InData%M6net)
   call RegPack(RF, InData%OrMat)
   call RegPack(RF, InData%RodUnOut)
   call RegPackAlloc(RF, InData%RodWrOutput)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackRod(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_Rod), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackRod'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%type); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropsIdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%typeNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AttachedA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AttachedB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TopA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%TopB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nAttachedA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nAttachedB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFlagList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%N); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%endTypeA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%endTypeB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnstrLen); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%mass); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rho); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%d); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Can); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CdEnd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CaEnd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%roll); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%pitch); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%h0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%r); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%rd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%q); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%V); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%U); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Ud); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%zeta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PDyn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%W); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Bo); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Pd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Dp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Dq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Ap); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Aq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%B); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Fnet); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%M); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FextA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FextB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Mext); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%r6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%v6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%a6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%F6net); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%M6net); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OrMat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RodUnOut); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RodWrOutput); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyLine(SrcLineData, DstLineData, CtrlCode, ErrStat, ErrMsg)
   type(MD_Line), intent(in) :: SrcLineData
   type(MD_Line), intent(inout) :: DstLineData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(3), UB(3)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MD_CopyLine'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstLineData%IdNum = SrcLineData%IdNum
   DstLineData%PropsIdNum = SrcLineData%PropsIdNum
   DstLineData%ElasticMod = SrcLineData%ElasticMod
   DstLineData%OutFlagList = SrcLineData%OutFlagList
   DstLineData%CtrlChan = SrcLineData%CtrlChan
   DstLineData%FairPoint = SrcLineData%FairPoint
   DstLineData%AnchPoint = SrcLineData%AnchPoint
   DstLineData%N = SrcLineData%N
   DstLineData%endTypeA = SrcLineData%endTypeA
   DstLineData%endTypeB = SrcLineData%endTypeB
   DstLineData%UnstrLen = SrcLineData%UnstrLen
   DstLineData%rho = SrcLineData%rho
   DstLineData%d = SrcLineData%d
   DstLineData%EA = SrcLineData%EA
   DstLineData%EA_D = SrcLineData%EA_D
   DstLineData%BA = SrcLineData%BA
   DstLineData%BA_D = SrcLineData%BA_D
   DstLineData%EI = SrcLineData%EI
   DstLineData%Can = SrcLineData%Can
   DstLineData%Cat = SrcLineData%Cat
   DstLineData%Cdn = SrcLineData%Cdn
   DstLineData%Cdt = SrcLineData%Cdt
   DstLineData%nEApoints = SrcLineData%nEApoints
   DstLineData%stiffXs = SrcLineData%stiffXs
   DstLineData%stiffYs = SrcLineData%stiffYs
   DstLineData%nBApoints = SrcLineData%nBApoints
   DstLineData%dampXs = SrcLineData%dampXs
   DstLineData%dampYs = SrcLineData%dampYs
   DstLineData%nEIpoints = SrcLineData%nEIpoints
   DstLineData%bstiffXs = SrcLineData%bstiffXs
   DstLineData%bstiffYs = SrcLineData%bstiffYs
   DstLineData%time = SrcLineData%time
   if (allocated(SrcLineData%r)) then
      LB(1:2) = lbound(SrcLineData%r, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%r, kind=B8Ki)
      if (.not. allocated(DstLineData%r)) then
         allocate(DstLineData%r(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%r.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%r = SrcLineData%r
   end if
   if (allocated(SrcLineData%rd)) then
      LB(1:2) = lbound(SrcLineData%rd, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%rd, kind=B8Ki)
      if (.not. allocated(DstLineData%rd)) then
         allocate(DstLineData%rd(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%rd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%rd = SrcLineData%rd
   end if
   if (allocated(SrcLineData%q)) then
      LB(1:2) = lbound(SrcLineData%q, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%q, kind=B8Ki)
      if (.not. allocated(DstLineData%q)) then
         allocate(DstLineData%q(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%q.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%q = SrcLineData%q
   end if
   if (allocated(SrcLineData%qs)) then
      LB(1:2) = lbound(SrcLineData%qs, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%qs, kind=B8Ki)
      if (.not. allocated(DstLineData%qs)) then
         allocate(DstLineData%qs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%qs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%qs = SrcLineData%qs
   end if
   if (allocated(SrcLineData%l)) then
      LB(1:1) = lbound(SrcLineData%l, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%l, kind=B8Ki)
      if (.not. allocated(DstLineData%l)) then
         allocate(DstLineData%l(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%l.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%l = SrcLineData%l
   end if
   if (allocated(SrcLineData%ld)) then
      LB(1:1) = lbound(SrcLineData%ld, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%ld, kind=B8Ki)
      if (.not. allocated(DstLineData%ld)) then
         allocate(DstLineData%ld(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%ld.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%ld = SrcLineData%ld
   end if
   if (allocated(SrcLineData%lstr)) then
      LB(1:1) = lbound(SrcLineData%lstr, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%lstr, kind=B8Ki)
      if (.not. allocated(DstLineData%lstr)) then
         allocate(DstLineData%lstr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%lstr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%lstr = SrcLineData%lstr
   end if
   if (allocated(SrcLineData%lstrd)) then
      LB(1:1) = lbound(SrcLineData%lstrd, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%lstrd, kind=B8Ki)
      if (.not. allocated(DstLineData%lstrd)) then
         allocate(DstLineData%lstrd(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%lstrd.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%lstrd = SrcLineData%lstrd
   end if
   if (allocated(SrcLineData%Kurv)) then
      LB(1:1) = lbound(SrcLineData%Kurv, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%Kurv, kind=B8Ki)
      if (.not. allocated(DstLineData%Kurv)) then
         allocate(DstLineData%Kurv(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Kurv.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Kurv = SrcLineData%Kurv
   end if
   if (allocated(SrcLineData%dl_1)) then
      LB(1:1) = lbound(SrcLineData%dl_1, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%dl_1, kind=B8Ki)
      if (.not. allocated(DstLineData%dl_1)) then
         allocate(DstLineData%dl_1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%dl_1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%dl_1 = SrcLineData%dl_1
   end if
   if (allocated(SrcLineData%V)) then
      LB(1:1) = lbound(SrcLineData%V, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%V, kind=B8Ki)
      if (.not. allocated(DstLineData%V)) then
         allocate(DstLineData%V(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%V.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%V = SrcLineData%V
   end if
   if (allocated(SrcLineData%U)) then
      LB(1:2) = lbound(SrcLineData%U, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%U, kind=B8Ki)
      if (.not. allocated(DstLineData%U)) then
         allocate(DstLineData%U(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%U.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%U = SrcLineData%U
   end if
   if (allocated(SrcLineData%Ud)) then
      LB(1:2) = lbound(SrcLineData%Ud, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Ud, kind=B8Ki)
      if (.not. allocated(DstLineData%Ud)) then
         allocate(DstLineData%Ud(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Ud.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Ud = SrcLineData%Ud
   end if
   if (allocated(SrcLineData%zeta)) then
      LB(1:1) = lbound(SrcLineData%zeta, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%zeta, kind=B8Ki)
      if (.not. allocated(DstLineData%zeta)) then
         allocate(DstLineData%zeta(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%zeta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%zeta = SrcLineData%zeta
   end if
   if (allocated(SrcLineData%PDyn)) then
      LB(1:1) = lbound(SrcLineData%PDyn, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%PDyn, kind=B8Ki)
      if (.not. allocated(DstLineData%PDyn)) then
         allocate(DstLineData%PDyn(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%PDyn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%PDyn = SrcLineData%PDyn
   end if
   if (allocated(SrcLineData%T)) then
      LB(1:2) = lbound(SrcLineData%T, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%T, kind=B8Ki)
      if (.not. allocated(DstLineData%T)) then
         allocate(DstLineData%T(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%T.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%T = SrcLineData%T
   end if
   if (allocated(SrcLineData%Td)) then
      LB(1:2) = lbound(SrcLineData%Td, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Td, kind=B8Ki)
      if (.not. allocated(DstLineData%Td)) then
         allocate(DstLineData%Td(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Td.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Td = SrcLineData%Td
   end if
   if (allocated(SrcLineData%W)) then
      LB(1:2) = lbound(SrcLineData%W, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%W, kind=B8Ki)
      if (.not. allocated(DstLineData%W)) then
         allocate(DstLineData%W(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%W.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%W = SrcLineData%W
   end if
   if (allocated(SrcLineData%Dp)) then
      LB(1:2) = lbound(SrcLineData%Dp, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Dp, kind=B8Ki)
      if (.not. allocated(DstLineData%Dp)) then
         allocate(DstLineData%Dp(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Dp.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Dp = SrcLineData%Dp
   end if
   if (allocated(SrcLineData%Dq)) then
      LB(1:2) = lbound(SrcLineData%Dq, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Dq, kind=B8Ki)
      if (.not. allocated(DstLineData%Dq)) then
         allocate(DstLineData%Dq(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Dq.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Dq = SrcLineData%Dq
   end if
   if (allocated(SrcLineData%Ap)) then
      LB(1:2) = lbound(SrcLineData%Ap, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Ap, kind=B8Ki)
      if (.not. allocated(DstLineData%Ap)) then
         allocate(DstLineData%Ap(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Ap.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Ap = SrcLineData%Ap
   end if
   if (allocated(SrcLineData%Aq)) then
      LB(1:2) = lbound(SrcLineData%Aq, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Aq, kind=B8Ki)
      if (.not. allocated(DstLineData%Aq)) then
         allocate(DstLineData%Aq(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Aq.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Aq = SrcLineData%Aq
   end if
   if (allocated(SrcLineData%B)) then
      LB(1:2) = lbound(SrcLineData%B, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%B, kind=B8Ki)
      if (.not. allocated(DstLineData%B)) then
         allocate(DstLineData%B(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%B.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%B = SrcLineData%B
   end if
   if (allocated(SrcLineData%Bs)) then
      LB(1:2) = lbound(SrcLineData%Bs, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Bs, kind=B8Ki)
      if (.not. allocated(DstLineData%Bs)) then
         allocate(DstLineData%Bs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Bs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Bs = SrcLineData%Bs
   end if
   if (allocated(SrcLineData%Fnet)) then
      LB(1:2) = lbound(SrcLineData%Fnet, kind=B8Ki)
      UB(1:2) = ubound(SrcLineData%Fnet, kind=B8Ki)
      if (.not. allocated(DstLineData%Fnet)) then
         allocate(DstLineData%Fnet(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%Fnet.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%Fnet = SrcLineData%Fnet
   end if
   if (allocated(SrcLineData%S)) then
      LB(1:3) = lbound(SrcLineData%S, kind=B8Ki)
      UB(1:3) = ubound(SrcLineData%S, kind=B8Ki)
      if (.not. allocated(DstLineData%S)) then
         allocate(DstLineData%S(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%S.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%S = SrcLineData%S
   end if
   if (allocated(SrcLineData%M)) then
      LB(1:3) = lbound(SrcLineData%M, kind=B8Ki)
      UB(1:3) = ubound(SrcLineData%M, kind=B8Ki)
      if (.not. allocated(DstLineData%M)) then
         allocate(DstLineData%M(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%M.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%M = SrcLineData%M
   end if
   DstLineData%EndMomentA = SrcLineData%EndMomentA
   DstLineData%EndMomentB = SrcLineData%EndMomentB
   DstLineData%LineUnOut = SrcLineData%LineUnOut
   if (allocated(SrcLineData%LineWrOutput)) then
      LB(1:1) = lbound(SrcLineData%LineWrOutput, kind=B8Ki)
      UB(1:1) = ubound(SrcLineData%LineWrOutput, kind=B8Ki)
      if (.not. allocated(DstLineData%LineWrOutput)) then
         allocate(DstLineData%LineWrOutput(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstLineData%LineWrOutput.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstLineData%LineWrOutput = SrcLineData%LineWrOutput
   end if
end subroutine

subroutine MD_DestroyLine(LineData, ErrStat, ErrMsg)
   type(MD_Line), intent(inout) :: LineData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyLine'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(LineData%r)) then
      deallocate(LineData%r)
   end if
   if (allocated(LineData%rd)) then
      deallocate(LineData%rd)
   end if
   if (allocated(LineData%q)) then
      deallocate(LineData%q)
   end if
   if (allocated(LineData%qs)) then
      deallocate(LineData%qs)
   end if
   if (allocated(LineData%l)) then
      deallocate(LineData%l)
   end if
   if (allocated(LineData%ld)) then
      deallocate(LineData%ld)
   end if
   if (allocated(LineData%lstr)) then
      deallocate(LineData%lstr)
   end if
   if (allocated(LineData%lstrd)) then
      deallocate(LineData%lstrd)
   end if
   if (allocated(LineData%Kurv)) then
      deallocate(LineData%Kurv)
   end if
   if (allocated(LineData%dl_1)) then
      deallocate(LineData%dl_1)
   end if
   if (allocated(LineData%V)) then
      deallocate(LineData%V)
   end if
   if (allocated(LineData%U)) then
      deallocate(LineData%U)
   end if
   if (allocated(LineData%Ud)) then
      deallocate(LineData%Ud)
   end if
   if (allocated(LineData%zeta)) then
      deallocate(LineData%zeta)
   end if
   if (allocated(LineData%PDyn)) then
      deallocate(LineData%PDyn)
   end if
   if (allocated(LineData%T)) then
      deallocate(LineData%T)
   end if
   if (allocated(LineData%Td)) then
      deallocate(LineData%Td)
   end if
   if (allocated(LineData%W)) then
      deallocate(LineData%W)
   end if
   if (allocated(LineData%Dp)) then
      deallocate(LineData%Dp)
   end if
   if (allocated(LineData%Dq)) then
      deallocate(LineData%Dq)
   end if
   if (allocated(LineData%Ap)) then
      deallocate(LineData%Ap)
   end if
   if (allocated(LineData%Aq)) then
      deallocate(LineData%Aq)
   end if
   if (allocated(LineData%B)) then
      deallocate(LineData%B)
   end if
   if (allocated(LineData%Bs)) then
      deallocate(LineData%Bs)
   end if
   if (allocated(LineData%Fnet)) then
      deallocate(LineData%Fnet)
   end if
   if (allocated(LineData%S)) then
      deallocate(LineData%S)
   end if
   if (allocated(LineData%M)) then
      deallocate(LineData%M)
   end if
   if (allocated(LineData%LineWrOutput)) then
      deallocate(LineData%LineWrOutput)
   end if
end subroutine

subroutine MD_PackLine(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_Line), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackLine'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   call RegPack(RF, InData%PropsIdNum)
   call RegPack(RF, InData%ElasticMod)
   call RegPack(RF, InData%OutFlagList)
   call RegPack(RF, InData%CtrlChan)
   call RegPack(RF, InData%FairPoint)
   call RegPack(RF, InData%AnchPoint)
   call RegPack(RF, InData%N)
   call RegPack(RF, InData%endTypeA)
   call RegPack(RF, InData%endTypeB)
   call RegPack(RF, InData%UnstrLen)
   call RegPack(RF, InData%rho)
   call RegPack(RF, InData%d)
   call RegPack(RF, InData%EA)
   call RegPack(RF, InData%EA_D)
   call RegPack(RF, InData%BA)
   call RegPack(RF, InData%BA_D)
   call RegPack(RF, InData%EI)
   call RegPack(RF, InData%Can)
   call RegPack(RF, InData%Cat)
   call RegPack(RF, InData%Cdn)
   call RegPack(RF, InData%Cdt)
   call RegPack(RF, InData%nEApoints)
   call RegPack(RF, InData%stiffXs)
   call RegPack(RF, InData%stiffYs)
   call RegPack(RF, InData%nBApoints)
   call RegPack(RF, InData%dampXs)
   call RegPack(RF, InData%dampYs)
   call RegPack(RF, InData%nEIpoints)
   call RegPack(RF, InData%bstiffXs)
   call RegPack(RF, InData%bstiffYs)
   call RegPack(RF, InData%time)
   call RegPackAlloc(RF, InData%r)
   call RegPackAlloc(RF, InData%rd)
   call RegPackAlloc(RF, InData%q)
   call RegPackAlloc(RF, InData%qs)
   call RegPackAlloc(RF, InData%l)
   call RegPackAlloc(RF, InData%ld)
   call RegPackAlloc(RF, InData%lstr)
   call RegPackAlloc(RF, InData%lstrd)
   call RegPackAlloc(RF, InData%Kurv)
   call RegPackAlloc(RF, InData%dl_1)
   call RegPackAlloc(RF, InData%V)
   call RegPackAlloc(RF, InData%U)
   call RegPackAlloc(RF, InData%Ud)
   call RegPackAlloc(RF, InData%zeta)
   call RegPackAlloc(RF, InData%PDyn)
   call RegPackAlloc(RF, InData%T)
   call RegPackAlloc(RF, InData%Td)
   call RegPackAlloc(RF, InData%W)
   call RegPackAlloc(RF, InData%Dp)
   call RegPackAlloc(RF, InData%Dq)
   call RegPackAlloc(RF, InData%Ap)
   call RegPackAlloc(RF, InData%Aq)
   call RegPackAlloc(RF, InData%B)
   call RegPackAlloc(RF, InData%Bs)
   call RegPackAlloc(RF, InData%Fnet)
   call RegPackAlloc(RF, InData%S)
   call RegPackAlloc(RF, InData%M)
   call RegPack(RF, InData%EndMomentA)
   call RegPack(RF, InData%EndMomentB)
   call RegPack(RF, InData%LineUnOut)
   call RegPackAlloc(RF, InData%LineWrOutput)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackLine(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_Line), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackLine'
   integer(B8Ki)   :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PropsIdNum); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ElasticMod); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OutFlagList); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%CtrlChan); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%FairPoint); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%AnchPoint); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%N); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%endTypeA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%endTypeB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnstrLen); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rho); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%d); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EA_D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%BA_D); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EI); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Can); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cat); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Cdt); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nEApoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%stiffXs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%stiffYs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nBApoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dampXs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dampYs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nEIpoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bstiffXs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%bstiffYs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%time); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%r); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%rd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%q); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%qs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%l); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ld); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%lstr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%lstrd); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Kurv); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dl_1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%V); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%U); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Ud); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%zeta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PDyn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%T); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Td); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%W); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Dp); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Dq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Ap); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Aq); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%B); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Bs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Fnet); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%S); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%M); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EndMomentA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%EndMomentB); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LineUnOut); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LineWrOutput); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyFail(SrcFailData, DstFailData, CtrlCode, ErrStat, ErrMsg)
   type(MD_Fail), intent(in) :: SrcFailData
   type(MD_Fail), intent(inout) :: DstFailData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyFail'
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%LineTypeList)) THEN
  i1_l = LBOUND(SrcMiscData%LineTypeList,1)
  i1_u = UBOUND(SrcMiscData%LineTypeList,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineTypeList)) THEN 
    ALLOCATE(DstMiscData%LineTypeList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineTypeList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%LineTypeList,1), UBOUND(SrcMiscData%LineTypeList,1)
      CALL MD_Copylineprop( SrcMiscData%LineTypeList(i1), DstMiscData%LineTypeList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%RodTypeList)) THEN
  i1_l = LBOUND(SrcMiscData%RodTypeList,1)
  i1_u = UBOUND(SrcMiscData%RodTypeList,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodTypeList)) THEN 
    ALLOCATE(DstMiscData%RodTypeList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodTypeList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%RodTypeList,1), UBOUND(SrcMiscData%RodTypeList,1)
      CALL MD_Copyrodprop( SrcMiscData%RodTypeList(i1), DstMiscData%RodTypeList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL MD_Copybody( SrcMiscData%GroundBody, DstMiscData%GroundBody, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMiscData%BodyList)) THEN
  i1_l = LBOUND(SrcMiscData%BodyList,1)
  i1_u = UBOUND(SrcMiscData%BodyList,1)
  IF (.NOT. ALLOCATED(DstMiscData%BodyList)) THEN 
    ALLOCATE(DstMiscData%BodyList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%BodyList,1), UBOUND(SrcMiscData%BodyList,1)
      CALL MD_Copybody( SrcMiscData%BodyList(i1), DstMiscData%BodyList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%RodList)) THEN
  i1_l = LBOUND(SrcMiscData%RodList,1)
  i1_u = UBOUND(SrcMiscData%RodList,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodList)) THEN 
    ALLOCATE(DstMiscData%RodList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%RodList,1), UBOUND(SrcMiscData%RodList,1)
      CALL MD_Copyrod( SrcMiscData%RodList(i1), DstMiscData%RodList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%PointList)) THEN
  i1_l = LBOUND(SrcMiscData%PointList,1)
  i1_u = UBOUND(SrcMiscData%PointList,1)
  IF (.NOT. ALLOCATED(DstMiscData%PointList)) THEN 
    ALLOCATE(DstMiscData%PointList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PointList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%PointList,1), UBOUND(SrcMiscData%PointList,1)
      CALL MD_Copypoint( SrcMiscData%PointList(i1), DstMiscData%PointList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%LineList)) THEN
  i1_l = LBOUND(SrcMiscData%LineList,1)
  i1_u = UBOUND(SrcMiscData%LineList,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineList)) THEN 
    ALLOCATE(DstMiscData%LineList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%LineList,1), UBOUND(SrcMiscData%LineList,1)
      CALL MD_Copyline( SrcMiscData%LineList(i1), DstMiscData%LineList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%FailList)) THEN
  i1_l = LBOUND(SrcMiscData%FailList,1)
  i1_u = UBOUND(SrcMiscData%FailList,1)
  IF (.NOT. ALLOCATED(DstMiscData%FailList)) THEN 
    ALLOCATE(DstMiscData%FailList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FailList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%FailList,1), UBOUND(SrcMiscData%FailList,1)
      CALL MD_Copyfail( SrcMiscData%FailList(i1), DstMiscData%FailList(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%FreePointIs)) THEN
  i1_l = LBOUND(SrcMiscData%FreePointIs,1)
  i1_u = UBOUND(SrcMiscData%FreePointIs,1)
  IF (.NOT. ALLOCATED(DstMiscData%FreePointIs)) THEN 
    ALLOCATE(DstMiscData%FreePointIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreePointIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FreePointIs = SrcMiscData%FreePointIs
ENDIF
IF (ALLOCATED(SrcMiscData%CpldPointIs)) THEN
  i1_l = LBOUND(SrcMiscData%CpldPointIs,1)
  i1_u = UBOUND(SrcMiscData%CpldPointIs,1)
  i2_l = LBOUND(SrcMiscData%CpldPointIs,2)
  i2_u = UBOUND(SrcMiscData%CpldPointIs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CpldPointIs)) THEN 
    ALLOCATE(DstMiscData%CpldPointIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldPointIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CpldPointIs = SrcMiscData%CpldPointIs
ENDIF
IF (ALLOCATED(SrcMiscData%FreeRodIs)) THEN
  i1_l = LBOUND(SrcMiscData%FreeRodIs,1)
  i1_u = UBOUND(SrcMiscData%FreeRodIs,1)
  IF (.NOT. ALLOCATED(DstMiscData%FreeRodIs)) THEN 
    ALLOCATE(DstMiscData%FreeRodIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeRodIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FreeRodIs = SrcMiscData%FreeRodIs
ENDIF
IF (ALLOCATED(SrcMiscData%CpldRodIs)) THEN
  i1_l = LBOUND(SrcMiscData%CpldRodIs,1)
  i1_u = UBOUND(SrcMiscData%CpldRodIs,1)
  i2_l = LBOUND(SrcMiscData%CpldRodIs,2)
  i2_u = UBOUND(SrcMiscData%CpldRodIs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CpldRodIs)) THEN 
    ALLOCATE(DstMiscData%CpldRodIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldRodIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CpldRodIs = SrcMiscData%CpldRodIs
ENDIF
IF (ALLOCATED(SrcMiscData%FreeBodyIs)) THEN
  i1_l = LBOUND(SrcMiscData%FreeBodyIs,1)
  i1_u = UBOUND(SrcMiscData%FreeBodyIs,1)
  IF (.NOT. ALLOCATED(DstMiscData%FreeBodyIs)) THEN 
    ALLOCATE(DstMiscData%FreeBodyIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeBodyIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FreeBodyIs = SrcMiscData%FreeBodyIs
ENDIF
IF (ALLOCATED(SrcMiscData%CpldBodyIs)) THEN
  i1_l = LBOUND(SrcMiscData%CpldBodyIs,1)
  i1_u = UBOUND(SrcMiscData%CpldBodyIs,1)
  i2_l = LBOUND(SrcMiscData%CpldBodyIs,2)
  i2_u = UBOUND(SrcMiscData%CpldBodyIs,2)
  IF (.NOT. ALLOCATED(DstMiscData%CpldBodyIs)) THEN 
    ALLOCATE(DstMiscData%CpldBodyIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldBodyIs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CpldBodyIs = SrcMiscData%CpldBodyIs
ENDIF
IF (ALLOCATED(SrcMiscData%LineStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%LineStateIs1,1)
  i1_u = UBOUND(SrcMiscData%LineStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineStateIs1)) THEN 
    ALLOCATE(DstMiscData%LineStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LineStateIs1 = SrcMiscData%LineStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%LineStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%LineStateIsN,1)
  i1_u = UBOUND(SrcMiscData%LineStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%LineStateIsN)) THEN 
    ALLOCATE(DstMiscData%LineStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LineStateIsN = SrcMiscData%LineStateIsN
ENDIF
IF (ALLOCATED(SrcMiscData%PointStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%PointStateIs1,1)
  i1_u = UBOUND(SrcMiscData%PointStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%PointStateIs1)) THEN 
    ALLOCATE(DstMiscData%PointStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PointStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%PointStateIs1 = SrcMiscData%PointStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%PointStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%PointStateIsN,1)
  i1_u = UBOUND(SrcMiscData%PointStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%PointStateIsN)) THEN 
    ALLOCATE(DstMiscData%PointStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PointStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%PointStateIsN = SrcMiscData%PointStateIsN
ENDIF
IF (ALLOCATED(SrcMiscData%RodStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%RodStateIs1,1)
  i1_u = UBOUND(SrcMiscData%RodStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodStateIs1)) THEN 
    ALLOCATE(DstMiscData%RodStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%RodStateIs1 = SrcMiscData%RodStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%RodStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%RodStateIsN,1)
  i1_u = UBOUND(SrcMiscData%RodStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%RodStateIsN)) THEN 
    ALLOCATE(DstMiscData%RodStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%RodStateIsN = SrcMiscData%RodStateIsN
ENDIF
IF (ALLOCATED(SrcMiscData%BodyStateIs1)) THEN
  i1_l = LBOUND(SrcMiscData%BodyStateIs1,1)
  i1_u = UBOUND(SrcMiscData%BodyStateIs1,1)
  IF (.NOT. ALLOCATED(DstMiscData%BodyStateIs1)) THEN 
    ALLOCATE(DstMiscData%BodyStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyStateIs1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BodyStateIs1 = SrcMiscData%BodyStateIs1
ENDIF
IF (ALLOCATED(SrcMiscData%BodyStateIsN)) THEN
  i1_l = LBOUND(SrcMiscData%BodyStateIsN,1)
  i1_u = UBOUND(SrcMiscData%BodyStateIsN,1)
  IF (.NOT. ALLOCATED(DstMiscData%BodyStateIsN)) THEN 
    ALLOCATE(DstMiscData%BodyStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyStateIsN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BodyStateIsN = SrcMiscData%BodyStateIsN
ENDIF
    DstMiscData%Nx = SrcMiscData%Nx
    DstMiscData%Nxtra = SrcMiscData%Nxtra
    DstMiscData%WaveTi = SrcMiscData%WaveTi
      CALL MD_CopyContState( SrcMiscData%xTemp, DstMiscData%xTemp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MD_CopyContState( SrcMiscData%xdTemp, DstMiscData%xdTemp, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%zeros6 = SrcMiscData%zeros6
IF (ALLOCATED(SrcMiscData%MDWrOutput)) THEN
  i1_l = LBOUND(SrcMiscData%MDWrOutput,1)
  i1_u = UBOUND(SrcMiscData%MDWrOutput,1)
  IF (.NOT. ALLOCATED(DstMiscData%MDWrOutput)) THEN 
    ALLOCATE(DstMiscData%MDWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%MDWrOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%MDWrOutput = SrcMiscData%MDWrOutput
ENDIF
    DstMiscData%LastOutTime = SrcMiscData%LastOutTime
    DstMiscData%PtfmInit = SrcMiscData%PtfmInit
IF (ALLOCATED(SrcMiscData%BathymetryGrid)) THEN
  i1_l = LBOUND(SrcMiscData%BathymetryGrid,1)
  i1_u = UBOUND(SrcMiscData%BathymetryGrid,1)
  i2_l = LBOUND(SrcMiscData%BathymetryGrid,2)
  i2_u = UBOUND(SrcMiscData%BathymetryGrid,2)
  IF (.NOT. ALLOCATED(DstMiscData%BathymetryGrid)) THEN 
    ALLOCATE(DstMiscData%BathymetryGrid(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathymetryGrid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathymetryGrid = SrcMiscData%BathymetryGrid
ENDIF
IF (ALLOCATED(SrcMiscData%BathGrid_Xs)) THEN
  i1_l = LBOUND(SrcMiscData%BathGrid_Xs,1)
  i1_u = UBOUND(SrcMiscData%BathGrid_Xs,1)
  IF (.NOT. ALLOCATED(DstMiscData%BathGrid_Xs)) THEN 
    ALLOCATE(DstMiscData%BathGrid_Xs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_Xs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathGrid_Xs = SrcMiscData%BathGrid_Xs
ENDIF
IF (ALLOCATED(SrcMiscData%BathGrid_Ys)) THEN
  i1_l = LBOUND(SrcMiscData%BathGrid_Ys,1)
  i1_u = UBOUND(SrcMiscData%BathGrid_Ys,1)
  IF (.NOT. ALLOCATED(DstMiscData%BathGrid_Ys)) THEN 
    ALLOCATE(DstMiscData%BathGrid_Ys(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_Ys.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathGrid_Ys = SrcMiscData%BathGrid_Ys
ENDIF
IF (ALLOCATED(SrcMiscData%BathGrid_npoints)) THEN
  i1_l = LBOUND(SrcMiscData%BathGrid_npoints,1)
  i1_u = UBOUND(SrcMiscData%BathGrid_npoints,1)
  IF (.NOT. ALLOCATED(DstMiscData%BathGrid_npoints)) THEN 
    ALLOCATE(DstMiscData%BathGrid_npoints(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_npoints.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BathGrid_npoints = SrcMiscData%BathGrid_npoints
ENDIF
 END SUBROUTINE MD_CopyMisc

 SUBROUTINE MD_DestroyMisc( MiscData, ErrStat, ErrMsg, DEALLOCATEpointers )
  TYPE(MD_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL,INTENT(IN   ) :: DEALLOCATEpointers
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  LOGICAL                        :: DEALLOCATEpointers_local
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  IF (PRESENT(DEALLOCATEpointers)) THEN
     DEALLOCATEpointers_local = DEALLOCATEpointers
  ELSE
     DEALLOCATEpointers_local = .true.
  END IF
  
IF (ALLOCATED(MiscData%LineTypeList)) THEN
DO i1 = LBOUND(MiscData%LineTypeList,1), UBOUND(MiscData%LineTypeList,1)
  CALL MD_Destroylineprop( MiscData%LineTypeList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%LineTypeList)
ENDIF
IF (ALLOCATED(MiscData%RodTypeList)) THEN
DO i1 = LBOUND(MiscData%RodTypeList,1), UBOUND(MiscData%RodTypeList,1)
  CALL MD_Destroyrodprop( MiscData%RodTypeList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%RodTypeList)
ENDIF
  CALL MD_Destroybody( MiscData%GroundBody, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%BodyList)) THEN
DO i1 = LBOUND(MiscData%BodyList,1), UBOUND(MiscData%BodyList,1)
  CALL MD_Destroybody( MiscData%BodyList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%BodyList)
ENDIF
IF (ALLOCATED(MiscData%RodList)) THEN
DO i1 = LBOUND(MiscData%RodList,1), UBOUND(MiscData%RodList,1)
  CALL MD_Destroyrod( MiscData%RodList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%RodList)
ENDIF
IF (ALLOCATED(MiscData%PointList)) THEN
DO i1 = LBOUND(MiscData%PointList,1), UBOUND(MiscData%PointList,1)
  CALL MD_Destroypoint( MiscData%PointList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%PointList)
ENDIF
IF (ALLOCATED(MiscData%LineList)) THEN
DO i1 = LBOUND(MiscData%LineList,1), UBOUND(MiscData%LineList,1)
  CALL MD_Destroyline( MiscData%LineList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%LineList)
ENDIF
IF (ALLOCATED(MiscData%FailList)) THEN
DO i1 = LBOUND(MiscData%FailList,1), UBOUND(MiscData%FailList,1)
  CALL MD_Destroyfail( MiscData%FailList(i1), ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%FailList)
ENDIF
IF (ALLOCATED(MiscData%FreePointIs)) THEN
  DEALLOCATE(MiscData%FreePointIs)
ENDIF
IF (ALLOCATED(MiscData%CpldPointIs)) THEN
  DEALLOCATE(MiscData%CpldPointIs)
ENDIF
IF (ALLOCATED(MiscData%FreeRodIs)) THEN
  DEALLOCATE(MiscData%FreeRodIs)
ENDIF
IF (ALLOCATED(MiscData%CpldRodIs)) THEN
  DEALLOCATE(MiscData%CpldRodIs)
ENDIF
IF (ALLOCATED(MiscData%FreeBodyIs)) THEN
  DEALLOCATE(MiscData%FreeBodyIs)
ENDIF
IF (ALLOCATED(MiscData%CpldBodyIs)) THEN
  DEALLOCATE(MiscData%CpldBodyIs)
ENDIF
IF (ALLOCATED(MiscData%LineStateIs1)) THEN
  DEALLOCATE(MiscData%LineStateIs1)
ENDIF
IF (ALLOCATED(MiscData%LineStateIsN)) THEN
  DEALLOCATE(MiscData%LineStateIsN)
ENDIF
IF (ALLOCATED(MiscData%PointStateIs1)) THEN
  DEALLOCATE(MiscData%PointStateIs1)
ENDIF
IF (ALLOCATED(MiscData%PointStateIsN)) THEN
  DEALLOCATE(MiscData%PointStateIsN)
ENDIF
IF (ALLOCATED(MiscData%RodStateIs1)) THEN
  DEALLOCATE(MiscData%RodStateIs1)
ENDIF
IF (ALLOCATED(MiscData%RodStateIsN)) THEN
  DEALLOCATE(MiscData%RodStateIsN)
ENDIF
IF (ALLOCATED(MiscData%BodyStateIs1)) THEN
  DEALLOCATE(MiscData%BodyStateIs1)
ENDIF
IF (ALLOCATED(MiscData%BodyStateIsN)) THEN
  DEALLOCATE(MiscData%BodyStateIsN)
ENDIF
  CALL MD_DestroyContState( MiscData%xTemp, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MD_DestroyContState( MiscData%xdTemp, ErrStat2, ErrMsg2, DEALLOCATEpointers_local )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%MDWrOutput)) THEN
  DEALLOCATE(MiscData%MDWrOutput)
ENDIF
IF (ALLOCATED(MiscData%BathymetryGrid)) THEN
  DEALLOCATE(MiscData%BathymetryGrid)
ENDIF
IF (ALLOCATED(MiscData%BathGrid_Xs)) THEN
  DEALLOCATE(MiscData%BathGrid_Xs)
ENDIF
IF (ALLOCATED(MiscData%BathGrid_Ys)) THEN
  DEALLOCATE(MiscData%BathGrid_Ys)
ENDIF
IF (ALLOCATED(MiscData%BathGrid_npoints)) THEN
  DEALLOCATE(MiscData%BathGrid_npoints)
ENDIF
 END SUBROUTINE MD_DestroyMisc

 SUBROUTINE MD_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! LineTypeList allocated yes/no
  IF ( ALLOCATED(InData%LineTypeList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! LineTypeList upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%LineTypeList,1), UBOUND(InData%LineTypeList,1)
      Int_BufSz   = Int_BufSz + 3  ! LineTypeList: size of buffers for each call to pack subtype
      CALL MD_Packlineprop( Re_Buf, Db_Buf, Int_Buf, InData%LineTypeList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! LineTypeList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! LineTypeList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! LineTypeList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! LineTypeList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RodTypeList allocated yes/no
  IF ( ALLOCATED(InData%RodTypeList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RodTypeList upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%RodTypeList,1), UBOUND(InData%RodTypeList,1)
      Int_BufSz   = Int_BufSz + 3  ! RodTypeList: size of buffers for each call to pack subtype
      CALL MD_Packrodprop( Re_Buf, Db_Buf, Int_Buf, InData%RodTypeList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! RodTypeList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! RodTypeList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! RodTypeList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! RodTypeList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
      Int_BufSz   = Int_BufSz + 3  ! GroundBody: size of buffers for each call to pack subtype
      CALL MD_Packbody( Re_Buf, Db_Buf, Int_Buf, InData%GroundBody, ErrStat2, ErrMsg2, .TRUE. ) ! GroundBody 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! GroundBody
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! GroundBody
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! GroundBody
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  Int_BufSz   = Int_BufSz   + 1     ! BodyList allocated yes/no
  IF ( ALLOCATED(InData%BodyList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BodyList upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%BodyList,1), UBOUND(InData%BodyList,1)
      Int_BufSz   = Int_BufSz + 3  ! BodyList: size of buffers for each call to pack subtype
      CALL MD_Packbody( Re_Buf, Db_Buf, Int_Buf, InData%BodyList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! BodyList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! BodyList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! BodyList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! BodyList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RodList allocated yes/no
  IF ( ALLOCATED(InData%RodList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RodList upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%RodList,1), UBOUND(InData%RodList,1)
      Int_BufSz   = Int_BufSz + 3  ! RodList: size of buffers for each call to pack subtype
      CALL MD_Packrod( Re_Buf, Db_Buf, Int_Buf, InData%RodList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! RodList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! RodList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! RodList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! RodList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PointList allocated yes/no
  IF ( ALLOCATED(InData%PointList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PointList upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%PointList,1), UBOUND(InData%PointList,1)
      Int_BufSz   = Int_BufSz + 3  ! PointList: size of buffers for each call to pack subtype
      CALL MD_Packpoint( Re_Buf, Db_Buf, Int_Buf, InData%PointList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! PointList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! PointList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! PointList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! PointList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! LineList allocated yes/no
  IF ( ALLOCATED(InData%LineList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! LineList upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%LineList,1), UBOUND(InData%LineList,1)
      Int_BufSz   = Int_BufSz + 3  ! LineList: size of buffers for each call to pack subtype
      CALL MD_Packline( Re_Buf, Db_Buf, Int_Buf, InData%LineList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! LineList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! LineList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! LineList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! LineList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FailList allocated yes/no
  IF ( ALLOCATED(InData%FailList) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FailList upper/lower bounds for each dimension
    DO i1 = LBOUND(InData%FailList,1), UBOUND(InData%FailList,1)
      Int_BufSz   = Int_BufSz + 3  ! FailList: size of buffers for each call to pack subtype
      CALL MD_Packfail( Re_Buf, Db_Buf, Int_Buf, InData%FailList(i1), ErrStat2, ErrMsg2, .TRUE. ) ! FailList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! FailList
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! FailList
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! FailList
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FreePointIs allocated yes/no
  IF ( ALLOCATED(InData%FreePointIs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FreePointIs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%FreePointIs)  ! FreePointIs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CpldPointIs allocated yes/no
  IF ( ALLOCATED(InData%CpldPointIs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CpldPointIs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%CpldPointIs)  ! CpldPointIs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FreeRodIs allocated yes/no
  IF ( ALLOCATED(InData%FreeRodIs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FreeRodIs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%FreeRodIs)  ! FreeRodIs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CpldRodIs allocated yes/no
  IF ( ALLOCATED(InData%CpldRodIs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CpldRodIs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%CpldRodIs)  ! CpldRodIs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! FreeBodyIs allocated yes/no
  IF ( ALLOCATED(InData%FreeBodyIs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! FreeBodyIs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%FreeBodyIs)  ! FreeBodyIs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CpldBodyIs allocated yes/no
  IF ( ALLOCATED(InData%CpldBodyIs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! CpldBodyIs upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%CpldBodyIs)  ! CpldBodyIs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! LineStateIs1 allocated yes/no
  IF ( ALLOCATED(InData%LineStateIs1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! LineStateIs1 upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%LineStateIs1)  ! LineStateIs1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! LineStateIsN allocated yes/no
  IF ( ALLOCATED(InData%LineStateIsN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! LineStateIsN upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%LineStateIsN)  ! LineStateIsN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PointStateIs1 allocated yes/no
  IF ( ALLOCATED(InData%PointStateIs1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PointStateIs1 upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%PointStateIs1)  ! PointStateIs1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PointStateIsN allocated yes/no
  IF ( ALLOCATED(InData%PointStateIsN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PointStateIsN upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%PointStateIsN)  ! PointStateIsN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RodStateIs1 allocated yes/no
  IF ( ALLOCATED(InData%RodStateIs1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RodStateIs1 upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%RodStateIs1)  ! RodStateIs1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RodStateIsN allocated yes/no
  IF ( ALLOCATED(InData%RodStateIsN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RodStateIsN upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%RodStateIsN)  ! RodStateIsN
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BodyStateIs1 allocated yes/no
  IF ( ALLOCATED(InData%BodyStateIs1) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BodyStateIs1 upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BodyStateIs1)  ! BodyStateIs1
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BodyStateIsN allocated yes/no
  IF ( ALLOCATED(InData%BodyStateIsN) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BodyStateIsN upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BodyStateIsN)  ! BodyStateIsN
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! Nx
      Int_BufSz  = Int_BufSz  + 1  ! Nxtra
      Int_BufSz  = Int_BufSz  + 1  ! WaveTi
      Int_BufSz   = Int_BufSz + 3  ! xTemp: size of buffers for each call to pack subtype
      CALL MD_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%xTemp, ErrStat2, ErrMsg2, .TRUE. ) ! xTemp 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! xTemp
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! xTemp
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! xTemp
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Int_BufSz   = Int_BufSz + 3  ! xdTemp: size of buffers for each call to pack subtype
      CALL MD_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%xdTemp, ErrStat2, ErrMsg2, .TRUE. ) ! xdTemp 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! xdTemp
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! xdTemp
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! xdTemp
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
      Db_BufSz   = Db_BufSz   + SIZE(InData%zeros6)  ! zeros6
  Int_BufSz   = Int_BufSz   + 1     ! MDWrOutput allocated yes/no
  IF ( ALLOCATED(InData%MDWrOutput) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! MDWrOutput upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%MDWrOutput)  ! MDWrOutput
  END IF
      Db_BufSz   = Db_BufSz   + 1  ! LastOutTime
      Re_BufSz   = Re_BufSz   + SIZE(InData%PtfmInit)  ! PtfmInit
  Int_BufSz   = Int_BufSz   + 1     ! BathymetryGrid allocated yes/no
  IF ( ALLOCATED(InData%BathymetryGrid) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BathymetryGrid upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%BathymetryGrid)  ! BathymetryGrid
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BathGrid_Xs allocated yes/no
  IF ( ALLOCATED(InData%BathGrid_Xs) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BathGrid_Xs upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%BathGrid_Xs)  ! BathGrid_Xs
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BathGrid_Ys allocated yes/no
  IF ( ALLOCATED(InData%BathGrid_Ys) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BathGrid_Ys upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%BathGrid_Ys)  ! BathGrid_Ys
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BathGrid_npoints allocated yes/no
  IF ( ALLOCATED(InData%BathGrid_npoints) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BathGrid_npoints upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BathGrid_npoints)  ! BathGrid_npoints
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%LineTypeList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LineTypeList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LineTypeList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%LineTypeList,1), UBOUND(InData%LineTypeList,1)
      CALL MD_Packlineprop( Re_Buf, Db_Buf, Int_Buf, InData%LineTypeList(i1), ErrStat2, ErrMsg2, OnlySize ) ! LineTypeList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RodTypeList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RodTypeList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RodTypeList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%RodTypeList,1), UBOUND(InData%RodTypeList,1)
      CALL MD_Packrodprop( Re_Buf, Db_Buf, Int_Buf, InData%RodTypeList(i1), ErrStat2, ErrMsg2, OnlySize ) ! RodTypeList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
      CALL MD_Packbody( Re_Buf, Db_Buf, Int_Buf, InData%GroundBody, ErrStat2, ErrMsg2, OnlySize ) ! GroundBody 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
  IF ( .NOT. ALLOCATED(InData%BodyList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BodyList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BodyList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%BodyList,1), UBOUND(InData%BodyList,1)
      CALL MD_Packbody( Re_Buf, Db_Buf, Int_Buf, InData%BodyList(i1), ErrStat2, ErrMsg2, OnlySize ) ! BodyList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RodList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RodList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RodList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%RodList,1), UBOUND(InData%RodList,1)
      CALL MD_Packrod( Re_Buf, Db_Buf, Int_Buf, InData%RodList(i1), ErrStat2, ErrMsg2, OnlySize ) ! RodList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%PointList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PointList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PointList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%PointList,1), UBOUND(InData%PointList,1)
      CALL MD_Packpoint( Re_Buf, Db_Buf, Int_Buf, InData%PointList(i1), ErrStat2, ErrMsg2, OnlySize ) ! PointList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%LineList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LineList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LineList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%LineList,1), UBOUND(InData%LineList,1)
      CALL MD_Packline( Re_Buf, Db_Buf, Int_Buf, InData%LineList(i1), ErrStat2, ErrMsg2, OnlySize ) ! LineList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%FailList) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FailList,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FailList,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%FailList,1), UBOUND(InData%FailList,1)
      CALL MD_Packfail( Re_Buf, Db_Buf, Int_Buf, InData%FailList(i1), ErrStat2, ErrMsg2, OnlySize ) ! FailList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%FreePointIs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FreePointIs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FreePointIs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%FreePointIs,1), UBOUND(InData%FreePointIs,1)
        IntKiBuf(Int_Xferred) = InData%FreePointIs(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CpldPointIs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CpldPointIs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CpldPointIs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CpldPointIs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CpldPointIs,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%CpldPointIs,2), UBOUND(InData%CpldPointIs,2)
        DO i1 = LBOUND(InData%CpldPointIs,1), UBOUND(InData%CpldPointIs,1)
          IntKiBuf(Int_Xferred) = InData%CpldPointIs(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%FreeRodIs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FreeRodIs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FreeRodIs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%FreeRodIs,1), UBOUND(InData%FreeRodIs,1)
        IntKiBuf(Int_Xferred) = InData%FreeRodIs(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CpldRodIs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CpldRodIs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CpldRodIs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CpldRodIs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CpldRodIs,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%CpldRodIs,2), UBOUND(InData%CpldRodIs,2)
        DO i1 = LBOUND(InData%CpldRodIs,1), UBOUND(InData%CpldRodIs,1)
          IntKiBuf(Int_Xferred) = InData%CpldRodIs(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%FreeBodyIs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%FreeBodyIs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%FreeBodyIs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%FreeBodyIs,1), UBOUND(InData%FreeBodyIs,1)
        IntKiBuf(Int_Xferred) = InData%FreeBodyIs(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%CpldBodyIs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CpldBodyIs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CpldBodyIs,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CpldBodyIs,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CpldBodyIs,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%CpldBodyIs,2), UBOUND(InData%CpldBodyIs,2)
        DO i1 = LBOUND(InData%CpldBodyIs,1), UBOUND(InData%CpldBodyIs,1)
          IntKiBuf(Int_Xferred) = InData%CpldBodyIs(i1,i2)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%LineStateIs1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LineStateIs1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LineStateIs1,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%LineStateIs1,1), UBOUND(InData%LineStateIs1,1)
        IntKiBuf(Int_Xferred) = InData%LineStateIs1(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%LineStateIsN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LineStateIsN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LineStateIsN,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%LineStateIsN,1), UBOUND(InData%LineStateIsN,1)
        IntKiBuf(Int_Xferred) = InData%LineStateIsN(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%PointStateIs1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PointStateIs1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PointStateIs1,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%PointStateIs1,1), UBOUND(InData%PointStateIs1,1)
        IntKiBuf(Int_Xferred) = InData%PointStateIs1(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%PointStateIsN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PointStateIsN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PointStateIsN,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%PointStateIsN,1), UBOUND(InData%PointStateIsN,1)
        IntKiBuf(Int_Xferred) = InData%PointStateIsN(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RodStateIs1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RodStateIs1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RodStateIs1,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RodStateIs1,1), UBOUND(InData%RodStateIs1,1)
        IntKiBuf(Int_Xferred) = InData%RodStateIs1(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RodStateIsN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RodStateIsN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RodStateIsN,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RodStateIsN,1), UBOUND(InData%RodStateIsN,1)
        IntKiBuf(Int_Xferred) = InData%RodStateIsN(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BodyStateIs1) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BodyStateIs1,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BodyStateIs1,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BodyStateIs1,1), UBOUND(InData%BodyStateIs1,1)
        IntKiBuf(Int_Xferred) = InData%BodyStateIs1(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BodyStateIsN) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BodyStateIsN,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BodyStateIsN,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BodyStateIsN,1), UBOUND(InData%BodyStateIsN,1)
        IntKiBuf(Int_Xferred) = InData%BodyStateIsN(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    IntKiBuf(Int_Xferred) = InData%Nx
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%Nxtra
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%WaveTi
    Int_Xferred = Int_Xferred + 1
      CALL MD_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%xTemp, ErrStat2, ErrMsg2, OnlySize ) ! xTemp 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      CALL MD_PackContState( Re_Buf, Db_Buf, Int_Buf, InData%xdTemp, ErrStat2, ErrMsg2, OnlySize ) ! xdTemp 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    DO i1 = LBOUND(InData%zeros6,1), UBOUND(InData%zeros6,1)
      DbKiBuf(Db_Xferred) = InData%zeros6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
  IF ( .NOT. ALLOCATED(InData%MDWrOutput) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%MDWrOutput,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%MDWrOutput,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%MDWrOutput,1), UBOUND(InData%MDWrOutput,1)
        DbKiBuf(Db_Xferred) = InData%MDWrOutput(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
    DbKiBuf(Db_Xferred) = InData%LastOutTime
    Db_Xferred = Db_Xferred + 1
    DO i1 = LBOUND(InData%PtfmInit,1), UBOUND(InData%PtfmInit,1)
      ReKiBuf(Re_Xferred) = InData%PtfmInit(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
  IF ( .NOT. ALLOCATED(InData%BathymetryGrid) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BathymetryGrid,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BathymetryGrid,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BathymetryGrid,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BathymetryGrid,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%BathymetryGrid,2), UBOUND(InData%BathymetryGrid,2)
        DO i1 = LBOUND(InData%BathymetryGrid,1), UBOUND(InData%BathymetryGrid,1)
          DbKiBuf(Db_Xferred) = InData%BathymetryGrid(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BathGrid_Xs) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BathGrid_Xs,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BathGrid_Xs,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BathGrid_Xs,1), UBOUND(InData%BathGrid_Xs,1)
        DbKiBuf(Db_Xferred) = InData%BathGrid_Xs(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BathGrid_Ys) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BathGrid_Ys,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BathGrid_Ys,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BathGrid_Ys,1), UBOUND(InData%BathGrid_Ys,1)
        DbKiBuf(Db_Xferred) = InData%BathGrid_Ys(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%BathGrid_npoints) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BathGrid_npoints,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BathGrid_npoints,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%BathGrid_npoints,1), UBOUND(InData%BathGrid_npoints,1)
        IntKiBuf(Int_Xferred) = InData%BathGrid_npoints(i1)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_PackMisc

 SUBROUTINE MD_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LineTypeList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LineTypeList)) DEALLOCATE(OutData%LineTypeList)
    ALLOCATE(OutData%LineTypeList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineTypeList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%LineTypeList,1), UBOUND(OutData%LineTypeList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpacklineprop( Re_Buf, Db_Buf, Int_Buf, OutData%LineTypeList(i1), ErrStat2, ErrMsg2 ) ! LineTypeList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RodTypeList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RodTypeList)) DEALLOCATE(OutData%RodTypeList)
    ALLOCATE(OutData%RodTypeList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodTypeList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%RodTypeList,1), UBOUND(OutData%RodTypeList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackrodprop( Re_Buf, Db_Buf, Int_Buf, OutData%RodTypeList(i1), ErrStat2, ErrMsg2 ) ! RodTypeList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackbody( Re_Buf, Db_Buf, Int_Buf, OutData%GroundBody, ErrStat2, ErrMsg2 ) ! GroundBody 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BodyList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BodyList)) DEALLOCATE(OutData%BodyList)
    ALLOCATE(OutData%BodyList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%BodyList,1), UBOUND(OutData%BodyList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackbody( Re_Buf, Db_Buf, Int_Buf, OutData%BodyList(i1), ErrStat2, ErrMsg2 ) ! BodyList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RodList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RodList)) DEALLOCATE(OutData%RodList)
    ALLOCATE(OutData%RodList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%RodList,1), UBOUND(OutData%RodList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackrod( Re_Buf, Db_Buf, Int_Buf, OutData%RodList(i1), ErrStat2, ErrMsg2 ) ! RodList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PointList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PointList)) DEALLOCATE(OutData%PointList)
    ALLOCATE(OutData%PointList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PointList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%PointList,1), UBOUND(OutData%PointList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackpoint( Re_Buf, Db_Buf, Int_Buf, OutData%PointList(i1), ErrStat2, ErrMsg2 ) ! PointList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LineList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LineList)) DEALLOCATE(OutData%LineList)
    ALLOCATE(OutData%LineList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%LineList,1), UBOUND(OutData%LineList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackline( Re_Buf, Db_Buf, Int_Buf, OutData%LineList(i1), ErrStat2, ErrMsg2 ) ! LineList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FailList not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FailList)) DEALLOCATE(OutData%FailList)
    ALLOCATE(OutData%FailList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FailList.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%FailList,1), UBOUND(OutData%FailList,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_Unpackfail( Re_Buf, Db_Buf, Int_Buf, OutData%FailList(i1), ErrStat2, ErrMsg2 ) ! FailList 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FreePointIs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FreePointIs)) DEALLOCATE(OutData%FreePointIs)
    ALLOCATE(OutData%FreePointIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FreePointIs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%FreePointIs,1), UBOUND(OutData%FreePointIs,1)
        OutData%FreePointIs(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CpldPointIs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CpldPointIs)) DEALLOCATE(OutData%CpldPointIs)
    ALLOCATE(OutData%CpldPointIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CpldPointIs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%CpldPointIs,2), UBOUND(OutData%CpldPointIs,2)
        DO i1 = LBOUND(OutData%CpldPointIs,1), UBOUND(OutData%CpldPointIs,1)
          OutData%CpldPointIs(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FreeRodIs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FreeRodIs)) DEALLOCATE(OutData%FreeRodIs)
    ALLOCATE(OutData%FreeRodIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FreeRodIs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%FreeRodIs,1), UBOUND(OutData%FreeRodIs,1)
        OutData%FreeRodIs(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CpldRodIs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CpldRodIs)) DEALLOCATE(OutData%CpldRodIs)
    ALLOCATE(OutData%CpldRodIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CpldRodIs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%CpldRodIs,2), UBOUND(OutData%CpldRodIs,2)
        DO i1 = LBOUND(OutData%CpldRodIs,1), UBOUND(OutData%CpldRodIs,1)
          OutData%CpldRodIs(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! FreeBodyIs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%FreeBodyIs)) DEALLOCATE(OutData%FreeBodyIs)
    ALLOCATE(OutData%FreeBodyIs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%FreeBodyIs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%FreeBodyIs,1), UBOUND(OutData%FreeBodyIs,1)
        OutData%FreeBodyIs(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CpldBodyIs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CpldBodyIs)) DEALLOCATE(OutData%CpldBodyIs)
    ALLOCATE(OutData%CpldBodyIs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CpldBodyIs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%CpldBodyIs,2), UBOUND(OutData%CpldBodyIs,2)
        DO i1 = LBOUND(OutData%CpldBodyIs,1), UBOUND(OutData%CpldBodyIs,1)
          OutData%CpldBodyIs(i1,i2) = IntKiBuf(Int_Xferred)
          Int_Xferred = Int_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LineStateIs1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LineStateIs1)) DEALLOCATE(OutData%LineStateIs1)
    ALLOCATE(OutData%LineStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineStateIs1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%LineStateIs1,1), UBOUND(OutData%LineStateIs1,1)
        OutData%LineStateIs1(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LineStateIsN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LineStateIsN)) DEALLOCATE(OutData%LineStateIsN)
    ALLOCATE(OutData%LineStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineStateIsN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%LineStateIsN,1), UBOUND(OutData%LineStateIsN,1)
        OutData%LineStateIsN(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PointStateIs1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PointStateIs1)) DEALLOCATE(OutData%PointStateIs1)
    ALLOCATE(OutData%PointStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PointStateIs1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%PointStateIs1,1), UBOUND(OutData%PointStateIs1,1)
        OutData%PointStateIs1(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PointStateIsN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PointStateIsN)) DEALLOCATE(OutData%PointStateIsN)
    ALLOCATE(OutData%PointStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PointStateIsN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%PointStateIsN,1), UBOUND(OutData%PointStateIsN,1)
        OutData%PointStateIsN(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RodStateIs1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RodStateIs1)) DEALLOCATE(OutData%RodStateIs1)
    ALLOCATE(OutData%RodStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodStateIs1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RodStateIs1,1), UBOUND(OutData%RodStateIs1,1)
        OutData%RodStateIs1(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RodStateIsN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RodStateIsN)) DEALLOCATE(OutData%RodStateIsN)
    ALLOCATE(OutData%RodStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodStateIsN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RodStateIsN,1), UBOUND(OutData%RodStateIsN,1)
        OutData%RodStateIsN(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BodyStateIs1 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BodyStateIs1)) DEALLOCATE(OutData%BodyStateIs1)
    ALLOCATE(OutData%BodyStateIs1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyStateIs1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BodyStateIs1,1), UBOUND(OutData%BodyStateIs1,1)
        OutData%BodyStateIs1(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BodyStateIsN not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BodyStateIsN)) DEALLOCATE(OutData%BodyStateIsN)
    ALLOCATE(OutData%BodyStateIsN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyStateIsN.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BodyStateIsN,1), UBOUND(OutData%BodyStateIsN,1)
        OutData%BodyStateIsN(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
    OutData%Nx = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%Nxtra = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%WaveTi = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_UnpackContState( Re_Buf, Db_Buf, Int_Buf, OutData%xTemp, ErrStat2, ErrMsg2 ) ! xTemp 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MD_UnpackContState( Re_Buf, Db_Buf, Int_Buf, OutData%xdTemp, ErrStat2, ErrMsg2 ) ! xdTemp 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    i1_l = LBOUND(OutData%zeros6,1)
    i1_u = UBOUND(OutData%zeros6,1)
    DO i1 = LBOUND(OutData%zeros6,1), UBOUND(OutData%zeros6,1)
      OutData%zeros6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! MDWrOutput not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%MDWrOutput)) DEALLOCATE(OutData%MDWrOutput)
    ALLOCATE(OutData%MDWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%MDWrOutput.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%MDWrOutput,1), UBOUND(OutData%MDWrOutput,1)
        OutData%MDWrOutput(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
    OutData%LastOutTime = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    i1_l = LBOUND(OutData%PtfmInit,1)
    i1_u = UBOUND(OutData%PtfmInit,1)
    DO i1 = LBOUND(OutData%PtfmInit,1), UBOUND(OutData%PtfmInit,1)
      OutData%PtfmInit(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BathymetryGrid not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BathymetryGrid)) DEALLOCATE(OutData%BathymetryGrid)
    ALLOCATE(OutData%BathymetryGrid(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathymetryGrid.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%BathymetryGrid,2), UBOUND(OutData%BathymetryGrid,2)
        DO i1 = LBOUND(OutData%BathymetryGrid,1), UBOUND(OutData%BathymetryGrid,1)
          OutData%BathymetryGrid(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BathGrid_Xs not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BathGrid_Xs)) DEALLOCATE(OutData%BathGrid_Xs)
    ALLOCATE(OutData%BathGrid_Xs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathGrid_Xs.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BathGrid_Xs,1), UBOUND(OutData%BathGrid_Xs,1)
        OutData%BathGrid_Xs(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BathGrid_Ys not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BathGrid_Ys)) DEALLOCATE(OutData%BathGrid_Ys)
    ALLOCATE(OutData%BathGrid_Ys(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathGrid_Ys.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BathGrid_Ys,1), UBOUND(OutData%BathGrid_Ys,1)
        OutData%BathGrid_Ys(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BathGrid_npoints not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BathGrid_npoints)) DEALLOCATE(OutData%BathGrid_npoints)
    ALLOCATE(OutData%BathGrid_npoints(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BathGrid_npoints.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%BathGrid_npoints,1), UBOUND(OutData%BathGrid_npoints,1)
        OutData%BathGrid_npoints(i1) = IntKiBuf(Int_Xferred)
        Int_Xferred = Int_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_UnPackMisc

 SUBROUTINE MD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(MD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackFail(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_Fail), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackFail'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%IdNum)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackFail(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_Fail), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackFail'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%IdNum); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyOutParmType(SrcOutParmTypeData, DstOutParmTypeData, CtrlCode, ErrStat, ErrMsg)
   type(MD_OutParmType), intent(in) :: SrcOutParmTypeData
   type(MD_OutParmType), intent(inout) :: DstOutParmTypeData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOutParmTypeData%Name = SrcOutParmTypeData%Name
   DstOutParmTypeData%Units = SrcOutParmTypeData%Units
   DstOutParmTypeData%QType = SrcOutParmTypeData%QType
   DstOutParmTypeData%OType = SrcOutParmTypeData%OType
   DstOutParmTypeData%NodeID = SrcOutParmTypeData%NodeID
   DstOutParmTypeData%ObjID = SrcOutParmTypeData%ObjID
end subroutine

subroutine MD_DestroyOutParmType(OutParmTypeData, ErrStat, ErrMsg)
   type(MD_OutParmType), intent(inout) :: OutParmTypeData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyOutParmType'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackOutParmType(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_OutParmType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackOutParmType'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%Name)
   call RegPack(RF, InData%Units)
   call RegPack(RF, InData%QType)
   call RegPack(RF, InData%OType)
   call RegPack(RF, InData%NodeID)
   call RegPack(RF, InData%ObjID)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackOutParmType(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_OutParmType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackOutParmType'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%Name); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Units); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%QType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%OType); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NodeID); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ObjID); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyVisDiam(SrcVisDiamData, DstVisDiamData, CtrlCode, ErrStat, ErrMsg)
   type(VisDiam), intent(in) :: SrcVisDiamData
   type(VisDiam), intent(inout) :: DstVisDiamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MD_CopyVisDiam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcVisDiamData%Diam)) then
      LB(1:1) = lbound(SrcVisDiamData%Diam, kind=B8Ki)
      UB(1:1) = ubound(SrcVisDiamData%Diam, kind=B8Ki)
      if (.not. allocated(DstVisDiamData%Diam)) then
         allocate(DstVisDiamData%Diam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstVisDiamData%Diam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstVisDiamData%Diam = SrcVisDiamData%Diam
   end if
end subroutine

subroutine MD_DestroyVisDiam(VisDiamData, ErrStat, ErrMsg)
   type(VisDiam), intent(inout) :: VisDiamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyVisDiam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(VisDiamData%Diam)) then
      deallocate(VisDiamData%Diam)
   end if
end subroutine

subroutine MD_PackVisDiam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(VisDiam), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackVisDiam'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%Diam)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackVisDiam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(VisDiam), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackVisDiam'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%Diam); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyInitOutput(SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg)
   type(MD_InitOutputType), intent(in) :: SrcInitOutputData
   type(MD_InitOutputType), intent(inout) :: DstInitOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_CopyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInitOutputData%writeOutputHdr)) then
      LB(1:1) = lbound(SrcInitOutputData%writeOutputHdr, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%writeOutputHdr, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%writeOutputHdr)) then
         allocate(DstInitOutputData%writeOutputHdr(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputHdr.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%writeOutputHdr = SrcInitOutputData%writeOutputHdr
   end if
   if (allocated(SrcInitOutputData%writeOutputUnt)) then
      LB(1:1) = lbound(SrcInitOutputData%writeOutputUnt, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%writeOutputUnt, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%writeOutputUnt)) then
         allocate(DstInitOutputData%writeOutputUnt(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%writeOutputUnt.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%writeOutputUnt = SrcInitOutputData%writeOutputUnt
   end if
   call NWTC_Library_CopyProgDesc(SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcInitOutputData%CableCChanRqst)) then
      LB(1:1) = lbound(SrcInitOutputData%CableCChanRqst, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%CableCChanRqst, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%CableCChanRqst)) then
         allocate(DstInitOutputData%CableCChanRqst(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%CableCChanRqst.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%CableCChanRqst = SrcInitOutputData%CableCChanRqst
   end if
   if (allocated(SrcInitOutputData%LinNames_y)) then
      LB(1:1) = lbound(SrcInitOutputData%LinNames_y, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%LinNames_y, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%LinNames_y)) then
         allocate(DstInitOutputData%LinNames_y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%LinNames_y = SrcInitOutputData%LinNames_y
   end if
   if (allocated(SrcInitOutputData%LinNames_x)) then
      LB(1:1) = lbound(SrcInitOutputData%LinNames_x, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%LinNames_x, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%LinNames_x)) then
         allocate(DstInitOutputData%LinNames_x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%LinNames_x = SrcInitOutputData%LinNames_x
   end if
   if (allocated(SrcInitOutputData%LinNames_u)) then
      LB(1:1) = lbound(SrcInitOutputData%LinNames_u, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%LinNames_u, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%LinNames_u)) then
         allocate(DstInitOutputData%LinNames_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%LinNames_u = SrcInitOutputData%LinNames_u
   end if
   if (allocated(SrcInitOutputData%RotFrame_y)) then
      LB(1:1) = lbound(SrcInitOutputData%RotFrame_y, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%RotFrame_y, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%RotFrame_y)) then
         allocate(DstInitOutputData%RotFrame_y(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_y.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%RotFrame_y = SrcInitOutputData%RotFrame_y
   end if
   if (allocated(SrcInitOutputData%RotFrame_x)) then
      LB(1:1) = lbound(SrcInitOutputData%RotFrame_x, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%RotFrame_x, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%RotFrame_x)) then
         allocate(DstInitOutputData%RotFrame_x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%RotFrame_x = SrcInitOutputData%RotFrame_x
   end if
   if (allocated(SrcInitOutputData%RotFrame_u)) then
      LB(1:1) = lbound(SrcInitOutputData%RotFrame_u, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%RotFrame_u, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%RotFrame_u)) then
         allocate(DstInitOutputData%RotFrame_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%RotFrame_u = SrcInitOutputData%RotFrame_u
   end if
   if (allocated(SrcInitOutputData%IsLoad_u)) then
      LB(1:1) = lbound(SrcInitOutputData%IsLoad_u, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%IsLoad_u, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%IsLoad_u)) then
         allocate(DstInitOutputData%IsLoad_u(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%IsLoad_u.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%IsLoad_u = SrcInitOutputData%IsLoad_u
   end if
   if (allocated(SrcInitOutputData%DerivOrder_x)) then
      LB(1:1) = lbound(SrcInitOutputData%DerivOrder_x, kind=B8Ki)
      UB(1:1) = ubound(SrcInitOutputData%DerivOrder_x, kind=B8Ki)
      if (.not. allocated(DstInitOutputData%DerivOrder_x)) then
         allocate(DstInitOutputData%DerivOrder_x(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%DerivOrder_x.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInitOutputData%DerivOrder_x = SrcInitOutputData%DerivOrder_x
   end if
end subroutine

subroutine MD_DestroyInitOutput(InitOutputData, ErrStat, ErrMsg)
   type(MD_InitOutputType), intent(inout) :: InitOutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_DestroyInitOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InitOutputData%writeOutputHdr)) then
      deallocate(InitOutputData%writeOutputHdr)
   end if
   if (allocated(InitOutputData%writeOutputUnt)) then
      deallocate(InitOutputData%writeOutputUnt)
   end if
   call NWTC_Library_DestroyProgDesc(InitOutputData%Ver, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(InitOutputData%CableCChanRqst)) then
      deallocate(InitOutputData%CableCChanRqst)
   end if
   if (allocated(InitOutputData%LinNames_y)) then
      deallocate(InitOutputData%LinNames_y)
   end if
   if (allocated(InitOutputData%LinNames_x)) then
      deallocate(InitOutputData%LinNames_x)
   end if
   if (allocated(InitOutputData%LinNames_u)) then
      deallocate(InitOutputData%LinNames_u)
   end if
   if (allocated(InitOutputData%RotFrame_y)) then
      deallocate(InitOutputData%RotFrame_y)
   end if
   if (allocated(InitOutputData%RotFrame_x)) then
      deallocate(InitOutputData%RotFrame_x)
   end if
   if (allocated(InitOutputData%RotFrame_u)) then
      deallocate(InitOutputData%RotFrame_u)
   end if
   if (allocated(InitOutputData%IsLoad_u)) then
      deallocate(InitOutputData%IsLoad_u)
   end if
   if (allocated(InitOutputData%DerivOrder_x)) then
      deallocate(InitOutputData%DerivOrder_x)
   end if
end subroutine

subroutine MD_PackInitOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInitOutput'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%writeOutputHdr)
   call RegPackAlloc(RF, InData%writeOutputUnt)
   call NWTC_Library_PackProgDesc(RF, InData%Ver) 
   call RegPackAlloc(RF, InData%CableCChanRqst)
   call RegPackAlloc(RF, InData%LinNames_y)
   call RegPackAlloc(RF, InData%LinNames_x)
   call RegPackAlloc(RF, InData%LinNames_u)
   call RegPackAlloc(RF, InData%RotFrame_y)
   call RegPackAlloc(RF, InData%RotFrame_x)
   call RegPackAlloc(RF, InData%RotFrame_u)
   call RegPackAlloc(RF, InData%IsLoad_u)
   call RegPackAlloc(RF, InData%DerivOrder_x)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackInitOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInitOutput'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%writeOutputHdr); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%writeOutputUnt); if (RegCheckErr(RF, RoutineName)) return
   call NWTC_Library_UnpackProgDesc(RF, OutData%Ver) ! Ver 
   call RegUnpackAlloc(RF, OutData%CableCChanRqst); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LinNames_y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LinNames_x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LinNames_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RotFrame_y); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RotFrame_x); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RotFrame_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%IsLoad_u); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DerivOrder_x); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyContState(SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg)
   type(MD_ContinuousStateType), intent(in) :: SrcContStateData
   type(MD_ContinuousStateType), intent(inout) :: DstContStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(*), parameter        :: RoutineName = 'MD_CopyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcContStateData%states)) then
      LB(1:1) = lbound(SrcContStateData%states, kind=B8Ki)
      UB(1:1) = ubound(SrcContStateData%states, kind=B8Ki)
      if (.not. allocated(DstContStateData%states)) then
         allocate(DstContStateData%states(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%states.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstContStateData%states = SrcContStateData%states
   end if
end subroutine

subroutine MD_DestroyContState(ContStateData, ErrStat, ErrMsg)
   type(MD_ContinuousStateType), intent(inout) :: ContStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyContState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ContStateData%states)) then
      deallocate(ContStateData%states)
   end if
end subroutine

subroutine MD_PackContState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackContState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPackAlloc(RF, InData%states)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackContState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackContState'
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpackAlloc(RF, OutData%states); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyDiscState(SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg)
   type(MD_DiscreteStateType), intent(in) :: SrcDiscStateData
   type(MD_DiscreteStateType), intent(inout) :: DstDiscStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstDiscStateData%dummy = SrcDiscStateData%dummy
end subroutine

subroutine MD_DestroyDiscState(DiscStateData, ErrStat, ErrMsg)
   type(MD_DiscreteStateType), intent(inout) :: DiscStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyDiscState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackDiscState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackDiscState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackDiscState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackDiscState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyConstrState(SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg)
   type(MD_ConstraintStateType), intent(in) :: SrcConstrStateData
   type(MD_ConstraintStateType), intent(inout) :: DstConstrStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstConstrStateData%dummy = SrcConstrStateData%dummy
end subroutine

subroutine MD_DestroyConstrState(ConstrStateData, ErrStat, ErrMsg)
   type(MD_ConstraintStateType), intent(inout) :: ConstrStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyConstrState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackConstrState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackConstrState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackConstrState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackConstrState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyOtherState(SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg)
   type(MD_OtherStateType), intent(in) :: SrcOtherStateData
   type(MD_OtherStateType), intent(inout) :: DstOtherStateData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_CopyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstOtherStateData%dummy = SrcOtherStateData%dummy
end subroutine

subroutine MD_DestroyOtherState(OtherStateData, ErrStat, ErrMsg)
   type(MD_OtherStateType), intent(inout) :: OtherStateData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   character(*), parameter        :: RoutineName = 'MD_DestroyOtherState'
   ErrStat = ErrID_None
   ErrMsg  = ''
end subroutine

subroutine MD_PackOtherState(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackOtherState'
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%dummy)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackOtherState(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackOtherState'
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%dummy); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyMisc(SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg)
   type(MD_MiscVarType), intent(in) :: SrcMiscData
   type(MD_MiscVarType), intent(inout) :: DstMiscData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)                  :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_CopyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcMiscData%LineTypeList)) then
      LB(1:1) = lbound(SrcMiscData%LineTypeList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%LineTypeList, kind=B8Ki)
      if (.not. allocated(DstMiscData%LineTypeList)) then
         allocate(DstMiscData%LineTypeList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineTypeList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyLineProp(SrcMiscData%LineTypeList(i1), DstMiscData%LineTypeList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%RodTypeList)) then
      LB(1:1) = lbound(SrcMiscData%RodTypeList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%RodTypeList, kind=B8Ki)
      if (.not. allocated(DstMiscData%RodTypeList)) then
         allocate(DstMiscData%RodTypeList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodTypeList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyRodProp(SrcMiscData%RodTypeList(i1), DstMiscData%RodTypeList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   call MD_CopyBody(SrcMiscData%GroundBody, DstMiscData%GroundBody, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   if (allocated(SrcMiscData%BodyList)) then
      LB(1:1) = lbound(SrcMiscData%BodyList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%BodyList, kind=B8Ki)
      if (.not. allocated(DstMiscData%BodyList)) then
         allocate(DstMiscData%BodyList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyBody(SrcMiscData%BodyList(i1), DstMiscData%BodyList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%RodList)) then
      LB(1:1) = lbound(SrcMiscData%RodList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%RodList, kind=B8Ki)
      if (.not. allocated(DstMiscData%RodList)) then
         allocate(DstMiscData%RodList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyRod(SrcMiscData%RodList(i1), DstMiscData%RodList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%PointList)) then
      LB(1:1) = lbound(SrcMiscData%PointList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%PointList, kind=B8Ki)
      if (.not. allocated(DstMiscData%PointList)) then
         allocate(DstMiscData%PointList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PointList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyPoint(SrcMiscData%PointList(i1), DstMiscData%PointList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%LineList)) then
      LB(1:1) = lbound(SrcMiscData%LineList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%LineList, kind=B8Ki)
      if (.not. allocated(DstMiscData%LineList)) then
         allocate(DstMiscData%LineList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyLine(SrcMiscData%LineList(i1), DstMiscData%LineList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%FailList)) then
      LB(1:1) = lbound(SrcMiscData%FailList, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%FailList, kind=B8Ki)
      if (.not. allocated(DstMiscData%FailList)) then
         allocate(DstMiscData%FailList(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FailList.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyFail(SrcMiscData%FailList(i1), DstMiscData%FailList(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcMiscData%FreePointIs)) then
      LB(1:1) = lbound(SrcMiscData%FreePointIs, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%FreePointIs, kind=B8Ki)
      if (.not. allocated(DstMiscData%FreePointIs)) then
         allocate(DstMiscData%FreePointIs(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreePointIs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FreePointIs = SrcMiscData%FreePointIs
   end if
   if (allocated(SrcMiscData%CpldPointIs)) then
      LB(1:2) = lbound(SrcMiscData%CpldPointIs, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%CpldPointIs, kind=B8Ki)
      if (.not. allocated(DstMiscData%CpldPointIs)) then
         allocate(DstMiscData%CpldPointIs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldPointIs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%CpldPointIs = SrcMiscData%CpldPointIs
   end if
   if (allocated(SrcMiscData%FreeRodIs)) then
      LB(1:1) = lbound(SrcMiscData%FreeRodIs, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%FreeRodIs, kind=B8Ki)
      if (.not. allocated(DstMiscData%FreeRodIs)) then
         allocate(DstMiscData%FreeRodIs(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeRodIs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FreeRodIs = SrcMiscData%FreeRodIs
   end if
   if (allocated(SrcMiscData%CpldRodIs)) then
      LB(1:2) = lbound(SrcMiscData%CpldRodIs, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%CpldRodIs, kind=B8Ki)
      if (.not. allocated(DstMiscData%CpldRodIs)) then
         allocate(DstMiscData%CpldRodIs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldRodIs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%CpldRodIs = SrcMiscData%CpldRodIs
   end if
   if (allocated(SrcMiscData%FreeBodyIs)) then
      LB(1:1) = lbound(SrcMiscData%FreeBodyIs, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%FreeBodyIs, kind=B8Ki)
      if (.not. allocated(DstMiscData%FreeBodyIs)) then
         allocate(DstMiscData%FreeBodyIs(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FreeBodyIs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%FreeBodyIs = SrcMiscData%FreeBodyIs
   end if
   if (allocated(SrcMiscData%CpldBodyIs)) then
      LB(1:2) = lbound(SrcMiscData%CpldBodyIs, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%CpldBodyIs, kind=B8Ki)
      if (.not. allocated(DstMiscData%CpldBodyIs)) then
         allocate(DstMiscData%CpldBodyIs(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CpldBodyIs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%CpldBodyIs = SrcMiscData%CpldBodyIs
   end if
   if (allocated(SrcMiscData%LineStateIs1)) then
      LB(1:1) = lbound(SrcMiscData%LineStateIs1, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%LineStateIs1, kind=B8Ki)
      if (.not. allocated(DstMiscData%LineStateIs1)) then
         allocate(DstMiscData%LineStateIs1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineStateIs1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%LineStateIs1 = SrcMiscData%LineStateIs1
   end if
   if (allocated(SrcMiscData%LineStateIsN)) then
      LB(1:1) = lbound(SrcMiscData%LineStateIsN, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%LineStateIsN, kind=B8Ki)
      if (.not. allocated(DstMiscData%LineStateIsN)) then
         allocate(DstMiscData%LineStateIsN(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LineStateIsN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%LineStateIsN = SrcMiscData%LineStateIsN
   end if
   if (allocated(SrcMiscData%PointStateIs1)) then
      LB(1:1) = lbound(SrcMiscData%PointStateIs1, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%PointStateIs1, kind=B8Ki)
      if (.not. allocated(DstMiscData%PointStateIs1)) then
         allocate(DstMiscData%PointStateIs1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PointStateIs1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%PointStateIs1 = SrcMiscData%PointStateIs1
   end if
   if (allocated(SrcMiscData%PointStateIsN)) then
      LB(1:1) = lbound(SrcMiscData%PointStateIsN, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%PointStateIsN, kind=B8Ki)
      if (.not. allocated(DstMiscData%PointStateIsN)) then
         allocate(DstMiscData%PointStateIsN(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%PointStateIsN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%PointStateIsN = SrcMiscData%PointStateIsN
   end if
   if (allocated(SrcMiscData%RodStateIs1)) then
      LB(1:1) = lbound(SrcMiscData%RodStateIs1, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%RodStateIs1, kind=B8Ki)
      if (.not. allocated(DstMiscData%RodStateIs1)) then
         allocate(DstMiscData%RodStateIs1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodStateIs1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%RodStateIs1 = SrcMiscData%RodStateIs1
   end if
   if (allocated(SrcMiscData%RodStateIsN)) then
      LB(1:1) = lbound(SrcMiscData%RodStateIsN, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%RodStateIsN, kind=B8Ki)
      if (.not. allocated(DstMiscData%RodStateIsN)) then
         allocate(DstMiscData%RodStateIsN(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%RodStateIsN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%RodStateIsN = SrcMiscData%RodStateIsN
   end if
   if (allocated(SrcMiscData%BodyStateIs1)) then
      LB(1:1) = lbound(SrcMiscData%BodyStateIs1, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%BodyStateIs1, kind=B8Ki)
      if (.not. allocated(DstMiscData%BodyStateIs1)) then
         allocate(DstMiscData%BodyStateIs1(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyStateIs1.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%BodyStateIs1 = SrcMiscData%BodyStateIs1
   end if
   if (allocated(SrcMiscData%BodyStateIsN)) then
      LB(1:1) = lbound(SrcMiscData%BodyStateIsN, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%BodyStateIsN, kind=B8Ki)
      if (.not. allocated(DstMiscData%BodyStateIsN)) then
         allocate(DstMiscData%BodyStateIsN(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BodyStateIsN.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%BodyStateIsN = SrcMiscData%BodyStateIsN
   end if
   DstMiscData%Nx = SrcMiscData%Nx
   DstMiscData%WaveTi = SrcMiscData%WaveTi
   call MD_CopyContState(SrcMiscData%xTemp, DstMiscData%xTemp, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   call MD_CopyContState(SrcMiscData%xdTemp, DstMiscData%xdTemp, CtrlCode, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (ErrStat >= AbortErrLev) return
   DstMiscData%zeros6 = SrcMiscData%zeros6
   if (allocated(SrcMiscData%MDWrOutput)) then
      LB(1:1) = lbound(SrcMiscData%MDWrOutput, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%MDWrOutput, kind=B8Ki)
      if (.not. allocated(DstMiscData%MDWrOutput)) then
         allocate(DstMiscData%MDWrOutput(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%MDWrOutput.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%MDWrOutput = SrcMiscData%MDWrOutput
   end if
   DstMiscData%LastOutTime = SrcMiscData%LastOutTime
   DstMiscData%PtfmInit = SrcMiscData%PtfmInit
   if (allocated(SrcMiscData%BathymetryGrid)) then
      LB(1:2) = lbound(SrcMiscData%BathymetryGrid, kind=B8Ki)
      UB(1:2) = ubound(SrcMiscData%BathymetryGrid, kind=B8Ki)
      if (.not. allocated(DstMiscData%BathymetryGrid)) then
         allocate(DstMiscData%BathymetryGrid(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathymetryGrid.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%BathymetryGrid = SrcMiscData%BathymetryGrid
   end if
   if (allocated(SrcMiscData%BathGrid_Xs)) then
      LB(1:1) = lbound(SrcMiscData%BathGrid_Xs, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%BathGrid_Xs, kind=B8Ki)
      if (.not. allocated(DstMiscData%BathGrid_Xs)) then
         allocate(DstMiscData%BathGrid_Xs(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_Xs.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%BathGrid_Xs = SrcMiscData%BathGrid_Xs
   end if
   if (allocated(SrcMiscData%BathGrid_Ys)) then
      LB(1:1) = lbound(SrcMiscData%BathGrid_Ys, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%BathGrid_Ys, kind=B8Ki)
      if (.not. allocated(DstMiscData%BathGrid_Ys)) then
         allocate(DstMiscData%BathGrid_Ys(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_Ys.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%BathGrid_Ys = SrcMiscData%BathGrid_Ys
   end if
   if (allocated(SrcMiscData%BathGrid_npoints)) then
      LB(1:1) = lbound(SrcMiscData%BathGrid_npoints, kind=B8Ki)
      UB(1:1) = ubound(SrcMiscData%BathGrid_npoints, kind=B8Ki)
      if (.not. allocated(DstMiscData%BathGrid_npoints)) then
         allocate(DstMiscData%BathGrid_npoints(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BathGrid_npoints.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstMiscData%BathGrid_npoints = SrcMiscData%BathGrid_npoints
   end if
end subroutine

subroutine MD_DestroyMisc(MiscData, ErrStat, ErrMsg)
   type(MD_MiscVarType), intent(inout) :: MiscData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_DestroyMisc'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(MiscData%LineTypeList)) then
      LB(1:1) = lbound(MiscData%LineTypeList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%LineTypeList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyLineProp(MiscData%LineTypeList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%LineTypeList)
   end if
   if (allocated(MiscData%RodTypeList)) then
      LB(1:1) = lbound(MiscData%RodTypeList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%RodTypeList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyRodProp(MiscData%RodTypeList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%RodTypeList)
   end if
   call MD_DestroyBody(MiscData%GroundBody, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%BodyList)) then
      LB(1:1) = lbound(MiscData%BodyList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%BodyList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyBody(MiscData%BodyList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%BodyList)
   end if
   if (allocated(MiscData%RodList)) then
      LB(1:1) = lbound(MiscData%RodList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%RodList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyRod(MiscData%RodList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%RodList)
   end if
   if (allocated(MiscData%PointList)) then
      LB(1:1) = lbound(MiscData%PointList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%PointList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyPoint(MiscData%PointList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%PointList)
   end if
   if (allocated(MiscData%LineList)) then
      LB(1:1) = lbound(MiscData%LineList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%LineList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyLine(MiscData%LineList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%LineList)
   end if
   if (allocated(MiscData%FailList)) then
      LB(1:1) = lbound(MiscData%FailList, kind=B8Ki)
      UB(1:1) = ubound(MiscData%FailList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyFail(MiscData%FailList(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(MiscData%FailList)
   end if
   if (allocated(MiscData%FreePointIs)) then
      deallocate(MiscData%FreePointIs)
   end if
   if (allocated(MiscData%CpldPointIs)) then
      deallocate(MiscData%CpldPointIs)
   end if
   if (allocated(MiscData%FreeRodIs)) then
      deallocate(MiscData%FreeRodIs)
   end if
   if (allocated(MiscData%CpldRodIs)) then
      deallocate(MiscData%CpldRodIs)
   end if
   if (allocated(MiscData%FreeBodyIs)) then
      deallocate(MiscData%FreeBodyIs)
   end if
   if (allocated(MiscData%CpldBodyIs)) then
      deallocate(MiscData%CpldBodyIs)
   end if
   if (allocated(MiscData%LineStateIs1)) then
      deallocate(MiscData%LineStateIs1)
   end if
   if (allocated(MiscData%LineStateIsN)) then
      deallocate(MiscData%LineStateIsN)
   end if
   if (allocated(MiscData%PointStateIs1)) then
      deallocate(MiscData%PointStateIs1)
   end if
   if (allocated(MiscData%PointStateIsN)) then
      deallocate(MiscData%PointStateIsN)
   end if
   if (allocated(MiscData%RodStateIs1)) then
      deallocate(MiscData%RodStateIs1)
   end if
   if (allocated(MiscData%RodStateIsN)) then
      deallocate(MiscData%RodStateIsN)
   end if
   if (allocated(MiscData%BodyStateIs1)) then
      deallocate(MiscData%BodyStateIs1)
   end if
   if (allocated(MiscData%BodyStateIsN)) then
      deallocate(MiscData%BodyStateIsN)
   end if
   call MD_DestroyContState(MiscData%xTemp, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   call MD_DestroyContState(MiscData%xdTemp, ErrStat2, ErrMsg2)
   call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if (allocated(MiscData%MDWrOutput)) then
      deallocate(MiscData%MDWrOutput)
   end if
   if (allocated(MiscData%BathymetryGrid)) then
      deallocate(MiscData%BathymetryGrid)
   end if
   if (allocated(MiscData%BathGrid_Xs)) then
      deallocate(MiscData%BathGrid_Xs)
   end if
   if (allocated(MiscData%BathGrid_Ys)) then
      deallocate(MiscData%BathGrid_Ys)
   end if
   if (allocated(MiscData%BathGrid_npoints)) then
      deallocate(MiscData%BathGrid_npoints)
   end if
end subroutine

subroutine MD_PackMisc(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%LineTypeList))
   if (allocated(InData%LineTypeList)) then
      call RegPackBounds(RF, 1, lbound(InData%LineTypeList, kind=B8Ki), ubound(InData%LineTypeList, kind=B8Ki))
      LB(1:1) = lbound(InData%LineTypeList, kind=B8Ki)
      UB(1:1) = ubound(InData%LineTypeList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackLineProp(RF, InData%LineTypeList(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%RodTypeList))
   if (allocated(InData%RodTypeList)) then
      call RegPackBounds(RF, 1, lbound(InData%RodTypeList, kind=B8Ki), ubound(InData%RodTypeList, kind=B8Ki))
      LB(1:1) = lbound(InData%RodTypeList, kind=B8Ki)
      UB(1:1) = ubound(InData%RodTypeList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackRodProp(RF, InData%RodTypeList(i1)) 
      end do
   end if
   call MD_PackBody(RF, InData%GroundBody) 
   call RegPack(RF, allocated(InData%BodyList))
   if (allocated(InData%BodyList)) then
      call RegPackBounds(RF, 1, lbound(InData%BodyList, kind=B8Ki), ubound(InData%BodyList, kind=B8Ki))
      LB(1:1) = lbound(InData%BodyList, kind=B8Ki)
      UB(1:1) = ubound(InData%BodyList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackBody(RF, InData%BodyList(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%RodList))
   if (allocated(InData%RodList)) then
      call RegPackBounds(RF, 1, lbound(InData%RodList, kind=B8Ki), ubound(InData%RodList, kind=B8Ki))
      LB(1:1) = lbound(InData%RodList, kind=B8Ki)
      UB(1:1) = ubound(InData%RodList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackRod(RF, InData%RodList(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%PointList))
   if (allocated(InData%PointList)) then
      call RegPackBounds(RF, 1, lbound(InData%PointList, kind=B8Ki), ubound(InData%PointList, kind=B8Ki))
      LB(1:1) = lbound(InData%PointList, kind=B8Ki)
      UB(1:1) = ubound(InData%PointList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackPoint(RF, InData%PointList(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%LineList))
   if (allocated(InData%LineList)) then
      call RegPackBounds(RF, 1, lbound(InData%LineList, kind=B8Ki), ubound(InData%LineList, kind=B8Ki))
      LB(1:1) = lbound(InData%LineList, kind=B8Ki)
      UB(1:1) = ubound(InData%LineList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackLine(RF, InData%LineList(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%FailList))
   if (allocated(InData%FailList)) then
      call RegPackBounds(RF, 1, lbound(InData%FailList, kind=B8Ki), ubound(InData%FailList, kind=B8Ki))
      LB(1:1) = lbound(InData%FailList, kind=B8Ki)
      UB(1:1) = ubound(InData%FailList, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackFail(RF, InData%FailList(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%FreePointIs)
   call RegPackAlloc(RF, InData%CpldPointIs)
   call RegPackAlloc(RF, InData%FreeRodIs)
   call RegPackAlloc(RF, InData%CpldRodIs)
   call RegPackAlloc(RF, InData%FreeBodyIs)
   call RegPackAlloc(RF, InData%CpldBodyIs)
   call RegPackAlloc(RF, InData%LineStateIs1)
   call RegPackAlloc(RF, InData%LineStateIsN)
   call RegPackAlloc(RF, InData%PointStateIs1)
   call RegPackAlloc(RF, InData%PointStateIsN)
   call RegPackAlloc(RF, InData%RodStateIs1)
   call RegPackAlloc(RF, InData%RodStateIsN)
   call RegPackAlloc(RF, InData%BodyStateIs1)
   call RegPackAlloc(RF, InData%BodyStateIsN)
   call RegPack(RF, InData%Nx)
   call RegPack(RF, InData%WaveTi)
   call MD_PackContState(RF, InData%xTemp) 
   call MD_PackContState(RF, InData%xdTemp) 
   call RegPack(RF, InData%zeros6)
   call RegPackAlloc(RF, InData%MDWrOutput)
   call RegPack(RF, InData%LastOutTime)
   call RegPack(RF, InData%PtfmInit)
   call RegPackAlloc(RF, InData%BathymetryGrid)
   call RegPackAlloc(RF, InData%BathGrid_Xs)
   call RegPackAlloc(RF, InData%BathGrid_Ys)
   call RegPackAlloc(RF, InData%BathGrid_npoints)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackMisc(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackMisc'
   integer(B8Ki)   :: i1, i2
   integer(B8Ki)   :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%LineTypeList)) deallocate(OutData%LineTypeList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%LineTypeList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineTypeList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackLineProp(RF, OutData%LineTypeList(i1)) ! LineTypeList 
      end do
   end if
   if (allocated(OutData%RodTypeList)) deallocate(OutData%RodTypeList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%RodTypeList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodTypeList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackRodProp(RF, OutData%RodTypeList(i1)) ! RodTypeList 
      end do
   end if
   call MD_UnpackBody(RF, OutData%GroundBody) ! GroundBody 
   if (allocated(OutData%BodyList)) deallocate(OutData%BodyList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%BodyList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BodyList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackBody(RF, OutData%BodyList(i1)) ! BodyList 
      end do
   end if
   if (allocated(OutData%RodList)) deallocate(OutData%RodList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%RodList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackRod(RF, OutData%RodList(i1)) ! RodList 
      end do
   end if
   if (allocated(OutData%PointList)) deallocate(OutData%PointList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%PointList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PointList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackPoint(RF, OutData%PointList(i1)) ! PointList 
      end do
   end if
   if (allocated(OutData%LineList)) deallocate(OutData%LineList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%LineList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LineList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackLine(RF, OutData%LineList(i1)) ! LineList 
      end do
   end if
   if (allocated(OutData%FailList)) deallocate(OutData%FailList)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%FailList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FailList.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackFail(RF, OutData%FailList(i1)) ! FailList 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%FreePointIs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CpldPointIs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FreeRodIs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CpldRodIs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%FreeBodyIs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%CpldBodyIs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LineStateIs1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%LineStateIsN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PointStateIs1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PointStateIsN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RodStateIs1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%RodStateIsN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BodyStateIs1); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BodyStateIsN); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveTi); if (RegCheckErr(RF, RoutineName)) return
   call MD_UnpackContState(RF, OutData%xTemp) ! xTemp 
   call MD_UnpackContState(RF, OutData%xdTemp) ! xdTemp 
   call RegUnpack(RF, OutData%zeros6); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%MDWrOutput); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%LastOutTime); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PtfmInit); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BathymetryGrid); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BathGrid_Xs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BathGrid_Ys); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%BathGrid_npoints); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyParam(SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg)
   type(MD_ParameterType), intent(in) :: SrcParamData
   type(MD_ParameterType), intent(inout) :: DstParamData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3, i4
   integer(B8Ki)                  :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_CopyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   DstParamData%nLineTypes = SrcParamData%nLineTypes
   DstParamData%nRodTypes = SrcParamData%nRodTypes
   DstParamData%nPoints = SrcParamData%nPoints
   DstParamData%nPointsExtra = SrcParamData%nPointsExtra
   DstParamData%nBodies = SrcParamData%nBodies
   DstParamData%nRods = SrcParamData%nRods
   DstParamData%nLines = SrcParamData%nLines
   DstParamData%nCtrlChans = SrcParamData%nCtrlChans
   DstParamData%nFails = SrcParamData%nFails
   DstParamData%nFreeBodies = SrcParamData%nFreeBodies
   DstParamData%nFreeRods = SrcParamData%nFreeRods
   DstParamData%nFreePoints = SrcParamData%nFreePoints
   if (allocated(SrcParamData%nCpldBodies)) then
      LB(1:1) = lbound(SrcParamData%nCpldBodies, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%nCpldBodies, kind=B8Ki)
      if (.not. allocated(DstParamData%nCpldBodies)) then
         allocate(DstParamData%nCpldBodies(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nCpldBodies.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%nCpldBodies = SrcParamData%nCpldBodies
   end if
   if (allocated(SrcParamData%nCpldRods)) then
      LB(1:1) = lbound(SrcParamData%nCpldRods, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%nCpldRods, kind=B8Ki)
      if (.not. allocated(DstParamData%nCpldRods)) then
         allocate(DstParamData%nCpldRods(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nCpldRods.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%nCpldRods = SrcParamData%nCpldRods
   end if
   if (allocated(SrcParamData%nCpldPoints)) then
      LB(1:1) = lbound(SrcParamData%nCpldPoints, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%nCpldPoints, kind=B8Ki)
      if (.not. allocated(DstParamData%nCpldPoints)) then
         allocate(DstParamData%nCpldPoints(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%nCpldPoints.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%nCpldPoints = SrcParamData%nCpldPoints
   end if
   DstParamData%NConns = SrcParamData%NConns
   DstParamData%NAnchs = SrcParamData%NAnchs
   DstParamData%Tmax = SrcParamData%Tmax
   DstParamData%g = SrcParamData%g
   DstParamData%rhoW = SrcParamData%rhoW
   DstParamData%WtrDpth = SrcParamData%WtrDpth
   DstParamData%kBot = SrcParamData%kBot
   DstParamData%cBot = SrcParamData%cBot
   DstParamData%dtM0 = SrcParamData%dtM0
   DstParamData%dtCoupling = SrcParamData%dtCoupling
   DstParamData%NumOuts = SrcParamData%NumOuts
   DstParamData%dtOut = SrcParamData%dtOut
   DstParamData%RootName = SrcParamData%RootName
   if (allocated(SrcParamData%OutParam)) then
      LB(1:1) = lbound(SrcParamData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%OutParam, kind=B8Ki)
      if (.not. allocated(DstParamData%OutParam)) then
         allocate(DstParamData%OutParam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyOutParmType(SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   DstParamData%Delim = SrcParamData%Delim
   DstParamData%MDUnOut = SrcParamData%MDUnOut
   DstParamData%PriPath = SrcParamData%PriPath
   DstParamData%writeLog = SrcParamData%writeLog
   DstParamData%UnLog = SrcParamData%UnLog
   DstParamData%WaveKin = SrcParamData%WaveKin
   DstParamData%Current = SrcParamData%Current
   DstParamData%nTurbines = SrcParamData%nTurbines
   if (allocated(SrcParamData%TurbineRefPos)) then
      LB(1:2) = lbound(SrcParamData%TurbineRefPos, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%TurbineRefPos, kind=B8Ki)
      if (.not. allocated(DstParamData%TurbineRefPos)) then
         allocate(DstParamData%TurbineRefPos(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TurbineRefPos.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%TurbineRefPos = SrcParamData%TurbineRefPos
   end if
   DstParamData%mu_kT = SrcParamData%mu_kT
   DstParamData%mu_kA = SrcParamData%mu_kA
   DstParamData%mc = SrcParamData%mc
   DstParamData%cv = SrcParamData%cv
   DstParamData%inertialF = SrcParamData%inertialF
   DstParamData%nxWave = SrcParamData%nxWave
   DstParamData%nyWave = SrcParamData%nyWave
   DstParamData%nzWave = SrcParamData%nzWave
   DstParamData%ntWave = SrcParamData%ntWave
   if (allocated(SrcParamData%pxWave)) then
      LB(1:1) = lbound(SrcParamData%pxWave, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%pxWave, kind=B8Ki)
      if (.not. allocated(DstParamData%pxWave)) then
         allocate(DstParamData%pxWave(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pxWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%pxWave = SrcParamData%pxWave
   end if
   if (allocated(SrcParamData%pyWave)) then
      LB(1:1) = lbound(SrcParamData%pyWave, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%pyWave, kind=B8Ki)
      if (.not. allocated(DstParamData%pyWave)) then
         allocate(DstParamData%pyWave(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pyWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%pyWave = SrcParamData%pyWave
   end if
   if (allocated(SrcParamData%pzWave)) then
      LB(1:1) = lbound(SrcParamData%pzWave, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%pzWave, kind=B8Ki)
      if (.not. allocated(DstParamData%pzWave)) then
         allocate(DstParamData%pzWave(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pzWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%pzWave = SrcParamData%pzWave
   end if
   DstParamData%dtWave = SrcParamData%dtWave
   if (allocated(SrcParamData%uxWave)) then
      LB(1:4) = lbound(SrcParamData%uxWave, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%uxWave, kind=B8Ki)
      if (.not. allocated(DstParamData%uxWave)) then
         allocate(DstParamData%uxWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uxWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%uxWave = SrcParamData%uxWave
   end if
   if (allocated(SrcParamData%uyWave)) then
      LB(1:4) = lbound(SrcParamData%uyWave, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%uyWave, kind=B8Ki)
      if (.not. allocated(DstParamData%uyWave)) then
         allocate(DstParamData%uyWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uyWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%uyWave = SrcParamData%uyWave
   end if
   if (allocated(SrcParamData%uzWave)) then
      LB(1:4) = lbound(SrcParamData%uzWave, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%uzWave, kind=B8Ki)
      if (.not. allocated(DstParamData%uzWave)) then
         allocate(DstParamData%uzWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uzWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%uzWave = SrcParamData%uzWave
   end if
   if (allocated(SrcParamData%axWave)) then
      LB(1:4) = lbound(SrcParamData%axWave, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%axWave, kind=B8Ki)
      if (.not. allocated(DstParamData%axWave)) then
         allocate(DstParamData%axWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%axWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%axWave = SrcParamData%axWave
   end if
   if (allocated(SrcParamData%ayWave)) then
      LB(1:4) = lbound(SrcParamData%ayWave, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%ayWave, kind=B8Ki)
      if (.not. allocated(DstParamData%ayWave)) then
         allocate(DstParamData%ayWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ayWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%ayWave = SrcParamData%ayWave
   end if
   if (allocated(SrcParamData%azWave)) then
      LB(1:4) = lbound(SrcParamData%azWave, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%azWave, kind=B8Ki)
      if (.not. allocated(DstParamData%azWave)) then
         allocate(DstParamData%azWave(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%azWave.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%azWave = SrcParamData%azWave
   end if
   if (allocated(SrcParamData%PDyn)) then
      LB(1:4) = lbound(SrcParamData%PDyn, kind=B8Ki)
      UB(1:4) = ubound(SrcParamData%PDyn, kind=B8Ki)
      if (.not. allocated(DstParamData%PDyn)) then
         allocate(DstParamData%PDyn(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PDyn.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%PDyn = SrcParamData%PDyn
   end if
   if (allocated(SrcParamData%zeta)) then
      LB(1:3) = lbound(SrcParamData%zeta, kind=B8Ki)
      UB(1:3) = ubound(SrcParamData%zeta, kind=B8Ki)
      if (.not. allocated(DstParamData%zeta)) then
         allocate(DstParamData%zeta(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%zeta.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%zeta = SrcParamData%zeta
   end if
   DstParamData%nzCurrent = SrcParamData%nzCurrent
   if (allocated(SrcParamData%pzCurrent)) then
      LB(1:1) = lbound(SrcParamData%pzCurrent, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%pzCurrent, kind=B8Ki)
      if (.not. allocated(DstParamData%pzCurrent)) then
         allocate(DstParamData%pzCurrent(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%pzCurrent.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%pzCurrent = SrcParamData%pzCurrent
   end if
   if (allocated(SrcParamData%uxCurrent)) then
      LB(1:1) = lbound(SrcParamData%uxCurrent, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%uxCurrent, kind=B8Ki)
      if (.not. allocated(DstParamData%uxCurrent)) then
         allocate(DstParamData%uxCurrent(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uxCurrent.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%uxCurrent = SrcParamData%uxCurrent
   end if
   if (allocated(SrcParamData%uyCurrent)) then
      LB(1:1) = lbound(SrcParamData%uyCurrent, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%uyCurrent, kind=B8Ki)
      if (.not. allocated(DstParamData%uyCurrent)) then
         allocate(DstParamData%uyCurrent(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%uyCurrent.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%uyCurrent = SrcParamData%uyCurrent
   end if
   DstParamData%Nx0 = SrcParamData%Nx0
   if (allocated(SrcParamData%Jac_u_indx)) then
      LB(1:2) = lbound(SrcParamData%Jac_u_indx, kind=B8Ki)
      UB(1:2) = ubound(SrcParamData%Jac_u_indx, kind=B8Ki)
      if (.not. allocated(DstParamData%Jac_u_indx)) then
         allocate(DstParamData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_u_indx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%Jac_u_indx = SrcParamData%Jac_u_indx
   end if
   if (allocated(SrcParamData%du)) then
      LB(1:1) = lbound(SrcParamData%du, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%du, kind=B8Ki)
      if (.not. allocated(DstParamData%du)) then
         allocate(DstParamData%du(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%du.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%du = SrcParamData%du
   end if
   if (allocated(SrcParamData%dx)) then
      LB(1:1) = lbound(SrcParamData%dx, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%dx, kind=B8Ki)
      if (.not. allocated(DstParamData%dx)) then
         allocate(DstParamData%dx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%dx = SrcParamData%dx
   end if
   DstParamData%Jac_ny = SrcParamData%Jac_ny
   DstParamData%Jac_nx = SrcParamData%Jac_nx
   if (allocated(SrcParamData%dxIdx_map2_xStateIdx)) then
      LB(1:1) = lbound(SrcParamData%dxIdx_map2_xStateIdx, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%dxIdx_map2_xStateIdx, kind=B8Ki)
      if (.not. allocated(DstParamData%dxIdx_map2_xStateIdx)) then
         allocate(DstParamData%dxIdx_map2_xStateIdx(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dxIdx_map2_xStateIdx.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstParamData%dxIdx_map2_xStateIdx = SrcParamData%dxIdx_map2_xStateIdx
   end if
   DstParamData%VisMeshes = SrcParamData%VisMeshes
   if (allocated(SrcParamData%VisRodsDiam)) then
      LB(1:1) = lbound(SrcParamData%VisRodsDiam, kind=B8Ki)
      UB(1:1) = ubound(SrcParamData%VisRodsDiam, kind=B8Ki)
      if (.not. allocated(DstParamData%VisRodsDiam)) then
         allocate(DstParamData%VisRodsDiam(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%VisRodsDiam.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MD_CopyVisDiam(SrcParamData%VisRodsDiam(i1), DstParamData%VisRodsDiam(i1), CtrlCode, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine MD_DestroyParam(ParamData, ErrStat, ErrMsg)
   type(MD_ParameterType), intent(inout) :: ParamData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1, i2, i3, i4
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_DestroyParam'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(ParamData%nCpldBodies)) then
      deallocate(ParamData%nCpldBodies)
   end if
   if (allocated(ParamData%nCpldRods)) then
      deallocate(ParamData%nCpldRods)
   end if
   if (allocated(ParamData%nCpldPoints)) then
      deallocate(ParamData%nCpldPoints)
   end if
   if (allocated(ParamData%OutParam)) then
      LB(1:1) = lbound(ParamData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(ParamData%OutParam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyOutParmType(ParamData%OutParam(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%OutParam)
   end if
   if (allocated(ParamData%TurbineRefPos)) then
      deallocate(ParamData%TurbineRefPos)
   end if
   if (allocated(ParamData%pxWave)) then
      deallocate(ParamData%pxWave)
   end if
   if (allocated(ParamData%pyWave)) then
      deallocate(ParamData%pyWave)
   end if
   if (allocated(ParamData%pzWave)) then
      deallocate(ParamData%pzWave)
   end if
   if (allocated(ParamData%uxWave)) then
      deallocate(ParamData%uxWave)
   end if
   if (allocated(ParamData%uyWave)) then
      deallocate(ParamData%uyWave)
   end if
   if (allocated(ParamData%uzWave)) then
      deallocate(ParamData%uzWave)
   end if
   if (allocated(ParamData%axWave)) then
      deallocate(ParamData%axWave)
   end if
   if (allocated(ParamData%ayWave)) then
      deallocate(ParamData%ayWave)
   end if
   if (allocated(ParamData%azWave)) then
      deallocate(ParamData%azWave)
   end if
   if (allocated(ParamData%PDyn)) then
      deallocate(ParamData%PDyn)
   end if
   if (allocated(ParamData%zeta)) then
      deallocate(ParamData%zeta)
   end if
   if (allocated(ParamData%pzCurrent)) then
      deallocate(ParamData%pzCurrent)
   end if
   if (allocated(ParamData%uxCurrent)) then
      deallocate(ParamData%uxCurrent)
   end if
   if (allocated(ParamData%uyCurrent)) then
      deallocate(ParamData%uyCurrent)
   end if
   if (allocated(ParamData%Jac_u_indx)) then
      deallocate(ParamData%Jac_u_indx)
   end if
   if (allocated(ParamData%du)) then
      deallocate(ParamData%du)
   end if
   if (allocated(ParamData%dx)) then
      deallocate(ParamData%dx)
   end if
   if (allocated(ParamData%dxIdx_map2_xStateIdx)) then
      deallocate(ParamData%dxIdx_map2_xStateIdx)
   end if
   if (allocated(ParamData%VisRodsDiam)) then
      LB(1:1) = lbound(ParamData%VisRodsDiam, kind=B8Ki)
      UB(1:1) = ubound(ParamData%VisRodsDiam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_DestroyVisDiam(ParamData%VisRodsDiam(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(ParamData%VisRodsDiam)
   end if
end subroutine

subroutine MD_PackParam(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackParam'
   integer(B8Ki)   :: i1, i2, i3, i4
   integer(B8Ki)   :: LB(4), UB(4)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, InData%nLineTypes)
   call RegPack(RF, InData%nRodTypes)
   call RegPack(RF, InData%nPoints)
   call RegPack(RF, InData%nPointsExtra)
   call RegPack(RF, InData%nBodies)
   call RegPack(RF, InData%nRods)
   call RegPack(RF, InData%nLines)
   call RegPack(RF, InData%nCtrlChans)
   call RegPack(RF, InData%nFails)
   call RegPack(RF, InData%nFreeBodies)
   call RegPack(RF, InData%nFreeRods)
   call RegPack(RF, InData%nFreePoints)
   call RegPackAlloc(RF, InData%nCpldBodies)
   call RegPackAlloc(RF, InData%nCpldRods)
   call RegPackAlloc(RF, InData%nCpldPoints)
   call RegPack(RF, InData%NConns)
   call RegPack(RF, InData%NAnchs)
   call RegPack(RF, InData%Tmax)
   call RegPack(RF, InData%g)
   call RegPack(RF, InData%rhoW)
   call RegPack(RF, InData%WtrDpth)
   call RegPack(RF, InData%kBot)
   call RegPack(RF, InData%cBot)
   call RegPack(RF, InData%dtM0)
   call RegPack(RF, InData%dtCoupling)
   call RegPack(RF, InData%NumOuts)
   call RegPack(RF, InData%dtOut)
   call RegPack(RF, InData%RootName)
   call RegPack(RF, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(RF, 1, lbound(InData%OutParam, kind=B8Ki), ubound(InData%OutParam, kind=B8Ki))
      LB(1:1) = lbound(InData%OutParam, kind=B8Ki)
      UB(1:1) = ubound(InData%OutParam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackOutParmType(RF, InData%OutParam(i1)) 
      end do
   end if
   call RegPack(RF, InData%Delim)
   call RegPack(RF, InData%MDUnOut)
   call RegPack(RF, InData%PriPath)
   call RegPack(RF, InData%writeLog)
   call RegPack(RF, InData%UnLog)
   call RegPack(RF, InData%WaveKin)
   call RegPack(RF, InData%Current)
   call RegPack(RF, InData%nTurbines)
   call RegPackAlloc(RF, InData%TurbineRefPos)
   call RegPack(RF, InData%mu_kT)
   call RegPack(RF, InData%mu_kA)
   call RegPack(RF, InData%mc)
   call RegPack(RF, InData%cv)
   call RegPack(RF, InData%inertialF)
   call RegPack(RF, InData%nxWave)
   call RegPack(RF, InData%nyWave)
   call RegPack(RF, InData%nzWave)
   call RegPack(RF, InData%ntWave)
   call RegPackAlloc(RF, InData%pxWave)
   call RegPackAlloc(RF, InData%pyWave)
   call RegPackAlloc(RF, InData%pzWave)
   call RegPack(RF, InData%dtWave)
   call RegPackAlloc(RF, InData%uxWave)
   call RegPackAlloc(RF, InData%uyWave)
   call RegPackAlloc(RF, InData%uzWave)
   call RegPackAlloc(RF, InData%axWave)
   call RegPackAlloc(RF, InData%ayWave)
   call RegPackAlloc(RF, InData%azWave)
   call RegPackAlloc(RF, InData%PDyn)
   call RegPackAlloc(RF, InData%zeta)
   call RegPack(RF, InData%nzCurrent)
   call RegPackAlloc(RF, InData%pzCurrent)
   call RegPackAlloc(RF, InData%uxCurrent)
   call RegPackAlloc(RF, InData%uyCurrent)
   call RegPack(RF, InData%Nx0)
   call RegPackAlloc(RF, InData%Jac_u_indx)
   call RegPackAlloc(RF, InData%du)
   call RegPackAlloc(RF, InData%dx)
   call RegPack(RF, InData%Jac_ny)
   call RegPack(RF, InData%Jac_nx)
   call RegPackAlloc(RF, InData%dxIdx_map2_xStateIdx)
   call RegPack(RF, InData%VisMeshes)
   call RegPack(RF, allocated(InData%VisRodsDiam))
   if (allocated(InData%VisRodsDiam)) then
      call RegPackBounds(RF, 1, lbound(InData%VisRodsDiam, kind=B8Ki), ubound(InData%VisRodsDiam, kind=B8Ki))
      LB(1:1) = lbound(InData%VisRodsDiam, kind=B8Ki)
      UB(1:1) = ubound(InData%VisRodsDiam, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MD_PackVisDiam(RF, InData%VisRodsDiam(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackParam(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackParam'
   integer(B8Ki)   :: i1, i2, i3, i4
   integer(B8Ki)   :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   call RegUnpack(RF, OutData%nLineTypes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nRodTypes); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nPoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nPointsExtra); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nBodies); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nRods); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nLines); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nCtrlChans); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nFails); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nFreeBodies); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nFreeRods); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nFreePoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%nCpldBodies); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%nCpldRods); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%nCpldPoints); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NConns); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NAnchs); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Tmax); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%g); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%rhoW); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WtrDpth); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%kBot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%cBot); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dtM0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dtCoupling); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%NumOuts); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dtOut); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%RootName); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackOutParmType(RF, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   call RegUnpack(RF, OutData%Delim); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%MDUnOut); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%PriPath); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%writeLog); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%UnLog); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%WaveKin); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Current); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nTurbines); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%TurbineRefPos); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%mu_kT); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%mu_kA); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%mc); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%cv); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%inertialF); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nxWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nyWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nzWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%ntWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%pxWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%pyWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%pzWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%dtWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%uxWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%uyWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%uzWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%axWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%ayWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%azWave); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%PDyn); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%zeta); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%nzCurrent); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%pzCurrent); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%uxCurrent); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%uyCurrent); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Nx0); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%Jac_u_indx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%du); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Jac_ny); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%Jac_nx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%dxIdx_map2_xStateIdx); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpack(RF, OutData%VisMeshes); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%VisRodsDiam)) deallocate(OutData%VisRodsDiam)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%VisRodsDiam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VisRodsDiam.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MD_UnpackVisDiam(RF, OutData%VisRodsDiam(i1)) ! VisRodsDiam 
      end do
   end if
end subroutine

subroutine MD_CopyInput(SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg)
   type(MD_InputType), intent(inout) :: SrcInputData
   type(MD_InputType), intent(inout) :: DstInputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_CopyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcInputData%CoupledKinematics)) then
      LB(1:1) = lbound(SrcInputData%CoupledKinematics, kind=B8Ki)
      UB(1:1) = ubound(SrcInputData%CoupledKinematics, kind=B8Ki)
      if (.not. allocated(DstInputData%CoupledKinematics)) then
         allocate(DstInputData%CoupledKinematics(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CoupledKinematics.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcInputData%CoupledKinematics(i1), DstInputData%CoupledKinematics(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcInputData%DeltaL)) then
      LB(1:1) = lbound(SrcInputData%DeltaL, kind=B8Ki)
      UB(1:1) = ubound(SrcInputData%DeltaL, kind=B8Ki)
      if (.not. allocated(DstInputData%DeltaL)) then
         allocate(DstInputData%DeltaL(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%DeltaL.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%DeltaL = SrcInputData%DeltaL
   end if
   if (allocated(SrcInputData%DeltaLdot)) then
      LB(1:1) = lbound(SrcInputData%DeltaLdot, kind=B8Ki)
      UB(1:1) = ubound(SrcInputData%DeltaLdot, kind=B8Ki)
      if (.not. allocated(DstInputData%DeltaLdot)) then
         allocate(DstInputData%DeltaLdot(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%DeltaLdot.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstInputData%DeltaLdot = SrcInputData%DeltaLdot
   end if
end subroutine

subroutine MD_DestroyInput(InputData, ErrStat, ErrMsg)
   type(MD_InputType), intent(inout) :: InputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_DestroyInput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(InputData%CoupledKinematics)) then
      LB(1:1) = lbound(InputData%CoupledKinematics, kind=B8Ki)
      UB(1:1) = ubound(InputData%CoupledKinematics, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( InputData%CoupledKinematics(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(InputData%CoupledKinematics)
   end if
   if (allocated(InputData%DeltaL)) then
      deallocate(InputData%DeltaL)
   end if
   if (allocated(InputData%DeltaLdot)) then
      deallocate(InputData%DeltaLdot)
   end if
end subroutine

subroutine MD_PackInput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackInput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%CoupledKinematics))
   if (allocated(InData%CoupledKinematics)) then
      call RegPackBounds(RF, 1, lbound(InData%CoupledKinematics, kind=B8Ki), ubound(InData%CoupledKinematics, kind=B8Ki))
      LB(1:1) = lbound(InData%CoupledKinematics, kind=B8Ki)
      UB(1:1) = ubound(InData%CoupledKinematics, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%CoupledKinematics(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%DeltaL)
   call RegPackAlloc(RF, InData%DeltaLdot)
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackInput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackInput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%CoupledKinematics)) deallocate(OutData%CoupledKinematics)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%CoupledKinematics(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoupledKinematics.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%CoupledKinematics(i1)) ! CoupledKinematics 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%DeltaL); if (RegCheckErr(RF, RoutineName)) return
   call RegUnpackAlloc(RF, OutData%DeltaLdot); if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_CopyOutput(SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg)
   type(MD_OutputType), intent(inout) :: SrcOutputData
   type(MD_OutputType), intent(inout) :: DstOutputData
   integer(IntKi),  intent(in   ) :: CtrlCode
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)                  :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_CopyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(SrcOutputData%CoupledLoads)) then
      LB(1:1) = lbound(SrcOutputData%CoupledLoads, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%CoupledLoads, kind=B8Ki)
      if (.not. allocated(DstOutputData%CoupledLoads)) then
         allocate(DstOutputData%CoupledLoads(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%CoupledLoads.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%CoupledLoads(i1), DstOutputData%CoupledLoads(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOutputData%WriteOutput)) then
      LB(1:1) = lbound(SrcOutputData%WriteOutput, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%WriteOutput, kind=B8Ki)
      if (.not. allocated(DstOutputData%WriteOutput)) then
         allocate(DstOutputData%WriteOutput(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      DstOutputData%WriteOutput = SrcOutputData%WriteOutput
   end if
   if (allocated(SrcOutputData%VisLinesMesh)) then
      LB(1:1) = lbound(SrcOutputData%VisLinesMesh, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%VisLinesMesh, kind=B8Ki)
      if (.not. allocated(DstOutputData%VisLinesMesh)) then
         allocate(DstOutputData%VisLinesMesh(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%VisLinesMesh.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%VisLinesMesh(i1), DstOutputData%VisLinesMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOutputData%VisRodsMesh)) then
      LB(1:1) = lbound(SrcOutputData%VisRodsMesh, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%VisRodsMesh, kind=B8Ki)
      if (.not. allocated(DstOutputData%VisRodsMesh)) then
         allocate(DstOutputData%VisRodsMesh(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%VisRodsMesh.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%VisRodsMesh(i1), DstOutputData%VisRodsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOutputData%VisBodiesMesh)) then
      LB(1:1) = lbound(SrcOutputData%VisBodiesMesh, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%VisBodiesMesh, kind=B8Ki)
      if (.not. allocated(DstOutputData%VisBodiesMesh)) then
         allocate(DstOutputData%VisBodiesMesh(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%VisBodiesMesh.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%VisBodiesMesh(i1), DstOutputData%VisBodiesMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
   if (allocated(SrcOutputData%VisAnchsMesh)) then
      LB(1:1) = lbound(SrcOutputData%VisAnchsMesh, kind=B8Ki)
      UB(1:1) = ubound(SrcOutputData%VisAnchsMesh, kind=B8Ki)
      if (.not. allocated(DstOutputData%VisAnchsMesh)) then
         allocate(DstOutputData%VisAnchsMesh(LB(1):UB(1)), stat=ErrStat2)
         if (ErrStat2 /= 0) then
            call SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%VisAnchsMesh.', ErrStat, ErrMsg, RoutineName)
            return
         end if
      end if
      do i1 = LB(1), UB(1)
         call MeshCopy(SrcOutputData%VisAnchsMesh(i1), DstOutputData%VisAnchsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         if (ErrStat >= AbortErrLev) return
      end do
   end if
end subroutine

subroutine MD_DestroyOutput(OutputData, ErrStat, ErrMsg)
   type(MD_OutputType), intent(inout) :: OutputData
   integer(IntKi),  intent(  out) :: ErrStat
   character(*),    intent(  out) :: ErrMsg
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)                 :: ErrStat2
   character(ErrMsgLen)           :: ErrMsg2
   character(*), parameter        :: RoutineName = 'MD_DestroyOutput'
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (allocated(OutputData%CoupledLoads)) then
      LB(1:1) = lbound(OutputData%CoupledLoads, kind=B8Ki)
      UB(1:1) = ubound(OutputData%CoupledLoads, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%CoupledLoads(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%CoupledLoads)
   end if
   if (allocated(OutputData%WriteOutput)) then
      deallocate(OutputData%WriteOutput)
   end if
   if (allocated(OutputData%VisLinesMesh)) then
      LB(1:1) = lbound(OutputData%VisLinesMesh, kind=B8Ki)
      UB(1:1) = ubound(OutputData%VisLinesMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%VisLinesMesh(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%VisLinesMesh)
   end if
   if (allocated(OutputData%VisRodsMesh)) then
      LB(1:1) = lbound(OutputData%VisRodsMesh, kind=B8Ki)
      UB(1:1) = ubound(OutputData%VisRodsMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%VisRodsMesh(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%VisRodsMesh)
   end if
   if (allocated(OutputData%VisBodiesMesh)) then
      LB(1:1) = lbound(OutputData%VisBodiesMesh, kind=B8Ki)
      UB(1:1) = ubound(OutputData%VisBodiesMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%VisBodiesMesh(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%VisBodiesMesh)
   end if
   if (allocated(OutputData%VisAnchsMesh)) then
      LB(1:1) = lbound(OutputData%VisAnchsMesh, kind=B8Ki)
      UB(1:1) = ubound(OutputData%VisAnchsMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshDestroy( OutputData%VisAnchsMesh(i1), ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end do
      deallocate(OutputData%VisAnchsMesh)
   end if
end subroutine

subroutine MD_PackOutput(RF, Indata)
   type(RegFile), intent(inout) :: RF
   type(MD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'MD_PackOutput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   if (RF%ErrStat >= AbortErrLev) return
   call RegPack(RF, allocated(InData%CoupledLoads))
   if (allocated(InData%CoupledLoads)) then
      call RegPackBounds(RF, 1, lbound(InData%CoupledLoads, kind=B8Ki), ubound(InData%CoupledLoads, kind=B8Ki))
      LB(1:1) = lbound(InData%CoupledLoads, kind=B8Ki)
      UB(1:1) = ubound(InData%CoupledLoads, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%CoupledLoads(i1)) 
      end do
   end if
   call RegPackAlloc(RF, InData%WriteOutput)
   call RegPack(RF, allocated(InData%VisLinesMesh))
   if (allocated(InData%VisLinesMesh)) then
      call RegPackBounds(RF, 1, lbound(InData%VisLinesMesh, kind=B8Ki), ubound(InData%VisLinesMesh, kind=B8Ki))
      LB(1:1) = lbound(InData%VisLinesMesh, kind=B8Ki)
      UB(1:1) = ubound(InData%VisLinesMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%VisLinesMesh(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%VisRodsMesh))
   if (allocated(InData%VisRodsMesh)) then
      call RegPackBounds(RF, 1, lbound(InData%VisRodsMesh, kind=B8Ki), ubound(InData%VisRodsMesh, kind=B8Ki))
      LB(1:1) = lbound(InData%VisRodsMesh, kind=B8Ki)
      UB(1:1) = ubound(InData%VisRodsMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%VisRodsMesh(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%VisBodiesMesh))
   if (allocated(InData%VisBodiesMesh)) then
      call RegPackBounds(RF, 1, lbound(InData%VisBodiesMesh, kind=B8Ki), ubound(InData%VisBodiesMesh, kind=B8Ki))
      LB(1:1) = lbound(InData%VisBodiesMesh, kind=B8Ki)
      UB(1:1) = ubound(InData%VisBodiesMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%VisBodiesMesh(i1)) 
      end do
   end if
   call RegPack(RF, allocated(InData%VisAnchsMesh))
   if (allocated(InData%VisAnchsMesh)) then
      call RegPackBounds(RF, 1, lbound(InData%VisAnchsMesh, kind=B8Ki), ubound(InData%VisAnchsMesh, kind=B8Ki))
      LB(1:1) = lbound(InData%VisAnchsMesh, kind=B8Ki)
      UB(1:1) = ubound(InData%VisAnchsMesh, kind=B8Ki)
      do i1 = LB(1), UB(1)
         call MeshPack(RF, InData%VisAnchsMesh(i1)) 
      end do
   end if
   if (RegCheckErr(RF, RoutineName)) return
end subroutine

subroutine MD_UnPackOutput(RF, OutData)
   type(RegFile), intent(inout)    :: RF
   type(MD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'MD_UnPackOutput'
   integer(B8Ki)   :: i1
   integer(B8Ki)   :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (RF%ErrStat /= ErrID_None) return
   if (allocated(OutData%CoupledLoads)) deallocate(OutData%CoupledLoads)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%CoupledLoads(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CoupledLoads.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%CoupledLoads(i1)) ! CoupledLoads 
      end do
   end if
   call RegUnpackAlloc(RF, OutData%WriteOutput); if (RegCheckErr(RF, RoutineName)) return
   if (allocated(OutData%VisLinesMesh)) deallocate(OutData%VisLinesMesh)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%VisLinesMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VisLinesMesh.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%VisLinesMesh(i1)) ! VisLinesMesh 
      end do
   end if
   if (allocated(OutData%VisRodsMesh)) deallocate(OutData%VisRodsMesh)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%VisRodsMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VisRodsMesh.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%VisRodsMesh(i1)) ! VisRodsMesh 
      end do
   end if
   if (allocated(OutData%VisBodiesMesh)) deallocate(OutData%VisBodiesMesh)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%VisBodiesMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VisBodiesMesh.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%VisBodiesMesh(i1)) ! VisBodiesMesh 
      end do
   end if
   if (allocated(OutData%VisAnchsMesh)) deallocate(OutData%VisAnchsMesh)
   call RegUnpack(RF, IsAllocAssoc); if (RegCheckErr(RF, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(RF, 1, LB, UB); if (RegCheckErr(RF, RoutineName)) return
      allocate(OutData%VisAnchsMesh(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VisAnchsMesh.', RF%ErrStat, RF%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call MeshUnpack(RF, OutData%VisAnchsMesh(i1)) ! VisAnchsMesh 
      end do
   end if
end subroutine

subroutine MD_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
   ! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(MD_InputType), intent(inout)  :: u(:) ! Input at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Inputs
   type(MD_InputType), intent(inout)  :: u_out ! Input at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'MD_Input_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(u)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(u)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(u) - 1
   select case (order)
   case (0)
      call MD_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call MD_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call MD_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(u) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE MD_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

   TYPE(MD_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
   TYPE(MD_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
   TYPE(MD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'MD_Input_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(u_out%CoupledKinematics) .AND. ALLOCATED(u1%CoupledKinematics)) THEN
      DO i1 = LBOUND(u_out%CoupledKinematics,1, kind=B8Ki),UBOUND(u_out%CoupledKinematics,1, kind=B8Ki)
         CALL MeshExtrapInterp1(u1%CoupledKinematics(i1), u2%CoupledKinematics(i1), tin, u_out%CoupledKinematics(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(u_out%DeltaL) .AND. ALLOCATED(u1%DeltaL)) THEN
      u_out%DeltaL = a1*u1%DeltaL + a2*u2%DeltaL
   END IF ! check if allocated
   IF (ALLOCATED(u_out%DeltaLdot) .AND. ALLOCATED(u1%DeltaLdot)) THEN
      u_out%DeltaLdot = a1*u1%DeltaLdot + a2*u2%DeltaLdot
   END IF ! check if allocated
END SUBROUTINE

SUBROUTINE MD_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

   TYPE(MD_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
   TYPE(MD_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
   TYPE(MD_InputType), INTENT(INOUT)  :: u3      ! Input at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
   TYPE(MD_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'MD_Input_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(u_out%CoupledKinematics) .AND. ALLOCATED(u1%CoupledKinematics)) THEN
      DO i1 = LBOUND(u_out%CoupledKinematics,1, kind=B8Ki),UBOUND(u_out%CoupledKinematics,1, kind=B8Ki)
         CALL MeshExtrapInterp2(u1%CoupledKinematics(i1), u2%CoupledKinematics(i1), u3%CoupledKinematics(i1), tin, u_out%CoupledKinematics(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(u_out%DeltaL) .AND. ALLOCATED(u1%DeltaL)) THEN
      u_out%DeltaL = a1*u1%DeltaL + a2*u2%DeltaL + a3*u3%DeltaL
   END IF ! check if allocated
   IF (ALLOCATED(u_out%DeltaLdot) .AND. ALLOCATED(u1%DeltaLdot)) THEN
      u_out%DeltaLdot = a1*u1%DeltaLdot + a2*u2%DeltaLdot + a3*u3%DeltaLdot
   END IF ! check if allocated
END SUBROUTINE

subroutine MD_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg)
   !
   ! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
   ! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
   !
   !  expressions below based on either
   !
   !  f(t) = a
   !  f(t) = a + b * t, or
   !  f(t) = a + b * t + c * t**2
   !
   !  where a, b and c are determined as the solution to
   !  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
   !
   !----------------------------------------------------------------------------------------------------------------------------------
   
   type(MD_OutputType), intent(inout)  :: y(:) ! Output at t1 > t2 > t3
   real(DbKi),                 intent(in   )  :: t(:)           ! Times associated with the Outputs
   type(MD_OutputType), intent(inout)  :: y_out ! Output at tin_out
   real(DbKi),                 intent(in   )  :: t_out           ! time to be extrap/interp'd to
   integer(IntKi),             intent(  out)  :: ErrStat         ! Error status of the operation
   character(*),               intent(  out)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
   integer(IntKi)                             :: order           ! order of polynomial fit (max 2)
   integer(IntKi)                             :: ErrStat2        ! local errors
   character(ErrMsgLen)                       :: ErrMsg2         ! local errors
   character(*),    PARAMETER                 :: RoutineName = 'MD_Output_ExtrapInterp'
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   if (size(t) /= size(y)) then
      call SetErrStat(ErrID_Fatal, 'size(t) must equal size(y)', ErrStat, ErrMsg, RoutineName)
      return
   endif
   order = size(y) - 1
   select case (order)
   case (0)
      call MD_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (1)
      call MD_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case (2)
      call MD_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   case default
      call SetErrStat(ErrID_Fatal, 'size(y) must be less than 4 (order must be less than 3).', ErrStat, ErrMsg, RoutineName)
      return
   end select
end subroutine

SUBROUTINE MD_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

   TYPE(MD_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
   TYPE(MD_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
   REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
   TYPE(MD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
   REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
   INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
   CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
   CHARACTER(*),                    PARAMETER :: RoutineName = 'MD_Output_ExtrapInterp1'
   REAL(DbKi)                                 :: a1, a2   ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   INTEGER                                    :: i01      ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1       ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF (EqualRealNos(t(1), t(2))) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg, RoutineName)
      RETURN
   END IF
   
   ! Calculate weighting factors from Lagrange polynomial
   a1 = -(t_out - t(2))/t(2)
   a2 = t_out/t(2)
   
   IF (ALLOCATED(y_out%CoupledLoads) .AND. ALLOCATED(y1%CoupledLoads)) THEN
      DO i1 = LBOUND(y_out%CoupledLoads,1, kind=B8Ki),UBOUND(y_out%CoupledLoads,1, kind=B8Ki)
         CALL MeshExtrapInterp1(y1%CoupledLoads(i1), y2%CoupledLoads(i1), tin, y_out%CoupledLoads(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
      y_out%WriteOutput = a1*y1%WriteOutput + a2*y2%WriteOutput
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisLinesMesh) .AND. ALLOCATED(y1%VisLinesMesh)) THEN
      DO i1 = LBOUND(y_out%VisLinesMesh,1, kind=B8Ki),UBOUND(y_out%VisLinesMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp1(y1%VisLinesMesh(i1), y2%VisLinesMesh(i1), tin, y_out%VisLinesMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisRodsMesh) .AND. ALLOCATED(y1%VisRodsMesh)) THEN
      DO i1 = LBOUND(y_out%VisRodsMesh,1, kind=B8Ki),UBOUND(y_out%VisRodsMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp1(y1%VisRodsMesh(i1), y2%VisRodsMesh(i1), tin, y_out%VisRodsMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisBodiesMesh) .AND. ALLOCATED(y1%VisBodiesMesh)) THEN
      DO i1 = LBOUND(y_out%VisBodiesMesh,1, kind=B8Ki),UBOUND(y_out%VisBodiesMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp1(y1%VisBodiesMesh(i1), y2%VisBodiesMesh(i1), tin, y_out%VisBodiesMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisAnchsMesh) .AND. ALLOCATED(y1%VisAnchsMesh)) THEN
      DO i1 = LBOUND(y_out%VisAnchsMesh,1, kind=B8Ki),UBOUND(y_out%VisAnchsMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp1(y1%VisAnchsMesh(i1), y2%VisAnchsMesh(i1), tin, y_out%VisAnchsMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
END SUBROUTINE

SUBROUTINE MD_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

   TYPE(MD_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
   TYPE(MD_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
   TYPE(MD_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
   REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
   TYPE(MD_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
   REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
   INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
   CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
   REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
   REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
   INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
   REAL(DbKi)                                 :: a1,a2,a3 ! temporary for extrapolation/interpolation
   INTEGER(IntKi)                             :: ErrStat2 ! local errors
   CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
   CHARACTER(*),            PARAMETER         :: RoutineName = 'MD_Output_ExtrapInterp2'
   INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
   INTEGER                                    :: i1    ! dim1 counter variable for arrays
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   ! we'll subtract a constant from the times to resolve some 
   ! numerical issues when t gets large (and to simplify the equations)
   t = tin - tin(1)
   t_out = tin_out - tin(1)
   
   IF ( EqualRealNos( t(1), t(2) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
      CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
      RETURN
   END IF
   
   ! Calculate Lagrange polynomial coefficients
   a1 = (t_out - t(2))*(t_out - t(3))/((t(1) - t(2))*(t(1) - t(3)))
   a2 = (t_out - t(1))*(t_out - t(3))/((t(2) - t(1))*(t(2) - t(3)))
   a3 = (t_out - t(1))*(t_out - t(2))/((t(3) - t(1))*(t(3) - t(2)))
   IF (ALLOCATED(y_out%CoupledLoads) .AND. ALLOCATED(y1%CoupledLoads)) THEN
      DO i1 = LBOUND(y_out%CoupledLoads,1, kind=B8Ki),UBOUND(y_out%CoupledLoads,1, kind=B8Ki)
         CALL MeshExtrapInterp2(y1%CoupledLoads(i1), y2%CoupledLoads(i1), y3%CoupledLoads(i1), tin, y_out%CoupledLoads(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
      y_out%WriteOutput = a1*y1%WriteOutput + a2*y2%WriteOutput + a3*y3%WriteOutput
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisLinesMesh) .AND. ALLOCATED(y1%VisLinesMesh)) THEN
      DO i1 = LBOUND(y_out%VisLinesMesh,1, kind=B8Ki),UBOUND(y_out%VisLinesMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp2(y1%VisLinesMesh(i1), y2%VisLinesMesh(i1), y3%VisLinesMesh(i1), tin, y_out%VisLinesMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisRodsMesh) .AND. ALLOCATED(y1%VisRodsMesh)) THEN
      DO i1 = LBOUND(y_out%VisRodsMesh,1, kind=B8Ki),UBOUND(y_out%VisRodsMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp2(y1%VisRodsMesh(i1), y2%VisRodsMesh(i1), y3%VisRodsMesh(i1), tin, y_out%VisRodsMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisBodiesMesh) .AND. ALLOCATED(y1%VisBodiesMesh)) THEN
      DO i1 = LBOUND(y_out%VisBodiesMesh,1, kind=B8Ki),UBOUND(y_out%VisBodiesMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp2(y1%VisBodiesMesh(i1), y2%VisBodiesMesh(i1), y3%VisBodiesMesh(i1), tin, y_out%VisBodiesMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
   IF (ALLOCATED(y_out%VisAnchsMesh) .AND. ALLOCATED(y1%VisAnchsMesh)) THEN
      DO i1 = LBOUND(y_out%VisAnchsMesh,1, kind=B8Ki),UBOUND(y_out%VisAnchsMesh,1, kind=B8Ki)
         CALL MeshExtrapInterp2(y1%VisAnchsMesh(i1), y2%VisAnchsMesh(i1), y3%VisAnchsMesh(i1), tin, y_out%VisAnchsMesh(i1), tin_out, ErrStat2, ErrMsg2)
            CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      END DO
   END IF ! check if allocated
END SUBROUTINE
END MODULE MoorDyn_Types
!ENDOFREGISTRYGENERATEDFILE
