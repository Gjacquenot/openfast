!STARTOFREGISTRYGENERATEDFILE 'Lidar_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Lidar_Types
!.................................................................................................................................
! This file is part of Lidar.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Lidar. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Lidar_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SensorType_None = 0
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SensorType_SinglePoint = 1
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SensorType_ContinuousLidar = 2
    INTEGER(IntKi), PUBLIC, PARAMETER  :: SensorType_PulsedLidar = 3
! =========  Lidar_InitInputType  =======
  TYPE, PUBLIC :: Lidar_InitInputType
    INTEGER(IntKi)  :: SensorType = SensorType_None      !< SensorType_* parameter [-]
    REAL(DbKi)  :: Tmax      !< the length of the simulation [s]
    REAL(ReKi) , DIMENSION(1:3)  :: RotorApexOffsetPos      !< position of the lidar unit relative to the rotor apex of rotation [m]
    REAL(ReKi) , DIMENSION(1:3)  :: HubPosition      !< initial position of the hub (lidar mounted on hub) [0,0,HubHeight] [m]
    INTEGER(IntKi)  :: NumPulseGate      !< the number of range gates to return wind speeds at [-]
    LOGICAL  :: LidRadialVel      !< TRUE => return radial component, FALSE => return 'x' direction estimate [-]
  END TYPE Lidar_InitInputType
! =======================
! =========  Lidar_InitOutputType  =======
  TYPE, PUBLIC :: Lidar_InitOutputType
    REAL(ReKi)  :: DummyInitOut 
  END TYPE Lidar_InitOutputType
! =======================
! =========  Lidar_ParameterType  =======
  TYPE, PUBLIC :: Lidar_ParameterType
    INTEGER(IntKi)  :: NumPulseGate      !< the number of range gates to return wind speeds at; pulsed lidar only [-]
    REAL(ReKi) , DIMENSION(1:3)  :: RotorApexOffsetPos      !< position of the lidar unit relative to the rotor apex of rotation [m]
    REAL(ReKi)  :: RayRangeSq      !< Rayleigh Range Squared [-]
    REAL(ReKi)  :: SpatialRes      !< spatial sampling distance of weighting function (1/2)*(avg ws)*dt [-]
    INTEGER(IntKi)  :: SensorType      !< SensorType_* parameter [-]
    REAL(ReKi)  :: WtFnTrunc      !< Percentage of the peak value at which to truncate weighting function [-]
    REAL(ReKi)  :: PulseRangeOne      !< the range to the closest range gate [m]
    REAL(ReKi)  :: DeltaP      !< the distance between range gates [m]
    REAL(ReKi)  :: DeltaR      !< the FWHM width of the pulse [-]
    REAL(ReKi)  :: r_p 
    LOGICAL  :: LidRadialVel      !< TRUE => return radial component, FALSE => return 'x' direction estimate [-]
    REAL(ReKi)  :: DisplacementLidarX      !< Displacement of the lidar system from the focal measurement point [m]
    REAL(ReKi)  :: DisplacementLidarY      !< Displacement of the lidar system from the focal measurement point [m]
    REAL(ReKi)  :: DisplacementLidarZ      !< Displacement of the lidar system from the focal measurement point [m]
    INTEGER(IntKi)  :: NumBeam      !< Number of lidar beams [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FocalDistanceX      !< LIDAR LOS focal distance co-ordinates in the x direction [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FocalDistanceY      !< LIDAR LOS focal distance co-ordinates in the y direction [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FocalDistanceZ      !< LIDAR LOS focal distance co-ordinates in the z direction [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MsrPosition      !< Position of the desired wind measurement (was XMsrPt, YMsrPt, ZMsrPt) [m]
    REAL(ReKi)  :: PulseSpacing      !< Distance between range gates [m]
    REAL(ReKi)  :: URefLid      !< Reference average wind speed for the lidar [m/s]
    INTEGER(IntKi)  :: ConsiderHubMotion      !< Flag whether to consider the hub motion's impact on the Lidar measurement [-]
    REAL(ReKi)  :: MeasurementInterval      !< Time steps between lidar measurements [s]
    REAL(ReKi) , DIMENSION(1:3)  :: LidPosition      !< Position of the Lidar unit (was XLidPt, YLidPt, ZLidPt) [m]
  END TYPE Lidar_ParameterType
! =======================
! =========  Lidar_ContinuousStateType  =======
  TYPE, PUBLIC :: Lidar_ContinuousStateType
    REAL(ReKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
  END TYPE Lidar_ContinuousStateType
! =======================
! =========  Lidar_DiscreteStateType  =======
  TYPE, PUBLIC :: Lidar_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !< Remove this variable if you have discrete states [-]
  END TYPE Lidar_DiscreteStateType
! =======================
! =========  Lidar_ConstraintStateType  =======
  TYPE, PUBLIC :: Lidar_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE Lidar_ConstraintStateType
! =======================
! =========  Lidar_OtherStateType  =======
  TYPE, PUBLIC :: Lidar_OtherStateType
    REAL(ReKi)  :: DummyOtherState 
  END TYPE Lidar_OtherStateType
! =======================
! =========  Lidar_MiscVarType  =======
  TYPE, PUBLIC :: Lidar_MiscVarType
    REAL(ReKi)  :: DummyMiscVar      !< Remove this variable if you have misc variables [-]
  END TYPE Lidar_MiscVarType
! =======================
! =========  Lidar_InputType  =======
  TYPE, PUBLIC :: Lidar_InputType
    REAL(ReKi)  :: PulseLidEl      !< the angle off of the x axis that the lidar is aimed (0 would be staring directly upwind, pi/2 would be staring perpendicular to the x axis) [-]
    REAL(ReKi)  :: PulseLidAz      !< the angle in the YZ plane that the lidar is staring (if PulseLidEl is set to pi/2, then 0 would be aligned with the positive z axis, pi/2 would be aligned with the positive y axis) [-]
    REAL(ReKi)  :: HubDisplacementX      !< X direction hub displacement of the lidar (from ElastoDyn) [m]
    REAL(ReKi)  :: HubDisplacementY      !< Y direction hub displacement of the lidar (from ElastoDyn) [m]
    REAL(ReKi)  :: HubDisplacementZ      !< Z direction hub displacement of the lidar (from ElastoDyn) [m]
  END TYPE Lidar_InputType
! =======================
! =========  Lidar_OutputType  =======
  TYPE, PUBLIC :: Lidar_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LidSpeed      !< Speed detected by Lidar at measurement point (range gates for pulsed lidar) [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WtTrunc      !< Contains the fraction of the peak that the weighting function was truncated at (for when truncated early). [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsX      !< Lidar X direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsY      !< Lidar Y direction measurement points [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: MsrPositionsZ      !< Lidar Z direction measurement points [m]
  END TYPE Lidar_OutputType
! =======================
CONTAINS
 SUBROUTINE Lidar_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(Lidar_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%SensorType = SrcInitInputData%SensorType
    DstInitInputData%Tmax = SrcInitInputData%Tmax
    DstInitInputData%RotorApexOffsetPos = SrcInitInputData%RotorApexOffsetPos
    DstInitInputData%HubPosition = SrcInitInputData%HubPosition
    DstInitInputData%NumPulseGate = SrcInitInputData%NumPulseGate
    DstInitInputData%LidRadialVel = SrcInitInputData%LidRadialVel
 END SUBROUTINE Lidar_CopyInitInput

 SUBROUTINE Lidar_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Lidar_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyInitInput


subroutine Lidar_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! SensorType
   call RegPack(Buf, InData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegPack(Buf, InData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotorApexOffsetPos
   call RegPack(Buf, InData%RotorApexOffsetPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubPosition
   call RegPack(Buf, InData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegPack(Buf, InData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidRadialVel
   call RegPack(Buf, InData%LidRadialVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackInitInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! SensorType
   call RegUnpack(Buf, OutData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tmax
   call RegUnpack(Buf, OutData%Tmax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotorApexOffsetPos
   call RegUnpack(Buf, OutData%RotorApexOffsetPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubPosition
   call RegUnpack(Buf, OutData%HubPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumPulseGate
   call RegUnpack(Buf, OutData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidRadialVel
   call RegUnpack(Buf, OutData%LidRadialVel)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(Lidar_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%DummyInitOut = SrcInitOutputData%DummyInitOut
 END SUBROUTINE Lidar_CopyInitOutput

 SUBROUTINE Lidar_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Lidar_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyInitOutput


subroutine Lidar_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyInitOut
   call RegPack(Buf, InData%DummyInitOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyInitOut
   call RegUnpack(Buf, OutData%DummyInitOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(Lidar_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%NumPulseGate = SrcParamData%NumPulseGate
    DstParamData%RotorApexOffsetPos = SrcParamData%RotorApexOffsetPos
    DstParamData%RayRangeSq = SrcParamData%RayRangeSq
    DstParamData%SpatialRes = SrcParamData%SpatialRes
    DstParamData%SensorType = SrcParamData%SensorType
    DstParamData%WtFnTrunc = SrcParamData%WtFnTrunc
    DstParamData%PulseRangeOne = SrcParamData%PulseRangeOne
    DstParamData%DeltaP = SrcParamData%DeltaP
    DstParamData%DeltaR = SrcParamData%DeltaR
    DstParamData%r_p = SrcParamData%r_p
    DstParamData%LidRadialVel = SrcParamData%LidRadialVel
    DstParamData%DisplacementLidarX = SrcParamData%DisplacementLidarX
    DstParamData%DisplacementLidarY = SrcParamData%DisplacementLidarY
    DstParamData%DisplacementLidarZ = SrcParamData%DisplacementLidarZ
    DstParamData%NumBeam = SrcParamData%NumBeam
IF (ALLOCATED(SrcParamData%FocalDistanceX)) THEN
  i1_l = LBOUND(SrcParamData%FocalDistanceX,1)
  i1_u = UBOUND(SrcParamData%FocalDistanceX,1)
  IF (.NOT. ALLOCATED(DstParamData%FocalDistanceX)) THEN 
    ALLOCATE(DstParamData%FocalDistanceX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FocalDistanceX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%FocalDistanceX = SrcParamData%FocalDistanceX
ENDIF
IF (ALLOCATED(SrcParamData%FocalDistanceY)) THEN
  i1_l = LBOUND(SrcParamData%FocalDistanceY,1)
  i1_u = UBOUND(SrcParamData%FocalDistanceY,1)
  IF (.NOT. ALLOCATED(DstParamData%FocalDistanceY)) THEN 
    ALLOCATE(DstParamData%FocalDistanceY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FocalDistanceY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%FocalDistanceY = SrcParamData%FocalDistanceY
ENDIF
IF (ALLOCATED(SrcParamData%FocalDistanceZ)) THEN
  i1_l = LBOUND(SrcParamData%FocalDistanceZ,1)
  i1_u = UBOUND(SrcParamData%FocalDistanceZ,1)
  IF (.NOT. ALLOCATED(DstParamData%FocalDistanceZ)) THEN 
    ALLOCATE(DstParamData%FocalDistanceZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FocalDistanceZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%FocalDistanceZ = SrcParamData%FocalDistanceZ
ENDIF
IF (ALLOCATED(SrcParamData%MsrPosition)) THEN
  i1_l = LBOUND(SrcParamData%MsrPosition,1)
  i1_u = UBOUND(SrcParamData%MsrPosition,1)
  i2_l = LBOUND(SrcParamData%MsrPosition,2)
  i2_u = UBOUND(SrcParamData%MsrPosition,2)
  IF (.NOT. ALLOCATED(DstParamData%MsrPosition)) THEN 
    ALLOCATE(DstParamData%MsrPosition(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MsrPosition.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MsrPosition = SrcParamData%MsrPosition
ENDIF
    DstParamData%PulseSpacing = SrcParamData%PulseSpacing
    DstParamData%URefLid = SrcParamData%URefLid
    DstParamData%ConsiderHubMotion = SrcParamData%ConsiderHubMotion
    DstParamData%MeasurementInterval = SrcParamData%MeasurementInterval
    DstParamData%LidPosition = SrcParamData%LidPosition
 END SUBROUTINE Lidar_CopyParam

 SUBROUTINE Lidar_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(Lidar_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%FocalDistanceX)) THEN
  DEALLOCATE(ParamData%FocalDistanceX)
ENDIF
IF (ALLOCATED(ParamData%FocalDistanceY)) THEN
  DEALLOCATE(ParamData%FocalDistanceY)
ENDIF
IF (ALLOCATED(ParamData%FocalDistanceZ)) THEN
  DEALLOCATE(ParamData%FocalDistanceZ)
ENDIF
IF (ALLOCATED(ParamData%MsrPosition)) THEN
  DEALLOCATE(ParamData%MsrPosition)
ENDIF
 END SUBROUTINE Lidar_DestroyParam


subroutine Lidar_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumPulseGate
   call RegPack(Buf, InData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotorApexOffsetPos
   call RegPack(Buf, InData%RotorApexOffsetPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RayRangeSq
   call RegPack(Buf, InData%RayRangeSq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpatialRes
   call RegPack(Buf, InData%SpatialRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegPack(Buf, InData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtFnTrunc
   call RegPack(Buf, InData%WtFnTrunc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseRangeOne
   call RegPack(Buf, InData%PulseRangeOne)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DeltaP
   call RegPack(Buf, InData%DeltaP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DeltaR
   call RegPack(Buf, InData%DeltaR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_p
   call RegPack(Buf, InData%r_p)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidRadialVel
   call RegPack(Buf, InData%LidRadialVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisplacementLidarX
   call RegPack(Buf, InData%DisplacementLidarX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisplacementLidarY
   call RegPack(Buf, InData%DisplacementLidarY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisplacementLidarZ
   call RegPack(Buf, InData%DisplacementLidarZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegPack(Buf, InData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FocalDistanceX
   call RegPack(Buf, allocated(InData%FocalDistanceX))
   if (allocated(InData%FocalDistanceX)) then
      call RegPackBounds(Buf, 1, lbound(InData%FocalDistanceX), ubound(InData%FocalDistanceX))
      call RegPack(Buf, InData%FocalDistanceX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FocalDistanceY
   call RegPack(Buf, allocated(InData%FocalDistanceY))
   if (allocated(InData%FocalDistanceY)) then
      call RegPackBounds(Buf, 1, lbound(InData%FocalDistanceY), ubound(InData%FocalDistanceY))
      call RegPack(Buf, InData%FocalDistanceY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FocalDistanceZ
   call RegPack(Buf, allocated(InData%FocalDistanceZ))
   if (allocated(InData%FocalDistanceZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%FocalDistanceZ), ubound(InData%FocalDistanceZ))
      call RegPack(Buf, InData%FocalDistanceZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPosition
   call RegPack(Buf, allocated(InData%MsrPosition))
   if (allocated(InData%MsrPosition)) then
      call RegPackBounds(Buf, 2, lbound(InData%MsrPosition), ubound(InData%MsrPosition))
      call RegPack(Buf, InData%MsrPosition)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseSpacing
   call RegPack(Buf, InData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegPack(Buf, InData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConsiderHubMotion
   call RegPack(Buf, InData%ConsiderHubMotion)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeasurementInterval
   call RegPack(Buf, InData%MeasurementInterval)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidPosition
   call RegPack(Buf, InData%LidPosition)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackParam'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NumPulseGate
   call RegUnpack(Buf, OutData%NumPulseGate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotorApexOffsetPos
   call RegUnpack(Buf, OutData%RotorApexOffsetPos)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RayRangeSq
   call RegUnpack(Buf, OutData%RayRangeSq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SpatialRes
   call RegUnpack(Buf, OutData%SpatialRes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SensorType
   call RegUnpack(Buf, OutData%SensorType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtFnTrunc
   call RegUnpack(Buf, OutData%WtFnTrunc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseRangeOne
   call RegUnpack(Buf, OutData%PulseRangeOne)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DeltaP
   call RegUnpack(Buf, OutData%DeltaP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DeltaR
   call RegUnpack(Buf, OutData%DeltaR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! r_p
   call RegUnpack(Buf, OutData%r_p)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidRadialVel
   call RegUnpack(Buf, OutData%LidRadialVel)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisplacementLidarX
   call RegUnpack(Buf, OutData%DisplacementLidarX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisplacementLidarY
   call RegUnpack(Buf, OutData%DisplacementLidarY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DisplacementLidarZ
   call RegUnpack(Buf, OutData%DisplacementLidarZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumBeam
   call RegUnpack(Buf, OutData%NumBeam)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FocalDistanceX
   if (allocated(OutData%FocalDistanceX)) deallocate(OutData%FocalDistanceX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FocalDistanceX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FocalDistanceX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FocalDistanceX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FocalDistanceY
   if (allocated(OutData%FocalDistanceY)) deallocate(OutData%FocalDistanceY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FocalDistanceY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FocalDistanceY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FocalDistanceY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FocalDistanceZ
   if (allocated(OutData%FocalDistanceZ)) deallocate(OutData%FocalDistanceZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FocalDistanceZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FocalDistanceZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FocalDistanceZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPosition
   if (allocated(OutData%MsrPosition)) deallocate(OutData%MsrPosition)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPosition(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPosition.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPosition)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PulseSpacing
   call RegUnpack(Buf, OutData%PulseSpacing)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URefLid
   call RegUnpack(Buf, OutData%URefLid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConsiderHubMotion
   call RegUnpack(Buf, OutData%ConsiderHubMotion)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeasurementInterval
   call RegUnpack(Buf, OutData%MeasurementInterval)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LidPosition
   call RegUnpack(Buf, OutData%LidPosition)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(Lidar_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE Lidar_CopyContState

 SUBROUTINE Lidar_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(Lidar_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyContState


subroutine Lidar_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyContState
   call RegPack(Buf, InData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyContState
   call RegUnpack(Buf, OutData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(Lidar_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE Lidar_CopyDiscState

 SUBROUTINE Lidar_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(Lidar_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyDiscState


subroutine Lidar_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyDiscState
   call RegPack(Buf, InData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyDiscState
   call RegUnpack(Buf, OutData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(Lidar_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE Lidar_CopyConstrState

 SUBROUTINE Lidar_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(Lidar_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyConstrState


subroutine Lidar_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(Lidar_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%DummyOtherState = SrcOtherStateData%DummyOtherState
 END SUBROUTINE Lidar_CopyOtherState

 SUBROUTINE Lidar_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(Lidar_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyOtherState


subroutine Lidar_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyOtherState
   call RegPack(Buf, InData%DummyOtherState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyOtherState
   call RegUnpack(Buf, OutData%DummyOtherState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(Lidar_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%DummyMiscVar = SrcMiscData%DummyMiscVar
 END SUBROUTINE Lidar_CopyMisc

 SUBROUTINE Lidar_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(Lidar_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyMisc


subroutine Lidar_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyMiscVar
   call RegPack(Buf, InData%DummyMiscVar)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyMiscVar
   call RegUnpack(Buf, OutData%DummyMiscVar)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_InputType), INTENT(IN) :: SrcInputData
   TYPE(Lidar_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputData%PulseLidEl = SrcInputData%PulseLidEl
    DstInputData%PulseLidAz = SrcInputData%PulseLidAz
    DstInputData%HubDisplacementX = SrcInputData%HubDisplacementX
    DstInputData%HubDisplacementY = SrcInputData%HubDisplacementY
    DstInputData%HubDisplacementZ = SrcInputData%HubDisplacementZ
 END SUBROUTINE Lidar_CopyInput

 SUBROUTINE Lidar_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(Lidar_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Lidar_DestroyInput


subroutine Lidar_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! PulseLidEl
   call RegPack(Buf, InData%PulseLidEl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseLidAz
   call RegPack(Buf, InData%PulseLidAz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubDisplacementX
   call RegPack(Buf, InData%HubDisplacementX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubDisplacementY
   call RegPack(Buf, InData%HubDisplacementY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubDisplacementZ
   call RegPack(Buf, InData%HubDisplacementZ)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! PulseLidEl
   call RegUnpack(Buf, OutData%PulseLidEl)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PulseLidAz
   call RegUnpack(Buf, OutData%PulseLidAz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubDisplacementX
   call RegUnpack(Buf, OutData%HubDisplacementX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubDisplacementY
   call RegUnpack(Buf, OutData%HubDisplacementY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HubDisplacementZ
   call RegUnpack(Buf, OutData%HubDisplacementZ)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Lidar_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Lidar_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(Lidar_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Lidar_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%LidSpeed)) THEN
  i1_l = LBOUND(SrcOutputData%LidSpeed,1)
  i1_u = UBOUND(SrcOutputData%LidSpeed,1)
  IF (.NOT. ALLOCATED(DstOutputData%LidSpeed)) THEN 
    ALLOCATE(DstOutputData%LidSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%LidSpeed.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%LidSpeed = SrcOutputData%LidSpeed
ENDIF
IF (ALLOCATED(SrcOutputData%WtTrunc)) THEN
  i1_l = LBOUND(SrcOutputData%WtTrunc,1)
  i1_u = UBOUND(SrcOutputData%WtTrunc,1)
  IF (.NOT. ALLOCATED(DstOutputData%WtTrunc)) THEN 
    ALLOCATE(DstOutputData%WtTrunc(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WtTrunc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WtTrunc = SrcOutputData%WtTrunc
ENDIF
IF (ALLOCATED(SrcOutputData%MsrPositionsX)) THEN
  i1_l = LBOUND(SrcOutputData%MsrPositionsX,1)
  i1_u = UBOUND(SrcOutputData%MsrPositionsX,1)
  IF (.NOT. ALLOCATED(DstOutputData%MsrPositionsX)) THEN 
    ALLOCATE(DstOutputData%MsrPositionsX(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%MsrPositionsX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%MsrPositionsX = SrcOutputData%MsrPositionsX
ENDIF
IF (ALLOCATED(SrcOutputData%MsrPositionsY)) THEN
  i1_l = LBOUND(SrcOutputData%MsrPositionsY,1)
  i1_u = UBOUND(SrcOutputData%MsrPositionsY,1)
  IF (.NOT. ALLOCATED(DstOutputData%MsrPositionsY)) THEN 
    ALLOCATE(DstOutputData%MsrPositionsY(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%MsrPositionsY.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%MsrPositionsY = SrcOutputData%MsrPositionsY
ENDIF
IF (ALLOCATED(SrcOutputData%MsrPositionsZ)) THEN
  i1_l = LBOUND(SrcOutputData%MsrPositionsZ,1)
  i1_u = UBOUND(SrcOutputData%MsrPositionsZ,1)
  IF (.NOT. ALLOCATED(DstOutputData%MsrPositionsZ)) THEN 
    ALLOCATE(DstOutputData%MsrPositionsZ(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%MsrPositionsZ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%MsrPositionsZ = SrcOutputData%MsrPositionsZ
ENDIF
 END SUBROUTINE Lidar_CopyOutput

 SUBROUTINE Lidar_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(Lidar_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Lidar_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%LidSpeed)) THEN
  DEALLOCATE(OutputData%LidSpeed)
ENDIF
IF (ALLOCATED(OutputData%WtTrunc)) THEN
  DEALLOCATE(OutputData%WtTrunc)
ENDIF
IF (ALLOCATED(OutputData%MsrPositionsX)) THEN
  DEALLOCATE(OutputData%MsrPositionsX)
ENDIF
IF (ALLOCATED(OutputData%MsrPositionsY)) THEN
  DEALLOCATE(OutputData%MsrPositionsY)
ENDIF
IF (ALLOCATED(OutputData%MsrPositionsZ)) THEN
  DEALLOCATE(OutputData%MsrPositionsZ)
ENDIF
 END SUBROUTINE Lidar_DestroyOutput


subroutine Lidar_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Lidar_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Lidar_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! LidSpeed
   call RegPack(Buf, allocated(InData%LidSpeed))
   if (allocated(InData%LidSpeed)) then
      call RegPackBounds(Buf, 1, lbound(InData%LidSpeed), ubound(InData%LidSpeed))
      call RegPack(Buf, InData%LidSpeed)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtTrunc
   call RegPack(Buf, allocated(InData%WtTrunc))
   if (allocated(InData%WtTrunc)) then
      call RegPackBounds(Buf, 1, lbound(InData%WtTrunc), ubound(InData%WtTrunc))
      call RegPack(Buf, InData%WtTrunc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsX
   call RegPack(Buf, allocated(InData%MsrPositionsX))
   if (allocated(InData%MsrPositionsX)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsX), ubound(InData%MsrPositionsX))
      call RegPack(Buf, InData%MsrPositionsX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsY
   call RegPack(Buf, allocated(InData%MsrPositionsY))
   if (allocated(InData%MsrPositionsY)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsY), ubound(InData%MsrPositionsY))
      call RegPack(Buf, InData%MsrPositionsY)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MsrPositionsZ
   call RegPack(Buf, allocated(InData%MsrPositionsZ))
   if (allocated(InData%MsrPositionsZ)) then
      call RegPackBounds(Buf, 1, lbound(InData%MsrPositionsZ), ubound(InData%MsrPositionsZ))
      call RegPack(Buf, InData%MsrPositionsZ)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Lidar_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Lidar_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Lidar_UnPackOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LidSpeed
   if (allocated(OutData%LidSpeed)) deallocate(OutData%LidSpeed)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LidSpeed(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LidSpeed.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LidSpeed)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WtTrunc
   if (allocated(OutData%WtTrunc)) deallocate(OutData%WtTrunc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WtTrunc(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WtTrunc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WtTrunc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsX
   if (allocated(OutData%MsrPositionsX)) deallocate(OutData%MsrPositionsX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsX(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsY
   if (allocated(OutData%MsrPositionsY)) deallocate(OutData%MsrPositionsY)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsY(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsY.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsY)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MsrPositionsZ
   if (allocated(OutData%MsrPositionsZ)) deallocate(OutData%MsrPositionsZ)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MsrPositionsZ(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MsrPositionsZ.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MsrPositionsZ)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE Lidar_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Lidar_InputType), INTENT(IN)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(Lidar_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'Lidar_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL Lidar_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL Lidar_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL Lidar_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE Lidar_Input_ExtrapInterp


 SUBROUTINE Lidar_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(Lidar_InputType), INTENT(IN)  :: u1    ! Input at t1 > t2
 TYPE(Lidar_InputType), INTENT(IN)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(Lidar_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'Lidar_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
  b = -(u1%PulseLidEl - u2%PulseLidEl)
  u_out%PulseLidEl = u1%PulseLidEl + b * ScaleFactor
  b = -(u1%PulseLidAz - u2%PulseLidAz)
  u_out%PulseLidAz = u1%PulseLidAz + b * ScaleFactor
  b = -(u1%HubDisplacementX - u2%HubDisplacementX)
  u_out%HubDisplacementX = u1%HubDisplacementX + b * ScaleFactor
  b = -(u1%HubDisplacementY - u2%HubDisplacementY)
  u_out%HubDisplacementY = u1%HubDisplacementY + b * ScaleFactor
  b = -(u1%HubDisplacementZ - u2%HubDisplacementZ)
  u_out%HubDisplacementZ = u1%HubDisplacementZ + b * ScaleFactor
 END SUBROUTINE Lidar_Input_ExtrapInterp1


 SUBROUTINE Lidar_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(Lidar_InputType), INTENT(IN)  :: u1      ! Input at t1 > t2 > t3
 TYPE(Lidar_InputType), INTENT(IN)  :: u2      ! Input at t2 > t3
 TYPE(Lidar_InputType), INTENT(IN)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(Lidar_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'Lidar_Input_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
  b = (t(3)**2*(u1%PulseLidEl - u2%PulseLidEl) + t(2)**2*(-u1%PulseLidEl + u3%PulseLidEl))* scaleFactor
  c = ( (t(2)-t(3))*u1%PulseLidEl + t(3)*u2%PulseLidEl - t(2)*u3%PulseLidEl ) * scaleFactor
  u_out%PulseLidEl = u1%PulseLidEl + b  + c * t_out
  b = (t(3)**2*(u1%PulseLidAz - u2%PulseLidAz) + t(2)**2*(-u1%PulseLidAz + u3%PulseLidAz))* scaleFactor
  c = ( (t(2)-t(3))*u1%PulseLidAz + t(3)*u2%PulseLidAz - t(2)*u3%PulseLidAz ) * scaleFactor
  u_out%PulseLidAz = u1%PulseLidAz + b  + c * t_out
  b = (t(3)**2*(u1%HubDisplacementX - u2%HubDisplacementX) + t(2)**2*(-u1%HubDisplacementX + u3%HubDisplacementX))* scaleFactor
  c = ( (t(2)-t(3))*u1%HubDisplacementX + t(3)*u2%HubDisplacementX - t(2)*u3%HubDisplacementX ) * scaleFactor
  u_out%HubDisplacementX = u1%HubDisplacementX + b  + c * t_out
  b = (t(3)**2*(u1%HubDisplacementY - u2%HubDisplacementY) + t(2)**2*(-u1%HubDisplacementY + u3%HubDisplacementY))* scaleFactor
  c = ( (t(2)-t(3))*u1%HubDisplacementY + t(3)*u2%HubDisplacementY - t(2)*u3%HubDisplacementY ) * scaleFactor
  u_out%HubDisplacementY = u1%HubDisplacementY + b  + c * t_out
  b = (t(3)**2*(u1%HubDisplacementZ - u2%HubDisplacementZ) + t(2)**2*(-u1%HubDisplacementZ + u3%HubDisplacementZ))* scaleFactor
  c = ( (t(2)-t(3))*u1%HubDisplacementZ + t(3)*u2%HubDisplacementZ - t(2)*u3%HubDisplacementZ ) * scaleFactor
  u_out%HubDisplacementZ = u1%HubDisplacementZ + b  + c * t_out
 END SUBROUTINE Lidar_Input_ExtrapInterp2


 SUBROUTINE Lidar_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Lidar_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(Lidar_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'Lidar_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL Lidar_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL Lidar_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL Lidar_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE Lidar_Output_ExtrapInterp


 SUBROUTINE Lidar_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(Lidar_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(Lidar_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(Lidar_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'Lidar_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%LidSpeed) .AND. ALLOCATED(y1%LidSpeed)) THEN
  DO i1 = LBOUND(y_out%LidSpeed,1),UBOUND(y_out%LidSpeed,1)
    b = -(y1%LidSpeed(i1) - y2%LidSpeed(i1))
    y_out%LidSpeed(i1) = y1%LidSpeed(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%WtTrunc) .AND. ALLOCATED(y1%WtTrunc)) THEN
  DO i1 = LBOUND(y_out%WtTrunc,1),UBOUND(y_out%WtTrunc,1)
    b = -(y1%WtTrunc(i1) - y2%WtTrunc(i1))
    y_out%WtTrunc(i1) = y1%WtTrunc(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MsrPositionsX) .AND. ALLOCATED(y1%MsrPositionsX)) THEN
  DO i1 = LBOUND(y_out%MsrPositionsX,1),UBOUND(y_out%MsrPositionsX,1)
    b = -(y1%MsrPositionsX(i1) - y2%MsrPositionsX(i1))
    y_out%MsrPositionsX(i1) = y1%MsrPositionsX(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MsrPositionsY) .AND. ALLOCATED(y1%MsrPositionsY)) THEN
  DO i1 = LBOUND(y_out%MsrPositionsY,1),UBOUND(y_out%MsrPositionsY,1)
    b = -(y1%MsrPositionsY(i1) - y2%MsrPositionsY(i1))
    y_out%MsrPositionsY(i1) = y1%MsrPositionsY(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MsrPositionsZ) .AND. ALLOCATED(y1%MsrPositionsZ)) THEN
  DO i1 = LBOUND(y_out%MsrPositionsZ,1),UBOUND(y_out%MsrPositionsZ,1)
    b = -(y1%MsrPositionsZ(i1) - y2%MsrPositionsZ(i1))
    y_out%MsrPositionsZ(i1) = y1%MsrPositionsZ(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE Lidar_Output_ExtrapInterp1


 SUBROUTINE Lidar_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(Lidar_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(Lidar_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(Lidar_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(Lidar_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'Lidar_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%LidSpeed) .AND. ALLOCATED(y1%LidSpeed)) THEN
  DO i1 = LBOUND(y_out%LidSpeed,1),UBOUND(y_out%LidSpeed,1)
    b = (t(3)**2*(y1%LidSpeed(i1) - y2%LidSpeed(i1)) + t(2)**2*(-y1%LidSpeed(i1) + y3%LidSpeed(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%LidSpeed(i1) + t(3)*y2%LidSpeed(i1) - t(2)*y3%LidSpeed(i1) ) * scaleFactor
    y_out%LidSpeed(i1) = y1%LidSpeed(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%WtTrunc) .AND. ALLOCATED(y1%WtTrunc)) THEN
  DO i1 = LBOUND(y_out%WtTrunc,1),UBOUND(y_out%WtTrunc,1)
    b = (t(3)**2*(y1%WtTrunc(i1) - y2%WtTrunc(i1)) + t(2)**2*(-y1%WtTrunc(i1) + y3%WtTrunc(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WtTrunc(i1) + t(3)*y2%WtTrunc(i1) - t(2)*y3%WtTrunc(i1) ) * scaleFactor
    y_out%WtTrunc(i1) = y1%WtTrunc(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MsrPositionsX) .AND. ALLOCATED(y1%MsrPositionsX)) THEN
  DO i1 = LBOUND(y_out%MsrPositionsX,1),UBOUND(y_out%MsrPositionsX,1)
    b = (t(3)**2*(y1%MsrPositionsX(i1) - y2%MsrPositionsX(i1)) + t(2)**2*(-y1%MsrPositionsX(i1) + y3%MsrPositionsX(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%MsrPositionsX(i1) + t(3)*y2%MsrPositionsX(i1) - t(2)*y3%MsrPositionsX(i1) ) * scaleFactor
    y_out%MsrPositionsX(i1) = y1%MsrPositionsX(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MsrPositionsY) .AND. ALLOCATED(y1%MsrPositionsY)) THEN
  DO i1 = LBOUND(y_out%MsrPositionsY,1),UBOUND(y_out%MsrPositionsY,1)
    b = (t(3)**2*(y1%MsrPositionsY(i1) - y2%MsrPositionsY(i1)) + t(2)**2*(-y1%MsrPositionsY(i1) + y3%MsrPositionsY(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%MsrPositionsY(i1) + t(3)*y2%MsrPositionsY(i1) - t(2)*y3%MsrPositionsY(i1) ) * scaleFactor
    y_out%MsrPositionsY(i1) = y1%MsrPositionsY(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%MsrPositionsZ) .AND. ALLOCATED(y1%MsrPositionsZ)) THEN
  DO i1 = LBOUND(y_out%MsrPositionsZ,1),UBOUND(y_out%MsrPositionsZ,1)
    b = (t(3)**2*(y1%MsrPositionsZ(i1) - y2%MsrPositionsZ(i1)) + t(2)**2*(-y1%MsrPositionsZ(i1) + y3%MsrPositionsZ(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%MsrPositionsZ(i1) + t(3)*y2%MsrPositionsZ(i1) - t(2)*y3%MsrPositionsZ(i1) ) * scaleFactor
    y_out%MsrPositionsZ(i1) = y1%MsrPositionsZ(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE Lidar_Output_ExtrapInterp2

END MODULE Lidar_Types
!ENDOFREGISTRYGENERATEDFILE
