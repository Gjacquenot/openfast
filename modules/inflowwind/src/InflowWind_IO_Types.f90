!STARTOFREGISTRYGENERATEDFILE 'InflowWind_IO_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! InflowWind_IO_Types
!.................................................................................................................................
! This file is part of InflowWind_IO.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in InflowWind_IO. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE InflowWind_IO_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE IfW_FlowField_Types
USE NWTC_Library
IMPLICIT NONE
! =========  WindFileDat  =======
  TYPE, PUBLIC :: WindFileDat
    character(1024)  :: FileName      !< Name of the windfile retrieved [-]
    INTEGER(IntKi)  :: WindType = 0      !< Type of the windfile [-]
    REAL(ReKi)  :: RefHt      !< Reference height given in file [meters]
    LOGICAL  :: RefHt_Set      !< Reference height was given in file [-]
    REAL(DbKi)  :: DT      !< TimeStep of the wind file -- zero value for none [seconds]
    INTEGER(IntKi)  :: NumTSteps      !< Number of timesteps in the time range of wind file [-]
    LOGICAL  :: ConstantDT      !< Timesteps are the same throughout file [-]
    REAL(ReKi) , DIMENSION(1:2)  :: TRange      !< Time range of the wind file [seconds]
    LOGICAL  :: TRange_Limited      !< TRange limits strictly enforced [-]
    REAL(ReKi) , DIMENSION(1:2)  :: YRange      !< Range in y direction [meters]
    LOGICAL  :: YRange_Limited      !< YRange limits strictly enforced [-]
    REAL(ReKi) , DIMENSION(1:2)  :: ZRange      !< Range in z direction [meters]
    LOGICAL  :: ZRange_Limited      !< ZRange limits strictly enforced [-]
    INTEGER(IntKi)  :: BinaryFormat      !< Binary format identifier [-]
    LOGICAL  :: IsBinary      !< Windfile is a binary file [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TI      !< Turbulence intensity (U,V,W) [-]
    LOGICAL  :: TI_listed      !< Turbulence intesity given in file [-]
    REAL(ReKi)  :: MWS      !< Approximate mean wind speed [-]
  END TYPE WindFileDat
! =======================
! =========  Steady_InitInputType  =======
  TYPE, PUBLIC :: Steady_InitInputType
    REAL(ReKi)  :: HWindSpeed      !< Horizontal wind speed [m/s]
    REAL(ReKi)  :: RefHt      !< Reference height for horizontal wind speed [meters]
    REAL(ReKi)  :: PLExp      !< Power law exponent [-]
  END TYPE Steady_InitInputType
! =======================
! =========  Uniform_InitInputType  =======
  TYPE, PUBLIC :: Uniform_InitInputType
    character(1024)  :: WindFileName      !< Name of the wind file to use [-]
    REAL(ReKi)  :: RefHt      !< Reference height for horizontal wind speed [meters]
    REAL(ReKi)  :: RefLength      !< Reference length for linear horizontal and vertical sheer [-]
    REAL(ReKi)  :: PropagationDir      !< Direction of wind propagation [radians]
    LOGICAL  :: UseInputFile = .true.      !< Flag for toggling file based IO in wind type 2. [-]
    TYPE(FileInfoType)  :: PassedFileData      !< Optional slot for wind type 2 data if file IO is not used. [-]
  END TYPE Uniform_InitInputType
! =======================
! =========  Grid3D_InitInputType  =======
  TYPE, PUBLIC :: Grid3D_InitInputType
    INTEGER(IntKi)  :: ScaleMethod = 0      !< Turbulence scaling method [0=none, 1=direct scaling, 2= calculate scaling factor based on a desired standard deviation] [-]
    REAL(ReKi) , DIMENSION(1:3)  :: SF      !< Turbulence scaling factor for each direction [ScaleMethod=1] [-]
    REAL(ReKi) , DIMENSION(1:3)  :: SigmaF      !< Turbulence standard deviation to calculate scaling from in each direction [ScaleMethod=2] [-]
    INTEGER(IntKi)  :: WindProfileType = -1      !< Wind profile type (0=constant;1=logarithmic;2=power law) [-]
    REAL(ReKi)  :: RefHt = 0      !< Reference (hub) height of the grid [meters]
    REAL(ReKi)  :: URef = 0      !< Mean u-component wind speed at the reference height [meters]
    REAL(ReKi)  :: PLExp = 0      !< Power law exponent (used for PL wind profile type only) [-]
    REAL(ReKi)  :: VLinShr = 0      !< Vertical linear wind shear coefficient (used for vertical linear wind profile type only) [-]
    REAL(ReKi)  :: HLinShr = 0      !< Horizontal linear wind shear coefficient (used for horizontal wind profile type only) [-]
    REAL(ReKi)  :: RefLength = 1      !< Reference (rotor) length of the grid (used for horizontal wind profile type only) [-]
    REAL(ReKi)  :: Z0 = 0      !< Surface roughness length (used for LOG wind profile type only) [-]
    REAL(ReKi)  :: XOffset = 0      !< distance offset for FF wind files [m]
  END TYPE Grid3D_InitInputType
! =======================
! =========  TurbSim_InitInputType  =======
  TYPE, PUBLIC :: TurbSim_InitInputType
    character(1024)  :: WindFileName      !< Name of the wind file to use [-]
  END TYPE TurbSim_InitInputType
! =======================
! =========  Bladed_InitInputType  =======
  TYPE, PUBLIC :: Bladed_InitInputType
    character(1024)  :: WindFileName      !< Root filename [-]
    INTEGER(IntKi)  :: WindType      !< Whether this is native Bladed (needs wind profile and TI scaling) or not [-]
    LOGICAL  :: NativeBladedFmt      !< Whether this is native Bladed (needs wind profile and TI scaling) or not [-]
    LOGICAL  :: TowerFileExist      !< Tower file exists [-]
    INTEGER(IntKi)  :: TurbineID = 0      !< Wind turbine ID number in the fixed (DEFAULT) file name when FixedWindFileRootName = .TRUE. (used by FAST.Farm) [-]
    LOGICAL  :: FixedWindFileRootName = .false.      !< Do the wind data files have a fixed (DEFAULT) file name? (used by FAST.Farm) [-]
  END TYPE Bladed_InitInputType
! =======================
! =========  Bladed_InitOutputType  =======
  TYPE, PUBLIC :: Bladed_InitOutputType
    REAL(ReKi)  :: PropagationDir      !< Propogation direction from native Bladed format [degrees]
    REAL(ReKi)  :: VFlowAngle      !< Vertical flow angle from native Bladed format [degrees]
  END TYPE Bladed_InitOutputType
! =======================
! =========  HAWC_InitInputType  =======
  TYPE, PUBLIC :: HAWC_InitInputType
    character(1024) , DIMENSION(1:3)  :: WindFileName      !< Name of the wind file to use [-]
    INTEGER(IntKi)  :: nx = 0      !< Number of grids in the x direction (in the 3 files above) [-]
    INTEGER(IntKi)  :: ny = 0      !< Number of grids in the y direction (in the 3 files above) [-]
    INTEGER(IntKi)  :: nz = 0      !< Number of grids in the z direction (in the 3 files above) [-]
    REAL(ReKi)  :: dx = 0      !< size of grids in the x direction (in the 3 files above) [-]
    REAL(ReKi)  :: dy = 0      !< size of grids in the y direction (in the 3 files above) [-]
    REAL(ReKi)  :: dz = 0      !< size of grids in the z direction (in the 3 files above) [-]
    TYPE(Grid3D_InitInputType)  :: G3D      !< Grid3D initialization input [-]
  END TYPE HAWC_InitInputType
! =======================
! =========  User_InitInputType  =======
  TYPE, PUBLIC :: User_InitInputType
    REAL(SiKi)  :: Dummy      !< User field initialization input dummy value [-]
  END TYPE User_InitInputType
! =======================
! =========  Grid4D_InitInputType  =======
  TYPE, PUBLIC :: Grid4D_InitInputType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of grid points in the x, y, z, and t directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction [m,m,m,s]
    REAL(ReKi) , DIMENSION(1:3)  :: pZero      !< fixed position of the XYZ grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: Vel => NULL()      !< pointer to 4D grid velocity data [m/s]
  END TYPE Grid4D_InitInputType
! =======================
! =========  Points_InitInputType  =======
  TYPE, PUBLIC :: Points_InitInputType
    INTEGER(IntKi)  :: NumWindPoints      !< Number of points where wind components will be provided [-]
  END TYPE Points_InitInputType
! =======================
CONTAINS
 SUBROUTINE InflowWind_IO_CopyWindFileDat( SrcWindFileDatData, DstWindFileDatData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WindFileDat), INTENT(IN) :: SrcWindFileDatData
   TYPE(WindFileDat), INTENT(INOUT) :: DstWindFileDatData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyWindFileDat'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstWindFileDatData%FileName = SrcWindFileDatData%FileName
    DstWindFileDatData%WindType = SrcWindFileDatData%WindType
    DstWindFileDatData%RefHt = SrcWindFileDatData%RefHt
    DstWindFileDatData%RefHt_Set = SrcWindFileDatData%RefHt_Set
    DstWindFileDatData%DT = SrcWindFileDatData%DT
    DstWindFileDatData%NumTSteps = SrcWindFileDatData%NumTSteps
    DstWindFileDatData%ConstantDT = SrcWindFileDatData%ConstantDT
    DstWindFileDatData%TRange = SrcWindFileDatData%TRange
    DstWindFileDatData%TRange_Limited = SrcWindFileDatData%TRange_Limited
    DstWindFileDatData%YRange = SrcWindFileDatData%YRange
    DstWindFileDatData%YRange_Limited = SrcWindFileDatData%YRange_Limited
    DstWindFileDatData%ZRange = SrcWindFileDatData%ZRange
    DstWindFileDatData%ZRange_Limited = SrcWindFileDatData%ZRange_Limited
    DstWindFileDatData%BinaryFormat = SrcWindFileDatData%BinaryFormat
    DstWindFileDatData%IsBinary = SrcWindFileDatData%IsBinary
    DstWindFileDatData%TI = SrcWindFileDatData%TI
    DstWindFileDatData%TI_listed = SrcWindFileDatData%TI_listed
    DstWindFileDatData%MWS = SrcWindFileDatData%MWS
 END SUBROUTINE InflowWind_IO_CopyWindFileDat

 SUBROUTINE InflowWind_IO_DestroyWindFileDat( WindFileDatData, ErrStat, ErrMsg )
  TYPE(WindFileDat), INTENT(INOUT) :: WindFileDatData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyWindFileDat'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyWindFileDat


subroutine InflowWind_IO_PackWindFileDat(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WindFileDat), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackWindFileDat'
   if (Buf%ErrStat >= AbortErrLev) return
   ! FileName
   call RegPack(Buf, InData%FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindType
   call RegPack(Buf, InData%WindType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegPack(Buf, InData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt_Set
   call RegPack(Buf, InData%RefHt_Set)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTSteps
   call RegPack(Buf, InData%NumTSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConstantDT
   call RegPack(Buf, InData%ConstantDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TRange
   call RegPack(Buf, InData%TRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TRange_Limited
   call RegPack(Buf, InData%TRange_Limited)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YRange
   call RegPack(Buf, InData%YRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YRange_Limited
   call RegPack(Buf, InData%YRange_Limited)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ZRange
   call RegPack(Buf, InData%ZRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ZRange_Limited
   call RegPack(Buf, InData%ZRange_Limited)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BinaryFormat
   call RegPack(Buf, InData%BinaryFormat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsBinary
   call RegPack(Buf, InData%IsBinary)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI
   call RegPack(Buf, InData%TI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI_listed
   call RegPack(Buf, InData%TI_listed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MWS
   call RegPack(Buf, InData%MWS)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackWindFileDat(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WindFileDat), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackWindFileDat'
   if (Buf%ErrStat /= ErrID_None) return
   ! FileName
   call RegUnpack(Buf, OutData%FileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindType
   call RegUnpack(Buf, OutData%WindType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegUnpack(Buf, OutData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt_Set
   call RegUnpack(Buf, OutData%RefHt_Set)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTSteps
   call RegUnpack(Buf, OutData%NumTSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ConstantDT
   call RegUnpack(Buf, OutData%ConstantDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TRange
   call RegUnpack(Buf, OutData%TRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TRange_Limited
   call RegUnpack(Buf, OutData%TRange_Limited)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YRange
   call RegUnpack(Buf, OutData%YRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YRange_Limited
   call RegUnpack(Buf, OutData%YRange_Limited)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ZRange
   call RegUnpack(Buf, OutData%ZRange)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ZRange_Limited
   call RegUnpack(Buf, OutData%ZRange_Limited)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BinaryFormat
   call RegUnpack(Buf, OutData%BinaryFormat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsBinary
   call RegUnpack(Buf, OutData%IsBinary)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI
   call RegUnpack(Buf, OutData%TI)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI_listed
   call RegUnpack(Buf, OutData%TI_listed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MWS
   call RegUnpack(Buf, OutData%MWS)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopySteady_InitInputType( SrcSteady_InitInputTypeData, DstSteady_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Steady_InitInputType), INTENT(IN) :: SrcSteady_InitInputTypeData
   TYPE(Steady_InitInputType), INTENT(INOUT) :: DstSteady_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopySteady_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstSteady_InitInputTypeData%HWindSpeed = SrcSteady_InitInputTypeData%HWindSpeed
    DstSteady_InitInputTypeData%RefHt = SrcSteady_InitInputTypeData%RefHt
    DstSteady_InitInputTypeData%PLExp = SrcSteady_InitInputTypeData%PLExp
 END SUBROUTINE InflowWind_IO_CopySteady_InitInputType

 SUBROUTINE InflowWind_IO_DestroySteady_InitInputType( Steady_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Steady_InitInputType), INTENT(INOUT) :: Steady_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroySteady_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroySteady_InitInputType


subroutine InflowWind_IO_PackSteady_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Steady_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackSteady_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! HWindSpeed
   call RegPack(Buf, InData%HWindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegPack(Buf, InData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PLExp
   call RegPack(Buf, InData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackSteady_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Steady_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackSteady_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! HWindSpeed
   call RegUnpack(Buf, OutData%HWindSpeed)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegUnpack(Buf, OutData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PLExp
   call RegUnpack(Buf, OutData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopyUniform_InitInputType( SrcUniform_InitInputTypeData, DstUniform_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Uniform_InitInputType), INTENT(IN) :: SrcUniform_InitInputTypeData
   TYPE(Uniform_InitInputType), INTENT(INOUT) :: DstUniform_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyUniform_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUniform_InitInputTypeData%WindFileName = SrcUniform_InitInputTypeData%WindFileName
    DstUniform_InitInputTypeData%RefHt = SrcUniform_InitInputTypeData%RefHt
    DstUniform_InitInputTypeData%RefLength = SrcUniform_InitInputTypeData%RefLength
    DstUniform_InitInputTypeData%PropagationDir = SrcUniform_InitInputTypeData%PropagationDir
    DstUniform_InitInputTypeData%UseInputFile = SrcUniform_InitInputTypeData%UseInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcUniform_InitInputTypeData%PassedFileData, DstUniform_InitInputTypeData%PassedFileData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE InflowWind_IO_CopyUniform_InitInputType

 SUBROUTINE InflowWind_IO_DestroyUniform_InitInputType( Uniform_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Uniform_InitInputType), INTENT(INOUT) :: Uniform_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyUniform_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyFileInfoType( Uniform_InitInputTypeData%PassedFileData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE InflowWind_IO_DestroyUniform_InitInputType


subroutine InflowWind_IO_PackUniform_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Uniform_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackUniform_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WindFileName
   call RegPack(Buf, InData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegPack(Buf, InData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegPack(Buf, InData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropagationDir
   call RegPack(Buf, InData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegPack(Buf, InData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedFileData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedFileData) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackUniform_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Uniform_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackUniform_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! WindFileName
   call RegUnpack(Buf, OutData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegUnpack(Buf, OutData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegUnpack(Buf, OutData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropagationDir
   call RegUnpack(Buf, OutData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegUnpack(Buf, OutData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedFileData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedFileData) ! PassedFileData 
end subroutine
 SUBROUTINE InflowWind_IO_CopyGrid3D_InitInputType( SrcGrid3D_InitInputTypeData, DstGrid3D_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Grid3D_InitInputType), INTENT(IN) :: SrcGrid3D_InitInputTypeData
   TYPE(Grid3D_InitInputType), INTENT(INOUT) :: DstGrid3D_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyGrid3D_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstGrid3D_InitInputTypeData%ScaleMethod = SrcGrid3D_InitInputTypeData%ScaleMethod
    DstGrid3D_InitInputTypeData%SF = SrcGrid3D_InitInputTypeData%SF
    DstGrid3D_InitInputTypeData%SigmaF = SrcGrid3D_InitInputTypeData%SigmaF
    DstGrid3D_InitInputTypeData%WindProfileType = SrcGrid3D_InitInputTypeData%WindProfileType
    DstGrid3D_InitInputTypeData%RefHt = SrcGrid3D_InitInputTypeData%RefHt
    DstGrid3D_InitInputTypeData%URef = SrcGrid3D_InitInputTypeData%URef
    DstGrid3D_InitInputTypeData%PLExp = SrcGrid3D_InitInputTypeData%PLExp
    DstGrid3D_InitInputTypeData%VLinShr = SrcGrid3D_InitInputTypeData%VLinShr
    DstGrid3D_InitInputTypeData%HLinShr = SrcGrid3D_InitInputTypeData%HLinShr
    DstGrid3D_InitInputTypeData%RefLength = SrcGrid3D_InitInputTypeData%RefLength
    DstGrid3D_InitInputTypeData%Z0 = SrcGrid3D_InitInputTypeData%Z0
    DstGrid3D_InitInputTypeData%XOffset = SrcGrid3D_InitInputTypeData%XOffset
 END SUBROUTINE InflowWind_IO_CopyGrid3D_InitInputType

 SUBROUTINE InflowWind_IO_DestroyGrid3D_InitInputType( Grid3D_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Grid3D_InitInputType), INTENT(INOUT) :: Grid3D_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyGrid3D_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyGrid3D_InitInputType


subroutine InflowWind_IO_PackGrid3D_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Grid3D_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackGrid3D_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! ScaleMethod
   call RegPack(Buf, InData%ScaleMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SF
   call RegPack(Buf, InData%SF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SigmaF
   call RegPack(Buf, InData%SigmaF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindProfileType
   call RegPack(Buf, InData%WindProfileType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegPack(Buf, InData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URef
   call RegPack(Buf, InData%URef)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PLExp
   call RegPack(Buf, InData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VLinShr
   call RegPack(Buf, InData%VLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLinShr
   call RegPack(Buf, InData%HLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegPack(Buf, InData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0
   call RegPack(Buf, InData%Z0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! XOffset
   call RegPack(Buf, InData%XOffset)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackGrid3D_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Grid3D_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackGrid3D_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! ScaleMethod
   call RegUnpack(Buf, OutData%ScaleMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SF
   call RegUnpack(Buf, OutData%SF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SigmaF
   call RegUnpack(Buf, OutData%SigmaF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindProfileType
   call RegUnpack(Buf, OutData%WindProfileType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHt
   call RegUnpack(Buf, OutData%RefHt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! URef
   call RegUnpack(Buf, OutData%URef)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PLExp
   call RegUnpack(Buf, OutData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VLinShr
   call RegUnpack(Buf, OutData%VLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLinShr
   call RegUnpack(Buf, OutData%HLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegUnpack(Buf, OutData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0
   call RegUnpack(Buf, OutData%Z0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! XOffset
   call RegUnpack(Buf, OutData%XOffset)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopyTurbSim_InitInputType( SrcTurbSim_InitInputTypeData, DstTurbSim_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(TurbSim_InitInputType), INTENT(IN) :: SrcTurbSim_InitInputTypeData
   TYPE(TurbSim_InitInputType), INTENT(INOUT) :: DstTurbSim_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyTurbSim_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstTurbSim_InitInputTypeData%WindFileName = SrcTurbSim_InitInputTypeData%WindFileName
 END SUBROUTINE InflowWind_IO_CopyTurbSim_InitInputType

 SUBROUTINE InflowWind_IO_DestroyTurbSim_InitInputType( TurbSim_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(TurbSim_InitInputType), INTENT(INOUT) :: TurbSim_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyTurbSim_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyTurbSim_InitInputType


subroutine InflowWind_IO_PackTurbSim_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(TurbSim_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackTurbSim_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WindFileName
   call RegPack(Buf, InData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackTurbSim_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(TurbSim_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackTurbSim_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! WindFileName
   call RegUnpack(Buf, OutData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopyBladed_InitInputType( SrcBladed_InitInputTypeData, DstBladed_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Bladed_InitInputType), INTENT(IN) :: SrcBladed_InitInputTypeData
   TYPE(Bladed_InitInputType), INTENT(INOUT) :: DstBladed_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyBladed_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBladed_InitInputTypeData%WindFileName = SrcBladed_InitInputTypeData%WindFileName
    DstBladed_InitInputTypeData%WindType = SrcBladed_InitInputTypeData%WindType
    DstBladed_InitInputTypeData%NativeBladedFmt = SrcBladed_InitInputTypeData%NativeBladedFmt
    DstBladed_InitInputTypeData%TowerFileExist = SrcBladed_InitInputTypeData%TowerFileExist
    DstBladed_InitInputTypeData%TurbineID = SrcBladed_InitInputTypeData%TurbineID
    DstBladed_InitInputTypeData%FixedWindFileRootName = SrcBladed_InitInputTypeData%FixedWindFileRootName
 END SUBROUTINE InflowWind_IO_CopyBladed_InitInputType

 SUBROUTINE InflowWind_IO_DestroyBladed_InitInputType( Bladed_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Bladed_InitInputType), INTENT(INOUT) :: Bladed_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyBladed_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyBladed_InitInputType


subroutine InflowWind_IO_PackBladed_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Bladed_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackBladed_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WindFileName
   call RegPack(Buf, InData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindType
   call RegPack(Buf, InData%WindType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NativeBladedFmt
   call RegPack(Buf, InData%NativeBladedFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerFileExist
   call RegPack(Buf, InData%TowerFileExist)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineID
   call RegPack(Buf, InData%TurbineID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FixedWindFileRootName
   call RegPack(Buf, InData%FixedWindFileRootName)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackBladed_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Bladed_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackBladed_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! WindFileName
   call RegUnpack(Buf, OutData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindType
   call RegUnpack(Buf, OutData%WindType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NativeBladedFmt
   call RegUnpack(Buf, OutData%NativeBladedFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TowerFileExist
   call RegUnpack(Buf, OutData%TowerFileExist)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TurbineID
   call RegUnpack(Buf, OutData%TurbineID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FixedWindFileRootName
   call RegUnpack(Buf, OutData%FixedWindFileRootName)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopyBladed_InitOutputType( SrcBladed_InitOutputTypeData, DstBladed_InitOutputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Bladed_InitOutputType), INTENT(IN) :: SrcBladed_InitOutputTypeData
   TYPE(Bladed_InitOutputType), INTENT(INOUT) :: DstBladed_InitOutputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyBladed_InitOutputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBladed_InitOutputTypeData%PropagationDir = SrcBladed_InitOutputTypeData%PropagationDir
    DstBladed_InitOutputTypeData%VFlowAngle = SrcBladed_InitOutputTypeData%VFlowAngle
 END SUBROUTINE InflowWind_IO_CopyBladed_InitOutputType

 SUBROUTINE InflowWind_IO_DestroyBladed_InitOutputType( Bladed_InitOutputTypeData, ErrStat, ErrMsg )
  TYPE(Bladed_InitOutputType), INTENT(INOUT) :: Bladed_InitOutputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyBladed_InitOutputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyBladed_InitOutputType


subroutine InflowWind_IO_PackBladed_InitOutputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Bladed_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackBladed_InitOutputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! PropagationDir
   call RegPack(Buf, InData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VFlowAngle
   call RegPack(Buf, InData%VFlowAngle)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackBladed_InitOutputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Bladed_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackBladed_InitOutputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! PropagationDir
   call RegUnpack(Buf, OutData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VFlowAngle
   call RegUnpack(Buf, OutData%VFlowAngle)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopyHAWC_InitInputType( SrcHAWC_InitInputTypeData, DstHAWC_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HAWC_InitInputType), INTENT(IN) :: SrcHAWC_InitInputTypeData
   TYPE(HAWC_InitInputType), INTENT(INOUT) :: DstHAWC_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyHAWC_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstHAWC_InitInputTypeData%WindFileName = SrcHAWC_InitInputTypeData%WindFileName
    DstHAWC_InitInputTypeData%nx = SrcHAWC_InitInputTypeData%nx
    DstHAWC_InitInputTypeData%ny = SrcHAWC_InitInputTypeData%ny
    DstHAWC_InitInputTypeData%nz = SrcHAWC_InitInputTypeData%nz
    DstHAWC_InitInputTypeData%dx = SrcHAWC_InitInputTypeData%dx
    DstHAWC_InitInputTypeData%dy = SrcHAWC_InitInputTypeData%dy
    DstHAWC_InitInputTypeData%dz = SrcHAWC_InitInputTypeData%dz
      CALL InflowWind_IO_Copygrid3d_initinputtype( SrcHAWC_InitInputTypeData%G3D, DstHAWC_InitInputTypeData%G3D, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE InflowWind_IO_CopyHAWC_InitInputType

 SUBROUTINE InflowWind_IO_DestroyHAWC_InitInputType( HAWC_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(HAWC_InitInputType), INTENT(INOUT) :: HAWC_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyHAWC_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL InflowWind_IO_DestroyGrid3D_InitInputType( HAWC_InitInputTypeData%G3D, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE InflowWind_IO_DestroyHAWC_InitInputType


subroutine InflowWind_IO_PackHAWC_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HAWC_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackHAWC_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WindFileName
   call RegPack(Buf, InData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nx
   call RegPack(Buf, InData%nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ny
   call RegPack(Buf, InData%ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nz
   call RegPack(Buf, InData%nz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegPack(Buf, InData%dx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dy
   call RegPack(Buf, InData%dy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dz
   call RegPack(Buf, InData%dz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! G3D
   call InflowWind_IO_PackGrid3D_InitInputType(Buf, InData%G3D) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackHAWC_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HAWC_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackHAWC_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! WindFileName
   call RegUnpack(Buf, OutData%WindFileName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nx
   call RegUnpack(Buf, OutData%nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ny
   call RegUnpack(Buf, OutData%ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nz
   call RegUnpack(Buf, OutData%nz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegUnpack(Buf, OutData%dx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dy
   call RegUnpack(Buf, OutData%dy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! dz
   call RegUnpack(Buf, OutData%dz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! G3D
   call InflowWind_IO_UnpackGrid3D_InitInputType(Buf, OutData%G3D) ! G3D 
end subroutine
 SUBROUTINE InflowWind_IO_CopyUser_InitInputType( SrcUser_InitInputTypeData, DstUser_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(User_InitInputType), INTENT(IN) :: SrcUser_InitInputTypeData
   TYPE(User_InitInputType), INTENT(INOUT) :: DstUser_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyUser_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUser_InitInputTypeData%Dummy = SrcUser_InitInputTypeData%Dummy
 END SUBROUTINE InflowWind_IO_CopyUser_InitInputType

 SUBROUTINE InflowWind_IO_DestroyUser_InitInputType( User_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(User_InitInputType), INTENT(INOUT) :: User_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyUser_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyUser_InitInputType


subroutine InflowWind_IO_PackUser_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(User_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackUser_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Dummy
   call RegPack(Buf, InData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackUser_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(User_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackUser_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! Dummy
   call RegUnpack(Buf, OutData%Dummy)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE InflowWind_IO_CopyGrid4D_InitInputType( SrcGrid4D_InitInputTypeData, DstGrid4D_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Grid4D_InitInputType), INTENT(IN) :: SrcGrid4D_InitInputTypeData
   TYPE(Grid4D_InitInputType), INTENT(INOUT) :: DstGrid4D_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyGrid4D_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstGrid4D_InitInputTypeData%n = SrcGrid4D_InitInputTypeData%n
    DstGrid4D_InitInputTypeData%delta = SrcGrid4D_InitInputTypeData%delta
    DstGrid4D_InitInputTypeData%pZero = SrcGrid4D_InitInputTypeData%pZero
    DstGrid4D_InitInputTypeData%Vel => SrcGrid4D_InitInputTypeData%Vel
 END SUBROUTINE InflowWind_IO_CopyGrid4D_InitInputType

 SUBROUTINE InflowWind_IO_DestroyGrid4D_InitInputType( Grid4D_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Grid4D_InitInputType), INTENT(INOUT) :: Grid4D_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyGrid4D_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

NULLIFY(Grid4D_InitInputTypeData%Vel)
 END SUBROUTINE InflowWind_IO_DestroyGrid4D_InitInputType


subroutine InflowWind_IO_PackGrid4D_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Grid4D_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackGrid4D_InitInputType'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! n
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegPack(Buf, InData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegPack(Buf, InData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vel
   call RegPack(Buf, associated(InData%Vel))
   if (associated(InData%Vel)) then
      call RegPackBounds(Buf, 5, lbound(InData%Vel), ubound(InData%Vel))
      call RegPackPointer(Buf, c_loc(InData%Vel), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%Vel)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackGrid4D_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Grid4D_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackGrid4D_InitInputType'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! n
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vel
   if (associated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%Vel, UB(1:5)-LB(1:5))
         OutData%Vel(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%Vel
      else
         allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%Vel)
         call RegUnpack(Buf, OutData%Vel)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%Vel => null()
   end if
end subroutine
 SUBROUTINE InflowWind_IO_CopyPoints_InitInputType( SrcPoints_InitInputTypeData, DstPoints_InitInputTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Points_InitInputType), INTENT(IN) :: SrcPoints_InitInputTypeData
   TYPE(Points_InitInputType), INTENT(INOUT) :: DstPoints_InitInputTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'InflowWind_IO_CopyPoints_InitInputType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstPoints_InitInputTypeData%NumWindPoints = SrcPoints_InitInputTypeData%NumWindPoints
 END SUBROUTINE InflowWind_IO_CopyPoints_InitInputType

 SUBROUTINE InflowWind_IO_DestroyPoints_InitInputType( Points_InitInputTypeData, ErrStat, ErrMsg )
  TYPE(Points_InitInputType), INTENT(INOUT) :: Points_InitInputTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'InflowWind_IO_DestroyPoints_InitInputType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE InflowWind_IO_DestroyPoints_InitInputType


subroutine InflowWind_IO_PackPoints_InitInputType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Points_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'InflowWind_IO_PackPoints_InitInputType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NumWindPoints
   call RegPack(Buf, InData%NumWindPoints)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine InflowWind_IO_UnPackPoints_InitInputType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Points_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'InflowWind_IO_UnPackPoints_InitInputType'
   if (Buf%ErrStat /= ErrID_None) return
   ! NumWindPoints
   call RegUnpack(Buf, OutData%NumWindPoints)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
END MODULE InflowWind_IO_Types
!ENDOFREGISTRYGENERATEDFILE
