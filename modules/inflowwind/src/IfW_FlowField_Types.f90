!STARTOFREGISTRYGENERATEDFILE 'IfW_FlowField_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! IfW_FlowField_Types
!.................................................................................................................................
! This file is part of IfW_FlowField.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in IfW_FlowField. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE IfW_FlowField_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Undef_FieldType = 0      ! This is the code for an undefined FieldType [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Uniform_FieldType = 1      ! Uniform FieldType from SteadyWind or Uniform Wind [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Grid3D_FieldType = 2      ! 3D Grid FieldType from TurbSim, Bladed, HAWC [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Grid4D_FieldType = 3      ! 4D Grid FieldType from FAST.Farm [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: Point_FieldType = 4      ! Points FieldType from ExtInflow [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: User_FieldType = 5      ! User FieldType configured by the user [-]
! =========  UniformFieldType  =======
  TYPE, PUBLIC :: UniformFieldType
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
    REAL(ReKi)  :: RefLength      !< reference length used to scale the linear shear [meters]
    INTEGER(IntKi)  :: DataSize      !< size of data in HH file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Time      !< HH time array [seconds]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelH      !< HH horizontal wind speed [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelHDot      !< Derivative of HH horizontal wind speed wrt time [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelV      !< HH vertical wind speed, including tower shadow [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelVDot      !< Derivative of HH vertical wind speed wrt time [meters/sec]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelGust      !< HH wind gust speed [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: VelGustDot      !< Derivative of HH wind gust speed wrt time [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleH      !< HH wind direction angle [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleHDot      !< Derivative of HH wind direction angle wrt time [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleV      !< HH upflow angle [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AngleVDot      !< Derivative of HH upflow angle wrt time [degrees]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrH      !< HH horizontal linear shear [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrHDot      !< Derivative of HH horizontal linear shear wrt time [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrV      !< HH vertical shear exponent [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShrVDot      !< Derivative of HH vertical shear exponent wrt time [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LinShrV      !< HH vertical linear shear [seconds]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: LinShrVDot      !< Derivative of HH vertical linear shear wrt time [seconds]
  END TYPE UniformFieldType
! =======================
! =========  UniformField_Interp  =======
  TYPE, PUBLIC :: UniformField_Interp
    REAL(ReKi)  :: VelH      !< HH horizontal wind speed [meters/sec]
    REAL(ReKi)  :: VelHDot      !< derivative of HH horizontal wind speed wrt Time [meters/sec]
    REAL(ReKi)  :: VelV      !< HH vertical wind speed, including tower shadow [meters/sec]
    REAL(ReKi)  :: VelVDot      !< derivative of HH vertical wind speed wrt Time [meters/sec]
    REAL(ReKi)  :: VelGust      !< HH wind gust speed [-]
    REAL(ReKi)  :: VelGustDot      !< derivative of HH wind gust speed wrt Time [-]
    REAL(ReKi)  :: AngleH      !< HH wind direction angle [degrees]
    REAL(ReKi)  :: AngleHDot      !< derivative of HH wind direction angle wrt Time [degrees]
    REAL(ReKi)  :: AngleV      !< HH upflow angle [degrees]
    REAL(ReKi)  :: AngleVDot      !< derivative of HH upflow angle wrt Time [degrees]
    REAL(ReKi)  :: ShrH      !< HH horizontal linear shear [-]
    REAL(ReKi)  :: ShrHDot      !< derivative of HH horizontal linear shear wrt Time [-]
    REAL(ReKi)  :: ShrV      !< HH vertical shear exponent [-]
    REAL(ReKi)  :: ShrVDot      !< derivative of HH vertical shear exponent wrt Time [-]
    REAL(ReKi)  :: LinShrV      !< HH vertical linear shear [seconds]
    REAL(ReKi)  :: LinShrVDot      !< derivative of HH vertical linear shear wrt Time [seconds]
    REAL(ReKi)  :: CosAngleH      !< Horizontal angle components [-]
    REAL(ReKi)  :: SinAngleH      !< Horizontal angle components [-]
    REAL(ReKi)  :: CosAngleV      !< Vertical angle components [-]
    REAL(ReKi)  :: SinAngleV      !< Vertical angle components [-]
  END TYPE UniformField_Interp
! =======================
! =========  Grid3DFieldType  =======
  TYPE, PUBLIC :: Grid3DFieldType
    INTEGER(IntKi)  :: WindFileFormat      !< Binary file format description number [-]
    INTEGER(IntKi)  :: WindProfileType = -1      !< Wind profile type (0=constant;1=logarithmic;2=power law) [-]
    LOGICAL  :: Periodic = .false.      !< Flag to indicate if the wind file is periodic [-]
    LOGICAL  :: InterpTower = .false.      !< Flag to indicate if we should interpolate wind speeds below the tower [-]
    LOGICAL  :: AddMeanAfterInterp = .false.      !< Add the mean wind speed after interpolating at a given height? [-]
    REAL(ReKi)  :: RefHeight = 0      !< Reference (hub) height of the grid [meters]
    REAL(ReKi)  :: RefLength = 1.0_ReKi      !< Reference (rotor) length of the grid (used for horizontal wind profile type only) [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vel      !< Array of field velocities [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Acc      !< Array of field accelerations [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: VelTower      !< Array of tower velocities [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AccTower      !< Array of tower accelerations [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: VelAvg      !< Average velocity profile by Z and time [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AccAvg      !< Average acceleration profile by Z and time [-]
    REAL(ReKi)  :: DTime = 0      !< Delta time [seconds]
    REAL(ReKi)  :: Rate = 0      !< Data rate (1/FFDTime) [Hertz]
    REAL(ReKi)  :: YHWid = 0      !< Half the grid width [meters]
    REAL(ReKi)  :: ZHWid = 0      !< Half the grid height [meters]
    REAL(ReKi)  :: GridBase = 0      !< the height of the bottom of the grid [meters]
    REAL(ReKi)  :: InitXPosition = 0      !< the initial x position of grid (distance in FF is offset) [meters]
    REAL(ReKi)  :: InvDY = 0      !< reciprocal of delta y [1/meters]
    REAL(ReKi)  :: InvDZ = 0      !< reciprocal of delta z [1/meters]
    REAL(ReKi)  :: MeanWS = 0      !< Mean wind speed (as defined in FF file), not necessarily of the portion used [meters/second]
    REAL(ReKi)  :: InvMWS = 0      !< reciprocal of mean wind speed (MeanFFWS) [seconds/meter]
    REAL(ReKi)  :: TotalTime = 0      !< The total time of the simulation [seconds]
    INTEGER(IntKi)  :: NComp = 3      !< Number of wind components [-]
    INTEGER(IntKi)  :: NYGrids = 0      !< Number of points in the lateral (y) direction of the grids [-]
    INTEGER(IntKi)  :: NZGrids = 0      !< Number of points in the vertical (z) direction of the grids [-]
    INTEGER(IntKi)  :: NTGrids = 0      !< Number of points in the vertical (z) direction on the tower (below the grids) [-]
    INTEGER(IntKi)  :: NSteps = 0      !< Number of time steps in the FF array [-]
    REAL(ReKi)  :: PLExp = 0      !< Power law exponent (used for PL wind profile type only) [-]
    REAL(ReKi)  :: Z0 = 0      !< Surface roughness length (used for LOG wind profile type only) [-]
    REAL(ReKi)  :: VLinShr = 0      !< Vertical linear wind shear coefficient (used for vertical linear wind profile type only) [-]
    REAL(ReKi)  :: HLinShr = 0      !< Horizontal linear wind shear coefficient (used for horizontal wind profile type only) [-]
    LOGICAL  :: BoxExceedAllowF = .FALSE.      !< Flag to allow Extrapolation winds outside box starting at this index (for OLAF wakes and LidarSim) [-]
    INTEGER(IntKi)  :: BoxExceedAllowIdx = -1      !< Extrapolate winds outside box starting at this index (for OLAF wakes and LidarSim) [-]
    LOGICAL  :: BoxExceedWarned = .FALSE.      !< Has a warning been issued for points extrapolated beyond FFWind grid [-]
  END TYPE Grid3DFieldType
! =======================
! =========  Grid4DFieldType  =======
  TYPE, PUBLIC :: Grid4DFieldType
    INTEGER(IntKi) , DIMENSION(1:4)  :: n      !< number of evenly-spaced grid points in the x, y, z, and t directions [-]
    REAL(ReKi) , DIMENSION(1:4)  :: delta      !< size between 2 consecutive grid points in each grid direction [m,m,m,s]
    REAL(ReKi) , DIMENSION(1:3)  :: pZero      !< fixed position of the XYZ grid (i.e., XYZ coordinates of m%V(:,1,1,1,:)) [m]
    REAL(SiKi) , DIMENSION(:,:,:,:,:), POINTER  :: Vel => NULL()      !< this is the 4-d velocity field for each wind component [{uvw},nx,ny,nz,nt] [-]
    REAL(ReKi)  :: TimeStart      !< this is the time where the first time grid in m%V starts (i.e, the time associated with m%V(:,:,:,:,1)) [s]
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
  END TYPE Grid4DFieldType
! =======================
! =========  PointsFieldType  =======
  TYPE, PUBLIC :: PointsFieldType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Vel      !< Point velocities populated by external driver [uvw,point] [-]
  END TYPE PointsFieldType
! =======================
! =========  UserFieldType  =======
  TYPE, PUBLIC :: UserFieldType
    REAL(ReKi)  :: RefHeight      !< reference height; used to center the wind [meters]
  END TYPE UserFieldType
! =======================
! =========  FlowFieldType  =======
  TYPE, PUBLIC :: FlowFieldType
    INTEGER(IntKi)  :: FieldType = 0      !< Switch for flow field type {1=Uniform, 2=Grid, 3=User, 4=External} [-]
    REAL(ReKi) , DIMENSION(1:3)  :: RefPosition      !< Reference position (point where box is rotated) [meters]
    REAL(ReKi)  :: PropagationDir      !< Direction of wind propagation [radians]
    REAL(ReKi)  :: VFlowAngle      !< Vertical (upflow) angle [radians]
    LOGICAL  :: VelInterpCubic = .false.      !< Velocity interpolation order in time (1=linear; 3=cubic) [Used with WindType=2,3,4,5,7] [-]
    LOGICAL  :: RotateWindBox = .false.      !< flag indicating if the wind will be rotated [-]
    LOGICAL  :: AccFieldValid = .false.      !< flag indicating that acceleration field has been calculated [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: RotToWind      !< Rotation matrix for rotating from the global XYZ coordinate system to the wind coordinate system (wind along X') [-]
    REAL(ReKi) , DIMENSION(1:3,1:3)  :: RotFromWind      !< Rotation matrix for rotating from the wind coordinate system (wind along X') back to the global XYZ coordinate system.  Equal to TRANSPOSE(RotToWind) [-]
    TYPE(UniformFieldType)  :: Uniform      !< Uniform Flow Data [-]
    TYPE(Grid3DFieldType)  :: Grid3D      !< Grid Field Wind Data [-]
    TYPE(Grid4DFieldType)  :: Grid4D      !< External Grid Flow Data [-]
    TYPE(PointsFieldType)  :: Points      !< External Point Flow Data [-]
    TYPE(UserFieldType)  :: User      !< User Field Wind Data [-]
  END TYPE FlowFieldType
! =======================
CONTAINS
 SUBROUTINE IfW_FlowField_CopyUniformFieldType( SrcUniformFieldTypeData, DstUniformFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UniformFieldType), INTENT(IN) :: SrcUniformFieldTypeData
   TYPE(UniformFieldType), INTENT(INOUT) :: DstUniformFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyUniformFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUniformFieldTypeData%RefHeight = SrcUniformFieldTypeData%RefHeight
    DstUniformFieldTypeData%RefLength = SrcUniformFieldTypeData%RefLength
    DstUniformFieldTypeData%DataSize = SrcUniformFieldTypeData%DataSize
IF (ALLOCATED(SrcUniformFieldTypeData%Time)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%Time,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%Time,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%Time)) THEN 
    ALLOCATE(DstUniformFieldTypeData%Time(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%Time.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%Time = SrcUniformFieldTypeData%Time
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelH)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelH,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelH,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelH)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelH.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelH = SrcUniformFieldTypeData%VelH
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelHDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelHDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelHDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelHDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelHDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelHDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelHDot = SrcUniformFieldTypeData%VelHDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelV = SrcUniformFieldTypeData%VelV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelVDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelVDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelVDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelVDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelVDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelVDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelVDot = SrcUniformFieldTypeData%VelVDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelGust)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelGust,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelGust,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelGust)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelGust(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelGust.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelGust = SrcUniformFieldTypeData%VelGust
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%VelGustDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%VelGustDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%VelGustDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%VelGustDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%VelGustDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%VelGustDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%VelGustDot = SrcUniformFieldTypeData%VelGustDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%AngleH)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%AngleH,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%AngleH,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%AngleH)) THEN 
    ALLOCATE(DstUniformFieldTypeData%AngleH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleH.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%AngleH = SrcUniformFieldTypeData%AngleH
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%AngleHDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%AngleHDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%AngleHDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%AngleHDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%AngleHDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleHDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%AngleHDot = SrcUniformFieldTypeData%AngleHDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%AngleV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%AngleV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%AngleV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%AngleV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%AngleV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%AngleV = SrcUniformFieldTypeData%AngleV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%AngleVDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%AngleVDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%AngleVDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%AngleVDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%AngleVDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%AngleVDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%AngleVDot = SrcUniformFieldTypeData%AngleVDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%ShrH)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%ShrH,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%ShrH,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%ShrH)) THEN 
    ALLOCATE(DstUniformFieldTypeData%ShrH(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrH.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%ShrH = SrcUniformFieldTypeData%ShrH
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%ShrHDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%ShrHDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%ShrHDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%ShrHDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%ShrHDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrHDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%ShrHDot = SrcUniformFieldTypeData%ShrHDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%ShrV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%ShrV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%ShrV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%ShrV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%ShrV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%ShrV = SrcUniformFieldTypeData%ShrV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%ShrVDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%ShrVDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%ShrVDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%ShrVDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%ShrVDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%ShrVDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%ShrVDot = SrcUniformFieldTypeData%ShrVDot
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%LinShrV)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%LinShrV,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%LinShrV,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%LinShrV)) THEN 
    ALLOCATE(DstUniformFieldTypeData%LinShrV(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%LinShrV.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%LinShrV = SrcUniformFieldTypeData%LinShrV
ENDIF
IF (ALLOCATED(SrcUniformFieldTypeData%LinShrVDot)) THEN
  i1_l = LBOUND(SrcUniformFieldTypeData%LinShrVDot,1)
  i1_u = UBOUND(SrcUniformFieldTypeData%LinShrVDot,1)
  IF (.NOT. ALLOCATED(DstUniformFieldTypeData%LinShrVDot)) THEN 
    ALLOCATE(DstUniformFieldTypeData%LinShrVDot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstUniformFieldTypeData%LinShrVDot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstUniformFieldTypeData%LinShrVDot = SrcUniformFieldTypeData%LinShrVDot
ENDIF
 END SUBROUTINE IfW_FlowField_CopyUniformFieldType

 SUBROUTINE IfW_FlowField_DestroyUniformFieldType( UniformFieldTypeData, ErrStat, ErrMsg )
  TYPE(UniformFieldType), INTENT(INOUT) :: UniformFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyUniformFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(UniformFieldTypeData%Time)) THEN
  DEALLOCATE(UniformFieldTypeData%Time)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelH)) THEN
  DEALLOCATE(UniformFieldTypeData%VelH)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelHDot)) THEN
  DEALLOCATE(UniformFieldTypeData%VelHDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelV)) THEN
  DEALLOCATE(UniformFieldTypeData%VelV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelVDot)) THEN
  DEALLOCATE(UniformFieldTypeData%VelVDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelGust)) THEN
  DEALLOCATE(UniformFieldTypeData%VelGust)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%VelGustDot)) THEN
  DEALLOCATE(UniformFieldTypeData%VelGustDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%AngleH)) THEN
  DEALLOCATE(UniformFieldTypeData%AngleH)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%AngleHDot)) THEN
  DEALLOCATE(UniformFieldTypeData%AngleHDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%AngleV)) THEN
  DEALLOCATE(UniformFieldTypeData%AngleV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%AngleVDot)) THEN
  DEALLOCATE(UniformFieldTypeData%AngleVDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%ShrH)) THEN
  DEALLOCATE(UniformFieldTypeData%ShrH)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%ShrHDot)) THEN
  DEALLOCATE(UniformFieldTypeData%ShrHDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%ShrV)) THEN
  DEALLOCATE(UniformFieldTypeData%ShrV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%ShrVDot)) THEN
  DEALLOCATE(UniformFieldTypeData%ShrVDot)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%LinShrV)) THEN
  DEALLOCATE(UniformFieldTypeData%LinShrV)
ENDIF
IF (ALLOCATED(UniformFieldTypeData%LinShrVDot)) THEN
  DEALLOCATE(UniformFieldTypeData%LinShrVDot)
ENDIF
 END SUBROUTINE IfW_FlowField_DestroyUniformFieldType


subroutine IfW_FlowField_PackUniformFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(UniformFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackUniformFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! RefHeight
   call RegPack(Buf, InData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegPack(Buf, InData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DataSize
   call RegPack(Buf, InData%DataSize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Time
   call RegPack(Buf, allocated(InData%Time))
   if (allocated(InData%Time)) then
      call RegPackBounds(Buf, 1, lbound(InData%Time), ubound(InData%Time))
      call RegPack(Buf, InData%Time)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelH
   call RegPack(Buf, allocated(InData%VelH))
   if (allocated(InData%VelH)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelH), ubound(InData%VelH))
      call RegPack(Buf, InData%VelH)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelHDot
   call RegPack(Buf, allocated(InData%VelHDot))
   if (allocated(InData%VelHDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelHDot), ubound(InData%VelHDot))
      call RegPack(Buf, InData%VelHDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelV
   call RegPack(Buf, allocated(InData%VelV))
   if (allocated(InData%VelV)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelV), ubound(InData%VelV))
      call RegPack(Buf, InData%VelV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelVDot
   call RegPack(Buf, allocated(InData%VelVDot))
   if (allocated(InData%VelVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelVDot), ubound(InData%VelVDot))
      call RegPack(Buf, InData%VelVDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelGust
   call RegPack(Buf, allocated(InData%VelGust))
   if (allocated(InData%VelGust)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelGust), ubound(InData%VelGust))
      call RegPack(Buf, InData%VelGust)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelGustDot
   call RegPack(Buf, allocated(InData%VelGustDot))
   if (allocated(InData%VelGustDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%VelGustDot), ubound(InData%VelGustDot))
      call RegPack(Buf, InData%VelGustDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleH
   call RegPack(Buf, allocated(InData%AngleH))
   if (allocated(InData%AngleH)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleH), ubound(InData%AngleH))
      call RegPack(Buf, InData%AngleH)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleHDot
   call RegPack(Buf, allocated(InData%AngleHDot))
   if (allocated(InData%AngleHDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleHDot), ubound(InData%AngleHDot))
      call RegPack(Buf, InData%AngleHDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleV
   call RegPack(Buf, allocated(InData%AngleV))
   if (allocated(InData%AngleV)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleV), ubound(InData%AngleV))
      call RegPack(Buf, InData%AngleV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleVDot
   call RegPack(Buf, allocated(InData%AngleVDot))
   if (allocated(InData%AngleVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%AngleVDot), ubound(InData%AngleVDot))
      call RegPack(Buf, InData%AngleVDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrH
   call RegPack(Buf, allocated(InData%ShrH))
   if (allocated(InData%ShrH)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrH), ubound(InData%ShrH))
      call RegPack(Buf, InData%ShrH)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrHDot
   call RegPack(Buf, allocated(InData%ShrHDot))
   if (allocated(InData%ShrHDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrHDot), ubound(InData%ShrHDot))
      call RegPack(Buf, InData%ShrHDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrV
   call RegPack(Buf, allocated(InData%ShrV))
   if (allocated(InData%ShrV)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrV), ubound(InData%ShrV))
      call RegPack(Buf, InData%ShrV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrVDot
   call RegPack(Buf, allocated(InData%ShrVDot))
   if (allocated(InData%ShrVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%ShrVDot), ubound(InData%ShrVDot))
      call RegPack(Buf, InData%ShrVDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinShrV
   call RegPack(Buf, allocated(InData%LinShrV))
   if (allocated(InData%LinShrV)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinShrV), ubound(InData%LinShrV))
      call RegPack(Buf, InData%LinShrV)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinShrVDot
   call RegPack(Buf, allocated(InData%LinShrVDot))
   if (allocated(InData%LinShrVDot)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinShrVDot), ubound(InData%LinShrVDot))
      call RegPack(Buf, InData%LinShrVDot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackUniformFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(UniformFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackUniformFieldType'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! RefHeight
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegUnpack(Buf, OutData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DataSize
   call RegUnpack(Buf, OutData%DataSize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Time
   if (allocated(OutData%Time)) deallocate(OutData%Time)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Time(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Time.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Time)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelH
   if (allocated(OutData%VelH)) deallocate(OutData%VelH)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelH(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelH.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelH)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelHDot
   if (allocated(OutData%VelHDot)) deallocate(OutData%VelHDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelHDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelHDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelHDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelV
   if (allocated(OutData%VelV)) deallocate(OutData%VelV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelVDot
   if (allocated(OutData%VelVDot)) deallocate(OutData%VelVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelGust
   if (allocated(OutData%VelGust)) deallocate(OutData%VelGust)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelGust(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelGust.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelGust)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelGustDot
   if (allocated(OutData%VelGustDot)) deallocate(OutData%VelGustDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelGustDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelGustDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelGustDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AngleH
   if (allocated(OutData%AngleH)) deallocate(OutData%AngleH)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleH(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleH.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleH)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AngleHDot
   if (allocated(OutData%AngleHDot)) deallocate(OutData%AngleHDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleHDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleHDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleHDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AngleV
   if (allocated(OutData%AngleV)) deallocate(OutData%AngleV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AngleVDot
   if (allocated(OutData%AngleVDot)) deallocate(OutData%AngleVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AngleVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AngleVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AngleVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ShrH
   if (allocated(OutData%ShrH)) deallocate(OutData%ShrH)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrH(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrH.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrH)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ShrHDot
   if (allocated(OutData%ShrHDot)) deallocate(OutData%ShrHDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrHDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrHDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrHDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ShrV
   if (allocated(OutData%ShrV)) deallocate(OutData%ShrV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ShrVDot
   if (allocated(OutData%ShrVDot)) deallocate(OutData%ShrVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ShrVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShrVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ShrVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinShrV
   if (allocated(OutData%LinShrV)) deallocate(OutData%LinShrV)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinShrV(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinShrV.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinShrV)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinShrVDot
   if (allocated(OutData%LinShrVDot)) deallocate(OutData%LinShrVDot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinShrVDot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinShrVDot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinShrVDot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE IfW_FlowField_CopyUniformField_Interp( SrcUniformField_InterpData, DstUniformField_InterpData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UniformField_Interp), INTENT(IN) :: SrcUniformField_InterpData
   TYPE(UniformField_Interp), INTENT(INOUT) :: DstUniformField_InterpData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyUniformField_Interp'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUniformField_InterpData%VelH = SrcUniformField_InterpData%VelH
    DstUniformField_InterpData%VelHDot = SrcUniformField_InterpData%VelHDot
    DstUniformField_InterpData%VelV = SrcUniformField_InterpData%VelV
    DstUniformField_InterpData%VelVDot = SrcUniformField_InterpData%VelVDot
    DstUniformField_InterpData%VelGust = SrcUniformField_InterpData%VelGust
    DstUniformField_InterpData%VelGustDot = SrcUniformField_InterpData%VelGustDot
    DstUniformField_InterpData%AngleH = SrcUniformField_InterpData%AngleH
    DstUniformField_InterpData%AngleHDot = SrcUniformField_InterpData%AngleHDot
    DstUniformField_InterpData%AngleV = SrcUniformField_InterpData%AngleV
    DstUniformField_InterpData%AngleVDot = SrcUniformField_InterpData%AngleVDot
    DstUniformField_InterpData%ShrH = SrcUniformField_InterpData%ShrH
    DstUniformField_InterpData%ShrHDot = SrcUniformField_InterpData%ShrHDot
    DstUniformField_InterpData%ShrV = SrcUniformField_InterpData%ShrV
    DstUniformField_InterpData%ShrVDot = SrcUniformField_InterpData%ShrVDot
    DstUniformField_InterpData%LinShrV = SrcUniformField_InterpData%LinShrV
    DstUniformField_InterpData%LinShrVDot = SrcUniformField_InterpData%LinShrVDot
    DstUniformField_InterpData%CosAngleH = SrcUniformField_InterpData%CosAngleH
    DstUniformField_InterpData%SinAngleH = SrcUniformField_InterpData%SinAngleH
    DstUniformField_InterpData%CosAngleV = SrcUniformField_InterpData%CosAngleV
    DstUniformField_InterpData%SinAngleV = SrcUniformField_InterpData%SinAngleV
 END SUBROUTINE IfW_FlowField_CopyUniformField_Interp

 SUBROUTINE IfW_FlowField_DestroyUniformField_Interp( UniformField_InterpData, ErrStat, ErrMsg )
  TYPE(UniformField_Interp), INTENT(INOUT) :: UniformField_InterpData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyUniformField_Interp'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE IfW_FlowField_DestroyUniformField_Interp


subroutine IfW_FlowField_PackUniformField_Interp(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(UniformField_Interp), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackUniformField_Interp'
   if (Buf%ErrStat >= AbortErrLev) return
   ! VelH
   call RegPack(Buf, InData%VelH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelHDot
   call RegPack(Buf, InData%VelHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelV
   call RegPack(Buf, InData%VelV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelVDot
   call RegPack(Buf, InData%VelVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelGust
   call RegPack(Buf, InData%VelGust)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelGustDot
   call RegPack(Buf, InData%VelGustDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleH
   call RegPack(Buf, InData%AngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleHDot
   call RegPack(Buf, InData%AngleHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleV
   call RegPack(Buf, InData%AngleV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleVDot
   call RegPack(Buf, InData%AngleVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrH
   call RegPack(Buf, InData%ShrH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrHDot
   call RegPack(Buf, InData%ShrHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrV
   call RegPack(Buf, InData%ShrV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrVDot
   call RegPack(Buf, InData%ShrVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinShrV
   call RegPack(Buf, InData%LinShrV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinShrVDot
   call RegPack(Buf, InData%LinShrVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CosAngleH
   call RegPack(Buf, InData%CosAngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SinAngleH
   call RegPack(Buf, InData%SinAngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CosAngleV
   call RegPack(Buf, InData%CosAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SinAngleV
   call RegPack(Buf, InData%SinAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackUniformField_Interp(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(UniformField_Interp), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackUniformField_Interp'
   if (Buf%ErrStat /= ErrID_None) return
   ! VelH
   call RegUnpack(Buf, OutData%VelH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelHDot
   call RegUnpack(Buf, OutData%VelHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelV
   call RegUnpack(Buf, OutData%VelV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelVDot
   call RegUnpack(Buf, OutData%VelVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelGust
   call RegUnpack(Buf, OutData%VelGust)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelGustDot
   call RegUnpack(Buf, OutData%VelGustDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleH
   call RegUnpack(Buf, OutData%AngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleHDot
   call RegUnpack(Buf, OutData%AngleHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleV
   call RegUnpack(Buf, OutData%AngleV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AngleVDot
   call RegUnpack(Buf, OutData%AngleVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrH
   call RegUnpack(Buf, OutData%ShrH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrHDot
   call RegUnpack(Buf, OutData%ShrHDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrV
   call RegUnpack(Buf, OutData%ShrV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShrVDot
   call RegUnpack(Buf, OutData%ShrVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinShrV
   call RegUnpack(Buf, OutData%LinShrV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinShrVDot
   call RegUnpack(Buf, OutData%LinShrVDot)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CosAngleH
   call RegUnpack(Buf, OutData%CosAngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SinAngleH
   call RegUnpack(Buf, OutData%SinAngleH)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CosAngleV
   call RegUnpack(Buf, OutData%CosAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SinAngleV
   call RegUnpack(Buf, OutData%SinAngleV)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE IfW_FlowField_CopyGrid3DFieldType( SrcGrid3DFieldTypeData, DstGrid3DFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Grid3DFieldType), INTENT(IN) :: SrcGrid3DFieldTypeData
   TYPE(Grid3DFieldType), INTENT(INOUT) :: DstGrid3DFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyGrid3DFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstGrid3DFieldTypeData%WindFileFormat = SrcGrid3DFieldTypeData%WindFileFormat
    DstGrid3DFieldTypeData%WindProfileType = SrcGrid3DFieldTypeData%WindProfileType
    DstGrid3DFieldTypeData%Periodic = SrcGrid3DFieldTypeData%Periodic
    DstGrid3DFieldTypeData%InterpTower = SrcGrid3DFieldTypeData%InterpTower
    DstGrid3DFieldTypeData%AddMeanAfterInterp = SrcGrid3DFieldTypeData%AddMeanAfterInterp
    DstGrid3DFieldTypeData%RefHeight = SrcGrid3DFieldTypeData%RefHeight
    DstGrid3DFieldTypeData%RefLength = SrcGrid3DFieldTypeData%RefLength
IF (ALLOCATED(SrcGrid3DFieldTypeData%Vel)) THEN
  i1_l = LBOUND(SrcGrid3DFieldTypeData%Vel,1)
  i1_u = UBOUND(SrcGrid3DFieldTypeData%Vel,1)
  i2_l = LBOUND(SrcGrid3DFieldTypeData%Vel,2)
  i2_u = UBOUND(SrcGrid3DFieldTypeData%Vel,2)
  i3_l = LBOUND(SrcGrid3DFieldTypeData%Vel,3)
  i3_u = UBOUND(SrcGrid3DFieldTypeData%Vel,3)
  i4_l = LBOUND(SrcGrid3DFieldTypeData%Vel,4)
  i4_u = UBOUND(SrcGrid3DFieldTypeData%Vel,4)
  IF (.NOT. ALLOCATED(DstGrid3DFieldTypeData%Vel)) THEN 
    ALLOCATE(DstGrid3DFieldTypeData%Vel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%Vel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGrid3DFieldTypeData%Vel = SrcGrid3DFieldTypeData%Vel
ENDIF
IF (ALLOCATED(SrcGrid3DFieldTypeData%Acc)) THEN
  i1_l = LBOUND(SrcGrid3DFieldTypeData%Acc,1)
  i1_u = UBOUND(SrcGrid3DFieldTypeData%Acc,1)
  i2_l = LBOUND(SrcGrid3DFieldTypeData%Acc,2)
  i2_u = UBOUND(SrcGrid3DFieldTypeData%Acc,2)
  i3_l = LBOUND(SrcGrid3DFieldTypeData%Acc,3)
  i3_u = UBOUND(SrcGrid3DFieldTypeData%Acc,3)
  i4_l = LBOUND(SrcGrid3DFieldTypeData%Acc,4)
  i4_u = UBOUND(SrcGrid3DFieldTypeData%Acc,4)
  IF (.NOT. ALLOCATED(DstGrid3DFieldTypeData%Acc)) THEN 
    ALLOCATE(DstGrid3DFieldTypeData%Acc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%Acc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGrid3DFieldTypeData%Acc = SrcGrid3DFieldTypeData%Acc
ENDIF
IF (ALLOCATED(SrcGrid3DFieldTypeData%VelTower)) THEN
  i1_l = LBOUND(SrcGrid3DFieldTypeData%VelTower,1)
  i1_u = UBOUND(SrcGrid3DFieldTypeData%VelTower,1)
  i2_l = LBOUND(SrcGrid3DFieldTypeData%VelTower,2)
  i2_u = UBOUND(SrcGrid3DFieldTypeData%VelTower,2)
  i3_l = LBOUND(SrcGrid3DFieldTypeData%VelTower,3)
  i3_u = UBOUND(SrcGrid3DFieldTypeData%VelTower,3)
  IF (.NOT. ALLOCATED(DstGrid3DFieldTypeData%VelTower)) THEN 
    ALLOCATE(DstGrid3DFieldTypeData%VelTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%VelTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGrid3DFieldTypeData%VelTower = SrcGrid3DFieldTypeData%VelTower
ENDIF
IF (ALLOCATED(SrcGrid3DFieldTypeData%AccTower)) THEN
  i1_l = LBOUND(SrcGrid3DFieldTypeData%AccTower,1)
  i1_u = UBOUND(SrcGrid3DFieldTypeData%AccTower,1)
  i2_l = LBOUND(SrcGrid3DFieldTypeData%AccTower,2)
  i2_u = UBOUND(SrcGrid3DFieldTypeData%AccTower,2)
  i3_l = LBOUND(SrcGrid3DFieldTypeData%AccTower,3)
  i3_u = UBOUND(SrcGrid3DFieldTypeData%AccTower,3)
  IF (.NOT. ALLOCATED(DstGrid3DFieldTypeData%AccTower)) THEN 
    ALLOCATE(DstGrid3DFieldTypeData%AccTower(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%AccTower.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGrid3DFieldTypeData%AccTower = SrcGrid3DFieldTypeData%AccTower
ENDIF
IF (ALLOCATED(SrcGrid3DFieldTypeData%VelAvg)) THEN
  i1_l = LBOUND(SrcGrid3DFieldTypeData%VelAvg,1)
  i1_u = UBOUND(SrcGrid3DFieldTypeData%VelAvg,1)
  i2_l = LBOUND(SrcGrid3DFieldTypeData%VelAvg,2)
  i2_u = UBOUND(SrcGrid3DFieldTypeData%VelAvg,2)
  i3_l = LBOUND(SrcGrid3DFieldTypeData%VelAvg,3)
  i3_u = UBOUND(SrcGrid3DFieldTypeData%VelAvg,3)
  IF (.NOT. ALLOCATED(DstGrid3DFieldTypeData%VelAvg)) THEN 
    ALLOCATE(DstGrid3DFieldTypeData%VelAvg(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%VelAvg.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGrid3DFieldTypeData%VelAvg = SrcGrid3DFieldTypeData%VelAvg
ENDIF
IF (ALLOCATED(SrcGrid3DFieldTypeData%AccAvg)) THEN
  i1_l = LBOUND(SrcGrid3DFieldTypeData%AccAvg,1)
  i1_u = UBOUND(SrcGrid3DFieldTypeData%AccAvg,1)
  i2_l = LBOUND(SrcGrid3DFieldTypeData%AccAvg,2)
  i2_u = UBOUND(SrcGrid3DFieldTypeData%AccAvg,2)
  i3_l = LBOUND(SrcGrid3DFieldTypeData%AccAvg,3)
  i3_u = UBOUND(SrcGrid3DFieldTypeData%AccAvg,3)
  IF (.NOT. ALLOCATED(DstGrid3DFieldTypeData%AccAvg)) THEN 
    ALLOCATE(DstGrid3DFieldTypeData%AccAvg(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstGrid3DFieldTypeData%AccAvg.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstGrid3DFieldTypeData%AccAvg = SrcGrid3DFieldTypeData%AccAvg
ENDIF
    DstGrid3DFieldTypeData%DTime = SrcGrid3DFieldTypeData%DTime
    DstGrid3DFieldTypeData%Rate = SrcGrid3DFieldTypeData%Rate
    DstGrid3DFieldTypeData%YHWid = SrcGrid3DFieldTypeData%YHWid
    DstGrid3DFieldTypeData%ZHWid = SrcGrid3DFieldTypeData%ZHWid
    DstGrid3DFieldTypeData%GridBase = SrcGrid3DFieldTypeData%GridBase
    DstGrid3DFieldTypeData%InitXPosition = SrcGrid3DFieldTypeData%InitXPosition
    DstGrid3DFieldTypeData%InvDY = SrcGrid3DFieldTypeData%InvDY
    DstGrid3DFieldTypeData%InvDZ = SrcGrid3DFieldTypeData%InvDZ
    DstGrid3DFieldTypeData%MeanWS = SrcGrid3DFieldTypeData%MeanWS
    DstGrid3DFieldTypeData%InvMWS = SrcGrid3DFieldTypeData%InvMWS
    DstGrid3DFieldTypeData%TotalTime = SrcGrid3DFieldTypeData%TotalTime
    DstGrid3DFieldTypeData%NComp = SrcGrid3DFieldTypeData%NComp
    DstGrid3DFieldTypeData%NYGrids = SrcGrid3DFieldTypeData%NYGrids
    DstGrid3DFieldTypeData%NZGrids = SrcGrid3DFieldTypeData%NZGrids
    DstGrid3DFieldTypeData%NTGrids = SrcGrid3DFieldTypeData%NTGrids
    DstGrid3DFieldTypeData%NSteps = SrcGrid3DFieldTypeData%NSteps
    DstGrid3DFieldTypeData%PLExp = SrcGrid3DFieldTypeData%PLExp
    DstGrid3DFieldTypeData%Z0 = SrcGrid3DFieldTypeData%Z0
    DstGrid3DFieldTypeData%VLinShr = SrcGrid3DFieldTypeData%VLinShr
    DstGrid3DFieldTypeData%HLinShr = SrcGrid3DFieldTypeData%HLinShr
    DstGrid3DFieldTypeData%BoxExceedAllowF = SrcGrid3DFieldTypeData%BoxExceedAllowF
    DstGrid3DFieldTypeData%BoxExceedAllowIdx = SrcGrid3DFieldTypeData%BoxExceedAllowIdx
    DstGrid3DFieldTypeData%BoxExceedWarned = SrcGrid3DFieldTypeData%BoxExceedWarned
 END SUBROUTINE IfW_FlowField_CopyGrid3DFieldType

 SUBROUTINE IfW_FlowField_DestroyGrid3DFieldType( Grid3DFieldTypeData, ErrStat, ErrMsg )
  TYPE(Grid3DFieldType), INTENT(INOUT) :: Grid3DFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyGrid3DFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(Grid3DFieldTypeData%Vel)) THEN
  DEALLOCATE(Grid3DFieldTypeData%Vel)
ENDIF
IF (ALLOCATED(Grid3DFieldTypeData%Acc)) THEN
  DEALLOCATE(Grid3DFieldTypeData%Acc)
ENDIF
IF (ALLOCATED(Grid3DFieldTypeData%VelTower)) THEN
  DEALLOCATE(Grid3DFieldTypeData%VelTower)
ENDIF
IF (ALLOCATED(Grid3DFieldTypeData%AccTower)) THEN
  DEALLOCATE(Grid3DFieldTypeData%AccTower)
ENDIF
IF (ALLOCATED(Grid3DFieldTypeData%VelAvg)) THEN
  DEALLOCATE(Grid3DFieldTypeData%VelAvg)
ENDIF
IF (ALLOCATED(Grid3DFieldTypeData%AccAvg)) THEN
  DEALLOCATE(Grid3DFieldTypeData%AccAvg)
ENDIF
 END SUBROUTINE IfW_FlowField_DestroyGrid3DFieldType


subroutine IfW_FlowField_PackGrid3DFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Grid3DFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackGrid3DFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WindFileFormat
   call RegPack(Buf, InData%WindFileFormat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindProfileType
   call RegPack(Buf, InData%WindProfileType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Periodic
   call RegPack(Buf, InData%Periodic)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InterpTower
   call RegPack(Buf, InData%InterpTower)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddMeanAfterInterp
   call RegPack(Buf, InData%AddMeanAfterInterp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHeight
   call RegPack(Buf, InData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegPack(Buf, InData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vel
   call RegPack(Buf, allocated(InData%Vel))
   if (allocated(InData%Vel)) then
      call RegPackBounds(Buf, 4, lbound(InData%Vel), ubound(InData%Vel))
      call RegPack(Buf, InData%Vel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Acc
   call RegPack(Buf, allocated(InData%Acc))
   if (allocated(InData%Acc)) then
      call RegPackBounds(Buf, 4, lbound(InData%Acc), ubound(InData%Acc))
      call RegPack(Buf, InData%Acc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelTower
   call RegPack(Buf, allocated(InData%VelTower))
   if (allocated(InData%VelTower)) then
      call RegPackBounds(Buf, 3, lbound(InData%VelTower), ubound(InData%VelTower))
      call RegPack(Buf, InData%VelTower)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AccTower
   call RegPack(Buf, allocated(InData%AccTower))
   if (allocated(InData%AccTower)) then
      call RegPackBounds(Buf, 3, lbound(InData%AccTower), ubound(InData%AccTower))
      call RegPack(Buf, InData%AccTower)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelAvg
   call RegPack(Buf, allocated(InData%VelAvg))
   if (allocated(InData%VelAvg)) then
      call RegPackBounds(Buf, 3, lbound(InData%VelAvg), ubound(InData%VelAvg))
      call RegPack(Buf, InData%VelAvg)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AccAvg
   call RegPack(Buf, allocated(InData%AccAvg))
   if (allocated(InData%AccAvg)) then
      call RegPackBounds(Buf, 3, lbound(InData%AccAvg), ubound(InData%AccAvg))
      call RegPack(Buf, InData%AccAvg)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DTime
   call RegPack(Buf, InData%DTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rate
   call RegPack(Buf, InData%Rate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YHWid
   call RegPack(Buf, InData%YHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ZHWid
   call RegPack(Buf, InData%ZHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GridBase
   call RegPack(Buf, InData%GridBase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitXPosition
   call RegPack(Buf, InData%InitXPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvDY
   call RegPack(Buf, InData%InvDY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvDZ
   call RegPack(Buf, InData%InvDZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeanWS
   call RegPack(Buf, InData%MeanWS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvMWS
   call RegPack(Buf, InData%InvMWS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TotalTime
   call RegPack(Buf, InData%TotalTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NComp
   call RegPack(Buf, InData%NComp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NYGrids
   call RegPack(Buf, InData%NYGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NZGrids
   call RegPack(Buf, InData%NZGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTGrids
   call RegPack(Buf, InData%NTGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NSteps
   call RegPack(Buf, InData%NSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PLExp
   call RegPack(Buf, InData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0
   call RegPack(Buf, InData%Z0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VLinShr
   call RegPack(Buf, InData%VLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLinShr
   call RegPack(Buf, InData%HLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BoxExceedAllowF
   call RegPack(Buf, InData%BoxExceedAllowF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BoxExceedAllowIdx
   call RegPack(Buf, InData%BoxExceedAllowIdx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BoxExceedWarned
   call RegPack(Buf, InData%BoxExceedWarned)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackGrid3DFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Grid3DFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackGrid3DFieldType'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WindFileFormat
   call RegUnpack(Buf, OutData%WindFileFormat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WindProfileType
   call RegUnpack(Buf, OutData%WindProfileType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Periodic
   call RegUnpack(Buf, OutData%Periodic)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InterpTower
   call RegUnpack(Buf, OutData%InterpTower)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddMeanAfterInterp
   call RegUnpack(Buf, OutData%AddMeanAfterInterp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHeight
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefLength
   call RegUnpack(Buf, OutData%RefLength)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vel
   if (allocated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Acc
   if (allocated(OutData%Acc)) deallocate(OutData%Acc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Acc(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Acc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Acc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelTower
   if (allocated(OutData%VelTower)) deallocate(OutData%VelTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelTower(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AccTower
   if (allocated(OutData%AccTower)) deallocate(OutData%AccTower)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AccTower(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccTower.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AccTower)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! VelAvg
   if (allocated(OutData%VelAvg)) deallocate(OutData%VelAvg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%VelAvg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%VelAvg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%VelAvg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AccAvg
   if (allocated(OutData%AccAvg)) deallocate(OutData%AccAvg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AccAvg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AccAvg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AccAvg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DTime
   call RegUnpack(Buf, OutData%DTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rate
   call RegUnpack(Buf, OutData%Rate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YHWid
   call RegUnpack(Buf, OutData%YHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ZHWid
   call RegUnpack(Buf, OutData%ZHWid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GridBase
   call RegUnpack(Buf, OutData%GridBase)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InitXPosition
   call RegUnpack(Buf, OutData%InitXPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvDY
   call RegUnpack(Buf, OutData%InvDY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvDZ
   call RegUnpack(Buf, OutData%InvDZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MeanWS
   call RegUnpack(Buf, OutData%MeanWS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvMWS
   call RegUnpack(Buf, OutData%InvMWS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TotalTime
   call RegUnpack(Buf, OutData%TotalTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NComp
   call RegUnpack(Buf, OutData%NComp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NYGrids
   call RegUnpack(Buf, OutData%NYGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NZGrids
   call RegUnpack(Buf, OutData%NZGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NTGrids
   call RegUnpack(Buf, OutData%NTGrids)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NSteps
   call RegUnpack(Buf, OutData%NSteps)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PLExp
   call RegUnpack(Buf, OutData%PLExp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Z0
   call RegUnpack(Buf, OutData%Z0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VLinShr
   call RegUnpack(Buf, OutData%VLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HLinShr
   call RegUnpack(Buf, OutData%HLinShr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BoxExceedAllowF
   call RegUnpack(Buf, OutData%BoxExceedAllowF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BoxExceedAllowIdx
   call RegUnpack(Buf, OutData%BoxExceedAllowIdx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! BoxExceedWarned
   call RegUnpack(Buf, OutData%BoxExceedWarned)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE IfW_FlowField_CopyGrid4DFieldType( SrcGrid4DFieldTypeData, DstGrid4DFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Grid4DFieldType), INTENT(IN) :: SrcGrid4DFieldTypeData
   TYPE(Grid4DFieldType), INTENT(INOUT) :: DstGrid4DFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: i5, i5_l, i5_u  !  bounds (upper/lower) for an array dimension 5
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyGrid4DFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstGrid4DFieldTypeData%n = SrcGrid4DFieldTypeData%n
    DstGrid4DFieldTypeData%delta = SrcGrid4DFieldTypeData%delta
    DstGrid4DFieldTypeData%pZero = SrcGrid4DFieldTypeData%pZero
    DstGrid4DFieldTypeData%Vel => SrcGrid4DFieldTypeData%Vel
    DstGrid4DFieldTypeData%TimeStart = SrcGrid4DFieldTypeData%TimeStart
    DstGrid4DFieldTypeData%RefHeight = SrcGrid4DFieldTypeData%RefHeight
 END SUBROUTINE IfW_FlowField_CopyGrid4DFieldType

 SUBROUTINE IfW_FlowField_DestroyGrid4DFieldType( Grid4DFieldTypeData, ErrStat, ErrMsg )
  TYPE(Grid4DFieldType), INTENT(INOUT) :: Grid4DFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyGrid4DFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

NULLIFY(Grid4DFieldTypeData%Vel)
 END SUBROUTINE IfW_FlowField_DestroyGrid4DFieldType


subroutine IfW_FlowField_PackGrid4DFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Grid4DFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackGrid4DFieldType'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! n
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegPack(Buf, InData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegPack(Buf, InData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vel
   call RegPack(Buf, associated(InData%Vel))
   if (associated(InData%Vel)) then
      call RegPackBounds(Buf, 5, lbound(InData%Vel), ubound(InData%Vel))
      call RegPackPointer(Buf, c_loc(InData%Vel), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%Vel)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TimeStart
   call RegPack(Buf, InData%TimeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHeight
   call RegPack(Buf, InData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackGrid4DFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Grid4DFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackGrid4DFieldType'
   integer(IntKi)  :: LB(5), UB(5)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! n
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! delta
   call RegUnpack(Buf, OutData%delta)
   if (RegCheckErr(Buf, RoutineName)) return
   ! pZero
   call RegUnpack(Buf, OutData%pZero)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Vel
   if (associated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 5, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%Vel, UB(1:5)-LB(1:5))
         OutData%Vel(LB(1):,LB(2):,LB(3):,LB(4):,LB(5):) => OutData%Vel
      else
         allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4),LB(5):UB(5)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%Vel)
         call RegUnpack(Buf, OutData%Vel)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%Vel => null()
   end if
   ! TimeStart
   call RegUnpack(Buf, OutData%TimeStart)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefHeight
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE IfW_FlowField_CopyPointsFieldType( SrcPointsFieldTypeData, DstPointsFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(PointsFieldType), INTENT(IN) :: SrcPointsFieldTypeData
   TYPE(PointsFieldType), INTENT(INOUT) :: DstPointsFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyPointsFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcPointsFieldTypeData%Vel)) THEN
  i1_l = LBOUND(SrcPointsFieldTypeData%Vel,1)
  i1_u = UBOUND(SrcPointsFieldTypeData%Vel,1)
  i2_l = LBOUND(SrcPointsFieldTypeData%Vel,2)
  i2_u = UBOUND(SrcPointsFieldTypeData%Vel,2)
  IF (.NOT. ALLOCATED(DstPointsFieldTypeData%Vel)) THEN 
    ALLOCATE(DstPointsFieldTypeData%Vel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstPointsFieldTypeData%Vel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstPointsFieldTypeData%Vel = SrcPointsFieldTypeData%Vel
ENDIF
 END SUBROUTINE IfW_FlowField_CopyPointsFieldType

 SUBROUTINE IfW_FlowField_DestroyPointsFieldType( PointsFieldTypeData, ErrStat, ErrMsg )
  TYPE(PointsFieldType), INTENT(INOUT) :: PointsFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyPointsFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(PointsFieldTypeData%Vel)) THEN
  DEALLOCATE(PointsFieldTypeData%Vel)
ENDIF
 END SUBROUTINE IfW_FlowField_DestroyPointsFieldType


subroutine IfW_FlowField_PackPointsFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(PointsFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackPointsFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Vel
   call RegPack(Buf, allocated(InData%Vel))
   if (allocated(InData%Vel)) then
      call RegPackBounds(Buf, 2, lbound(InData%Vel), ubound(InData%Vel))
      call RegPack(Buf, InData%Vel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackPointsFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(PointsFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackPointsFieldType'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Vel
   if (allocated(OutData%Vel)) deallocate(OutData%Vel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Vel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Vel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE IfW_FlowField_CopyUserFieldType( SrcUserFieldTypeData, DstUserFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(UserFieldType), INTENT(IN) :: SrcUserFieldTypeData
   TYPE(UserFieldType), INTENT(INOUT) :: DstUserFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyUserFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstUserFieldTypeData%RefHeight = SrcUserFieldTypeData%RefHeight
 END SUBROUTINE IfW_FlowField_CopyUserFieldType

 SUBROUTINE IfW_FlowField_DestroyUserFieldType( UserFieldTypeData, ErrStat, ErrMsg )
  TYPE(UserFieldType), INTENT(INOUT) :: UserFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyUserFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE IfW_FlowField_DestroyUserFieldType


subroutine IfW_FlowField_PackUserFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(UserFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackUserFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! RefHeight
   call RegPack(Buf, InData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackUserFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(UserFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackUserFieldType'
   if (Buf%ErrStat /= ErrID_None) return
   ! RefHeight
   call RegUnpack(Buf, OutData%RefHeight)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE IfW_FlowField_CopyFlowFieldType( SrcFlowFieldTypeData, DstFlowFieldTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FlowFieldType), INTENT(IN) :: SrcFlowFieldTypeData
   TYPE(FlowFieldType), INTENT(INOUT) :: DstFlowFieldTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_FlowField_CopyFlowFieldType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstFlowFieldTypeData%FieldType = SrcFlowFieldTypeData%FieldType
    DstFlowFieldTypeData%RefPosition = SrcFlowFieldTypeData%RefPosition
    DstFlowFieldTypeData%PropagationDir = SrcFlowFieldTypeData%PropagationDir
    DstFlowFieldTypeData%VFlowAngle = SrcFlowFieldTypeData%VFlowAngle
    DstFlowFieldTypeData%VelInterpCubic = SrcFlowFieldTypeData%VelInterpCubic
    DstFlowFieldTypeData%RotateWindBox = SrcFlowFieldTypeData%RotateWindBox
    DstFlowFieldTypeData%AccFieldValid = SrcFlowFieldTypeData%AccFieldValid
    DstFlowFieldTypeData%RotToWind = SrcFlowFieldTypeData%RotToWind
    DstFlowFieldTypeData%RotFromWind = SrcFlowFieldTypeData%RotFromWind
      CALL IfW_FlowField_Copyuniformfieldtype( SrcFlowFieldTypeData%Uniform, DstFlowFieldTypeData%Uniform, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IfW_FlowField_Copygrid3dfieldtype( SrcFlowFieldTypeData%Grid3D, DstFlowFieldTypeData%Grid3D, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IfW_FlowField_Copygrid4dfieldtype( SrcFlowFieldTypeData%Grid4D, DstFlowFieldTypeData%Grid4D, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IfW_FlowField_Copypointsfieldtype( SrcFlowFieldTypeData%Points, DstFlowFieldTypeData%Points, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL IfW_FlowField_Copyuserfieldtype( SrcFlowFieldTypeData%User, DstFlowFieldTypeData%User, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE IfW_FlowField_CopyFlowFieldType

 SUBROUTINE IfW_FlowField_DestroyFlowFieldType( FlowFieldTypeData, ErrStat, ErrMsg )
  TYPE(FlowFieldType), INTENT(INOUT) :: FlowFieldTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_FlowField_DestroyFlowFieldType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL IfW_FlowField_DestroyUniformFieldType( FlowFieldTypeData%Uniform, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IfW_FlowField_DestroyGrid3DFieldType( FlowFieldTypeData%Grid3D, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IfW_FlowField_DestroyGrid4DFieldType( FlowFieldTypeData%Grid4D, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IfW_FlowField_DestroyPointsFieldType( FlowFieldTypeData%Points, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL IfW_FlowField_DestroyUserFieldType( FlowFieldTypeData%User, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE IfW_FlowField_DestroyFlowFieldType


subroutine IfW_FlowField_PackFlowFieldType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(FlowFieldType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'IfW_FlowField_PackFlowFieldType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! FieldType
   call RegPack(Buf, InData%FieldType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefPosition
   call RegPack(Buf, InData%RefPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropagationDir
   call RegPack(Buf, InData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VFlowAngle
   call RegPack(Buf, InData%VFlowAngle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelInterpCubic
   call RegPack(Buf, InData%VelInterpCubic)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotateWindBox
   call RegPack(Buf, InData%RotateWindBox)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AccFieldValid
   call RegPack(Buf, InData%AccFieldValid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotToWind
   call RegPack(Buf, InData%RotToWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFromWind
   call RegPack(Buf, InData%RotFromWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Uniform
   call IfW_FlowField_PackUniformFieldType(Buf, InData%Uniform) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Grid3D
   call IfW_FlowField_PackGrid3DFieldType(Buf, InData%Grid3D) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Grid4D
   call IfW_FlowField_PackGrid4DFieldType(Buf, InData%Grid4D) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Points
   call IfW_FlowField_PackPointsFieldType(Buf, InData%Points) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! User
   call IfW_FlowField_PackUserFieldType(Buf, InData%User) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine IfW_FlowField_UnPackFlowFieldType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(FlowFieldType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'IfW_FlowField_UnPackFlowFieldType'
   if (Buf%ErrStat /= ErrID_None) return
   ! FieldType
   call RegUnpack(Buf, OutData%FieldType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RefPosition
   call RegUnpack(Buf, OutData%RefPosition)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropagationDir
   call RegUnpack(Buf, OutData%PropagationDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VFlowAngle
   call RegUnpack(Buf, OutData%VFlowAngle)
   if (RegCheckErr(Buf, RoutineName)) return
   ! VelInterpCubic
   call RegUnpack(Buf, OutData%VelInterpCubic)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotateWindBox
   call RegUnpack(Buf, OutData%RotateWindBox)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AccFieldValid
   call RegUnpack(Buf, OutData%AccFieldValid)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotToWind
   call RegUnpack(Buf, OutData%RotToWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFromWind
   call RegUnpack(Buf, OutData%RotFromWind)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Uniform
   call IfW_FlowField_UnpackUniformFieldType(Buf, OutData%Uniform) ! Uniform 
   ! Grid3D
   call IfW_FlowField_UnpackGrid3DFieldType(Buf, OutData%Grid3D) ! Grid3D 
   ! Grid4D
   call IfW_FlowField_UnpackGrid4DFieldType(Buf, OutData%Grid4D) ! Grid4D 
   ! Points
   call IfW_FlowField_UnpackPointsFieldType(Buf, OutData%Points) ! Points 
   ! User
   call IfW_FlowField_UnpackUserFieldType(Buf, OutData%User) ! User 
end subroutine
END MODULE IfW_FlowField_Types
!ENDOFREGISTRYGENERATEDFILE
