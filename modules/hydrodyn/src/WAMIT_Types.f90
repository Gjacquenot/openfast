!STARTOFREGISTRYGENERATEDFILE 'WAMIT_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! WAMIT_Types
!.................................................................................................................................
! This file is part of WAMIT.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in WAMIT. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE WAMIT_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE Conv_Radiation_Types
USE SS_Radiation_Types
USE SS_Excitation_Types
USE NWTC_Library
IMPLICIT NONE
! =========  WAMIT_InitInputType  =======
  TYPE, PUBLIC :: WAMIT_InitInputType
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    INTEGER(IntKi)  :: NBodyMod      !< Body coupling model {1: include coupling terms between each body and NBody in HydroDyn equals NBODY in WAMIT, 2: neglect coupling terms between each body and NBODY=1 with XBODY=0 in WAMIT, 3: Neglect coupling terms between each body and NBODY=1 with XBODY=/0 in WAMIT} (switch) [only used when PotMod=1] [-]
    REAL(ReKi)  :: Gravity      !< Supplied by Driver:  Gravitational acceleration [(m/s^2)]
    REAL(ReKi)  :: WtrDpth      !< Water depth (positive-valued) [m]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmVol0      !<  [-]
    LOGICAL  :: HasWAMIT      !< .TRUE. if using WAMIT model, .FALSE. otherwise [-]
    REAL(ReKi)  :: WAMITULEN      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefxt      !< The xt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1 ] [(m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefyt      !< The yt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1 ] [(m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefzt      !< The zt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: PtfmRefztRot      !< The rotation about zt of the body reference frame(s) from xt/yt [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmCOBxt      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmCOByt      !<  [-]
    INTEGER(IntKi)  :: RdtnMod      !<  [-]
    INTEGER(IntKi)  :: ExctnMod      !<  [-]
    INTEGER(IntKi)  :: ExctnDisp      !< 0: use undisplaced position, 1: use displaced position, 2: use low-pass filtered displaced position) [only used when PotMod=1 and ExctnMod>0] [-]
    REAL(ReKi)  :: ExctnCutOff      !< Cutoff (corner) frequency of the low-pass time-filtered displaced position (Hz) [>0.0]  [Hz]
    REAL(DbKi)  :: RdtnTMax      !<  [-]
    REAL(ReKi)  :: WaveDir      !<  [-]
    CHARACTER(1024)  :: WAMITFile      !<  [-]
    TYPE(Conv_Rdtn_InitInputType)  :: Conv_Rdtn      !<  [-]
    REAL(ReKi)  :: Rhoxg      !<  [-]
    INTEGER(IntKi)  :: NStepWave      !<  [-]
    INTEGER(IntKi)  :: NStepWave2      !<  [-]
    REAL(ReKi)  :: WaveDOmega      !<  [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveElev0 => NULL()      !< Wave elevation time history at origin (needed for SS_Excitation module) [m]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev1 => NULL()      !< First order wave elevation (points to SeaState module data) [-]
    REAL(SiKi) , DIMENSION(:,:), POINTER  :: WaveElevC0 => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part (points to SeaState module data) [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElevC => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at all grid points.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< (points to SeaState module data) [-]
    INTEGER(IntKi)  :: WaveMod      !<  [-]
    REAL(ReKi)  :: WtrDens      !<  [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveDirArr => NULL()      !< Array of wave directions (one per frequency) from the Waves module (points to SeaState module data) [-]
    REAL(SiKi)  :: WaveDirMin      !< Minimum wave direction from Waves module [-]
    REAL(SiKi)  :: WaveDirMax      !< Maximum wave direction from Waves module [-]
    TYPE(SeaSt_Interp_ParameterType)  :: SeaSt_Interp_p      !< parameter information from the SeaState Interpolation module [-]
  END TYPE WAMIT_InitInputType
! =======================
! =========  WAMIT_ContinuousStateType  =======
  TYPE, PUBLIC :: WAMIT_ContinuousStateType
    TYPE(SS_Rad_ContinuousStateType)  :: SS_Rdtn      !< continuous states from the State Space radiation module [-]
    TYPE(SS_Exc_ContinuousStateType)  :: SS_Exctn      !< continuous states from the State Space radiation module [-]
    TYPE(Conv_Rdtn_ContinuousStateType)  :: Conv_Rdtn      !< placeholder [-]
  END TYPE WAMIT_ContinuousStateType
! =======================
! =========  WAMIT_DiscreteStateType  =======
  TYPE, PUBLIC :: WAMIT_DiscreteStateType
    TYPE(Conv_Rdtn_DiscreteStateType)  :: Conv_Rdtn      !< discrete states from the convolution radiation module [-]
    TYPE(SS_Rad_DiscreteStateType)  :: SS_Rdtn      !< placeholder [-]
    TYPE(SS_Exc_DiscreteStateType)  :: SS_Exctn      !< placeholder [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: BdyPosFilt      !< Low-pass filtered WAMIT body position at the current and previous steps used when ExctnDisp=2 [-]
  END TYPE WAMIT_DiscreteStateType
! =======================
! =========  WAMIT_ConstraintStateType  =======
  TYPE, PUBLIC :: WAMIT_ConstraintStateType
    TYPE(Conv_Rdtn_ConstraintStateType)  :: Conv_Rdtn      !< placeholder [-]
    TYPE(SS_Rad_ConstraintStateType)  :: SS_Rdtn      !< placeholder [-]
    TYPE(SS_Exc_ConstraintStateType)  :: SS_Exctn      !< placeholder [-]
  END TYPE WAMIT_ConstraintStateType
! =======================
! =========  WAMIT_OtherStateType  =======
  TYPE, PUBLIC :: WAMIT_OtherStateType
    TYPE(SS_Rad_OtherStateType)  :: SS_Rdtn      !<  [-]
    TYPE(SS_Exc_OtherStateType)  :: SS_Exctn      !<  [-]
    TYPE(Conv_Rdtn_OtherStateType)  :: Conv_Rdtn      !<  [-]
  END TYPE WAMIT_OtherStateType
! =======================
! =========  WAMIT_MiscVarType  =======
  TYPE, PUBLIC :: WAMIT_MiscVarType
    INTEGER(IntKi)  :: LastIndWave      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_HS      !< local variable in CalcOutput:Total load contribution from hydrostatics, including the effects of waterplane area and the center of buoyancy [(N, N-m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_Waves1      !< local variable in CalcOutput:Total load contribution from incident waves (i.e., the diffraction problem) [(N, N-m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_Rdtn      !< local variable in CalcOutput:Total load contribution from wave radiation damping (i.e., the diffraction problem) [(N, N-m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_PtfmAM      !< local variable in CalcOutput: [-]
    TYPE(SS_Rad_MiscVarType)  :: SS_Rdtn      !<  [-]
    TYPE(SS_Rad_InputType)  :: SS_Rdtn_u      !<  [-]
    TYPE(SS_Rad_OutputType)  :: SS_Rdtn_y      !<  [-]
    TYPE(SS_Exc_MiscVarType)  :: SS_Exctn      !<  [-]
    TYPE(SS_Exc_InputType)  :: SS_Exctn_u      !<  [-]
    TYPE(SS_Exc_OutputType)  :: SS_Exctn_y      !<  [-]
    TYPE(Conv_Rdtn_MiscVarType)  :: Conv_Rdtn      !<  [-]
    TYPE(Conv_Rdtn_InputType)  :: Conv_Rdtn_u      !<  [-]
    TYPE(Conv_Rdtn_OutputType)  :: Conv_Rdtn_y      !<  [-]
    TYPE(SeaSt_Interp_MiscVarType)  :: SeaSt_Interp_m      !< misc var information from the SeaState Interpolation module [-]
  END TYPE WAMIT_MiscVarType
! =======================
! =========  WAMIT_ParameterType  =======
  TYPE, PUBLIC :: WAMIT_ParameterType
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    INTEGER(IntKi)  :: NBodyMod      !< Body coupling model {1: include coupling terms between each body and NBody in HydroDyn equals NBODY in WAMIT, 2: neglect coupling terms between each body and NBODY=1 with XBODY=0 in WAMIT, 3: Neglect coupling terms between each body and NBODY=1 with XBODY=/0 in WAMIT} (switch) [only used when PotMod=1] [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: F_HS_Moment_Offset      !< The offset moment due to the COB being offset from the WAMIT body's local location {matrix 3xNBody} [N-m]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: HdroAdMsI      !<  [(sec)]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: HdroSttc      !<  [-]
    INTEGER(IntKi)  :: RdtnMod      !<  [-]
    INTEGER(IntKi)  :: ExctnMod      !<  [-]
    INTEGER(IntKi)  :: ExctnDisp      !< 0: use undisplaced position, 1: use displaced position, 2: use low-pass filtered displaced position) [only used when PotMod=1 and ExctnMod>0] [-]
    REAL(ReKi)  :: ExctnCutOff      !< Cutoff (corner) frequency of the low-pass time-filtered displaced position (Hz) [>0.0]  [Hz]
    REAL(ReKi)  :: ExctnFiltConst      !< Low-pass time filter constant computed from ExctnCutOff [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveExctn      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: WaveExctnGrid      !< WaveExctnGrid dimensions are: 1st: wavetime, 2nd: X, 3rd: Y, 4th: Force component for eac WAMIT Body [-]
    INTEGER(IntKi)  :: NStepWave      !<  [-]
    TYPE(Conv_Rdtn_ParameterType)  :: Conv_Rdtn      !<  [-]
    TYPE(SS_Rad_ParameterType)  :: SS_Rdtn      !<  [-]
    TYPE(SS_Exc_ParameterType)  :: SS_Exctn      !<  [-]
    REAL(DbKi)  :: DT      !<  [-]
    TYPE(SeaSt_Interp_ParameterType)  :: SeaSt_Interp_p      !< parameter information from the SeaState Interpolation module [-]
  END TYPE WAMIT_ParameterType
! =======================
! =========  WAMIT_InputType  =======
  TYPE, PUBLIC :: WAMIT_InputType
    TYPE(MeshType)  :: Mesh      !< Displacements at the WAMIT reference point in the inertial frame [-]
  END TYPE WAMIT_InputType
! =======================
! =========  WAMIT_OutputType  =======
  TYPE, PUBLIC :: WAMIT_OutputType
    TYPE(MeshType)  :: Mesh      !< Loads at the WAMIT reference point in the inertial frame [-]
  END TYPE WAMIT_OutputType
! =======================
CONTAINS
 SUBROUTINE WAMIT_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(WAMIT_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%NBody = SrcInitInputData%NBody
    DstInitInputData%NBodyMod = SrcInitInputData%NBodyMod
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
IF (ALLOCATED(SrcInitInputData%PtfmVol0)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmVol0,1)
  i1_u = UBOUND(SrcInitInputData%PtfmVol0,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmVol0)) THEN 
    ALLOCATE(DstInitInputData%PtfmVol0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmVol0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmVol0 = SrcInitInputData%PtfmVol0
ENDIF
    DstInitInputData%HasWAMIT = SrcInitInputData%HasWAMIT
    DstInitInputData%WAMITULEN = SrcInitInputData%WAMITULEN
IF (ALLOCATED(SrcInitInputData%PtfmRefxt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefxt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefxt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefxt)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefxt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefxt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefxt = SrcInitInputData%PtfmRefxt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmRefyt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefyt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefyt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefyt)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefyt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefyt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefyt = SrcInitInputData%PtfmRefyt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmRefzt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefzt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefzt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefzt)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefzt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefzt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefzt = SrcInitInputData%PtfmRefzt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmRefztRot)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefztRot,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefztRot,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefztRot)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefztRot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefztRot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefztRot = SrcInitInputData%PtfmRefztRot
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmCOBxt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmCOBxt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmCOBxt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmCOBxt)) THEN 
    ALLOCATE(DstInitInputData%PtfmCOBxt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmCOBxt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmCOBxt = SrcInitInputData%PtfmCOBxt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmCOByt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmCOByt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmCOByt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmCOByt)) THEN 
    ALLOCATE(DstInitInputData%PtfmCOByt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmCOByt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmCOByt = SrcInitInputData%PtfmCOByt
ENDIF
    DstInitInputData%RdtnMod = SrcInitInputData%RdtnMod
    DstInitInputData%ExctnMod = SrcInitInputData%ExctnMod
    DstInitInputData%ExctnDisp = SrcInitInputData%ExctnDisp
    DstInitInputData%ExctnCutOff = SrcInitInputData%ExctnCutOff
    DstInitInputData%RdtnTMax = SrcInitInputData%RdtnTMax
    DstInitInputData%WaveDir = SrcInitInputData%WaveDir
    DstInitInputData%WAMITFile = SrcInitInputData%WAMITFile
      CALL Conv_Rdtn_CopyInitInput( SrcInitInputData%Conv_Rdtn, DstInitInputData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%Rhoxg = SrcInitInputData%Rhoxg
    DstInitInputData%NStepWave = SrcInitInputData%NStepWave
    DstInitInputData%NStepWave2 = SrcInitInputData%NStepWave2
    DstInitInputData%WaveDOmega = SrcInitInputData%WaveDOmega
    DstInitInputData%WaveElev0 => SrcInitInputData%WaveElev0
    DstInitInputData%WaveElev1 => SrcInitInputData%WaveElev1
    DstInitInputData%WaveElevC0 => SrcInitInputData%WaveElevC0
    DstInitInputData%WaveElevC => SrcInitInputData%WaveElevC
    DstInitInputData%WaveTime => SrcInitInputData%WaveTime
    DstInitInputData%WaveMod = SrcInitInputData%WaveMod
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
    DstInitInputData%WaveDirArr => SrcInitInputData%WaveDirArr
    DstInitInputData%WaveDirMin = SrcInitInputData%WaveDirMin
    DstInitInputData%WaveDirMax = SrcInitInputData%WaveDirMax
      CALL SeaSt_Interp_CopyParam( SrcInitInputData%SeaSt_Interp_p, DstInitInputData%SeaSt_Interp_p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyInitInput

 SUBROUTINE WAMIT_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(WAMIT_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%PtfmVol0)) THEN
  DEALLOCATE(InitInputData%PtfmVol0)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefxt)) THEN
  DEALLOCATE(InitInputData%PtfmRefxt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefyt)) THEN
  DEALLOCATE(InitInputData%PtfmRefyt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefzt)) THEN
  DEALLOCATE(InitInputData%PtfmRefzt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefztRot)) THEN
  DEALLOCATE(InitInputData%PtfmRefztRot)
ENDIF
IF (ALLOCATED(InitInputData%PtfmCOBxt)) THEN
  DEALLOCATE(InitInputData%PtfmCOBxt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmCOByt)) THEN
  DEALLOCATE(InitInputData%PtfmCOByt)
ENDIF
  CALL Conv_Rdtn_DestroyInitInput( InitInputData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
NULLIFY(InitInputData%WaveElev0)
NULLIFY(InitInputData%WaveElev1)
NULLIFY(InitInputData%WaveElevC0)
NULLIFY(InitInputData%WaveElevC)
NULLIFY(InitInputData%WaveTime)
NULLIFY(InitInputData%WaveDirArr)
  CALL SeaSt_Interp_DestroyParam( InitInputData%SeaSt_Interp_p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyInitInput


subroutine WAMIT_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackInitInput'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegPack(Buf, InData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmVol0
   call RegPack(Buf, allocated(InData%PtfmVol0))
   if (allocated(InData%PtfmVol0)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmVol0), ubound(InData%PtfmVol0))
      call RegPack(Buf, InData%PtfmVol0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HasWAMIT
   call RegPack(Buf, InData%HasWAMIT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITULEN
   call RegPack(Buf, InData%WAMITULEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefxt
   call RegPack(Buf, allocated(InData%PtfmRefxt))
   if (allocated(InData%PtfmRefxt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefxt), ubound(InData%PtfmRefxt))
      call RegPack(Buf, InData%PtfmRefxt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefyt
   call RegPack(Buf, allocated(InData%PtfmRefyt))
   if (allocated(InData%PtfmRefyt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefyt), ubound(InData%PtfmRefyt))
      call RegPack(Buf, InData%PtfmRefyt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefzt
   call RegPack(Buf, allocated(InData%PtfmRefzt))
   if (allocated(InData%PtfmRefzt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefzt), ubound(InData%PtfmRefzt))
      call RegPack(Buf, InData%PtfmRefzt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefztRot
   call RegPack(Buf, allocated(InData%PtfmRefztRot))
   if (allocated(InData%PtfmRefztRot)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefztRot), ubound(InData%PtfmRefztRot))
      call RegPack(Buf, InData%PtfmRefztRot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmCOBxt
   call RegPack(Buf, allocated(InData%PtfmCOBxt))
   if (allocated(InData%PtfmCOBxt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmCOBxt), ubound(InData%PtfmCOBxt))
      call RegPack(Buf, InData%PtfmCOBxt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmCOByt
   call RegPack(Buf, allocated(InData%PtfmCOByt))
   if (allocated(InData%PtfmCOByt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmCOByt), ubound(InData%PtfmCOByt))
      call RegPack(Buf, InData%PtfmCOByt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnMod
   call RegPack(Buf, InData%RdtnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnMod
   call RegPack(Buf, InData%ExctnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegPack(Buf, InData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnCutOff
   call RegPack(Buf, InData%ExctnCutOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnTMax
   call RegPack(Buf, InData%RdtnTMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegPack(Buf, InData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITFile
   call RegPack(Buf, InData%WAMITFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackInitInput(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rhoxg
   call RegPack(Buf, InData%Rhoxg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegPack(Buf, InData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegPack(Buf, InData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   call RegPack(Buf, associated(InData%WaveElev0))
   if (associated(InData%WaveElev0)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElev0), ubound(InData%WaveElev0))
      call RegPackPointer(Buf, c_loc(InData%WaveElev0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev1
   call RegPack(Buf, associated(InData%WaveElev1))
   if (associated(InData%WaveElev1)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev1), ubound(InData%WaveElev1))
      call RegPackPointer(Buf, c_loc(InData%WaveElev1), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev1)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC0
   call RegPack(Buf, associated(InData%WaveElevC0))
   if (associated(InData%WaveElevC0)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevC0), ubound(InData%WaveElevC0))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC
   call RegPack(Buf, associated(InData%WaveElevC))
   if (associated(InData%WaveElevC)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElevC), ubound(InData%WaveElevC))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegPack(Buf, InData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   call RegPack(Buf, associated(InData%WaveDirArr))
   if (associated(InData%WaveDirArr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveDirArr), ubound(InData%WaveDirArr))
      call RegPackPointer(Buf, c_loc(InData%WaveDirArr), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDirArr)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMin
   call RegPack(Buf, InData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegPack(Buf, InData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_PackParam(Buf, InData%SeaSt_Interp_p) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegUnpack(Buf, OutData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmVol0
   if (allocated(OutData%PtfmVol0)) deallocate(OutData%PtfmVol0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmVol0(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmVol0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmVol0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HasWAMIT
   call RegUnpack(Buf, OutData%HasWAMIT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITULEN
   call RegUnpack(Buf, OutData%WAMITULEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefxt
   if (allocated(OutData%PtfmRefxt)) deallocate(OutData%PtfmRefxt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefxt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefxt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefxt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefyt
   if (allocated(OutData%PtfmRefyt)) deallocate(OutData%PtfmRefyt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefyt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefyt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefyt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefzt
   if (allocated(OutData%PtfmRefzt)) deallocate(OutData%PtfmRefzt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefzt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefzt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefzt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefztRot
   if (allocated(OutData%PtfmRefztRot)) deallocate(OutData%PtfmRefztRot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefztRot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefztRot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefztRot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmCOBxt
   if (allocated(OutData%PtfmCOBxt)) deallocate(OutData%PtfmCOBxt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmCOBxt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmCOBxt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmCOBxt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmCOByt
   if (allocated(OutData%PtfmCOByt)) deallocate(OutData%PtfmCOByt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmCOByt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmCOByt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmCOByt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RdtnMod
   call RegUnpack(Buf, OutData%RdtnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnMod
   call RegUnpack(Buf, OutData%ExctnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegUnpack(Buf, OutData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnCutOff
   call RegUnpack(Buf, OutData%ExctnCutOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnTMax
   call RegUnpack(Buf, OutData%RdtnTMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegUnpack(Buf, OutData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITFile
   call RegUnpack(Buf, OutData%WAMITFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackInitInput(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
   ! Rhoxg
   call RegUnpack(Buf, OutData%Rhoxg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegUnpack(Buf, OutData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegUnpack(Buf, OutData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   if (associated(OutData%WaveElev0)) deallocate(OutData%WaveElev0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev0, UB(1:1)-LB(1:1))
         OutData%WaveElev0(LB(1):) => OutData%WaveElev0
      else
         allocate(OutData%WaveElev0(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev0)
         call RegUnpack(Buf, OutData%WaveElev0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev0 => null()
   end if
   ! WaveElev1
   if (associated(OutData%WaveElev1)) deallocate(OutData%WaveElev1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev1, UB(1:3)-LB(1:3))
         OutData%WaveElev1(LB(1):,LB(2):,LB(3):) => OutData%WaveElev1
      else
         allocate(OutData%WaveElev1(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev1)
         call RegUnpack(Buf, OutData%WaveElev1)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev1 => null()
   end if
   ! WaveElevC0
   if (associated(OutData%WaveElevC0)) deallocate(OutData%WaveElevC0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC0, UB(1:2)-LB(1:2))
         OutData%WaveElevC0(LB(1):,LB(2):) => OutData%WaveElevC0
      else
         allocate(OutData%WaveElevC0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC0)
         call RegUnpack(Buf, OutData%WaveElevC0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC0 => null()
   end if
   ! WaveElevC
   if (associated(OutData%WaveElevC)) deallocate(OutData%WaveElevC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC, UB(1:3)-LB(1:3))
         OutData%WaveElevC(LB(1):,LB(2):,LB(3):) => OutData%WaveElevC
      else
         allocate(OutData%WaveElevC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC)
         call RegUnpack(Buf, OutData%WaveElevC)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC => null()
   end if
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! WaveMod
   call RegUnpack(Buf, OutData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   if (associated(OutData%WaveDirArr)) deallocate(OutData%WaveDirArr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDirArr, UB(1:1)-LB(1:1))
         OutData%WaveDirArr(LB(1):) => OutData%WaveDirArr
      else
         allocate(OutData%WaveDirArr(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDirArr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDirArr)
         call RegUnpack(Buf, OutData%WaveDirArr)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDirArr => null()
   end if
   ! WaveDirMin
   call RegUnpack(Buf, OutData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegUnpack(Buf, OutData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_UnpackParam(Buf, OutData%SeaSt_Interp_p) ! SeaSt_Interp_p 
end subroutine
 SUBROUTINE WAMIT_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(WAMIT_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SS_Rad_CopyContState( SrcContStateData%SS_Rdtn, DstContStateData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyContState( SrcContStateData%SS_Exctn, DstContStateData%SS_Exctn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Conv_Rdtn_CopyContState( SrcContStateData%Conv_Rdtn, DstContStateData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyContState

 SUBROUTINE WAMIT_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL SS_Rad_DestroyContState( ContStateData%SS_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyContState( ContStateData%SS_Exctn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Conv_Rdtn_DestroyContState( ContStateData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyContState


subroutine WAMIT_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! SS_Rdtn
   call SS_Rad_PackContState(Buf, InData%SS_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn
   call SS_Exc_PackContState(Buf, InData%SS_Exctn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackContState(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   ! SS_Rdtn
   call SS_Rad_UnpackContState(Buf, OutData%SS_Rdtn) ! SS_Rdtn 
   ! SS_Exctn
   call SS_Exc_UnpackContState(Buf, OutData%SS_Exctn) ! SS_Exctn 
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackContState(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
end subroutine
 SUBROUTINE WAMIT_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(WAMIT_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL Conv_Rdtn_CopyDiscState( SrcDiscStateData%Conv_Rdtn, DstDiscStateData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyDiscState( SrcDiscStateData%SS_Rdtn, DstDiscStateData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyDiscState( SrcDiscStateData%SS_Exctn, DstDiscStateData%SS_Exctn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcDiscStateData%BdyPosFilt)) THEN
  i1_l = LBOUND(SrcDiscStateData%BdyPosFilt,1)
  i1_u = UBOUND(SrcDiscStateData%BdyPosFilt,1)
  i2_l = LBOUND(SrcDiscStateData%BdyPosFilt,2)
  i2_u = UBOUND(SrcDiscStateData%BdyPosFilt,2)
  i3_l = LBOUND(SrcDiscStateData%BdyPosFilt,3)
  i3_u = UBOUND(SrcDiscStateData%BdyPosFilt,3)
  IF (.NOT. ALLOCATED(DstDiscStateData%BdyPosFilt)) THEN 
    ALLOCATE(DstDiscStateData%BdyPosFilt(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%BdyPosFilt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%BdyPosFilt = SrcDiscStateData%BdyPosFilt
ENDIF
 END SUBROUTINE WAMIT_CopyDiscState

 SUBROUTINE WAMIT_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL Conv_Rdtn_DestroyDiscState( DiscStateData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Rad_DestroyDiscState( DiscStateData%SS_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyDiscState( DiscStateData%SS_Exctn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(DiscStateData%BdyPosFilt)) THEN
  DEALLOCATE(DiscStateData%BdyPosFilt)
ENDIF
 END SUBROUTINE WAMIT_DestroyDiscState


subroutine WAMIT_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackDiscState(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Rdtn
   call SS_Rad_PackDiscState(Buf, InData%SS_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn
   call SS_Exc_PackDiscState(Buf, InData%SS_Exctn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! BdyPosFilt
   call RegPack(Buf, allocated(InData%BdyPosFilt))
   if (allocated(InData%BdyPosFilt)) then
      call RegPackBounds(Buf, 3, lbound(InData%BdyPosFilt), ubound(InData%BdyPosFilt))
      call RegPack(Buf, InData%BdyPosFilt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackDiscState'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackDiscState(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
   ! SS_Rdtn
   call SS_Rad_UnpackDiscState(Buf, OutData%SS_Rdtn) ! SS_Rdtn 
   ! SS_Exctn
   call SS_Exc_UnpackDiscState(Buf, OutData%SS_Exctn) ! SS_Exctn 
   ! BdyPosFilt
   if (allocated(OutData%BdyPosFilt)) deallocate(OutData%BdyPosFilt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%BdyPosFilt(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%BdyPosFilt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%BdyPosFilt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE WAMIT_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(WAMIT_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL Conv_Rdtn_CopyConstrState( SrcConstrStateData%Conv_Rdtn, DstConstrStateData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyConstrState( SrcConstrStateData%SS_Rdtn, DstConstrStateData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyConstrState( SrcConstrStateData%SS_Exctn, DstConstrStateData%SS_Exctn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyConstrState

 SUBROUTINE WAMIT_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL Conv_Rdtn_DestroyConstrState( ConstrStateData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Rad_DestroyConstrState( ConstrStateData%SS_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyConstrState( ConstrStateData%SS_Exctn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyConstrState


subroutine WAMIT_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackConstrState(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Rdtn
   call SS_Rad_PackConstrState(Buf, InData%SS_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn
   call SS_Exc_PackConstrState(Buf, InData%SS_Exctn) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackConstrState(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
   ! SS_Rdtn
   call SS_Rad_UnpackConstrState(Buf, OutData%SS_Rdtn) ! SS_Rdtn 
   ! SS_Exctn
   call SS_Exc_UnpackConstrState(Buf, OutData%SS_Exctn) ! SS_Exctn 
end subroutine
 SUBROUTINE WAMIT_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(WAMIT_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL SS_Rad_CopyOtherState( SrcOtherStateData%SS_Rdtn, DstOtherStateData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyOtherState( SrcOtherStateData%SS_Exctn, DstOtherStateData%SS_Exctn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Conv_Rdtn_CopyOtherState( SrcOtherStateData%Conv_Rdtn, DstOtherStateData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyOtherState

 SUBROUTINE WAMIT_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(WAMIT_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL SS_Rad_DestroyOtherState( OtherStateData%SS_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyOtherState( OtherStateData%SS_Exctn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Conv_Rdtn_DestroyOtherState( OtherStateData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyOtherState


subroutine WAMIT_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! SS_Rdtn
   call SS_Rad_PackOtherState(Buf, InData%SS_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn
   call SS_Exc_PackOtherState(Buf, InData%SS_Exctn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackOtherState(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! SS_Rdtn
   call SS_Rad_UnpackOtherState(Buf, OutData%SS_Rdtn) ! SS_Rdtn 
   ! SS_Exctn
   call SS_Exc_UnpackOtherState(Buf, OutData%SS_Exctn) ! SS_Exctn 
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackOtherState(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
end subroutine
 SUBROUTINE WAMIT_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(WAMIT_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
IF (ALLOCATED(SrcMiscData%F_HS)) THEN
  i1_l = LBOUND(SrcMiscData%F_HS,1)
  i1_u = UBOUND(SrcMiscData%F_HS,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_HS)) THEN 
    ALLOCATE(DstMiscData%F_HS(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_HS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_HS = SrcMiscData%F_HS
ENDIF
IF (ALLOCATED(SrcMiscData%F_Waves1)) THEN
  i1_l = LBOUND(SrcMiscData%F_Waves1,1)
  i1_u = UBOUND(SrcMiscData%F_Waves1,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_Waves1)) THEN 
    ALLOCATE(DstMiscData%F_Waves1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_Waves1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_Waves1 = SrcMiscData%F_Waves1
ENDIF
IF (ALLOCATED(SrcMiscData%F_Rdtn)) THEN
  i1_l = LBOUND(SrcMiscData%F_Rdtn,1)
  i1_u = UBOUND(SrcMiscData%F_Rdtn,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_Rdtn)) THEN 
    ALLOCATE(DstMiscData%F_Rdtn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_Rdtn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_Rdtn = SrcMiscData%F_Rdtn
ENDIF
IF (ALLOCATED(SrcMiscData%F_PtfmAM)) THEN
  i1_l = LBOUND(SrcMiscData%F_PtfmAM,1)
  i1_u = UBOUND(SrcMiscData%F_PtfmAM,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_PtfmAM)) THEN 
    ALLOCATE(DstMiscData%F_PtfmAM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_PtfmAM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_PtfmAM = SrcMiscData%F_PtfmAM
ENDIF
      CALL SS_Rad_CopyMisc( SrcMiscData%SS_Rdtn, DstMiscData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyInput( SrcMiscData%SS_Rdtn_u, DstMiscData%SS_Rdtn_u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyOutput( SrcMiscData%SS_Rdtn_y, DstMiscData%SS_Rdtn_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyMisc( SrcMiscData%SS_Exctn, DstMiscData%SS_Exctn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyInput( SrcMiscData%SS_Exctn_u, DstMiscData%SS_Exctn_u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyOutput( SrcMiscData%SS_Exctn_y, DstMiscData%SS_Exctn_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Conv_Rdtn_CopyMisc( SrcMiscData%Conv_Rdtn, DstMiscData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Conv_Rdtn_CopyInput( SrcMiscData%Conv_Rdtn_u, DstMiscData%Conv_Rdtn_u, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Conv_Rdtn_CopyOutput( SrcMiscData%Conv_Rdtn_y, DstMiscData%Conv_Rdtn_y, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SeaSt_Interp_CopyMisc( SrcMiscData%SeaSt_Interp_m, DstMiscData%SeaSt_Interp_m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyMisc

 SUBROUTINE WAMIT_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(WAMIT_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%F_HS)) THEN
  DEALLOCATE(MiscData%F_HS)
ENDIF
IF (ALLOCATED(MiscData%F_Waves1)) THEN
  DEALLOCATE(MiscData%F_Waves1)
ENDIF
IF (ALLOCATED(MiscData%F_Rdtn)) THEN
  DEALLOCATE(MiscData%F_Rdtn)
ENDIF
IF (ALLOCATED(MiscData%F_PtfmAM)) THEN
  DEALLOCATE(MiscData%F_PtfmAM)
ENDIF
  CALL SS_Rad_DestroyMisc( MiscData%SS_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Rad_DestroyInput( MiscData%SS_Rdtn_u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Rad_DestroyOutput( MiscData%SS_Rdtn_y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyMisc( MiscData%SS_Exctn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyInput( MiscData%SS_Exctn_u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyOutput( MiscData%SS_Exctn_y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Conv_Rdtn_DestroyMisc( MiscData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Conv_Rdtn_DestroyInput( MiscData%Conv_Rdtn_u, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Conv_Rdtn_DestroyOutput( MiscData%Conv_Rdtn_y, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_Interp_DestroyMisc( MiscData%SeaSt_Interp_m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyMisc


subroutine WAMIT_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! LastIndWave
   call RegPack(Buf, InData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_HS
   call RegPack(Buf, allocated(InData%F_HS))
   if (allocated(InData%F_HS)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_HS), ubound(InData%F_HS))
      call RegPack(Buf, InData%F_HS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Waves1
   call RegPack(Buf, allocated(InData%F_Waves1))
   if (allocated(InData%F_Waves1)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_Waves1), ubound(InData%F_Waves1))
      call RegPack(Buf, InData%F_Waves1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Rdtn
   call RegPack(Buf, allocated(InData%F_Rdtn))
   if (allocated(InData%F_Rdtn)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_Rdtn), ubound(InData%F_Rdtn))
      call RegPack(Buf, InData%F_Rdtn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_PtfmAM
   call RegPack(Buf, allocated(InData%F_PtfmAM))
   if (allocated(InData%F_PtfmAM)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_PtfmAM), ubound(InData%F_PtfmAM))
      call RegPack(Buf, InData%F_PtfmAM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Rdtn
   call SS_Rad_PackMisc(Buf, InData%SS_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Rdtn_u
   call SS_Rad_PackInput(Buf, InData%SS_Rdtn_u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Rdtn_y
   call SS_Rad_PackOutput(Buf, InData%SS_Rdtn_y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn
   call SS_Exc_PackMisc(Buf, InData%SS_Exctn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn_u
   call SS_Exc_PackInput(Buf, InData%SS_Exctn_u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn_y
   call SS_Exc_PackOutput(Buf, InData%SS_Exctn_y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackMisc(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn_u
   call Conv_Rdtn_PackInput(Buf, InData%Conv_Rdtn_u) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn_y
   call Conv_Rdtn_PackOutput(Buf, InData%Conv_Rdtn_y) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_m
   call SeaSt_Interp_PackMisc(Buf, InData%SeaSt_Interp_m) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackMisc'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LastIndWave
   call RegUnpack(Buf, OutData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_HS
   if (allocated(OutData%F_HS)) deallocate(OutData%F_HS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_HS(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_HS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_HS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_Waves1
   if (allocated(OutData%F_Waves1)) deallocate(OutData%F_Waves1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_Waves1(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_Waves1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_Waves1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_Rdtn
   if (allocated(OutData%F_Rdtn)) deallocate(OutData%F_Rdtn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_Rdtn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_Rdtn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_Rdtn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_PtfmAM
   if (allocated(OutData%F_PtfmAM)) deallocate(OutData%F_PtfmAM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_PtfmAM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_PtfmAM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_PtfmAM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SS_Rdtn
   call SS_Rad_UnpackMisc(Buf, OutData%SS_Rdtn) ! SS_Rdtn 
   ! SS_Rdtn_u
   call SS_Rad_UnpackInput(Buf, OutData%SS_Rdtn_u) ! SS_Rdtn_u 
   ! SS_Rdtn_y
   call SS_Rad_UnpackOutput(Buf, OutData%SS_Rdtn_y) ! SS_Rdtn_y 
   ! SS_Exctn
   call SS_Exc_UnpackMisc(Buf, OutData%SS_Exctn) ! SS_Exctn 
   ! SS_Exctn_u
   call SS_Exc_UnpackInput(Buf, OutData%SS_Exctn_u) ! SS_Exctn_u 
   ! SS_Exctn_y
   call SS_Exc_UnpackOutput(Buf, OutData%SS_Exctn_y) ! SS_Exctn_y 
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackMisc(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
   ! Conv_Rdtn_u
   call Conv_Rdtn_UnpackInput(Buf, OutData%Conv_Rdtn_u) ! Conv_Rdtn_u 
   ! Conv_Rdtn_y
   call Conv_Rdtn_UnpackOutput(Buf, OutData%Conv_Rdtn_y) ! Conv_Rdtn_y 
   ! SeaSt_Interp_m
   call SeaSt_Interp_UnpackMisc(Buf, OutData%SeaSt_Interp_m) ! SeaSt_Interp_m 
end subroutine
 SUBROUTINE WAMIT_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(WAMIT_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%NBody = SrcParamData%NBody
    DstParamData%NBodyMod = SrcParamData%NBodyMod
IF (ALLOCATED(SrcParamData%F_HS_Moment_Offset)) THEN
  i1_l = LBOUND(SrcParamData%F_HS_Moment_Offset,1)
  i1_u = UBOUND(SrcParamData%F_HS_Moment_Offset,1)
  i2_l = LBOUND(SrcParamData%F_HS_Moment_Offset,2)
  i2_u = UBOUND(SrcParamData%F_HS_Moment_Offset,2)
  IF (.NOT. ALLOCATED(DstParamData%F_HS_Moment_Offset)) THEN 
    ALLOCATE(DstParamData%F_HS_Moment_Offset(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%F_HS_Moment_Offset.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%F_HS_Moment_Offset = SrcParamData%F_HS_Moment_Offset
ENDIF
IF (ALLOCATED(SrcParamData%HdroAdMsI)) THEN
  i1_l = LBOUND(SrcParamData%HdroAdMsI,1)
  i1_u = UBOUND(SrcParamData%HdroAdMsI,1)
  i2_l = LBOUND(SrcParamData%HdroAdMsI,2)
  i2_u = UBOUND(SrcParamData%HdroAdMsI,2)
  IF (.NOT. ALLOCATED(DstParamData%HdroAdMsI)) THEN 
    ALLOCATE(DstParamData%HdroAdMsI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%HdroAdMsI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%HdroAdMsI = SrcParamData%HdroAdMsI
ENDIF
IF (ALLOCATED(SrcParamData%HdroSttc)) THEN
  i1_l = LBOUND(SrcParamData%HdroSttc,1)
  i1_u = UBOUND(SrcParamData%HdroSttc,1)
  i2_l = LBOUND(SrcParamData%HdroSttc,2)
  i2_u = UBOUND(SrcParamData%HdroSttc,2)
  IF (.NOT. ALLOCATED(DstParamData%HdroSttc)) THEN 
    ALLOCATE(DstParamData%HdroSttc(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%HdroSttc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%HdroSttc = SrcParamData%HdroSttc
ENDIF
    DstParamData%RdtnMod = SrcParamData%RdtnMod
    DstParamData%ExctnMod = SrcParamData%ExctnMod
    DstParamData%ExctnDisp = SrcParamData%ExctnDisp
    DstParamData%ExctnCutOff = SrcParamData%ExctnCutOff
    DstParamData%ExctnFiltConst = SrcParamData%ExctnFiltConst
IF (ALLOCATED(SrcParamData%WaveExctn)) THEN
  i1_l = LBOUND(SrcParamData%WaveExctn,1)
  i1_u = UBOUND(SrcParamData%WaveExctn,1)
  i2_l = LBOUND(SrcParamData%WaveExctn,2)
  i2_u = UBOUND(SrcParamData%WaveExctn,2)
  IF (.NOT. ALLOCATED(DstParamData%WaveExctn)) THEN 
    ALLOCATE(DstParamData%WaveExctn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveExctn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveExctn = SrcParamData%WaveExctn
ENDIF
IF (ALLOCATED(SrcParamData%WaveExctnGrid)) THEN
  i1_l = LBOUND(SrcParamData%WaveExctnGrid,1)
  i1_u = UBOUND(SrcParamData%WaveExctnGrid,1)
  i2_l = LBOUND(SrcParamData%WaveExctnGrid,2)
  i2_u = UBOUND(SrcParamData%WaveExctnGrid,2)
  i3_l = LBOUND(SrcParamData%WaveExctnGrid,3)
  i3_u = UBOUND(SrcParamData%WaveExctnGrid,3)
  i4_l = LBOUND(SrcParamData%WaveExctnGrid,4)
  i4_u = UBOUND(SrcParamData%WaveExctnGrid,4)
  IF (.NOT. ALLOCATED(DstParamData%WaveExctnGrid)) THEN 
    ALLOCATE(DstParamData%WaveExctnGrid(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveExctnGrid.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveExctnGrid = SrcParamData%WaveExctnGrid
ENDIF
    DstParamData%NStepWave = SrcParamData%NStepWave
      CALL Conv_Rdtn_CopyParam( SrcParamData%Conv_Rdtn, DstParamData%Conv_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Rad_CopyParam( SrcParamData%SS_Rdtn, DstParamData%SS_Rdtn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL SS_Exc_CopyParam( SrcParamData%SS_Exctn, DstParamData%SS_Exctn, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstParamData%DT = SrcParamData%DT
      CALL SeaSt_Interp_CopyParam( SrcParamData%SeaSt_Interp_p, DstParamData%SeaSt_Interp_p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyParam

 SUBROUTINE WAMIT_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(WAMIT_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%F_HS_Moment_Offset)) THEN
  DEALLOCATE(ParamData%F_HS_Moment_Offset)
ENDIF
IF (ALLOCATED(ParamData%HdroAdMsI)) THEN
  DEALLOCATE(ParamData%HdroAdMsI)
ENDIF
IF (ALLOCATED(ParamData%HdroSttc)) THEN
  DEALLOCATE(ParamData%HdroSttc)
ENDIF
IF (ALLOCATED(ParamData%WaveExctn)) THEN
  DEALLOCATE(ParamData%WaveExctn)
ENDIF
IF (ALLOCATED(ParamData%WaveExctnGrid)) THEN
  DEALLOCATE(ParamData%WaveExctnGrid)
ENDIF
  CALL Conv_Rdtn_DestroyParam( ParamData%Conv_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Rad_DestroyParam( ParamData%SS_Rdtn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SS_Exc_DestroyParam( ParamData%SS_Exctn, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL SeaSt_Interp_DestroyParam( ParamData%SeaSt_Interp_p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyParam


subroutine WAMIT_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegPack(Buf, InData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_HS_Moment_Offset
   call RegPack(Buf, allocated(InData%F_HS_Moment_Offset))
   if (allocated(InData%F_HS_Moment_Offset)) then
      call RegPackBounds(Buf, 2, lbound(InData%F_HS_Moment_Offset), ubound(InData%F_HS_Moment_Offset))
      call RegPack(Buf, InData%F_HS_Moment_Offset)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HdroAdMsI
   call RegPack(Buf, allocated(InData%HdroAdMsI))
   if (allocated(InData%HdroAdMsI)) then
      call RegPackBounds(Buf, 2, lbound(InData%HdroAdMsI), ubound(InData%HdroAdMsI))
      call RegPack(Buf, InData%HdroAdMsI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HdroSttc
   call RegPack(Buf, allocated(InData%HdroSttc))
   if (allocated(InData%HdroSttc)) then
      call RegPackBounds(Buf, 2, lbound(InData%HdroSttc), ubound(InData%HdroSttc))
      call RegPack(Buf, InData%HdroSttc)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnMod
   call RegPack(Buf, InData%RdtnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnMod
   call RegPack(Buf, InData%ExctnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegPack(Buf, InData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnCutOff
   call RegPack(Buf, InData%ExctnCutOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnFiltConst
   call RegPack(Buf, InData%ExctnFiltConst)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveExctn
   call RegPack(Buf, allocated(InData%WaveExctn))
   if (allocated(InData%WaveExctn)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveExctn), ubound(InData%WaveExctn))
      call RegPack(Buf, InData%WaveExctn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveExctnGrid
   call RegPack(Buf, allocated(InData%WaveExctnGrid))
   if (allocated(InData%WaveExctnGrid)) then
      call RegPackBounds(Buf, 4, lbound(InData%WaveExctnGrid), ubound(InData%WaveExctnGrid))
      call RegPack(Buf, InData%WaveExctnGrid)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_PackParam(Buf, InData%Conv_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Rdtn
   call SS_Rad_PackParam(Buf, InData%SS_Rdtn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! SS_Exctn
   call SS_Exc_PackParam(Buf, InData%SS_Exctn) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_PackParam(Buf, InData%SeaSt_Interp_p) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackParam'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegUnpack(Buf, OutData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_HS_Moment_Offset
   if (allocated(OutData%F_HS_Moment_Offset)) deallocate(OutData%F_HS_Moment_Offset)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_HS_Moment_Offset(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_HS_Moment_Offset.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_HS_Moment_Offset)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HdroAdMsI
   if (allocated(OutData%HdroAdMsI)) deallocate(OutData%HdroAdMsI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HdroAdMsI(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HdroAdMsI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HdroAdMsI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HdroSttc
   if (allocated(OutData%HdroSttc)) deallocate(OutData%HdroSttc)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HdroSttc(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HdroSttc.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HdroSttc)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RdtnMod
   call RegUnpack(Buf, OutData%RdtnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnMod
   call RegUnpack(Buf, OutData%ExctnMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegUnpack(Buf, OutData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnCutOff
   call RegUnpack(Buf, OutData%ExctnCutOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnFiltConst
   call RegUnpack(Buf, OutData%ExctnFiltConst)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveExctn
   if (allocated(OutData%WaveExctn)) deallocate(OutData%WaveExctn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveExctn(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveExctn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveExctn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveExctnGrid
   if (allocated(OutData%WaveExctnGrid)) deallocate(OutData%WaveExctnGrid)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveExctnGrid(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveExctnGrid.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveExctnGrid)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Conv_Rdtn
   call Conv_Rdtn_UnpackParam(Buf, OutData%Conv_Rdtn) ! Conv_Rdtn 
   ! SS_Rdtn
   call SS_Rad_UnpackParam(Buf, OutData%SS_Rdtn) ! SS_Rdtn 
   ! SS_Exctn
   call SS_Exc_UnpackParam(Buf, OutData%SS_Exctn) ! SS_Exctn 
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_UnpackParam(Buf, OutData%SeaSt_Interp_p) ! SeaSt_Interp_p 
end subroutine
 SUBROUTINE WAMIT_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(WAMIT_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcInputData%Mesh, DstInputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyInput

 SUBROUTINE WAMIT_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(WAMIT_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( InputData%Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyInput


subroutine WAMIT_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Mesh
   call MeshPack(Buf, InData%Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Mesh
   call MeshUnpack(Buf, OutData%Mesh) ! Mesh 
end subroutine
 SUBROUTINE WAMIT_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(WAMIT_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcOutputData%Mesh, DstOutputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT_CopyOutput

 SUBROUTINE WAMIT_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(WAMIT_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( OutputData%Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT_DestroyOutput


subroutine WAMIT_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Mesh
   call MeshPack(Buf, InData%Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT_UnPackOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Mesh
   call MeshUnpack(Buf, OutData%Mesh) ! Mesh 
end subroutine

 SUBROUTINE WAMIT_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'WAMIT_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL WAMIT_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL WAMIT_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL WAMIT_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE WAMIT_Input_ExtrapInterp


 SUBROUTINE WAMIT_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'WAMIT_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(u1%Mesh, u2%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE WAMIT_Input_ExtrapInterp1


 SUBROUTINE WAMIT_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(WAMIT_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'WAMIT_Input_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(u1%Mesh, u2%Mesh, u3%Mesh, tin, u_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE WAMIT_Input_ExtrapInterp2


 SUBROUTINE WAMIT_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'WAMIT_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL WAMIT_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL WAMIT_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL WAMIT_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE WAMIT_Output_ExtrapInterp


 SUBROUTINE WAMIT_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'WAMIT_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(y1%Mesh, y2%Mesh, tin, y_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE WAMIT_Output_ExtrapInterp1


 SUBROUTINE WAMIT_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(WAMIT_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'WAMIT_Output_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(y1%Mesh, y2%Mesh, y3%Mesh, tin, y_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE WAMIT_Output_ExtrapInterp2

END MODULE WAMIT_Types
!ENDOFREGISTRYGENERATEDFILE
