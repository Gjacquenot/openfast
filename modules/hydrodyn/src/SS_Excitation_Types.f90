!STARTOFREGISTRYGENERATEDFILE 'SS_Excitation_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! SS_Excitation_Types
!.................................................................................................................................
! This file is part of SS_Excitation.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in SS_Excitation. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE SS_Excitation_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE SeaState_Interp_Types
USE NWTC_Library
IMPLICIT NONE
! =========  SS_Exc_InitInputType  =======
  TYPE, PUBLIC :: SS_Exc_InitInputType
    CHARACTER(1024)  :: InputFile      !< Name of the input file [-]
    INTEGER(IntKi)  :: NBody      !< Number of WAMIT bodies for this State Space model [-]
    INTEGER(IntKi)  :: ExctnDisp      !< 0: use undisplaced position, 1: use displaced position, 2: use low-pass filtered displaced position) [only used when PotMod=1 and ExctnMod>0] [-]
    REAL(ReKi)  :: WaveDir      !< Wave direction [rad]
    INTEGER(IntKi)  :: NStepWave      !< Number of timesteps in the WaveTime array [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: PtfmRefztRot      !< The rotation about zt of the body reference frame(s) from xt/yt [radians]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveElev0 => NULL()      !< Wave elevation time history at origin [m]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev1 => NULL()      !< First order wave elevation (points to SeaState module data) [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Times where wave elevation is known (points to SeaState module data) [s]
    TYPE(SeaSt_Interp_ParameterType)  :: SeaSt_Interp_p      !< parameter information from the SeaState Interpolation module [-]
  END TYPE SS_Exc_InitInputType
! =======================
! =========  SS_Exc_InitOutputType  =======
  TYPE, PUBLIC :: SS_Exc_InitOutputType
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Header of the output [-]
    CHARACTER(10) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output [-]
  END TYPE SS_Exc_InitOutputType
! =======================
! =========  SS_Exc_ContinuousStateType  =======
  TYPE, PUBLIC :: SS_Exc_ContinuousStateType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: x      !< Continuous States [-]
  END TYPE SS_Exc_ContinuousStateType
! =======================
! =========  SS_Exc_DiscreteStateType  =======
  TYPE, PUBLIC :: SS_Exc_DiscreteStateType
    REAL(SiKi)  :: DummyDiscState      !<  [-]
  END TYPE SS_Exc_DiscreteStateType
! =======================
! =========  SS_Exc_ConstraintStateType  =======
  TYPE, PUBLIC :: SS_Exc_ConstraintStateType
    REAL(SiKi)  :: DummyConstrState      !<  [-]
  END TYPE SS_Exc_ConstraintStateType
! =======================
! =========  SS_Exc_OtherStateType  =======
  TYPE, PUBLIC :: SS_Exc_OtherStateType
    INTEGER(IntKi)  :: n      !< Current Time step [-]
    TYPE(SS_Exc_ContinuousStateType) , DIMENSION(1:4)  :: xdot      !< Old Values of dxdt to used by the solver (multistep method) [-]
  END TYPE SS_Exc_OtherStateType
! =======================
! =========  SS_Exc_MiscVarType  =======
  TYPE, PUBLIC :: SS_Exc_MiscVarType
    INTEGER(IntKi)  :: LastIndWave = 1      !< last used index in the WaveTime array [-]
    TYPE(SeaSt_Interp_MiscVarType)  :: SeaSt_Interp_m      !< misc var information from the SeaState Interpolation module [-]
  END TYPE SS_Exc_MiscVarType
! =======================
! =========  SS_Exc_ParameterType  =======
  TYPE, PUBLIC :: SS_Exc_ParameterType
    REAL(DbKi)  :: DT      !< Time step [s]
    INTEGER(IntKi)  :: NBody      !< Number of WAMIT bodies for this State Space model [-]
    INTEGER(IntKi)  :: ExctnDisp      !< 0: use undisplaced position, 1: use displaced position, 2: use low-pass filtered displaced position) [only used when PotMod=1 and ExctnMod>0] [-]
    INTEGER(IntKi)  :: NStepWave      !< Number of timesteps in the WaveTime array [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: spDOF      !< States per DOF [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: A      !< A matrix [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: B      !< B matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C      !< C matrix [-]
    INTEGER(IntKi)  :: numStates = 0      !< Number of states [-]
    REAL(DbKi)  :: Tc      !< Time shift [s]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveElev0 => NULL()      !< Wave elevation time history at origin [m]
    REAL(SiKi) , DIMENSION(:,:,:), POINTER  :: WaveElev1 => NULL()      !< First order wave elevation (points to SeaState module data) [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Times where wave elevation is known (points to SeaState module data) [s]
    TYPE(SeaSt_Interp_ParameterType)  :: SeaSt_Interp_p      !< parameter information from the SeaState Interpolation module [-]
  END TYPE SS_Exc_ParameterType
! =======================
! =========  SS_Exc_InputType  =======
  TYPE, PUBLIC :: SS_Exc_InputType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PtfmPos      !< Positions of the NBody platforms.  Used when ExctnDisp = 1. For NBodyMod = 2, use actual instantaneous position, otherwise use only displacement [-]
  END TYPE SS_Exc_InputType
! =======================
! =========  SS_Exc_OutputType  =======
  TYPE, PUBLIC :: SS_Exc_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: y      !< Force/Moments [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< output Data [kN]
  END TYPE SS_Exc_OutputType
! =======================
CONTAINS
 SUBROUTINE SS_Exc_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(SS_Exc_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%NBody = SrcInitInputData%NBody
    DstInitInputData%ExctnDisp = SrcInitInputData%ExctnDisp
    DstInitInputData%WaveDir = SrcInitInputData%WaveDir
    DstInitInputData%NStepWave = SrcInitInputData%NStepWave
IF (ALLOCATED(SrcInitInputData%PtfmRefztRot)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefztRot,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefztRot,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefztRot)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefztRot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefztRot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefztRot = SrcInitInputData%PtfmRefztRot
ENDIF
    DstInitInputData%WaveElev0 => SrcInitInputData%WaveElev0
    DstInitInputData%WaveElev1 => SrcInitInputData%WaveElev1
    DstInitInputData%WaveTime => SrcInitInputData%WaveTime
      CALL SeaSt_Interp_CopyParam( SrcInitInputData%SeaSt_Interp_p, DstInitInputData%SeaSt_Interp_p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SS_Exc_CopyInitInput

 SUBROUTINE SS_Exc_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SS_Exc_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%PtfmRefztRot)) THEN
  DEALLOCATE(InitInputData%PtfmRefztRot)
ENDIF
NULLIFY(InitInputData%WaveElev0)
NULLIFY(InitInputData%WaveElev1)
NULLIFY(InitInputData%WaveTime)
  CALL SeaSt_Interp_DestroyParam( InitInputData%SeaSt_Interp_p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SS_Exc_DestroyInitInput


subroutine SS_Exc_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackInitInput'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegPack(Buf, InData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegPack(Buf, InData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefztRot
   call RegPack(Buf, allocated(InData%PtfmRefztRot))
   if (allocated(InData%PtfmRefztRot)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefztRot), ubound(InData%PtfmRefztRot))
      call RegPack(Buf, InData%PtfmRefztRot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   call RegPack(Buf, associated(InData%WaveElev0))
   if (associated(InData%WaveElev0)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElev0), ubound(InData%WaveElev0))
      call RegPackPointer(Buf, c_loc(InData%WaveElev0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev1
   call RegPack(Buf, associated(InData%WaveElev1))
   if (associated(InData%WaveElev1)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev1), ubound(InData%WaveElev1))
      call RegPackPointer(Buf, c_loc(InData%WaveElev1), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev1)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_PackParam(Buf, InData%SeaSt_Interp_p) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegUnpack(Buf, OutData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegUnpack(Buf, OutData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefztRot
   if (allocated(OutData%PtfmRefztRot)) deallocate(OutData%PtfmRefztRot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefztRot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefztRot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefztRot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveElev0
   if (associated(OutData%WaveElev0)) deallocate(OutData%WaveElev0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev0, UB(1:1)-LB(1:1))
         OutData%WaveElev0(LB(1):) => OutData%WaveElev0
      else
         allocate(OutData%WaveElev0(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev0)
         call RegUnpack(Buf, OutData%WaveElev0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev0 => null()
   end if
   ! WaveElev1
   if (associated(OutData%WaveElev1)) deallocate(OutData%WaveElev1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev1, UB(1:3)-LB(1:3))
         OutData%WaveElev1(LB(1):,LB(2):,LB(3):) => OutData%WaveElev1
      else
         allocate(OutData%WaveElev1(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev1)
         call RegUnpack(Buf, OutData%WaveElev1)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev1 => null()
   end if
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! SeaSt_Interp_p
   call SeaSt_Interp_UnpackParam(Buf, OutData%SeaSt_Interp_p) ! SeaSt_Interp_p 
end subroutine
 SUBROUTINE SS_Exc_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SS_Exc_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
 END SUBROUTINE SS_Exc_CopyInitOutput

 SUBROUTINE SS_Exc_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SS_Exc_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
 END SUBROUTINE SS_Exc_DestroyInitOutput


subroutine SS_Exc_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SS_Exc_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(SS_Exc_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%x)) THEN
  i1_l = LBOUND(SrcContStateData%x,1)
  i1_u = UBOUND(SrcContStateData%x,1)
  IF (.NOT. ALLOCATED(DstContStateData%x)) THEN 
    ALLOCATE(DstContStateData%x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%x = SrcContStateData%x
ENDIF
 END SUBROUTINE SS_Exc_CopyContState

 SUBROUTINE SS_Exc_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SS_Exc_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%x)) THEN
  DEALLOCATE(ContStateData%x)
ENDIF
 END SUBROUTINE SS_Exc_DestroyContState


subroutine SS_Exc_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! x
   call RegPack(Buf, allocated(InData%x))
   if (allocated(InData%x)) then
      call RegPackBounds(Buf, 1, lbound(InData%x), ubound(InData%x))
      call RegPack(Buf, InData%x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackContState'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! x
   if (allocated(OutData%x)) deallocate(OutData%x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SS_Exc_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(SS_Exc_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE SS_Exc_CopyDiscState

 SUBROUTINE SS_Exc_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SS_Exc_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SS_Exc_DestroyDiscState


subroutine SS_Exc_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyDiscState
   call RegPack(Buf, InData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyDiscState
   call RegUnpack(Buf, OutData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SS_Exc_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(SS_Exc_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE SS_Exc_CopyConstrState

 SUBROUTINE SS_Exc_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SS_Exc_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SS_Exc_DestroyConstrState


subroutine SS_Exc_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SS_Exc_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(SS_Exc_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%n = SrcOtherStateData%n
    DO i1 = LBOUND(SrcOtherStateData%xdot,1), UBOUND(SrcOtherStateData%xdot,1)
      CALL SS_Exc_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
 END SUBROUTINE SS_Exc_CopyOtherState

 SUBROUTINE SS_Exc_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SS_Exc_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

DO i1 = LBOUND(OtherStateData%xdot,1), UBOUND(OtherStateData%xdot,1)
  CALL SS_Exc_DestroyContState( OtherStateData%xdot(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
 END SUBROUTINE SS_Exc_DestroyOtherState


subroutine SS_Exc_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! n
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xdot
   LB(1:1) = lbound(InData%xdot)
   UB(1:1) = ubound(InData%xdot)
   do i1 = LB(1), UB(1)
      call SS_Exc_PackContState(Buf, InData%xdot(i1)) 
   end do
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat /= ErrID_None) return
   ! n
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
   ! xdot
   LB(1:1) = lbound(OutData%xdot)
   UB(1:1) = ubound(OutData%xdot)
   do i1 = LB(1), UB(1)
      call SS_Exc_UnpackContState(Buf, OutData%xdot(i1)) ! xdot 
   end do
end subroutine
 SUBROUTINE SS_Exc_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(SS_Exc_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
      CALL SeaSt_Interp_CopyMisc( SrcMiscData%SeaSt_Interp_m, DstMiscData%SeaSt_Interp_m, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SS_Exc_CopyMisc

 SUBROUTINE SS_Exc_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(SS_Exc_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL SeaSt_Interp_DestroyMisc( MiscData%SeaSt_Interp_m, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SS_Exc_DestroyMisc


subroutine SS_Exc_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! LastIndWave
   call RegPack(Buf, InData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_m
   call SeaSt_Interp_PackMisc(Buf, InData%SeaSt_Interp_m) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   ! LastIndWave
   call RegUnpack(Buf, OutData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_m
   call SeaSt_Interp_UnpackMisc(Buf, OutData%SeaSt_Interp_m) ! SeaSt_Interp_m 
end subroutine
 SUBROUTINE SS_Exc_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SS_Exc_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%NBody = SrcParamData%NBody
    DstParamData%ExctnDisp = SrcParamData%ExctnDisp
    DstParamData%NStepWave = SrcParamData%NStepWave
IF (ALLOCATED(SrcParamData%spDOF)) THEN
  i1_l = LBOUND(SrcParamData%spDOF,1)
  i1_u = UBOUND(SrcParamData%spDOF,1)
  IF (.NOT. ALLOCATED(DstParamData%spDOF)) THEN 
    ALLOCATE(DstParamData%spDOF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%spDOF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%spDOF = SrcParamData%spDOF
ENDIF
IF (ALLOCATED(SrcParamData%A)) THEN
  i1_l = LBOUND(SrcParamData%A,1)
  i1_u = UBOUND(SrcParamData%A,1)
  i2_l = LBOUND(SrcParamData%A,2)
  i2_u = UBOUND(SrcParamData%A,2)
  IF (.NOT. ALLOCATED(DstParamData%A)) THEN 
    ALLOCATE(DstParamData%A(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%A.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%A = SrcParamData%A
ENDIF
IF (ALLOCATED(SrcParamData%B)) THEN
  i1_l = LBOUND(SrcParamData%B,1)
  i1_u = UBOUND(SrcParamData%B,1)
  IF (.NOT. ALLOCATED(DstParamData%B)) THEN 
    ALLOCATE(DstParamData%B(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%B = SrcParamData%B
ENDIF
IF (ALLOCATED(SrcParamData%C)) THEN
  i1_l = LBOUND(SrcParamData%C,1)
  i1_u = UBOUND(SrcParamData%C,1)
  i2_l = LBOUND(SrcParamData%C,2)
  i2_u = UBOUND(SrcParamData%C,2)
  IF (.NOT. ALLOCATED(DstParamData%C)) THEN 
    ALLOCATE(DstParamData%C(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%C = SrcParamData%C
ENDIF
    DstParamData%numStates = SrcParamData%numStates
    DstParamData%Tc = SrcParamData%Tc
    DstParamData%WaveElev0 => SrcParamData%WaveElev0
    DstParamData%WaveElev1 => SrcParamData%WaveElev1
    DstParamData%WaveTime => SrcParamData%WaveTime
      CALL SeaSt_Interp_CopyParam( SrcParamData%SeaSt_Interp_p, DstParamData%SeaSt_Interp_p, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE SS_Exc_CopyParam

 SUBROUTINE SS_Exc_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SS_Exc_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%spDOF)) THEN
  DEALLOCATE(ParamData%spDOF)
ENDIF
IF (ALLOCATED(ParamData%A)) THEN
  DEALLOCATE(ParamData%A)
ENDIF
IF (ALLOCATED(ParamData%B)) THEN
  DEALLOCATE(ParamData%B)
ENDIF
IF (ALLOCATED(ParamData%C)) THEN
  DEALLOCATE(ParamData%C)
ENDIF
NULLIFY(ParamData%WaveElev0)
NULLIFY(ParamData%WaveElev1)
NULLIFY(ParamData%WaveTime)
  CALL SeaSt_Interp_DestroyParam( ParamData%SeaSt_Interp_p, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SS_Exc_DestroyParam


subroutine SS_Exc_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackParam'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegPack(Buf, InData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! spDOF
   call RegPack(Buf, allocated(InData%spDOF))
   if (allocated(InData%spDOF)) then
      call RegPackBounds(Buf, 1, lbound(InData%spDOF), ubound(InData%spDOF))
      call RegPack(Buf, InData%spDOF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! A
   call RegPack(Buf, allocated(InData%A))
   if (allocated(InData%A)) then
      call RegPackBounds(Buf, 2, lbound(InData%A), ubound(InData%A))
      call RegPack(Buf, InData%A)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! B
   call RegPack(Buf, allocated(InData%B))
   if (allocated(InData%B)) then
      call RegPackBounds(Buf, 1, lbound(InData%B), ubound(InData%B))
      call RegPack(Buf, InData%B)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C
   call RegPack(Buf, allocated(InData%C))
   if (allocated(InData%C)) then
      call RegPackBounds(Buf, 2, lbound(InData%C), ubound(InData%C))
      call RegPack(Buf, InData%C)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! numStates
   call RegPack(Buf, InData%numStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tc
   call RegPack(Buf, InData%Tc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   call RegPack(Buf, associated(InData%WaveElev0))
   if (associated(InData%WaveElev0)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElev0), ubound(InData%WaveElev0))
      call RegPackPointer(Buf, c_loc(InData%WaveElev0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev1
   call RegPack(Buf, associated(InData%WaveElev1))
   if (associated(InData%WaveElev1)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElev1), ubound(InData%WaveElev1))
      call RegPackPointer(Buf, c_loc(InData%WaveElev1), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElev1)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaSt_Interp_p
   call SeaSt_Interp_PackParam(Buf, InData%SeaSt_Interp_p) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackParam'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ExctnDisp
   call RegUnpack(Buf, OutData%ExctnDisp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! spDOF
   if (allocated(OutData%spDOF)) deallocate(OutData%spDOF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%spDOF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%spDOF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%spDOF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! A
   if (allocated(OutData%A)) deallocate(OutData%A)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%A(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%A.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%A)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! B
   if (allocated(OutData%B)) deallocate(OutData%B)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%B(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%B.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%B)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C
   if (allocated(OutData%C)) deallocate(OutData%C)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! numStates
   call RegUnpack(Buf, OutData%numStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Tc
   call RegUnpack(Buf, OutData%Tc)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   if (associated(OutData%WaveElev0)) deallocate(OutData%WaveElev0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev0, UB(1:1)-LB(1:1))
         OutData%WaveElev0(LB(1):) => OutData%WaveElev0
      else
         allocate(OutData%WaveElev0(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev0)
         call RegUnpack(Buf, OutData%WaveElev0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev0 => null()
   end if
   ! WaveElev1
   if (associated(OutData%WaveElev1)) deallocate(OutData%WaveElev1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElev1, UB(1:3)-LB(1:3))
         OutData%WaveElev1(LB(1):,LB(2):,LB(3):) => OutData%WaveElev1
      else
         allocate(OutData%WaveElev1(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElev1)
         call RegUnpack(Buf, OutData%WaveElev1)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElev1 => null()
   end if
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! SeaSt_Interp_p
   call SeaSt_Interp_UnpackParam(Buf, OutData%SeaSt_Interp_p) ! SeaSt_Interp_p 
end subroutine
 SUBROUTINE SS_Exc_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_InputType), INTENT(IN) :: SrcInputData
   TYPE(SS_Exc_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%PtfmPos)) THEN
  i1_l = LBOUND(SrcInputData%PtfmPos,1)
  i1_u = UBOUND(SrcInputData%PtfmPos,1)
  i2_l = LBOUND(SrcInputData%PtfmPos,2)
  i2_u = UBOUND(SrcInputData%PtfmPos,2)
  IF (.NOT. ALLOCATED(DstInputData%PtfmPos)) THEN 
    ALLOCATE(DstInputData%PtfmPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%PtfmPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%PtfmPos = SrcInputData%PtfmPos
ENDIF
 END SUBROUTINE SS_Exc_CopyInput

 SUBROUTINE SS_Exc_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SS_Exc_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%PtfmPos)) THEN
  DEALLOCATE(InputData%PtfmPos)
ENDIF
 END SUBROUTINE SS_Exc_DestroyInput


subroutine SS_Exc_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! PtfmPos
   call RegPack(Buf, allocated(InData%PtfmPos))
   if (allocated(InData%PtfmPos)) then
      call RegPackBounds(Buf, 2, lbound(InData%PtfmPos), ubound(InData%PtfmPos))
      call RegPack(Buf, InData%PtfmPos)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! PtfmPos
   if (allocated(OutData%PtfmPos)) deallocate(OutData%PtfmPos)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmPos(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmPos.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmPos)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SS_Exc_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SS_Exc_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(SS_Exc_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SS_Exc_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%y)) THEN
  i1_l = LBOUND(SrcOutputData%y,1)
  i1_u = UBOUND(SrcOutputData%y,1)
  IF (.NOT. ALLOCATED(DstOutputData%y)) THEN 
    ALLOCATE(DstOutputData%y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%y = SrcOutputData%y
ENDIF
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SS_Exc_CopyOutput

 SUBROUTINE SS_Exc_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SS_Exc_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SS_Exc_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%y)) THEN
  DEALLOCATE(OutputData%y)
ENDIF
IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE SS_Exc_DestroyOutput


subroutine SS_Exc_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SS_Exc_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SS_Exc_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! y
   call RegPack(Buf, allocated(InData%y))
   if (allocated(InData%y)) then
      call RegPackBounds(Buf, 1, lbound(InData%y), ubound(InData%y))
      call RegPack(Buf, InData%y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SS_Exc_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SS_Exc_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SS_Exc_UnPackOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! y
   if (allocated(OutData%y)) deallocate(OutData%y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE SS_Exc_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SS_Exc_InputType), INTENT(IN)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(SS_Exc_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'SS_Exc_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL SS_Exc_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL SS_Exc_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL SS_Exc_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE SS_Exc_Input_ExtrapInterp


 SUBROUTINE SS_Exc_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(SS_Exc_InputType), INTENT(IN)  :: u1    ! Input at t1 > t2
 TYPE(SS_Exc_InputType), INTENT(IN)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(SS_Exc_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'SS_Exc_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%PtfmPos) .AND. ALLOCATED(u1%PtfmPos)) THEN
  DO i2 = LBOUND(u_out%PtfmPos,2),UBOUND(u_out%PtfmPos,2)
    DO i1 = LBOUND(u_out%PtfmPos,1),UBOUND(u_out%PtfmPos,1)
      b = -(u1%PtfmPos(i1,i2) - u2%PtfmPos(i1,i2))
      u_out%PtfmPos(i1,i2) = u1%PtfmPos(i1,i2) + b * ScaleFactor
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE SS_Exc_Input_ExtrapInterp1


 SUBROUTINE SS_Exc_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(SS_Exc_InputType), INTENT(IN)  :: u1      ! Input at t1 > t2 > t3
 TYPE(SS_Exc_InputType), INTENT(IN)  :: u2      ! Input at t2 > t3
 TYPE(SS_Exc_InputType), INTENT(IN)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(SS_Exc_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'SS_Exc_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
 INTEGER                                    :: i2    ! dim2 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%PtfmPos) .AND. ALLOCATED(u1%PtfmPos)) THEN
  DO i2 = LBOUND(u_out%PtfmPos,2),UBOUND(u_out%PtfmPos,2)
    DO i1 = LBOUND(u_out%PtfmPos,1),UBOUND(u_out%PtfmPos,1)
      b = (t(3)**2*(u1%PtfmPos(i1,i2) - u2%PtfmPos(i1,i2)) + t(2)**2*(-u1%PtfmPos(i1,i2) + u3%PtfmPos(i1,i2)))* scaleFactor
      c = ( (t(2)-t(3))*u1%PtfmPos(i1,i2) + t(3)*u2%PtfmPos(i1,i2) - t(2)*u3%PtfmPos(i1,i2) ) * scaleFactor
      u_out%PtfmPos(i1,i2) = u1%PtfmPos(i1,i2) + b  + c * t_out
    END DO
  END DO
END IF ! check if allocated
 END SUBROUTINE SS_Exc_Input_ExtrapInterp2


 SUBROUTINE SS_Exc_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SS_Exc_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(SS_Exc_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'SS_Exc_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL SS_Exc_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL SS_Exc_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL SS_Exc_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE SS_Exc_Output_ExtrapInterp


 SUBROUTINE SS_Exc_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(SS_Exc_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(SS_Exc_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(SS_Exc_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'SS_Exc_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%y) .AND. ALLOCATED(y1%y)) THEN
  DO i1 = LBOUND(y_out%y,1),UBOUND(y_out%y,1)
    b = -(y1%y(i1) - y2%y(i1))
    y_out%y(i1) = y1%y(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE SS_Exc_Output_ExtrapInterp1


 SUBROUTINE SS_Exc_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(SS_Exc_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(SS_Exc_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(SS_Exc_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(SS_Exc_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'SS_Exc_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%y) .AND. ALLOCATED(y1%y)) THEN
  DO i1 = LBOUND(y_out%y,1),UBOUND(y_out%y,1)
    b = (t(3)**2*(y1%y(i1) - y2%y(i1)) + t(2)**2*(-y1%y(i1) + y3%y(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%y(i1) + t(3)*y2%y(i1) - t(2)*y3%y(i1) ) * scaleFactor
    y_out%y(i1) = y1%y(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE SS_Exc_Output_ExtrapInterp2

END MODULE SS_Excitation_Types
!ENDOFREGISTRYGENERATEDFILE
