!STARTOFREGISTRYGENERATEDFILE 'HydroDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! HydroDyn_Types
!.................................................................................................................................
! This file is part of HydroDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in HydroDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE HydroDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE Conv_Radiation_Types
USE SS_Radiation_Types
USE SS_Excitation_Types
USE WAMIT_Types
USE WAMIT2_Types
USE Morison_Types
USE SeaState_Types
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxHDOutputs = 510      ! The maximum number of output channels supported by this module [-]
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxUserOutputs = 5150      !  Total possible number of output channels:  SS_Excitation = 7 + SS_Radiation = 7 + Morison= 4626 + HydroDyn=510   =  5150 [-]
! =========  HydroDyn_InputFile  =======
  TYPE, PUBLIC :: HydroDyn_InputFile
    LOGICAL  :: EchoFlag      !< Echo the input file [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AddF0      !< Additional pre-load forces and moments (N,N,N,N-m,N-m,N-m) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AddCLin      !< Additional stiffness matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AddBLin      !< Additional linear damping matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AddBQuad      !< Additional quadratic damping (drag) matrix [-]
    TYPE(SeaSt_InitInputType)  :: SeaState      !< Initialization data for SeaState module [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: PotFile      !< The name of the root potential flow file (without extension for WAMIT, complete name for FIT) [-]
    INTEGER(IntKi)  :: nWAMITObj      !< number of WAMIT input files.  If NBodyMod = 1 then nPotFiles will be 1 even if NBody > 1 [-]
    INTEGER(IntKi)  :: vecMultiplier      !< multiplier for the WAMIT vectors and matrices.  If NBodyMod=1 then this = NBody, else 1 [-]
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    INTEGER(IntKi)  :: NBodyMod      !< Body coupling model {1: include coupling terms between each body and NBody in HydroDyn equals NBODY in WAMIT, 2: neglect coupling terms between each body and NBODY=1 with XBODY=0 in WAMIT, 3: Neglect coupling terms between each body and NBODY=1 with XBODY=/0 in WAMIT} (switch) [only used when PotMod=1] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmVol0      !<  [-]
    LOGICAL  :: HasWAMIT      !< .TRUE. if using WAMIT model, .FALSE. otherwise [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WAMITULEN      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefxt      !< The xt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefyt      !< The yt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefzt      !< The zt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: PtfmRefztRot      !< The rotation about zt of the body reference frame(s) from xt/yt [radians]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmCOBxt      !<  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmCOByt      !<  [-]
    TYPE(WAMIT_InitInputType)  :: WAMIT      !< Initialization data for WAMIT module [-]
    TYPE(WAMIT2_InitInputType)  :: WAMIT2      !< Initialization data for WAMIT2 module [-]
    TYPE(Morison_InitInputType)  :: Morison      !< Initialization data for Morison module [-]
    LOGICAL  :: Echo      !< Echo the input files to a file with the same name as the input but with a .echo extension [T/F] [-]
    INTEGER(IntKi)  :: PotMod      !< 1 if using WAMIT model, 0 if no potential flow model, or 2 if FIT model [-]
    INTEGER(IntKi)  :: NUserOutputs      !< Number of Hydrodyn-level requested output channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: UserOutputs      !< This should really be dimensioned with MaxOutPts [-]
    INTEGER(IntKi)  :: OutSwtch      !< Output requested channels to: [1=Hydrodyn.out 2=GlueCode.out  3=both files] [-]
    LOGICAL  :: OutAll      !< Output all user-specified member and joint loads (only at each member end, not interior locations) [T/F] [-]
    INTEGER(IntKi)  :: NumOuts      !< The number of outputs for this module as requested in the input file [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: OutList      !< The user-requested output channel labels for this modules. This should really be dimensioned with MaxOutPts [-]
    LOGICAL  :: HDSum      !< Generate a HydroDyn summary file [T/F] [-]
    INTEGER(IntKi)  :: UnSum      !< File unit for the HydroDyn summary file [-1 = no summary file] [-]
    CHARACTER(20)  :: OutFmt      !< Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      !< Output format for header strings [-]
  END TYPE HydroDyn_InputFile
! =======================
! =========  HydroDyn_InitInputType  =======
  TYPE, PUBLIC :: HydroDyn_InitInputType
    CHARACTER(1024)  :: InputFile      !< Supplied by Driver:  full path and filename for the HydroDyn module [-]
    LOGICAL  :: UseInputFile = .TRUE.      !< Supplied by Driver:  .TRUE. if using a input file, .FALSE. if all inputs are being passed in by the caller [-]
    TYPE(FileInfoType)  :: PassedFileData      !< If we don't use the input file, pass everything through this [-]
    CHARACTER(1024)  :: OutRootName      !< Supplied by Driver:  The name of the root file (without extension) including the full path [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
    REAL(ReKi)  :: Gravity      !< Supplied by Driver:  Gravitational acceleration [(m/s^2)]
    REAL(ReKi)  :: WtrDens      !< Water density from the driver; may be overwritten                       [(kg/m^3)]
    REAL(ReKi)  :: WtrDpth      !< Water depth from the driver; may be overwritten                         [m]
    REAL(ReKi)  :: MSL2SWL      !< Mean sea level to still water level from the driver; may be overwritten [m]
    REAL(DbKi)  :: TMax      !< Supplied by Driver:  The total simulation time [(sec)]
    REAL(ReKi)  :: PtfmLocationX      !< Supplied by Driver:  X coordinate of platform location in the wave field [m]
    REAL(ReKi)  :: PtfmLocationY      !< Supplied by Driver:  Y coordinate of platform location in the wave field [m]
    INTEGER(IntKi)  :: NStepWave = 0      !< Total number of frequency components = total number of time steps in the incident wave [-]
    INTEGER(IntKi)  :: NStepWave2 = 0      !< NStepWave / 2 [-]
    REAL(SiKi)  :: RhoXg      !< = WtrDens*Gravity [-]
    INTEGER(IntKi)  :: WaveMod      !< Incident wave kinematics model {0: none=still water, 1: plane progressive (regular), 2: JONSWAP/Pierson-Moskowitz spectrum (irregular), 3: white-noise spectrum, 4: user-defind spectrum from routine UserWaveSpctrm (irregular), 5: GH BLADED } [-]
    INTEGER(IntKi)  :: WaveStMod      !< Model for stretching incident wave kinematics to instantaneous free surface {0: none=no stretching, 1: vertical stretching, 2: extrapolation stretching, 3: Wheeler stretching} [-]
    INTEGER(IntKi)  :: WaveDirMod      !< Directional wave spreading function {0: none, 1: COS2S} [only used if WaveMod=6] [-]
    REAL(SiKi)  :: WvLowCOff      !< Low cut-off frequency or lower frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WvHiCOff      !< High cut-off frequency or upper frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(SiKi)  :: WvLowCOffD      !< Minimum frequency used in the difference methods [Ignored if all difference methods = 0] [(rad/s)]
    REAL(SiKi)  :: WvHiCOffD      !< Maximum frequency used in the difference methods [Ignored if all difference methods = 0] [(rad/s)]
    REAL(SiKi)  :: WvLowCOffS      !< Minimum frequency used in the sum-QTF method     [Ignored if SumQTF = 0] [(rad/s)]
    REAL(SiKi)  :: WvHiCOffS      !< Maximum frequency used in the sum-QTF method     [Ignored if SumQTF = 0] [(rad/s)]
    LOGICAL  :: InvalidWithSSExctn      !< Whether SeaState configuration is invalid with HydroDyn's state-space excitation (ExctnMod=2) [(-)]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: WaveElev0      !< Instantaneous elevation time-series of incident waves at the platform reference point [(meters)]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveElevC      !< Discrete Fourier transform of the instantaneous elevation of incident waves at all grid points.  First column is real part, second column is imaginary part [(meters)]
    REAL(SiKi)  :: WaveDirMin      !< Minimum wave direction. [(degrees)]
    REAL(SiKi)  :: WaveDirMax      !< Maximum wave direction. [(degrees)]
    REAL(SiKi)  :: WaveDir      !< Incident wave propagation heading direction [(degrees)]
    LOGICAL  :: WaveMultiDir      !< Indicates the waves are multidirectional -- set by HydroDyn_Input [-]
    REAL(SiKi)  :: WaveDOmega      !< Frequency step for incident wave calculations [(rad/s)]
    REAL(SiKi)  :: MCFD      !< Diameter of MacCamy-Fuchs members [(meters)]
    TYPE(SeaSt_WaveFieldType) , POINTER :: WaveField => NULL()      !< Pointer to SeaState wave field [-]
  END TYPE HydroDyn_InitInputType
! =======================
! =========  HydroDyn_InitOutputType  =======
  TYPE, PUBLIC :: HydroDyn_InitOutputType
    TYPE(Morison_InitOutputType)  :: Morison      !< Initialization output from the Morison module [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< The is the list of all HD-related output channel header strings (includes all sub-module channels) [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< The is the list of all HD-related output channel unit strings (includes all sub-module channels) [-]
    TYPE(ProgDesc)  :: Ver      !< Version of HydroDyn [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the continuous states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
  END TYPE HydroDyn_InitOutputType
! =======================
! =========  HD_ModuleMapType  =======
  TYPE, PUBLIC :: HD_ModuleMapType
    TYPE(MeshMapType)  :: uW_P_2_PRP_P      !< Mesh mapping data: WAMIT body kinematics to PRP node at (0,0,0) [-]
    TYPE(MeshMapType)  :: W_P_2_PRP_P      !< Mesh mapping data: WAMIT loads to PRP node at (0,0,0) [-]
    TYPE(MeshMapType)  :: M_P_2_PRP_P      !< Mesh mapping data: lumped Morison loads to PRP node at (0,0,0) [-]
  END TYPE HD_ModuleMapType
! =======================
! =========  HydroDyn_ContinuousStateType  =======
  TYPE, PUBLIC :: HydroDyn_ContinuousStateType
    TYPE(WAMIT_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: WAMIT      !< continuous states from the wamit module [-]
    TYPE(Morison_ContinuousStateType)  :: Morison      !< continuous states from the Morison module [-]
  END TYPE HydroDyn_ContinuousStateType
! =======================
! =========  HydroDyn_DiscreteStateType  =======
  TYPE, PUBLIC :: HydroDyn_DiscreteStateType
    TYPE(WAMIT_DiscreteStateType) , DIMENSION(:), ALLOCATABLE  :: WAMIT      !< discrete states from the wamit module [-]
    TYPE(Morison_DiscreteStateType)  :: Morison      !< discrete states from the Morison module [-]
  END TYPE HydroDyn_DiscreteStateType
! =======================
! =========  HydroDyn_ConstraintStateType  =======
  TYPE, PUBLIC :: HydroDyn_ConstraintStateType
    TYPE(WAMIT_ConstraintStateType)  :: WAMIT      !< constraint states from WAMIT (may be empty) [-]
    TYPE(Morison_ConstraintStateType)  :: Morison      !< constraint states from the Morison module [-]
  END TYPE HydroDyn_ConstraintStateType
! =======================
! =========  HydroDyn_OtherStateType  =======
  TYPE, PUBLIC :: HydroDyn_OtherStateType
    TYPE(WAMIT_OtherStateType) , DIMENSION(:), ALLOCATABLE  :: WAMIT      !< OtherState information from the WAMIT module [-]
    TYPE(Morison_OtherStateType)  :: Morison      !< OtherState information from the Morison module [-]
  END TYPE HydroDyn_OtherStateType
! =======================
! =========  HydroDyn_MiscVarType  =======
  TYPE, PUBLIC :: HydroDyn_MiscVarType
    TYPE(MeshType)  :: AllHdroOrigin      !< An intermediate mesh used to transfer hydrodynamic loads from the various HD-related meshes to the AllHdroOrigin mesh [-]
    TYPE(HD_ModuleMapType)  :: HD_MeshMap 
    INTEGER(IntKi)  :: Decimate      !< The output decimation counter [-]
    REAL(DbKi)  :: LastOutTime      !< Last time step which was written to the output file (sec) [-]
    INTEGER(IntKi)  :: LastIndWave      !< The last index used in the wave kinematics arrays, used to optimize interpolation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_PtfmAdd      !< The total forces and moments due to additional pre-load, stiffness, and damping [-]
    REAL(ReKi) , DIMENSION(1:6)  :: F_Hydro      !< The total hydrodynamic forces and moments integrated about the (0,0,0) platform reference point [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_Waves      !< The total waves forces on a WAMIT body calculated by first and second order methods (WAMIT and WAMIT2 modules) [-]
    TYPE(WAMIT_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: WAMIT      !< misc var information from the WAMIT module [-]
    TYPE(WAMIT2_MiscVarType) , DIMENSION(:), ALLOCATABLE  :: WAMIT2      !< misc var information from the WAMIT2 module [-]
    TYPE(Morison_MiscVarType)  :: Morison      !< misc var information from the Morison module [-]
    TYPE(WAMIT_InputType) , DIMENSION(:), ALLOCATABLE  :: u_WAMIT      !< WAMIT module inputs [-]
  END TYPE HydroDyn_MiscVarType
! =======================
! =========  HydroDyn_ParameterType  =======
  TYPE, PUBLIC :: HydroDyn_ParameterType
    INTEGER(IntKi)  :: nWAMITObj      !< number of WAMIT input files and matrices.  If NBodyMod = 1 then nPotFiles will be 1 even if NBody > 1 [-]
    INTEGER(IntKi)  :: vecMultiplier      !< multiplier for the WAMIT vectors and matrices.  If NBodyMod=1 then this = NBody, else 1 [-]
    TYPE(WAMIT_ParameterType) , DIMENSION(:), ALLOCATABLE  :: WAMIT      !< Parameter data for the WAMIT module [-]
    TYPE(WAMIT2_ParameterType) , DIMENSION(:), ALLOCATABLE  :: WAMIT2      !< Parameter data for the WAMIT2 module [-]
    LOGICAL  :: WAMIT2used = .FALSE.      !< Indicates when WAMIT2 is used.  Shortcuts some calculations [-]
    TYPE(Morison_ParameterType)  :: Morison      !< Parameter data for the Morison module [-]
    INTEGER(IntKi)  :: PotMod      !< 1 if using WAMIT model, 0 if no potential flow model, or 2 if FIT model [-]
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    INTEGER(IntKi)  :: NBodyMod      !< Body coupling model {1: include coupling terms between each body and NBody in HydroDyn equals NBODY in WAMIT, 2: neglect coupling terms between each body and NBODY=1 with XBODY=0 in WAMIT, 3: Neglect coupling terms between each body and NBODY=1 with XBODY=/0 in WAMIT} (switch) [only used when PotMod=1] [-]
    INTEGER(IntKi)  :: totalStates      !< Number of excitation and radiation states for all WAMIT bodies [-]
    INTEGER(IntKi)  :: totalExctnStates      !< Number of excitation states for all WAMIT bodies [-]
    INTEGER(IntKi)  :: totalRdtnStates      !< Number of radiation states for all WAMIT bodies [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveTime => NULL()      !< Array of time samples, (sec) [-]
    INTEGER(IntKi)  :: NStepWave      !< Number of data points in the wave kinematics arrays [-]
    REAL(ReKi)  :: WtrDpth      !< Water depth [(m)]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AddF0      !< Additional pre-load forces and moments (N,N,N,N-m,N-m,N-m) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AddCLin      !< Additional stiffness matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AddBLin      !< Additional linear damping matrix [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: AddBQuad      !< Additional quadratic damping (drag) matrix [-]
    REAL(DbKi)  :: DT      !< Time step in seconds for integration of continuous states (if a fixed-step integrator is used) and update of discrete states [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !<  [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of HydroDyn module-level outputs (not the total number including sub-modules [-]
    INTEGER(IntKi)  :: NumTotalOuts      !< Number of all requested outputs including sub-modules [-]
    INTEGER(IntKi)  :: OutSwtch      !< Output requested channels to: [1=Hydrodyn.out 2=GlueCode.out  3=both files] [-]
    CHARACTER(20)  :: OutFmt      !< Output format for numerical results [-]
    CHARACTER(20)  :: OutSFmt      !< Output format for header strings [-]
    CHARACTER(ChanLen)  :: Delim      !< Delimiter string for outputs, defaults to tab-delimiters [-]
    INTEGER(IntKi)  :: UnOutFile      !< File unit for the HydroDyn outputs [-]
    INTEGER(IntKi)  :: OutDec      !< Write every OutDec time steps [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
    INTEGER(IntKi)  :: Jac_ny      !< number of outputs in jacobian matrix [-]
    LOGICAL  :: PointsToSeaState = .TRUE.      !< Flag that determines if the data contains pointers to SeaState module or if new copies (from restart) [-]
  END TYPE HydroDyn_ParameterType
! =======================
! =========  HydroDyn_InputType  =======
  TYPE, PUBLIC :: HydroDyn_InputType
    TYPE(Morison_InputType)  :: Morison      !< Morison module inputs [-]
    TYPE(MeshType)  :: WAMITMesh      !< Motions at the WAMIT reference point(s) in the inertial frame [-]
    TYPE(MeshType)  :: PRPMesh      !< Motions at the Platform reference point in the inertial frame [-]
  END TYPE HydroDyn_InputType
! =======================
! =========  HydroDyn_OutputType  =======
  TYPE, PUBLIC :: HydroDyn_OutputType
    TYPE(WAMIT_OutputType) , DIMENSION(:), ALLOCATABLE  :: WAMIT      !< WAMIT module outputs [-]
    TYPE(WAMIT2_OutputType) , DIMENSION(:), ALLOCATABLE  :: WAMIT2      !< WAMIT2 module outputs [-]
    TYPE(Morison_OutputType)  :: Morison      !< Morison module outputs [-]
    TYPE(MeshType)  :: WAMITMesh      !< Point Loads at the WAMIT reference point(s) in the inertial frame [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Outputs to be written to the output file(s) [-]
  END TYPE HydroDyn_OutputType
! =======================
CONTAINS
 SUBROUTINE HydroDyn_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(HydroDyn_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%EchoFlag = SrcInputFileData%EchoFlag
IF (ALLOCATED(SrcInputFileData%AddF0)) THEN
  i1_l = LBOUND(SrcInputFileData%AddF0,1)
  i1_u = UBOUND(SrcInputFileData%AddF0,1)
  i2_l = LBOUND(SrcInputFileData%AddF0,2)
  i2_u = UBOUND(SrcInputFileData%AddF0,2)
  IF (.NOT. ALLOCATED(DstInputFileData%AddF0)) THEN 
    ALLOCATE(DstInputFileData%AddF0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AddF0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%AddF0 = SrcInputFileData%AddF0
ENDIF
IF (ALLOCATED(SrcInputFileData%AddCLin)) THEN
  i1_l = LBOUND(SrcInputFileData%AddCLin,1)
  i1_u = UBOUND(SrcInputFileData%AddCLin,1)
  i2_l = LBOUND(SrcInputFileData%AddCLin,2)
  i2_u = UBOUND(SrcInputFileData%AddCLin,2)
  i3_l = LBOUND(SrcInputFileData%AddCLin,3)
  i3_u = UBOUND(SrcInputFileData%AddCLin,3)
  IF (.NOT. ALLOCATED(DstInputFileData%AddCLin)) THEN 
    ALLOCATE(DstInputFileData%AddCLin(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AddCLin.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%AddCLin = SrcInputFileData%AddCLin
ENDIF
IF (ALLOCATED(SrcInputFileData%AddBLin)) THEN
  i1_l = LBOUND(SrcInputFileData%AddBLin,1)
  i1_u = UBOUND(SrcInputFileData%AddBLin,1)
  i2_l = LBOUND(SrcInputFileData%AddBLin,2)
  i2_u = UBOUND(SrcInputFileData%AddBLin,2)
  i3_l = LBOUND(SrcInputFileData%AddBLin,3)
  i3_u = UBOUND(SrcInputFileData%AddBLin,3)
  IF (.NOT. ALLOCATED(DstInputFileData%AddBLin)) THEN 
    ALLOCATE(DstInputFileData%AddBLin(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AddBLin.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%AddBLin = SrcInputFileData%AddBLin
ENDIF
IF (ALLOCATED(SrcInputFileData%AddBQuad)) THEN
  i1_l = LBOUND(SrcInputFileData%AddBQuad,1)
  i1_u = UBOUND(SrcInputFileData%AddBQuad,1)
  i2_l = LBOUND(SrcInputFileData%AddBQuad,2)
  i2_u = UBOUND(SrcInputFileData%AddBQuad,2)
  i3_l = LBOUND(SrcInputFileData%AddBQuad,3)
  i3_u = UBOUND(SrcInputFileData%AddBQuad,3)
  IF (.NOT. ALLOCATED(DstInputFileData%AddBQuad)) THEN 
    ALLOCATE(DstInputFileData%AddBQuad(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%AddBQuad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%AddBQuad = SrcInputFileData%AddBQuad
ENDIF
      CALL SeaSt_CopyInitInput( SrcInputFileData%SeaState, DstInputFileData%SeaState, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInputFileData%PotFile)) THEN
  i1_l = LBOUND(SrcInputFileData%PotFile,1)
  i1_u = UBOUND(SrcInputFileData%PotFile,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PotFile)) THEN 
    ALLOCATE(DstInputFileData%PotFile(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PotFile.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PotFile = SrcInputFileData%PotFile
ENDIF
    DstInputFileData%nWAMITObj = SrcInputFileData%nWAMITObj
    DstInputFileData%vecMultiplier = SrcInputFileData%vecMultiplier
    DstInputFileData%NBody = SrcInputFileData%NBody
    DstInputFileData%NBodyMod = SrcInputFileData%NBodyMod
IF (ALLOCATED(SrcInputFileData%PtfmVol0)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmVol0,1)
  i1_u = UBOUND(SrcInputFileData%PtfmVol0,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmVol0)) THEN 
    ALLOCATE(DstInputFileData%PtfmVol0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmVol0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmVol0 = SrcInputFileData%PtfmVol0
ENDIF
    DstInputFileData%HasWAMIT = SrcInputFileData%HasWAMIT
IF (ALLOCATED(SrcInputFileData%WAMITULEN)) THEN
  i1_l = LBOUND(SrcInputFileData%WAMITULEN,1)
  i1_u = UBOUND(SrcInputFileData%WAMITULEN,1)
  IF (.NOT. ALLOCATED(DstInputFileData%WAMITULEN)) THEN 
    ALLOCATE(DstInputFileData%WAMITULEN(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%WAMITULEN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%WAMITULEN = SrcInputFileData%WAMITULEN
ENDIF
IF (ALLOCATED(SrcInputFileData%PtfmRefxt)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmRefxt,1)
  i1_u = UBOUND(SrcInputFileData%PtfmRefxt,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmRefxt)) THEN 
    ALLOCATE(DstInputFileData%PtfmRefxt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmRefxt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmRefxt = SrcInputFileData%PtfmRefxt
ENDIF
IF (ALLOCATED(SrcInputFileData%PtfmRefyt)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmRefyt,1)
  i1_u = UBOUND(SrcInputFileData%PtfmRefyt,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmRefyt)) THEN 
    ALLOCATE(DstInputFileData%PtfmRefyt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmRefyt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmRefyt = SrcInputFileData%PtfmRefyt
ENDIF
IF (ALLOCATED(SrcInputFileData%PtfmRefzt)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmRefzt,1)
  i1_u = UBOUND(SrcInputFileData%PtfmRefzt,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmRefzt)) THEN 
    ALLOCATE(DstInputFileData%PtfmRefzt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmRefzt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmRefzt = SrcInputFileData%PtfmRefzt
ENDIF
IF (ALLOCATED(SrcInputFileData%PtfmRefztRot)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmRefztRot,1)
  i1_u = UBOUND(SrcInputFileData%PtfmRefztRot,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmRefztRot)) THEN 
    ALLOCATE(DstInputFileData%PtfmRefztRot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmRefztRot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmRefztRot = SrcInputFileData%PtfmRefztRot
ENDIF
IF (ALLOCATED(SrcInputFileData%PtfmCOBxt)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmCOBxt,1)
  i1_u = UBOUND(SrcInputFileData%PtfmCOBxt,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmCOBxt)) THEN 
    ALLOCATE(DstInputFileData%PtfmCOBxt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmCOBxt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmCOBxt = SrcInputFileData%PtfmCOBxt
ENDIF
IF (ALLOCATED(SrcInputFileData%PtfmCOByt)) THEN
  i1_l = LBOUND(SrcInputFileData%PtfmCOByt,1)
  i1_u = UBOUND(SrcInputFileData%PtfmCOByt,1)
  IF (.NOT. ALLOCATED(DstInputFileData%PtfmCOByt)) THEN 
    ALLOCATE(DstInputFileData%PtfmCOByt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%PtfmCOByt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%PtfmCOByt = SrcInputFileData%PtfmCOByt
ENDIF
      CALL WAMIT_CopyInitInput( SrcInputFileData%WAMIT, DstInputFileData%WAMIT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL WAMIT2_CopyInitInput( SrcInputFileData%WAMIT2, DstInputFileData%WAMIT2, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Morison_CopyInitInput( SrcInputFileData%Morison, DstInputFileData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInputFileData%Echo = SrcInputFileData%Echo
    DstInputFileData%PotMod = SrcInputFileData%PotMod
    DstInputFileData%NUserOutputs = SrcInputFileData%NUserOutputs
IF (ALLOCATED(SrcInputFileData%UserOutputs)) THEN
  i1_l = LBOUND(SrcInputFileData%UserOutputs,1)
  i1_u = UBOUND(SrcInputFileData%UserOutputs,1)
  IF (.NOT. ALLOCATED(DstInputFileData%UserOutputs)) THEN 
    ALLOCATE(DstInputFileData%UserOutputs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%UserOutputs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%UserOutputs = SrcInputFileData%UserOutputs
ENDIF
    DstInputFileData%OutSwtch = SrcInputFileData%OutSwtch
    DstInputFileData%OutAll = SrcInputFileData%OutAll
    DstInputFileData%NumOuts = SrcInputFileData%NumOuts
IF (ALLOCATED(SrcInputFileData%OutList)) THEN
  i1_l = LBOUND(SrcInputFileData%OutList,1)
  i1_u = UBOUND(SrcInputFileData%OutList,1)
  IF (.NOT. ALLOCATED(DstInputFileData%OutList)) THEN 
    ALLOCATE(DstInputFileData%OutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputFileData%OutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputFileData%OutList = SrcInputFileData%OutList
ENDIF
    DstInputFileData%HDSum = SrcInputFileData%HDSum
    DstInputFileData%UnSum = SrcInputFileData%UnSum
    DstInputFileData%OutFmt = SrcInputFileData%OutFmt
    DstInputFileData%OutSFmt = SrcInputFileData%OutSFmt
 END SUBROUTINE HydroDyn_CopyInputFile

 SUBROUTINE HydroDyn_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(HydroDyn_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyInputFile'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputFileData%AddF0)) THEN
  DEALLOCATE(InputFileData%AddF0)
ENDIF
IF (ALLOCATED(InputFileData%AddCLin)) THEN
  DEALLOCATE(InputFileData%AddCLin)
ENDIF
IF (ALLOCATED(InputFileData%AddBLin)) THEN
  DEALLOCATE(InputFileData%AddBLin)
ENDIF
IF (ALLOCATED(InputFileData%AddBQuad)) THEN
  DEALLOCATE(InputFileData%AddBQuad)
ENDIF
  CALL SeaSt_DestroyInitInput( InputFileData%SeaState, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InputFileData%PotFile)) THEN
  DEALLOCATE(InputFileData%PotFile)
ENDIF
IF (ALLOCATED(InputFileData%PtfmVol0)) THEN
  DEALLOCATE(InputFileData%PtfmVol0)
ENDIF
IF (ALLOCATED(InputFileData%WAMITULEN)) THEN
  DEALLOCATE(InputFileData%WAMITULEN)
ENDIF
IF (ALLOCATED(InputFileData%PtfmRefxt)) THEN
  DEALLOCATE(InputFileData%PtfmRefxt)
ENDIF
IF (ALLOCATED(InputFileData%PtfmRefyt)) THEN
  DEALLOCATE(InputFileData%PtfmRefyt)
ENDIF
IF (ALLOCATED(InputFileData%PtfmRefzt)) THEN
  DEALLOCATE(InputFileData%PtfmRefzt)
ENDIF
IF (ALLOCATED(InputFileData%PtfmRefztRot)) THEN
  DEALLOCATE(InputFileData%PtfmRefztRot)
ENDIF
IF (ALLOCATED(InputFileData%PtfmCOBxt)) THEN
  DEALLOCATE(InputFileData%PtfmCOBxt)
ENDIF
IF (ALLOCATED(InputFileData%PtfmCOByt)) THEN
  DEALLOCATE(InputFileData%PtfmCOByt)
ENDIF
  CALL WAMIT_DestroyInitInput( InputFileData%WAMIT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL WAMIT2_DestroyInitInput( InputFileData%WAMIT2, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Morison_DestroyInitInput( InputFileData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InputFileData%UserOutputs)) THEN
  DEALLOCATE(InputFileData%UserOutputs)
ENDIF
IF (ALLOCATED(InputFileData%OutList)) THEN
  DEALLOCATE(InputFileData%OutList)
ENDIF
 END SUBROUTINE HydroDyn_DestroyInputFile


subroutine HydroDyn_PackInputFile(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_InputFile), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackInputFile'
   if (Buf%ErrStat >= AbortErrLev) return
   ! EchoFlag
   call RegPack(Buf, InData%EchoFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddF0
   call RegPack(Buf, allocated(InData%AddF0))
   if (allocated(InData%AddF0)) then
      call RegPackBounds(Buf, 2, lbound(InData%AddF0), ubound(InData%AddF0))
      call RegPack(Buf, InData%AddF0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddCLin
   call RegPack(Buf, allocated(InData%AddCLin))
   if (allocated(InData%AddCLin)) then
      call RegPackBounds(Buf, 3, lbound(InData%AddCLin), ubound(InData%AddCLin))
      call RegPack(Buf, InData%AddCLin)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddBLin
   call RegPack(Buf, allocated(InData%AddBLin))
   if (allocated(InData%AddBLin)) then
      call RegPackBounds(Buf, 3, lbound(InData%AddBLin), ubound(InData%AddBLin))
      call RegPack(Buf, InData%AddBLin)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddBQuad
   call RegPack(Buf, allocated(InData%AddBQuad))
   if (allocated(InData%AddBQuad)) then
      call RegPackBounds(Buf, 3, lbound(InData%AddBQuad), ubound(InData%AddBQuad))
      call RegPack(Buf, InData%AddBQuad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SeaState
   call SeaSt_PackInitInput(Buf, InData%SeaState) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PotFile
   call RegPack(Buf, allocated(InData%PotFile))
   if (allocated(InData%PotFile)) then
      call RegPackBounds(Buf, 1, lbound(InData%PotFile), ubound(InData%PotFile))
      call RegPack(Buf, InData%PotFile)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nWAMITObj
   call RegPack(Buf, InData%nWAMITObj)
   if (RegCheckErr(Buf, RoutineName)) return
   ! vecMultiplier
   call RegPack(Buf, InData%vecMultiplier)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegPack(Buf, InData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmVol0
   call RegPack(Buf, allocated(InData%PtfmVol0))
   if (allocated(InData%PtfmVol0)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmVol0), ubound(InData%PtfmVol0))
      call RegPack(Buf, InData%PtfmVol0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HasWAMIT
   call RegPack(Buf, InData%HasWAMIT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITULEN
   call RegPack(Buf, allocated(InData%WAMITULEN))
   if (allocated(InData%WAMITULEN)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMITULEN), ubound(InData%WAMITULEN))
      call RegPack(Buf, InData%WAMITULEN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefxt
   call RegPack(Buf, allocated(InData%PtfmRefxt))
   if (allocated(InData%PtfmRefxt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefxt), ubound(InData%PtfmRefxt))
      call RegPack(Buf, InData%PtfmRefxt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefyt
   call RegPack(Buf, allocated(InData%PtfmRefyt))
   if (allocated(InData%PtfmRefyt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefyt), ubound(InData%PtfmRefyt))
      call RegPack(Buf, InData%PtfmRefyt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefzt
   call RegPack(Buf, allocated(InData%PtfmRefzt))
   if (allocated(InData%PtfmRefzt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefzt), ubound(InData%PtfmRefzt))
      call RegPack(Buf, InData%PtfmRefzt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefztRot
   call RegPack(Buf, allocated(InData%PtfmRefztRot))
   if (allocated(InData%PtfmRefztRot)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefztRot), ubound(InData%PtfmRefztRot))
      call RegPack(Buf, InData%PtfmRefztRot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmCOBxt
   call RegPack(Buf, allocated(InData%PtfmCOBxt))
   if (allocated(InData%PtfmCOBxt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmCOBxt), ubound(InData%PtfmCOBxt))
      call RegPack(Buf, InData%PtfmCOBxt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmCOByt
   call RegPack(Buf, allocated(InData%PtfmCOByt))
   if (allocated(InData%PtfmCOByt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmCOByt), ubound(InData%PtfmCOByt))
      call RegPack(Buf, InData%PtfmCOByt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT
   call WAMIT_PackInitInput(Buf, InData%WAMIT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT2
   call WAMIT2_PackInitInput(Buf, InData%WAMIT2) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackInitInput(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Echo
   call RegPack(Buf, InData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PotMod
   call RegPack(Buf, InData%PotMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NUserOutputs
   call RegPack(Buf, InData%NUserOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UserOutputs
   call RegPack(Buf, allocated(InData%UserOutputs))
   if (allocated(InData%UserOutputs)) then
      call RegPackBounds(Buf, 1, lbound(InData%UserOutputs), ubound(InData%UserOutputs))
      call RegPack(Buf, InData%UserOutputs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegPack(Buf, InData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAll
   call RegPack(Buf, InData%OutAll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   call RegPack(Buf, allocated(InData%OutList))
   if (allocated(InData%OutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutList), ubound(InData%OutList))
      call RegPack(Buf, InData%OutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HDSum
   call RegPack(Buf, InData%HDSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnSum
   call RegPack(Buf, InData%UnSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegPack(Buf, InData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackInputFile(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_InputFile), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackInputFile'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! EchoFlag
   call RegUnpack(Buf, OutData%EchoFlag)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddF0
   if (allocated(OutData%AddF0)) deallocate(OutData%AddF0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddF0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddF0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddF0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AddCLin
   if (allocated(OutData%AddCLin)) deallocate(OutData%AddCLin)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddCLin(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddCLin.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddCLin)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AddBLin
   if (allocated(OutData%AddBLin)) deallocate(OutData%AddBLin)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddBLin(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddBLin.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddBLin)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AddBQuad
   if (allocated(OutData%AddBQuad)) deallocate(OutData%AddBQuad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddBQuad(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddBQuad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddBQuad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SeaState
   call SeaSt_UnpackInitInput(Buf, OutData%SeaState) ! SeaState 
   ! PotFile
   if (allocated(OutData%PotFile)) deallocate(OutData%PotFile)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PotFile(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PotFile.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PotFile)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nWAMITObj
   call RegUnpack(Buf, OutData%nWAMITObj)
   if (RegCheckErr(Buf, RoutineName)) return
   ! vecMultiplier
   call RegUnpack(Buf, OutData%vecMultiplier)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegUnpack(Buf, OutData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmVol0
   if (allocated(OutData%PtfmVol0)) deallocate(OutData%PtfmVol0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmVol0(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmVol0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmVol0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HasWAMIT
   call RegUnpack(Buf, OutData%HasWAMIT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITULEN
   if (allocated(OutData%WAMITULEN)) deallocate(OutData%WAMITULEN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMITULEN(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMITULEN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WAMITULEN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefxt
   if (allocated(OutData%PtfmRefxt)) deallocate(OutData%PtfmRefxt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefxt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefxt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefxt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefyt
   if (allocated(OutData%PtfmRefyt)) deallocate(OutData%PtfmRefyt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefyt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefyt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefyt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefzt
   if (allocated(OutData%PtfmRefzt)) deallocate(OutData%PtfmRefzt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefzt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefzt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefzt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefztRot
   if (allocated(OutData%PtfmRefztRot)) deallocate(OutData%PtfmRefztRot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefztRot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefztRot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefztRot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmCOBxt
   if (allocated(OutData%PtfmCOBxt)) deallocate(OutData%PtfmCOBxt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmCOBxt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmCOBxt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmCOBxt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmCOByt
   if (allocated(OutData%PtfmCOByt)) deallocate(OutData%PtfmCOByt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmCOByt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmCOByt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmCOByt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WAMIT
   call WAMIT_UnpackInitInput(Buf, OutData%WAMIT) ! WAMIT 
   ! WAMIT2
   call WAMIT2_UnpackInitInput(Buf, OutData%WAMIT2) ! WAMIT2 
   ! Morison
   call Morison_UnpackInitInput(Buf, OutData%Morison) ! Morison 
   ! Echo
   call RegUnpack(Buf, OutData%Echo)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PotMod
   call RegUnpack(Buf, OutData%PotMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NUserOutputs
   call RegUnpack(Buf, OutData%NUserOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UserOutputs
   if (allocated(OutData%UserOutputs)) deallocate(OutData%UserOutputs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UserOutputs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UserOutputs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UserOutputs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OutSwtch
   call RegUnpack(Buf, OutData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAll
   call RegUnpack(Buf, OutData%OutAll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutList
   if (allocated(OutData%OutList)) deallocate(OutData%OutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HDSum
   call RegUnpack(Buf, OutData%HDSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnSum
   call RegUnpack(Buf, OutData%UnSum)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegUnpack(Buf, OutData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE HydroDyn_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(HydroDyn_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%InputFile = SrcInitInputData%InputFile
    DstInitInputData%UseInputFile = SrcInitInputData%UseInputFile
      CALL NWTC_Library_Copyfileinfotype( SrcInitInputData%PassedFileData, DstInitInputData%PassedFileData, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%OutRootName = SrcInitInputData%OutRootName
    DstInitInputData%Linearize = SrcInitInputData%Linearize
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%MSL2SWL = SrcInitInputData%MSL2SWL
    DstInitInputData%TMax = SrcInitInputData%TMax
    DstInitInputData%PtfmLocationX = SrcInitInputData%PtfmLocationX
    DstInitInputData%PtfmLocationY = SrcInitInputData%PtfmLocationY
    DstInitInputData%NStepWave = SrcInitInputData%NStepWave
    DstInitInputData%NStepWave2 = SrcInitInputData%NStepWave2
    DstInitInputData%RhoXg = SrcInitInputData%RhoXg
    DstInitInputData%WaveMod = SrcInitInputData%WaveMod
    DstInitInputData%WaveStMod = SrcInitInputData%WaveStMod
    DstInitInputData%WaveDirMod = SrcInitInputData%WaveDirMod
    DstInitInputData%WvLowCOff = SrcInitInputData%WvLowCOff
    DstInitInputData%WvHiCOff = SrcInitInputData%WvHiCOff
    DstInitInputData%WvLowCOffD = SrcInitInputData%WvLowCOffD
    DstInitInputData%WvHiCOffD = SrcInitInputData%WvHiCOffD
    DstInitInputData%WvLowCOffS = SrcInitInputData%WvLowCOffS
    DstInitInputData%WvHiCOffS = SrcInitInputData%WvHiCOffS
    DstInitInputData%InvalidWithSSExctn = SrcInitInputData%InvalidWithSSExctn
IF (ALLOCATED(SrcInitInputData%WaveElev0)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveElev0,1)
  i1_u = UBOUND(SrcInitInputData%WaveElev0,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveElev0)) THEN 
    ALLOCATE(DstInitInputData%WaveElev0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveElev0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveElev0 = SrcInitInputData%WaveElev0
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveElevC)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveElevC,1)
  i1_u = UBOUND(SrcInitInputData%WaveElevC,1)
  i2_l = LBOUND(SrcInitInputData%WaveElevC,2)
  i2_u = UBOUND(SrcInitInputData%WaveElevC,2)
  i3_l = LBOUND(SrcInitInputData%WaveElevC,3)
  i3_u = UBOUND(SrcInitInputData%WaveElevC,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveElevC)) THEN 
    ALLOCATE(DstInitInputData%WaveElevC(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveElevC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveElevC = SrcInitInputData%WaveElevC
ENDIF
    DstInitInputData%WaveDirMin = SrcInitInputData%WaveDirMin
    DstInitInputData%WaveDirMax = SrcInitInputData%WaveDirMax
    DstInitInputData%WaveDir = SrcInitInputData%WaveDir
    DstInitInputData%WaveMultiDir = SrcInitInputData%WaveMultiDir
    DstInitInputData%WaveDOmega = SrcInitInputData%WaveDOmega
    DstInitInputData%MCFD = SrcInitInputData%MCFD
    DstInitInputData%WaveField => SrcInitInputData%WaveField
 END SUBROUTINE HydroDyn_CopyInitInput

 SUBROUTINE HydroDyn_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(HydroDyn_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyFileInfoType( InitInputData%PassedFileData, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitInputData%WaveElev0)) THEN
  DEALLOCATE(InitInputData%WaveElev0)
ENDIF
IF (ALLOCATED(InitInputData%WaveElevC)) THEN
  DEALLOCATE(InitInputData%WaveElevC)
ENDIF
NULLIFY(InitInputData%WaveField)
 END SUBROUTINE HydroDyn_DestroyInitInput


subroutine HydroDyn_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackInitInput'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! InputFile
   call RegPack(Buf, InData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegPack(Buf, InData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedFileData
   call NWTC_Library_PackFileInfoType(Buf, InData%PassedFileData) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutRootName
   call RegPack(Buf, InData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegPack(Buf, InData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMax
   call RegPack(Buf, InData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationX
   call RegPack(Buf, InData%PtfmLocationX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationY
   call RegPack(Buf, InData%PtfmLocationY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegPack(Buf, InData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegPack(Buf, InData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegPack(Buf, InData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegPack(Buf, InData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMod
   call RegPack(Buf, InData%WaveDirMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegPack(Buf, InData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegPack(Buf, InData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffD
   call RegPack(Buf, InData%WvLowCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffD
   call RegPack(Buf, InData%WvHiCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffS
   call RegPack(Buf, InData%WvLowCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffS
   call RegPack(Buf, InData%WvHiCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvalidWithSSExctn
   call RegPack(Buf, InData%InvalidWithSSExctn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   call RegPack(Buf, allocated(InData%WaveElev0))
   if (allocated(InData%WaveElev0)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveElev0), ubound(InData%WaveElev0))
      call RegPack(Buf, InData%WaveElev0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC
   call RegPack(Buf, allocated(InData%WaveElevC))
   if (allocated(InData%WaveElevC)) then
      call RegPackBounds(Buf, 3, lbound(InData%WaveElevC), ubound(InData%WaveElevC))
      call RegPack(Buf, InData%WaveElevC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMin
   call RegPack(Buf, InData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegPack(Buf, InData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegPack(Buf, InData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegPack(Buf, InData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegPack(Buf, InData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MCFD
   call RegPack(Buf, InData%MCFD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveField
   call RegPack(Buf, associated(InData%WaveField))
   if (associated(InData%WaveField)) then
      call RegPackPointer(Buf, c_loc(InData%WaveField), PtrInIndex)
      if (.not. PtrInIndex) then
         call SeaSt_WaveField_PackSeaSt_WaveFieldType(Buf, InData%WaveField) 
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! InputFile
   call RegUnpack(Buf, OutData%InputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UseInputFile
   call RegUnpack(Buf, OutData%UseInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PassedFileData
   call NWTC_Library_UnpackFileInfoType(Buf, OutData%PassedFileData) ! PassedFileData 
   ! OutRootName
   call RegUnpack(Buf, OutData%OutRootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MSL2SWL
   call RegUnpack(Buf, OutData%MSL2SWL)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TMax
   call RegUnpack(Buf, OutData%TMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationX
   call RegUnpack(Buf, OutData%PtfmLocationX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmLocationY
   call RegUnpack(Buf, OutData%PtfmLocationY)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegUnpack(Buf, OutData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegUnpack(Buf, OutData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegUnpack(Buf, OutData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveStMod
   call RegUnpack(Buf, OutData%WaveStMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMod
   call RegUnpack(Buf, OutData%WaveDirMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegUnpack(Buf, OutData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegUnpack(Buf, OutData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffD
   call RegUnpack(Buf, OutData%WvLowCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffD
   call RegUnpack(Buf, OutData%WvHiCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffS
   call RegUnpack(Buf, OutData%WvLowCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffS
   call RegUnpack(Buf, OutData%WvHiCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! InvalidWithSSExctn
   call RegUnpack(Buf, OutData%InvalidWithSSExctn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElev0
   if (allocated(OutData%WaveElev0)) deallocate(OutData%WaveElev0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElev0(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElev0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveElevC
   if (allocated(OutData%WaveElevC)) deallocate(OutData%WaveElevC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveElevC(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveElevC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WaveDirMin
   call RegUnpack(Buf, OutData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegUnpack(Buf, OutData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegUnpack(Buf, OutData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegUnpack(Buf, OutData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegUnpack(Buf, OutData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MCFD
   call RegUnpack(Buf, OutData%MCFD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveField
   if (associated(OutData%WaveField)) deallocate(OutData%WaveField)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveField)
      else
         allocate(OutData%WaveField,stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveField.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveField)
         call SeaSt_WaveField_UnpackSeaSt_WaveFieldType(Buf, OutData%WaveField) ! WaveField 
      end if
   else
      OutData%WaveField => null()
   end if
end subroutine
 SUBROUTINE HydroDyn_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(HydroDyn_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL Morison_CopyInitOutput( SrcInitOutputData%Morison, DstInitOutputData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%LinNames_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_y,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_y)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_y = SrcInitOutputData%LinNames_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_x,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_x)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_x = SrcInitOutputData%LinNames_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_u,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_u)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_u = SrcInitOutputData%LinNames_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%DerivOrder_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%DerivOrder_x,1)
  i1_u = UBOUND(SrcInitOutputData%DerivOrder_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%DerivOrder_x)) THEN 
    ALLOCATE(DstInitOutputData%DerivOrder_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%DerivOrder_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%DerivOrder_x = SrcInitOutputData%DerivOrder_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%IsLoad_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%IsLoad_u,1)
  i1_u = UBOUND(SrcInitOutputData%IsLoad_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%IsLoad_u)) THEN 
    ALLOCATE(DstInitOutputData%IsLoad_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%IsLoad_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%IsLoad_u = SrcInitOutputData%IsLoad_u
ENDIF
 END SUBROUTINE HydroDyn_CopyInitOutput

 SUBROUTINE HydroDyn_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(HydroDyn_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL Morison_DestroyInitOutput( InitOutputData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%LinNames_y)) THEN
  DEALLOCATE(InitOutputData%LinNames_y)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_x)) THEN
  DEALLOCATE(InitOutputData%LinNames_x)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_u)) THEN
  DEALLOCATE(InitOutputData%LinNames_u)
ENDIF
IF (ALLOCATED(InitOutputData%DerivOrder_x)) THEN
  DEALLOCATE(InitOutputData%DerivOrder_x)
ENDIF
IF (ALLOCATED(InitOutputData%IsLoad_u)) THEN
  DEALLOCATE(InitOutputData%IsLoad_u)
ENDIF
 END SUBROUTINE HydroDyn_DestroyInitOutput


subroutine HydroDyn_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Morison
   call Morison_PackInitOutput(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_y
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_x
   call RegPack(Buf, allocated(InData%LinNames_x))
   if (allocated(InData%LinNames_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_x), ubound(InData%LinNames_x))
      call RegPack(Buf, InData%LinNames_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_u
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DerivOrder_x
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsLoad_u
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Morison
   call Morison_UnpackInitOutput(Buf, OutData%Morison) ! Morison 
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! LinNames_y
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_x
   if (allocated(OutData%LinNames_x)) deallocate(OutData%LinNames_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_u
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DerivOrder_x
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsLoad_u
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE HydroDyn_CopyHD_ModuleMapType( SrcHD_ModuleMapTypeData, DstHD_ModuleMapTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HD_ModuleMapType), INTENT(INOUT) :: SrcHD_ModuleMapTypeData
   TYPE(HD_ModuleMapType), INTENT(INOUT) :: DstHD_ModuleMapTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyHD_ModuleMapType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copymeshmaptype( SrcHD_ModuleMapTypeData%uW_P_2_PRP_P, DstHD_ModuleMapTypeData%uW_P_2_PRP_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcHD_ModuleMapTypeData%W_P_2_PRP_P, DstHD_ModuleMapTypeData%W_P_2_PRP_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL NWTC_Library_Copymeshmaptype( SrcHD_ModuleMapTypeData%M_P_2_PRP_P, DstHD_ModuleMapTypeData%M_P_2_PRP_P, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE HydroDyn_CopyHD_ModuleMapType

 SUBROUTINE HydroDyn_DestroyHD_ModuleMapType( HD_ModuleMapTypeData, ErrStat, ErrMsg )
  TYPE(HD_ModuleMapType), INTENT(INOUT) :: HD_ModuleMapTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyHD_ModuleMapType'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL NWTC_Library_DestroyMeshMapType( HD_ModuleMapTypeData%uW_P_2_PRP_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( HD_ModuleMapTypeData%W_P_2_PRP_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL NWTC_Library_DestroyMeshMapType( HD_ModuleMapTypeData%M_P_2_PRP_P, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE HydroDyn_DestroyHD_ModuleMapType


subroutine HydroDyn_PackHD_ModuleMapType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HD_ModuleMapType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackHD_ModuleMapType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! uW_P_2_PRP_P
   call NWTC_Library_PackMeshMapType(Buf, InData%uW_P_2_PRP_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! W_P_2_PRP_P
   call NWTC_Library_PackMeshMapType(Buf, InData%W_P_2_PRP_P) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! M_P_2_PRP_P
   call NWTC_Library_PackMeshMapType(Buf, InData%M_P_2_PRP_P) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackHD_ModuleMapType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HD_ModuleMapType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackHD_ModuleMapType'
   if (Buf%ErrStat /= ErrID_None) return
   ! uW_P_2_PRP_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%uW_P_2_PRP_P) ! uW_P_2_PRP_P 
   ! W_P_2_PRP_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%W_P_2_PRP_P) ! W_P_2_PRP_P 
   ! M_P_2_PRP_P
   call NWTC_Library_UnpackMeshMapType(Buf, OutData%M_P_2_PRP_P) ! M_P_2_PRP_P 
end subroutine
 SUBROUTINE HydroDyn_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(HydroDyn_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%WAMIT)) THEN
  i1_l = LBOUND(SrcContStateData%WAMIT,1)
  i1_u = UBOUND(SrcContStateData%WAMIT,1)
  IF (.NOT. ALLOCATED(DstContStateData%WAMIT)) THEN 
    ALLOCATE(DstContStateData%WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcContStateData%WAMIT,1), UBOUND(SrcContStateData%WAMIT,1)
      CALL WAMIT_CopyContState( SrcContStateData%WAMIT(i1), DstContStateData%WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL Morison_CopyContState( SrcContStateData%Morison, DstContStateData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE HydroDyn_CopyContState

 SUBROUTINE HydroDyn_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(HydroDyn_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%WAMIT)) THEN
DO i1 = LBOUND(ContStateData%WAMIT,1), UBOUND(ContStateData%WAMIT,1)
  CALL WAMIT_DestroyContState( ContStateData%WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ContStateData%WAMIT)
ENDIF
  CALL Morison_DestroyContState( ContStateData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE HydroDyn_DestroyContState


subroutine HydroDyn_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! WAMIT
   call RegPack(Buf, allocated(InData%WAMIT))
   if (allocated(InData%WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT), ubound(InData%WAMIT))
      LB(1:1) = lbound(InData%WAMIT)
      UB(1:1) = ubound(InData%WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackContState(Buf, InData%WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackContState(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackContState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WAMIT
   if (allocated(OutData%WAMIT)) deallocate(OutData%WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackContState(Buf, OutData%WAMIT(i1)) ! WAMIT 
      end do
   end if
   ! Morison
   call Morison_UnpackContState(Buf, OutData%Morison) ! Morison 
end subroutine
 SUBROUTINE HydroDyn_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(HydroDyn_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%WAMIT)) THEN
  i1_l = LBOUND(SrcDiscStateData%WAMIT,1)
  i1_u = UBOUND(SrcDiscStateData%WAMIT,1)
  IF (.NOT. ALLOCATED(DstDiscStateData%WAMIT)) THEN 
    ALLOCATE(DstDiscStateData%WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcDiscStateData%WAMIT,1), UBOUND(SrcDiscStateData%WAMIT,1)
      CALL WAMIT_CopyDiscState( SrcDiscStateData%WAMIT(i1), DstDiscStateData%WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL Morison_CopyDiscState( SrcDiscStateData%Morison, DstDiscStateData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE HydroDyn_CopyDiscState

 SUBROUTINE HydroDyn_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(HydroDyn_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%WAMIT)) THEN
DO i1 = LBOUND(DiscStateData%WAMIT,1), UBOUND(DiscStateData%WAMIT,1)
  CALL WAMIT_DestroyDiscState( DiscStateData%WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(DiscStateData%WAMIT)
ENDIF
  CALL Morison_DestroyDiscState( DiscStateData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE HydroDyn_DestroyDiscState


subroutine HydroDyn_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! WAMIT
   call RegPack(Buf, allocated(InData%WAMIT))
   if (allocated(InData%WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT), ubound(InData%WAMIT))
      LB(1:1) = lbound(InData%WAMIT)
      UB(1:1) = ubound(InData%WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackDiscState(Buf, InData%WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackDiscState(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackDiscState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WAMIT
   if (allocated(OutData%WAMIT)) deallocate(OutData%WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackDiscState(Buf, OutData%WAMIT(i1)) ! WAMIT 
      end do
   end if
   ! Morison
   call Morison_UnpackDiscState(Buf, OutData%Morison) ! Morison 
end subroutine
 SUBROUTINE HydroDyn_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(HydroDyn_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL WAMIT_CopyConstrState( SrcConstrStateData%WAMIT, DstConstrStateData%WAMIT, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL Morison_CopyConstrState( SrcConstrStateData%Morison, DstConstrStateData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE HydroDyn_CopyConstrState

 SUBROUTINE HydroDyn_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(HydroDyn_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL WAMIT_DestroyConstrState( ConstrStateData%WAMIT, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL Morison_DestroyConstrState( ConstrStateData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE HydroDyn_DestroyConstrState


subroutine HydroDyn_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WAMIT
   call WAMIT_PackConstrState(Buf, InData%WAMIT) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackConstrState(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! WAMIT
   call WAMIT_UnpackConstrState(Buf, OutData%WAMIT) ! WAMIT 
   ! Morison
   call Morison_UnpackConstrState(Buf, OutData%Morison) ! Morison 
end subroutine
 SUBROUTINE HydroDyn_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(HydroDyn_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%WAMIT)) THEN
  i1_l = LBOUND(SrcOtherStateData%WAMIT,1)
  i1_u = UBOUND(SrcOtherStateData%WAMIT,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%WAMIT)) THEN 
    ALLOCATE(DstOtherStateData%WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%WAMIT,1), UBOUND(SrcOtherStateData%WAMIT,1)
      CALL WAMIT_CopyOtherState( SrcOtherStateData%WAMIT(i1), DstOtherStateData%WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL Morison_CopyOtherState( SrcOtherStateData%Morison, DstOtherStateData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE HydroDyn_CopyOtherState

 SUBROUTINE HydroDyn_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(HydroDyn_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%WAMIT)) THEN
DO i1 = LBOUND(OtherStateData%WAMIT,1), UBOUND(OtherStateData%WAMIT,1)
  CALL WAMIT_DestroyOtherState( OtherStateData%WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%WAMIT)
ENDIF
  CALL Morison_DestroyOtherState( OtherStateData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE HydroDyn_DestroyOtherState


subroutine HydroDyn_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! WAMIT
   call RegPack(Buf, allocated(InData%WAMIT))
   if (allocated(InData%WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT), ubound(InData%WAMIT))
      LB(1:1) = lbound(InData%WAMIT)
      UB(1:1) = ubound(InData%WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackOtherState(Buf, InData%WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackOtherState(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WAMIT
   if (allocated(OutData%WAMIT)) deallocate(OutData%WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackOtherState(Buf, OutData%WAMIT(i1)) ! WAMIT 
      end do
   end if
   ! Morison
   call Morison_UnpackOtherState(Buf, OutData%Morison) ! Morison 
end subroutine
 SUBROUTINE HydroDyn_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_MiscVarType), INTENT(INOUT) :: SrcMiscData
   TYPE(HydroDyn_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcMiscData%AllHdroOrigin, DstMiscData%AllHdroOrigin, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL HydroDyn_Copyhd_modulemaptype( SrcMiscData%HD_MeshMap, DstMiscData%HD_MeshMap, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstMiscData%Decimate = SrcMiscData%Decimate
    DstMiscData%LastOutTime = SrcMiscData%LastOutTime
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
IF (ALLOCATED(SrcMiscData%F_PtfmAdd)) THEN
  i1_l = LBOUND(SrcMiscData%F_PtfmAdd,1)
  i1_u = UBOUND(SrcMiscData%F_PtfmAdd,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_PtfmAdd)) THEN 
    ALLOCATE(DstMiscData%F_PtfmAdd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_PtfmAdd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_PtfmAdd = SrcMiscData%F_PtfmAdd
ENDIF
    DstMiscData%F_Hydro = SrcMiscData%F_Hydro
IF (ALLOCATED(SrcMiscData%F_Waves)) THEN
  i1_l = LBOUND(SrcMiscData%F_Waves,1)
  i1_u = UBOUND(SrcMiscData%F_Waves,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_Waves)) THEN 
    ALLOCATE(DstMiscData%F_Waves(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_Waves.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_Waves = SrcMiscData%F_Waves
ENDIF
IF (ALLOCATED(SrcMiscData%WAMIT)) THEN
  i1_l = LBOUND(SrcMiscData%WAMIT,1)
  i1_u = UBOUND(SrcMiscData%WAMIT,1)
  IF (.NOT. ALLOCATED(DstMiscData%WAMIT)) THEN 
    ALLOCATE(DstMiscData%WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%WAMIT,1), UBOUND(SrcMiscData%WAMIT,1)
      CALL WAMIT_CopyMisc( SrcMiscData%WAMIT(i1), DstMiscData%WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcMiscData%WAMIT2)) THEN
  i1_l = LBOUND(SrcMiscData%WAMIT2,1)
  i1_u = UBOUND(SrcMiscData%WAMIT2,1)
  IF (.NOT. ALLOCATED(DstMiscData%WAMIT2)) THEN 
    ALLOCATE(DstMiscData%WAMIT2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%WAMIT2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%WAMIT2,1), UBOUND(SrcMiscData%WAMIT2,1)
      CALL WAMIT2_CopyMisc( SrcMiscData%WAMIT2(i1), DstMiscData%WAMIT2(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL Morison_CopyMisc( SrcMiscData%Morison, DstMiscData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcMiscData%u_WAMIT)) THEN
  i1_l = LBOUND(SrcMiscData%u_WAMIT,1)
  i1_u = UBOUND(SrcMiscData%u_WAMIT,1)
  IF (.NOT. ALLOCATED(DstMiscData%u_WAMIT)) THEN 
    ALLOCATE(DstMiscData%u_WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%u_WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcMiscData%u_WAMIT,1), UBOUND(SrcMiscData%u_WAMIT,1)
      CALL WAMIT_CopyInput( SrcMiscData%u_WAMIT(i1), DstMiscData%u_WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
 END SUBROUTINE HydroDyn_CopyMisc

 SUBROUTINE HydroDyn_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(HydroDyn_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( MiscData%AllHdroOrigin, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL HydroDyn_DestroyHD_ModuleMapType( MiscData%HD_MeshMap, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%F_PtfmAdd)) THEN
  DEALLOCATE(MiscData%F_PtfmAdd)
ENDIF
IF (ALLOCATED(MiscData%F_Waves)) THEN
  DEALLOCATE(MiscData%F_Waves)
ENDIF
IF (ALLOCATED(MiscData%WAMIT)) THEN
DO i1 = LBOUND(MiscData%WAMIT,1), UBOUND(MiscData%WAMIT,1)
  CALL WAMIT_DestroyMisc( MiscData%WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%WAMIT)
ENDIF
IF (ALLOCATED(MiscData%WAMIT2)) THEN
DO i1 = LBOUND(MiscData%WAMIT2,1), UBOUND(MiscData%WAMIT2,1)
  CALL WAMIT2_DestroyMisc( MiscData%WAMIT2(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%WAMIT2)
ENDIF
  CALL Morison_DestroyMisc( MiscData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(MiscData%u_WAMIT)) THEN
DO i1 = LBOUND(MiscData%u_WAMIT,1), UBOUND(MiscData%u_WAMIT,1)
  CALL WAMIT_DestroyInput( MiscData%u_WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(MiscData%u_WAMIT)
ENDIF
 END SUBROUTINE HydroDyn_DestroyMisc


subroutine HydroDyn_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackMisc'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! AllHdroOrigin
   call MeshPack(Buf, InData%AllHdroOrigin) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! HD_MeshMap
   call HydroDyn_PackHD_ModuleMapType(Buf, InData%HD_MeshMap) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Decimate
   call RegPack(Buf, InData%Decimate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastOutTime
   call RegPack(Buf, InData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastIndWave
   call RegPack(Buf, InData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_PtfmAdd
   call RegPack(Buf, allocated(InData%F_PtfmAdd))
   if (allocated(InData%F_PtfmAdd)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_PtfmAdd), ubound(InData%F_PtfmAdd))
      call RegPack(Buf, InData%F_PtfmAdd)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Hydro
   call RegPack(Buf, InData%F_Hydro)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Waves
   call RegPack(Buf, allocated(InData%F_Waves))
   if (allocated(InData%F_Waves)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_Waves), ubound(InData%F_Waves))
      call RegPack(Buf, InData%F_Waves)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT
   call RegPack(Buf, allocated(InData%WAMIT))
   if (allocated(InData%WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT), ubound(InData%WAMIT))
      LB(1:1) = lbound(InData%WAMIT)
      UB(1:1) = ubound(InData%WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackMisc(Buf, InData%WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT2
   call RegPack(Buf, allocated(InData%WAMIT2))
   if (allocated(InData%WAMIT2)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT2), ubound(InData%WAMIT2))
      LB(1:1) = lbound(InData%WAMIT2)
      UB(1:1) = ubound(InData%WAMIT2)
      do i1 = LB(1), UB(1)
         call WAMIT2_PackMisc(Buf, InData%WAMIT2(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackMisc(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_WAMIT
   call RegPack(Buf, allocated(InData%u_WAMIT))
   if (allocated(InData%u_WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%u_WAMIT), ubound(InData%u_WAMIT))
      LB(1:1) = lbound(InData%u_WAMIT)
      UB(1:1) = ubound(InData%u_WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackInput(Buf, InData%u_WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackMisc'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! AllHdroOrigin
   call MeshUnpack(Buf, OutData%AllHdroOrigin) ! AllHdroOrigin 
   ! HD_MeshMap
   call HydroDyn_UnpackHD_ModuleMapType(Buf, OutData%HD_MeshMap) ! HD_MeshMap 
   ! Decimate
   call RegUnpack(Buf, OutData%Decimate)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastOutTime
   call RegUnpack(Buf, OutData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastIndWave
   call RegUnpack(Buf, OutData%LastIndWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_PtfmAdd
   if (allocated(OutData%F_PtfmAdd)) deallocate(OutData%F_PtfmAdd)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_PtfmAdd(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_PtfmAdd.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_PtfmAdd)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_Hydro
   call RegUnpack(Buf, OutData%F_Hydro)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Waves
   if (allocated(OutData%F_Waves)) deallocate(OutData%F_Waves)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_Waves(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_Waves.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_Waves)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WAMIT
   if (allocated(OutData%WAMIT)) deallocate(OutData%WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackMisc(Buf, OutData%WAMIT(i1)) ! WAMIT 
      end do
   end if
   ! WAMIT2
   if (allocated(OutData%WAMIT2)) deallocate(OutData%WAMIT2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT2(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT2_UnpackMisc(Buf, OutData%WAMIT2(i1)) ! WAMIT2 
      end do
   end if
   ! Morison
   call Morison_UnpackMisc(Buf, OutData%Morison) ! Morison 
   ! u_WAMIT
   if (allocated(OutData%u_WAMIT)) deallocate(OutData%u_WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%u_WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%u_WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackInput(Buf, OutData%u_WAMIT(i1)) ! u_WAMIT 
      end do
   end if
end subroutine
 SUBROUTINE HydroDyn_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(HydroDyn_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%nWAMITObj = SrcParamData%nWAMITObj
    DstParamData%vecMultiplier = SrcParamData%vecMultiplier
IF (ALLOCATED(SrcParamData%WAMIT)) THEN
  i1_l = LBOUND(SrcParamData%WAMIT,1)
  i1_u = UBOUND(SrcParamData%WAMIT,1)
  IF (.NOT. ALLOCATED(DstParamData%WAMIT)) THEN 
    ALLOCATE(DstParamData%WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%WAMIT,1), UBOUND(SrcParamData%WAMIT,1)
      CALL WAMIT_CopyParam( SrcParamData%WAMIT(i1), DstParamData%WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%WAMIT2)) THEN
  i1_l = LBOUND(SrcParamData%WAMIT2,1)
  i1_u = UBOUND(SrcParamData%WAMIT2,1)
  IF (.NOT. ALLOCATED(DstParamData%WAMIT2)) THEN 
    ALLOCATE(DstParamData%WAMIT2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WAMIT2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%WAMIT2,1), UBOUND(SrcParamData%WAMIT2,1)
      CALL WAMIT2_CopyParam( SrcParamData%WAMIT2(i1), DstParamData%WAMIT2(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%WAMIT2used = SrcParamData%WAMIT2used
      CALL Morison_CopyParam( SrcParamData%Morison, DstParamData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstParamData%PotMod = SrcParamData%PotMod
    DstParamData%NBody = SrcParamData%NBody
    DstParamData%NBodyMod = SrcParamData%NBodyMod
    DstParamData%totalStates = SrcParamData%totalStates
    DstParamData%totalExctnStates = SrcParamData%totalExctnStates
    DstParamData%totalRdtnStates = SrcParamData%totalRdtnStates
    DstParamData%WaveTime => SrcParamData%WaveTime
    DstParamData%NStepWave = SrcParamData%NStepWave
    DstParamData%WtrDpth = SrcParamData%WtrDpth
IF (ALLOCATED(SrcParamData%AddF0)) THEN
  i1_l = LBOUND(SrcParamData%AddF0,1)
  i1_u = UBOUND(SrcParamData%AddF0,1)
  i2_l = LBOUND(SrcParamData%AddF0,2)
  i2_u = UBOUND(SrcParamData%AddF0,2)
  IF (.NOT. ALLOCATED(DstParamData%AddF0)) THEN 
    ALLOCATE(DstParamData%AddF0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AddF0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AddF0 = SrcParamData%AddF0
ENDIF
IF (ALLOCATED(SrcParamData%AddCLin)) THEN
  i1_l = LBOUND(SrcParamData%AddCLin,1)
  i1_u = UBOUND(SrcParamData%AddCLin,1)
  i2_l = LBOUND(SrcParamData%AddCLin,2)
  i2_u = UBOUND(SrcParamData%AddCLin,2)
  i3_l = LBOUND(SrcParamData%AddCLin,3)
  i3_u = UBOUND(SrcParamData%AddCLin,3)
  IF (.NOT. ALLOCATED(DstParamData%AddCLin)) THEN 
    ALLOCATE(DstParamData%AddCLin(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AddCLin.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AddCLin = SrcParamData%AddCLin
ENDIF
IF (ALLOCATED(SrcParamData%AddBLin)) THEN
  i1_l = LBOUND(SrcParamData%AddBLin,1)
  i1_u = UBOUND(SrcParamData%AddBLin,1)
  i2_l = LBOUND(SrcParamData%AddBLin,2)
  i2_u = UBOUND(SrcParamData%AddBLin,2)
  i3_l = LBOUND(SrcParamData%AddBLin,3)
  i3_u = UBOUND(SrcParamData%AddBLin,3)
  IF (.NOT. ALLOCATED(DstParamData%AddBLin)) THEN 
    ALLOCATE(DstParamData%AddBLin(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AddBLin.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AddBLin = SrcParamData%AddBLin
ENDIF
IF (ALLOCATED(SrcParamData%AddBQuad)) THEN
  i1_l = LBOUND(SrcParamData%AddBQuad,1)
  i1_u = UBOUND(SrcParamData%AddBQuad,1)
  i2_l = LBOUND(SrcParamData%AddBQuad,2)
  i2_u = UBOUND(SrcParamData%AddBQuad,2)
  i3_l = LBOUND(SrcParamData%AddBQuad,3)
  i3_u = UBOUND(SrcParamData%AddBQuad,3)
  IF (.NOT. ALLOCATED(DstParamData%AddBQuad)) THEN 
    ALLOCATE(DstParamData%AddBQuad(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AddBQuad.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AddBQuad = SrcParamData%AddBQuad
ENDIF
    DstParamData%DT = SrcParamData%DT
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%NumTotalOuts = SrcParamData%NumTotalOuts
    DstParamData%OutSwtch = SrcParamData%OutSwtch
    DstParamData%OutFmt = SrcParamData%OutFmt
    DstParamData%OutSFmt = SrcParamData%OutSFmt
    DstParamData%Delim = SrcParamData%Delim
    DstParamData%UnOutFile = SrcParamData%UnOutFile
    DstParamData%OutDec = SrcParamData%OutDec
IF (ALLOCATED(SrcParamData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcParamData%Jac_u_indx,1)
  i1_u = UBOUND(SrcParamData%Jac_u_indx,1)
  i2_l = LBOUND(SrcParamData%Jac_u_indx,2)
  i2_u = UBOUND(SrcParamData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_u_indx)) THEN 
    ALLOCATE(DstParamData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_u_indx = SrcParamData%Jac_u_indx
ENDIF
IF (ALLOCATED(SrcParamData%du)) THEN
  i1_l = LBOUND(SrcParamData%du,1)
  i1_u = UBOUND(SrcParamData%du,1)
  IF (.NOT. ALLOCATED(DstParamData%du)) THEN 
    ALLOCATE(DstParamData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%du.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%du = SrcParamData%du
ENDIF
IF (ALLOCATED(SrcParamData%dx)) THEN
  i1_l = LBOUND(SrcParamData%dx,1)
  i1_u = UBOUND(SrcParamData%dx,1)
  IF (.NOT. ALLOCATED(DstParamData%dx)) THEN 
    ALLOCATE(DstParamData%dx(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%dx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%dx = SrcParamData%dx
ENDIF
    DstParamData%Jac_ny = SrcParamData%Jac_ny
    DstParamData%PointsToSeaState = SrcParamData%PointsToSeaState
 END SUBROUTINE HydroDyn_CopyParam

 SUBROUTINE HydroDyn_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(HydroDyn_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%WAMIT)) THEN
DO i1 = LBOUND(ParamData%WAMIT,1), UBOUND(ParamData%WAMIT,1)
  CALL WAMIT_DestroyParam( ParamData%WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%WAMIT)
ENDIF
IF (ALLOCATED(ParamData%WAMIT2)) THEN
DO i1 = LBOUND(ParamData%WAMIT2,1), UBOUND(ParamData%WAMIT2,1)
  CALL WAMIT2_DestroyParam( ParamData%WAMIT2(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%WAMIT2)
ENDIF
  CALL Morison_DestroyParam( ParamData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
NULLIFY(ParamData%WaveTime)
IF (ALLOCATED(ParamData%AddF0)) THEN
  DEALLOCATE(ParamData%AddF0)
ENDIF
IF (ALLOCATED(ParamData%AddCLin)) THEN
  DEALLOCATE(ParamData%AddCLin)
ENDIF
IF (ALLOCATED(ParamData%AddBLin)) THEN
  DEALLOCATE(ParamData%AddBLin)
ENDIF
IF (ALLOCATED(ParamData%AddBQuad)) THEN
  DEALLOCATE(ParamData%AddBQuad)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( ParamData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
IF (ALLOCATED(ParamData%Jac_u_indx)) THEN
  DEALLOCATE(ParamData%Jac_u_indx)
ENDIF
IF (ALLOCATED(ParamData%du)) THEN
  DEALLOCATE(ParamData%du)
ENDIF
IF (ALLOCATED(ParamData%dx)) THEN
  DEALLOCATE(ParamData%dx)
ENDIF
 END SUBROUTINE HydroDyn_DestroyParam


subroutine HydroDyn_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackParam'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! nWAMITObj
   call RegPack(Buf, InData%nWAMITObj)
   if (RegCheckErr(Buf, RoutineName)) return
   ! vecMultiplier
   call RegPack(Buf, InData%vecMultiplier)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT
   call RegPack(Buf, allocated(InData%WAMIT))
   if (allocated(InData%WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT), ubound(InData%WAMIT))
      LB(1:1) = lbound(InData%WAMIT)
      UB(1:1) = ubound(InData%WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackParam(Buf, InData%WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT2
   call RegPack(Buf, allocated(InData%WAMIT2))
   if (allocated(InData%WAMIT2)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT2), ubound(InData%WAMIT2))
      LB(1:1) = lbound(InData%WAMIT2)
      UB(1:1) = ubound(InData%WAMIT2)
      do i1 = LB(1), UB(1)
         call WAMIT2_PackParam(Buf, InData%WAMIT2(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT2used
   call RegPack(Buf, InData%WAMIT2used)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackParam(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PotMod
   call RegPack(Buf, InData%PotMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegPack(Buf, InData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalStates
   call RegPack(Buf, InData%totalStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalExctnStates
   call RegPack(Buf, InData%totalExctnStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalRdtnStates
   call RegPack(Buf, InData%totalRdtnStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   call RegPack(Buf, associated(InData%WaveTime))
   if (associated(InData%WaveTime)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveTime), ubound(InData%WaveTime))
      call RegPackPointer(Buf, c_loc(InData%WaveTime), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveTime)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddF0
   call RegPack(Buf, allocated(InData%AddF0))
   if (allocated(InData%AddF0)) then
      call RegPackBounds(Buf, 2, lbound(InData%AddF0), ubound(InData%AddF0))
      call RegPack(Buf, InData%AddF0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddCLin
   call RegPack(Buf, allocated(InData%AddCLin))
   if (allocated(InData%AddCLin)) then
      call RegPackBounds(Buf, 3, lbound(InData%AddCLin), ubound(InData%AddCLin))
      call RegPack(Buf, InData%AddCLin)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddBLin
   call RegPack(Buf, allocated(InData%AddBLin))
   if (allocated(InData%AddBLin)) then
      call RegPackBounds(Buf, 3, lbound(InData%AddBLin), ubound(InData%AddBLin))
      call RegPack(Buf, InData%AddBLin)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddBQuad
   call RegPack(Buf, allocated(InData%AddBQuad))
   if (allocated(InData%AddBQuad)) then
      call RegPackBounds(Buf, 3, lbound(InData%AddBQuad), ubound(InData%AddBQuad))
      call RegPack(Buf, InData%AddBQuad)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTotalOuts
   call RegPack(Buf, InData%NumTotalOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegPack(Buf, InData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegPack(Buf, InData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnOutFile
   call RegPack(Buf, InData%UnOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDec
   call RegPack(Buf, InData%OutDec)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! du
   call RegPack(Buf, allocated(InData%du))
   if (allocated(InData%du)) then
      call RegPackBounds(Buf, 1, lbound(InData%du), ubound(InData%du))
      call RegPack(Buf, InData%du)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegPack(Buf, allocated(InData%dx))
   if (allocated(InData%dx)) then
      call RegPackBounds(Buf, 1, lbound(InData%dx), ubound(InData%dx))
      call RegPack(Buf, InData%dx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegPack(Buf, InData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PointsToSeaState
   call RegPack(Buf, InData%PointsToSeaState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackParam'
   integer(IntKi)  :: i1, i2, i3
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! nWAMITObj
   call RegUnpack(Buf, OutData%nWAMITObj)
   if (RegCheckErr(Buf, RoutineName)) return
   ! vecMultiplier
   call RegUnpack(Buf, OutData%vecMultiplier)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT
   if (allocated(OutData%WAMIT)) deallocate(OutData%WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackParam(Buf, OutData%WAMIT(i1)) ! WAMIT 
      end do
   end if
   ! WAMIT2
   if (allocated(OutData%WAMIT2)) deallocate(OutData%WAMIT2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT2(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT2_UnpackParam(Buf, OutData%WAMIT2(i1)) ! WAMIT2 
      end do
   end if
   ! WAMIT2used
   call RegUnpack(Buf, OutData%WAMIT2used)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_UnpackParam(Buf, OutData%Morison) ! Morison 
   ! PotMod
   call RegUnpack(Buf, OutData%PotMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegUnpack(Buf, OutData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalStates
   call RegUnpack(Buf, OutData%totalStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalExctnStates
   call RegUnpack(Buf, OutData%totalExctnStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! totalRdtnStates
   call RegUnpack(Buf, OutData%totalRdtnStates)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveTime
   if (associated(OutData%WaveTime)) deallocate(OutData%WaveTime)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveTime, UB(1:1)-LB(1:1))
         OutData%WaveTime(LB(1):) => OutData%WaveTime
      else
         allocate(OutData%WaveTime(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveTime)
         call RegUnpack(Buf, OutData%WaveTime)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveTime => null()
   end if
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! AddF0
   if (allocated(OutData%AddF0)) deallocate(OutData%AddF0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddF0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddF0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddF0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AddCLin
   if (allocated(OutData%AddCLin)) deallocate(OutData%AddCLin)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddCLin(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddCLin.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddCLin)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AddBLin
   if (allocated(OutData%AddBLin)) deallocate(OutData%AddBLin)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddBLin(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddBLin.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddBLin)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AddBQuad
   if (allocated(OutData%AddBQuad)) deallocate(OutData%AddBQuad)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AddBQuad(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AddBQuad.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AddBQuad)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumTotalOuts
   call RegUnpack(Buf, OutData%NumTotalOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegUnpack(Buf, OutData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegUnpack(Buf, OutData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnOutFile
   call RegUnpack(Buf, OutData%UnOutFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDec
   call RegUnpack(Buf, OutData%OutDec)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! du
   if (allocated(OutData%du)) deallocate(OutData%du)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%du(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%du)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dx
   if (allocated(OutData%dx)) deallocate(OutData%dx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%dx(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%dx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%dx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Jac_ny
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PointsToSeaState
   call RegUnpack(Buf, OutData%PointsToSeaState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE HydroDyn_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(HydroDyn_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL Morison_CopyInput( SrcInputData%Morison, DstInputData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInputData%WAMITMesh, DstInputData%WAMITMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInputData%PRPMesh, DstInputData%PRPMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE HydroDyn_CopyInput

 SUBROUTINE HydroDyn_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(HydroDyn_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL Morison_DestroyInput( InputData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( InputData%WAMITMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( InputData%PRPMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE HydroDyn_DestroyInput


subroutine HydroDyn_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Morison
   call Morison_PackInput(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITMesh
   call MeshPack(Buf, InData%WAMITMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! PRPMesh
   call MeshPack(Buf, InData%PRPMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackInput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Morison
   call Morison_UnpackInput(Buf, OutData%Morison) ! Morison 
   ! WAMITMesh
   call MeshUnpack(Buf, OutData%WAMITMesh) ! WAMITMesh 
   ! PRPMesh
   call MeshUnpack(Buf, OutData%PRPMesh) ! PRPMesh 
end subroutine
 SUBROUTINE HydroDyn_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(HydroDyn_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(HydroDyn_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'HydroDyn_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%WAMIT)) THEN
  i1_l = LBOUND(SrcOutputData%WAMIT,1)
  i1_u = UBOUND(SrcOutputData%WAMIT,1)
  IF (.NOT. ALLOCATED(DstOutputData%WAMIT)) THEN 
    ALLOCATE(DstOutputData%WAMIT(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WAMIT.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%WAMIT,1), UBOUND(SrcOutputData%WAMIT,1)
      CALL WAMIT_CopyOutput( SrcOutputData%WAMIT(i1), DstOutputData%WAMIT(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcOutputData%WAMIT2)) THEN
  i1_l = LBOUND(SrcOutputData%WAMIT2,1)
  i1_u = UBOUND(SrcOutputData%WAMIT2,1)
  IF (.NOT. ALLOCATED(DstOutputData%WAMIT2)) THEN 
    ALLOCATE(DstOutputData%WAMIT2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WAMIT2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOutputData%WAMIT2,1), UBOUND(SrcOutputData%WAMIT2,1)
      CALL WAMIT2_CopyOutput( SrcOutputData%WAMIT2(i1), DstOutputData%WAMIT2(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
      CALL Morison_CopyOutput( SrcOutputData%Morison, DstOutputData%Morison, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcOutputData%WAMITMesh, DstOutputData%WAMITMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE HydroDyn_CopyOutput

 SUBROUTINE HydroDyn_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(HydroDyn_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'HydroDyn_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%WAMIT)) THEN
DO i1 = LBOUND(OutputData%WAMIT,1), UBOUND(OutputData%WAMIT,1)
  CALL WAMIT_DestroyOutput( OutputData%WAMIT(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%WAMIT)
ENDIF
IF (ALLOCATED(OutputData%WAMIT2)) THEN
DO i1 = LBOUND(OutputData%WAMIT2,1), UBOUND(OutputData%WAMIT2,1)
  CALL WAMIT2_DestroyOutput( OutputData%WAMIT2(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OutputData%WAMIT2)
ENDIF
  CALL Morison_DestroyOutput( OutputData%Morison, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( OutputData%WAMITMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE HydroDyn_DestroyOutput


subroutine HydroDyn_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(HydroDyn_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'HydroDyn_PackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! WAMIT
   call RegPack(Buf, allocated(InData%WAMIT))
   if (allocated(InData%WAMIT)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT), ubound(InData%WAMIT))
      LB(1:1) = lbound(InData%WAMIT)
      UB(1:1) = ubound(InData%WAMIT)
      do i1 = LB(1), UB(1)
         call WAMIT_PackOutput(Buf, InData%WAMIT(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMIT2
   call RegPack(Buf, allocated(InData%WAMIT2))
   if (allocated(InData%WAMIT2)) then
      call RegPackBounds(Buf, 1, lbound(InData%WAMIT2), ubound(InData%WAMIT2))
      LB(1:1) = lbound(InData%WAMIT2)
      UB(1:1) = ubound(InData%WAMIT2)
      do i1 = LB(1), UB(1)
         call WAMIT2_PackOutput(Buf, InData%WAMIT2(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Morison
   call Morison_PackOutput(Buf, InData%Morison) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITMesh
   call MeshPack(Buf, InData%WAMITMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine HydroDyn_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(HydroDyn_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'HydroDyn_UnPackOutput'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WAMIT
   if (allocated(OutData%WAMIT)) deallocate(OutData%WAMIT)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT_UnpackOutput(Buf, OutData%WAMIT(i1)) ! WAMIT 
      end do
   end if
   ! WAMIT2
   if (allocated(OutData%WAMIT2)) deallocate(OutData%WAMIT2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WAMIT2(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WAMIT2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call WAMIT2_UnpackOutput(Buf, OutData%WAMIT2(i1)) ! WAMIT2 
      end do
   end if
   ! Morison
   call Morison_UnpackOutput(Buf, OutData%Morison) ! Morison 
   ! WAMITMesh
   call MeshUnpack(Buf, OutData%WAMITMesh) ! WAMITMesh 
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE HydroDyn_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'HydroDyn_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL HydroDyn_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL HydroDyn_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL HydroDyn_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE HydroDyn_Input_ExtrapInterp


 SUBROUTINE HydroDyn_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'HydroDyn_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL Morison_Input_ExtrapInterp1( u1%Morison, u2%Morison, tin, u_out%Morison, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(u1%WAMITMesh, u2%WAMITMesh, tin, u_out%WAMITMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(u1%PRPMesh, u2%PRPMesh, tin, u_out%PRPMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE HydroDyn_Input_ExtrapInterp1


 SUBROUTINE HydroDyn_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(HydroDyn_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'HydroDyn_Input_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL Morison_Input_ExtrapInterp2( u1%Morison, u2%Morison, u3%Morison, tin, u_out%Morison, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(u1%WAMITMesh, u2%WAMITMesh, u3%WAMITMesh, tin, u_out%WAMITMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(u1%PRPMesh, u2%PRPMesh, u3%PRPMesh, tin, u_out%PRPMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE HydroDyn_Input_ExtrapInterp2


 SUBROUTINE HydroDyn_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'HydroDyn_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL HydroDyn_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL HydroDyn_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL HydroDyn_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE HydroDyn_Output_ExtrapInterp


 SUBROUTINE HydroDyn_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'HydroDyn_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%WAMIT) .AND. ALLOCATED(y1%WAMIT)) THEN
  DO i1 = LBOUND(y_out%WAMIT,1),UBOUND(y_out%WAMIT,1)
      CALL WAMIT_Output_ExtrapInterp1( y1%WAMIT(i1), y2%WAMIT(i1), tin, y_out%WAMIT(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%WAMIT2) .AND. ALLOCATED(y1%WAMIT2)) THEN
  DO i1 = LBOUND(y_out%WAMIT2,1),UBOUND(y_out%WAMIT2,1)
      CALL WAMIT2_Output_ExtrapInterp1( y1%WAMIT2(i1), y2%WAMIT2(i1), tin, y_out%WAMIT2(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL Morison_Output_ExtrapInterp1( y1%Morison, y2%Morison, tin, y_out%Morison, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(y1%WAMITMesh, y2%WAMITMesh, tin, y_out%WAMITMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE HydroDyn_Output_ExtrapInterp1


 SUBROUTINE HydroDyn_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(HydroDyn_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'HydroDyn_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%WAMIT) .AND. ALLOCATED(y1%WAMIT)) THEN
  DO i1 = LBOUND(y_out%WAMIT,1),UBOUND(y_out%WAMIT,1)
      CALL WAMIT_Output_ExtrapInterp2( y1%WAMIT(i1), y2%WAMIT(i1), y3%WAMIT(i1), tin, y_out%WAMIT(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(y_out%WAMIT2) .AND. ALLOCATED(y1%WAMIT2)) THEN
  DO i1 = LBOUND(y_out%WAMIT2,1),UBOUND(y_out%WAMIT2,1)
      CALL WAMIT2_Output_ExtrapInterp2( y1%WAMIT2(i1), y2%WAMIT2(i1), y3%WAMIT2(i1), tin, y_out%WAMIT2(i1), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
      CALL Morison_Output_ExtrapInterp2( y1%Morison, y2%Morison, y3%Morison, tin, y_out%Morison, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(y1%WAMITMesh, y2%WAMITMesh, y3%WAMITMesh, tin, y_out%WAMITMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE HydroDyn_Output_ExtrapInterp2

END MODULE HydroDyn_Types
!ENDOFREGISTRYGENERATEDFILE
