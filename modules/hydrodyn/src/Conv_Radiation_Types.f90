!STARTOFREGISTRYGENERATEDFILE 'Conv_Radiation_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! Conv_Radiation_Types
!.................................................................................................................................
! This file is part of Conv_Radiation.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in Conv_Radiation. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE Conv_Radiation_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  Conv_Rdtn_InitInputType  =======
  TYPE, PUBLIC :: Conv_Rdtn_InitInputType
    REAL(DbKi)  :: RdtnDT      !<  [-]
    CHARACTER(80)  :: RdtnDTChr 
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    REAL(ReKi)  :: HighFreq      !<  [-]
    CHARACTER(1024)  :: WAMITFile      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: HdroAddMs      !<  [-]
    REAL(SiKi) , DIMENSION(:), ALLOCATABLE  :: HdroFreq      !<  [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: HdroDmpng      !<  [-]
    INTEGER(IntKi)  :: NInpFreq      !<  [-]
    REAL(DbKi)  :: RdtnTMax      !<  [-]
  END TYPE Conv_Rdtn_InitInputType
! =======================
! =========  Conv_Rdtn_InitOutputType  =======
  TYPE, PUBLIC :: Conv_Rdtn_InitOutputType
    INTEGER(IntKi)  :: DummyInitOut      !<  [-]
  END TYPE Conv_Rdtn_InitOutputType
! =======================
! =========  Conv_Rdtn_ContinuousStateType  =======
  TYPE, PUBLIC :: Conv_Rdtn_ContinuousStateType
    REAL(SiKi)  :: DummyContState      !< Remove this variable if you have continuous states [-]
  END TYPE Conv_Rdtn_ContinuousStateType
! =======================
! =========  Conv_Rdtn_DiscreteStateType  =======
  TYPE, PUBLIC :: Conv_Rdtn_DiscreteStateType
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: XDHistory      !<  [-]
    REAL(DbKi)  :: LastTime      !<  [-]
  END TYPE Conv_Rdtn_DiscreteStateType
! =======================
! =========  Conv_Rdtn_ConstraintStateType  =======
  TYPE, PUBLIC :: Conv_Rdtn_ConstraintStateType
    REAL(SiKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE Conv_Rdtn_ConstraintStateType
! =======================
! =========  Conv_Rdtn_OtherStateType  =======
  TYPE, PUBLIC :: Conv_Rdtn_OtherStateType
    INTEGER(IntKi)  :: IndRdtn      !<  [-]
  END TYPE Conv_Rdtn_OtherStateType
! =======================
! =========  Conv_Rdtn_MiscVarType  =======
  TYPE, PUBLIC :: Conv_Rdtn_MiscVarType
    INTEGER(IntKi)  :: LastIndRdtn      !<  [-]
  END TYPE Conv_Rdtn_MiscVarType
! =======================
! =========  Conv_Rdtn_ParameterType  =======
  TYPE, PUBLIC :: Conv_Rdtn_ParameterType
    REAL(DbKi)  :: DT      !< Time step for continuous state integration & discrete state update [seconds]
    REAL(DbKi)  :: RdtnDT      !<  [-]
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    REAL(SiKi) , DIMENSION(:,:,:), ALLOCATABLE  :: RdtnKrnl      !<  [-]
    INTEGER(IntKi)  :: NStepRdtn      !<  [-]
    INTEGER(IntKi)  :: NStepRdtn1      !<  [-]
  END TYPE Conv_Rdtn_ParameterType
! =======================
! =========  Conv_Rdtn_InputType  =======
  TYPE, PUBLIC :: Conv_Rdtn_InputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Velocity      !<  [-]
  END TYPE Conv_Rdtn_InputType
! =======================
! =========  Conv_Rdtn_OutputType  =======
  TYPE, PUBLIC :: Conv_Rdtn_OutputType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_Rdtn      !<  [-]
  END TYPE Conv_Rdtn_OutputType
! =======================
CONTAINS
 SUBROUTINE Conv_Rdtn_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(Conv_Rdtn_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%RdtnDT = SrcInitInputData%RdtnDT
    DstInitInputData%RdtnDTChr = SrcInitInputData%RdtnDTChr
    DstInitInputData%NBody = SrcInitInputData%NBody
    DstInitInputData%HighFreq = SrcInitInputData%HighFreq
    DstInitInputData%WAMITFile = SrcInitInputData%WAMITFile
IF (ALLOCATED(SrcInitInputData%HdroAddMs)) THEN
  i1_l = LBOUND(SrcInitInputData%HdroAddMs,1)
  i1_u = UBOUND(SrcInitInputData%HdroAddMs,1)
  i2_l = LBOUND(SrcInitInputData%HdroAddMs,2)
  i2_u = UBOUND(SrcInitInputData%HdroAddMs,2)
  i3_l = LBOUND(SrcInitInputData%HdroAddMs,3)
  i3_u = UBOUND(SrcInitInputData%HdroAddMs,3)
  IF (.NOT. ALLOCATED(DstInitInputData%HdroAddMs)) THEN 
    ALLOCATE(DstInitInputData%HdroAddMs(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%HdroAddMs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%HdroAddMs = SrcInitInputData%HdroAddMs
ENDIF
IF (ALLOCATED(SrcInitInputData%HdroFreq)) THEN
  i1_l = LBOUND(SrcInitInputData%HdroFreq,1)
  i1_u = UBOUND(SrcInitInputData%HdroFreq,1)
  IF (.NOT. ALLOCATED(DstInitInputData%HdroFreq)) THEN 
    ALLOCATE(DstInitInputData%HdroFreq(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%HdroFreq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%HdroFreq = SrcInitInputData%HdroFreq
ENDIF
IF (ALLOCATED(SrcInitInputData%HdroDmpng)) THEN
  i1_l = LBOUND(SrcInitInputData%HdroDmpng,1)
  i1_u = UBOUND(SrcInitInputData%HdroDmpng,1)
  i2_l = LBOUND(SrcInitInputData%HdroDmpng,2)
  i2_u = UBOUND(SrcInitInputData%HdroDmpng,2)
  i3_l = LBOUND(SrcInitInputData%HdroDmpng,3)
  i3_u = UBOUND(SrcInitInputData%HdroDmpng,3)
  IF (.NOT. ALLOCATED(DstInitInputData%HdroDmpng)) THEN 
    ALLOCATE(DstInitInputData%HdroDmpng(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%HdroDmpng.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%HdroDmpng = SrcInitInputData%HdroDmpng
ENDIF
    DstInitInputData%NInpFreq = SrcInitInputData%NInpFreq
    DstInitInputData%RdtnTMax = SrcInitInputData%RdtnTMax
 END SUBROUTINE Conv_Rdtn_CopyInitInput

 SUBROUTINE Conv_Rdtn_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%HdroAddMs)) THEN
  DEALLOCATE(InitInputData%HdroAddMs)
ENDIF
IF (ALLOCATED(InitInputData%HdroFreq)) THEN
  DEALLOCATE(InitInputData%HdroFreq)
ENDIF
IF (ALLOCATED(InitInputData%HdroDmpng)) THEN
  DEALLOCATE(InitInputData%HdroDmpng)
ENDIF
 END SUBROUTINE Conv_Rdtn_DestroyInitInput


subroutine Conv_Rdtn_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! RdtnDT
   call RegPack(Buf, InData%RdtnDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnDTChr
   call RegPack(Buf, InData%RdtnDTChr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HighFreq
   call RegPack(Buf, InData%HighFreq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITFile
   call RegPack(Buf, InData%WAMITFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HdroAddMs
   call RegPack(Buf, allocated(InData%HdroAddMs))
   if (allocated(InData%HdroAddMs)) then
      call RegPackBounds(Buf, 3, lbound(InData%HdroAddMs), ubound(InData%HdroAddMs))
      call RegPack(Buf, InData%HdroAddMs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HdroFreq
   call RegPack(Buf, allocated(InData%HdroFreq))
   if (allocated(InData%HdroFreq)) then
      call RegPackBounds(Buf, 1, lbound(InData%HdroFreq), ubound(InData%HdroFreq))
      call RegPack(Buf, InData%HdroFreq)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! HdroDmpng
   call RegPack(Buf, allocated(InData%HdroDmpng))
   if (allocated(InData%HdroDmpng)) then
      call RegPackBounds(Buf, 3, lbound(InData%HdroDmpng), ubound(InData%HdroDmpng))
      call RegPack(Buf, InData%HdroDmpng)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NInpFreq
   call RegPack(Buf, InData%NInpFreq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnTMax
   call RegPack(Buf, InData%RdtnTMax)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! RdtnDT
   call RegUnpack(Buf, OutData%RdtnDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnDTChr
   call RegUnpack(Buf, OutData%RdtnDTChr)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HighFreq
   call RegUnpack(Buf, OutData%HighFreq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITFile
   call RegUnpack(Buf, OutData%WAMITFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! HdroAddMs
   if (allocated(OutData%HdroAddMs)) deallocate(OutData%HdroAddMs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HdroAddMs(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HdroAddMs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HdroAddMs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HdroFreq
   if (allocated(OutData%HdroFreq)) deallocate(OutData%HdroFreq)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HdroFreq(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HdroFreq.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HdroFreq)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! HdroDmpng
   if (allocated(OutData%HdroDmpng)) deallocate(OutData%HdroDmpng)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%HdroDmpng(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%HdroDmpng.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%HdroDmpng)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NInpFreq
   call RegUnpack(Buf, OutData%NInpFreq)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnTMax
   call RegUnpack(Buf, OutData%RdtnTMax)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(Conv_Rdtn_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%DummyInitOut = SrcInitOutputData%DummyInitOut
 END SUBROUTINE Conv_Rdtn_CopyInitOutput

 SUBROUTINE Conv_Rdtn_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Conv_Rdtn_DestroyInitOutput


subroutine Conv_Rdtn_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyInitOut
   call RegPack(Buf, InData%DummyInitOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackInitOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyInitOut
   call RegUnpack(Buf, OutData%DummyInitOut)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(Conv_Rdtn_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstContStateData%DummyContState = SrcContStateData%DummyContState
 END SUBROUTINE Conv_Rdtn_CopyContState

 SUBROUTINE Conv_Rdtn_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Conv_Rdtn_DestroyContState


subroutine Conv_Rdtn_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyContState
   call RegPack(Buf, InData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackContState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyContState
   call RegUnpack(Buf, OutData%DummyContState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(Conv_Rdtn_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDiscStateData%XDHistory)) THEN
  i1_l = LBOUND(SrcDiscStateData%XDHistory,1)
  i1_u = UBOUND(SrcDiscStateData%XDHistory,1)
  i2_l = LBOUND(SrcDiscStateData%XDHistory,2)
  i2_u = UBOUND(SrcDiscStateData%XDHistory,2)
  IF (.NOT. ALLOCATED(DstDiscStateData%XDHistory)) THEN 
    ALLOCATE(DstDiscStateData%XDHistory(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDiscStateData%XDHistory.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDiscStateData%XDHistory = SrcDiscStateData%XDHistory
ENDIF
    DstDiscStateData%LastTime = SrcDiscStateData%LastTime
 END SUBROUTINE Conv_Rdtn_CopyDiscState

 SUBROUTINE Conv_Rdtn_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(DiscStateData%XDHistory)) THEN
  DEALLOCATE(DiscStateData%XDHistory)
ENDIF
 END SUBROUTINE Conv_Rdtn_DestroyDiscState


subroutine Conv_Rdtn_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! XDHistory
   call RegPack(Buf, allocated(InData%XDHistory))
   if (allocated(InData%XDHistory)) then
      call RegPackBounds(Buf, 2, lbound(InData%XDHistory), ubound(InData%XDHistory))
      call RegPack(Buf, InData%XDHistory)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastTime
   call RegPack(Buf, InData%LastTime)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackDiscState'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! XDHistory
   if (allocated(OutData%XDHistory)) deallocate(OutData%XDHistory)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%XDHistory(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%XDHistory.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%XDHistory)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LastTime
   call RegUnpack(Buf, OutData%LastTime)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(Conv_Rdtn_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE Conv_Rdtn_CopyConstrState

 SUBROUTINE Conv_Rdtn_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Conv_Rdtn_DestroyConstrState


subroutine Conv_Rdtn_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(Conv_Rdtn_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%IndRdtn = SrcOtherStateData%IndRdtn
 END SUBROUTINE Conv_Rdtn_CopyOtherState

 SUBROUTINE Conv_Rdtn_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Conv_Rdtn_DestroyOtherState


subroutine Conv_Rdtn_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackOtherState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! IndRdtn
   call RegPack(Buf, InData%IndRdtn)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackOtherState'
   if (Buf%ErrStat /= ErrID_None) return
   ! IndRdtn
   call RegUnpack(Buf, OutData%IndRdtn)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(Conv_Rdtn_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%LastIndRdtn = SrcMiscData%LastIndRdtn
 END SUBROUTINE Conv_Rdtn_CopyMisc

 SUBROUTINE Conv_Rdtn_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE Conv_Rdtn_DestroyMisc


subroutine Conv_Rdtn_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! LastIndRdtn
   call RegPack(Buf, InData%LastIndRdtn)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackMisc'
   if (Buf%ErrStat /= ErrID_None) return
   ! LastIndRdtn
   call RegUnpack(Buf, OutData%LastIndRdtn)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(Conv_Rdtn_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%DT = SrcParamData%DT
    DstParamData%RdtnDT = SrcParamData%RdtnDT
    DstParamData%NBody = SrcParamData%NBody
IF (ALLOCATED(SrcParamData%RdtnKrnl)) THEN
  i1_l = LBOUND(SrcParamData%RdtnKrnl,1)
  i1_u = UBOUND(SrcParamData%RdtnKrnl,1)
  i2_l = LBOUND(SrcParamData%RdtnKrnl,2)
  i2_u = UBOUND(SrcParamData%RdtnKrnl,2)
  i3_l = LBOUND(SrcParamData%RdtnKrnl,3)
  i3_u = UBOUND(SrcParamData%RdtnKrnl,3)
  IF (.NOT. ALLOCATED(DstParamData%RdtnKrnl)) THEN 
    ALLOCATE(DstParamData%RdtnKrnl(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%RdtnKrnl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%RdtnKrnl = SrcParamData%RdtnKrnl
ENDIF
    DstParamData%NStepRdtn = SrcParamData%NStepRdtn
    DstParamData%NStepRdtn1 = SrcParamData%NStepRdtn1
 END SUBROUTINE Conv_Rdtn_CopyParam

 SUBROUTINE Conv_Rdtn_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%RdtnKrnl)) THEN
  DEALLOCATE(ParamData%RdtnKrnl)
ENDIF
 END SUBROUTINE Conv_Rdtn_DestroyParam


subroutine Conv_Rdtn_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnDT
   call RegPack(Buf, InData%RdtnDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnKrnl
   call RegPack(Buf, allocated(InData%RdtnKrnl))
   if (allocated(InData%RdtnKrnl)) then
      call RegPackBounds(Buf, 3, lbound(InData%RdtnKrnl), ubound(InData%RdtnKrnl))
      call RegPack(Buf, InData%RdtnKrnl)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepRdtn
   call RegPack(Buf, InData%NStepRdtn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepRdtn1
   call RegPack(Buf, InData%NStepRdtn1)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackParam'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnDT
   call RegUnpack(Buf, OutData%RdtnDT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RdtnKrnl
   if (allocated(OutData%RdtnKrnl)) deallocate(OutData%RdtnKrnl)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RdtnKrnl(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RdtnKrnl.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RdtnKrnl)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NStepRdtn
   call RegUnpack(Buf, OutData%NStepRdtn)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepRdtn1
   call RegUnpack(Buf, OutData%NStepRdtn1)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE Conv_Rdtn_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_InputType), INTENT(IN) :: SrcInputData
   TYPE(Conv_Rdtn_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%Velocity)) THEN
  i1_l = LBOUND(SrcInputData%Velocity,1)
  i1_u = UBOUND(SrcInputData%Velocity,1)
  IF (.NOT. ALLOCATED(DstInputData%Velocity)) THEN 
    ALLOCATE(DstInputData%Velocity(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%Velocity.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%Velocity = SrcInputData%Velocity
ENDIF
 END SUBROUTINE Conv_Rdtn_CopyInput

 SUBROUTINE Conv_Rdtn_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InputData%Velocity)) THEN
  DEALLOCATE(InputData%Velocity)
ENDIF
 END SUBROUTINE Conv_Rdtn_DestroyInput


subroutine Conv_Rdtn_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Velocity
   call RegPack(Buf, allocated(InData%Velocity))
   if (allocated(InData%Velocity)) then
      call RegPackBounds(Buf, 1, lbound(InData%Velocity), ubound(InData%Velocity))
      call RegPack(Buf, InData%Velocity)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackInput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Velocity
   if (allocated(OutData%Velocity)) deallocate(OutData%Velocity)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Velocity(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Velocity.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Velocity)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE Conv_Rdtn_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Conv_Rdtn_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(Conv_Rdtn_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'Conv_Rdtn_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%F_Rdtn)) THEN
  i1_l = LBOUND(SrcOutputData%F_Rdtn,1)
  i1_u = UBOUND(SrcOutputData%F_Rdtn,1)
  IF (.NOT. ALLOCATED(DstOutputData%F_Rdtn)) THEN 
    ALLOCATE(DstOutputData%F_Rdtn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%F_Rdtn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%F_Rdtn = SrcOutputData%F_Rdtn
ENDIF
 END SUBROUTINE Conv_Rdtn_CopyOutput

 SUBROUTINE Conv_Rdtn_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(Conv_Rdtn_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'Conv_Rdtn_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OutputData%F_Rdtn)) THEN
  DEALLOCATE(OutputData%F_Rdtn)
ENDIF
 END SUBROUTINE Conv_Rdtn_DestroyOutput


subroutine Conv_Rdtn_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(Conv_Rdtn_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'Conv_Rdtn_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! F_Rdtn
   call RegPack(Buf, allocated(InData%F_Rdtn))
   if (allocated(InData%F_Rdtn)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_Rdtn), ubound(InData%F_Rdtn))
      call RegPack(Buf, InData%F_Rdtn)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine Conv_Rdtn_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(Conv_Rdtn_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'Conv_Rdtn_UnPackOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! F_Rdtn
   if (allocated(OutData%F_Rdtn)) deallocate(OutData%F_Rdtn)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_Rdtn(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_Rdtn.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_Rdtn)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE Conv_Rdtn_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Conv_Rdtn_InputType), INTENT(IN)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(Conv_Rdtn_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'Conv_Rdtn_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL Conv_Rdtn_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL Conv_Rdtn_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL Conv_Rdtn_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE Conv_Rdtn_Input_ExtrapInterp


 SUBROUTINE Conv_Rdtn_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(Conv_Rdtn_InputType), INTENT(IN)  :: u1    ! Input at t1 > t2
 TYPE(Conv_Rdtn_InputType), INTENT(IN)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(Conv_Rdtn_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'Conv_Rdtn_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(u_out%Velocity) .AND. ALLOCATED(u1%Velocity)) THEN
  DO i1 = LBOUND(u_out%Velocity,1),UBOUND(u_out%Velocity,1)
    b = -(u1%Velocity(i1) - u2%Velocity(i1))
    u_out%Velocity(i1) = u1%Velocity(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE Conv_Rdtn_Input_ExtrapInterp1


 SUBROUTINE Conv_Rdtn_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(Conv_Rdtn_InputType), INTENT(IN)  :: u1      ! Input at t1 > t2 > t3
 TYPE(Conv_Rdtn_InputType), INTENT(IN)  :: u2      ! Input at t2 > t3
 TYPE(Conv_Rdtn_InputType), INTENT(IN)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(Conv_Rdtn_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'Conv_Rdtn_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(u_out%Velocity) .AND. ALLOCATED(u1%Velocity)) THEN
  DO i1 = LBOUND(u_out%Velocity,1),UBOUND(u_out%Velocity,1)
    b = (t(3)**2*(u1%Velocity(i1) - u2%Velocity(i1)) + t(2)**2*(-u1%Velocity(i1) + u3%Velocity(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%Velocity(i1) + t(3)*u2%Velocity(i1) - t(2)*u3%Velocity(i1) ) * scaleFactor
    u_out%Velocity(i1) = u1%Velocity(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE Conv_Rdtn_Input_ExtrapInterp2


 SUBROUTINE Conv_Rdtn_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(Conv_Rdtn_OutputType), INTENT(IN)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(Conv_Rdtn_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'Conv_Rdtn_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL Conv_Rdtn_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL Conv_Rdtn_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL Conv_Rdtn_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE Conv_Rdtn_Output_ExtrapInterp


 SUBROUTINE Conv_Rdtn_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(Conv_Rdtn_OutputType), INTENT(IN)  :: y1    ! Output at t1 > t2
 TYPE(Conv_Rdtn_OutputType), INTENT(IN)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(Conv_Rdtn_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'Conv_Rdtn_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
IF (ALLOCATED(y_out%F_Rdtn) .AND. ALLOCATED(y1%F_Rdtn)) THEN
  DO i1 = LBOUND(y_out%F_Rdtn,1),UBOUND(y_out%F_Rdtn,1)
    b = -(y1%F_Rdtn(i1) - y2%F_Rdtn(i1))
    y_out%F_Rdtn(i1) = y1%F_Rdtn(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE Conv_Rdtn_Output_ExtrapInterp1


 SUBROUTINE Conv_Rdtn_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(Conv_Rdtn_OutputType), INTENT(IN)  :: y1      ! Output at t1 > t2 > t3
 TYPE(Conv_Rdtn_OutputType), INTENT(IN)  :: y2      ! Output at t2 > t3
 TYPE(Conv_Rdtn_OutputType), INTENT(IN)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(Conv_Rdtn_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'Conv_Rdtn_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
IF (ALLOCATED(y_out%F_Rdtn) .AND. ALLOCATED(y1%F_Rdtn)) THEN
  DO i1 = LBOUND(y_out%F_Rdtn,1),UBOUND(y_out%F_Rdtn,1)
    b = (t(3)**2*(y1%F_Rdtn(i1) - y2%F_Rdtn(i1)) + t(2)**2*(-y1%F_Rdtn(i1) + y3%F_Rdtn(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%F_Rdtn(i1) + t(3)*y2%F_Rdtn(i1) - t(2)*y3%F_Rdtn(i1) ) * scaleFactor
    y_out%F_Rdtn(i1) = y1%F_Rdtn(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE Conv_Rdtn_Output_ExtrapInterp2

END MODULE Conv_Radiation_Types
!ENDOFREGISTRYGENERATEDFILE
