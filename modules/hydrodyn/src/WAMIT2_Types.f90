!STARTOFREGISTRYGENERATEDFILE 'WAMIT2_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! WAMIT2_Types
!.................................................................................................................................
! This file is part of WAMIT2.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in WAMIT2. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE WAMIT2_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
    INTEGER(IntKi), PUBLIC, PARAMETER  :: MaxWAMIT2Outputs = 6      !  [-]
! =========  WAMIT2_InitInputType  =======
  TYPE, PUBLIC :: WAMIT2_InitInputType
    LOGICAL  :: HasWAMIT      !< .TRUE. if using WAMIT model, .FALSE. otherwise [-]
    CHARACTER(1024)  :: WAMITFile      !< Root of the filename for WAMIT2 outputs [-]
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    INTEGER(IntKi)  :: NBodyMod      !< Body coupling model {1: include coupling terms between each body and NBody in HydroDyn equals NBODY in WAMIT, 2: neglect coupling terms between each body and NBODY=1 with XBODY=0 in WAMIT, 3: Neglect coupling terms between each body and NBODY=1 with XBODY=/0 in WAMIT} (switch) [only used when PotMod=1] [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefxt      !< The xt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefyt      !< The yt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PtfmRefzt      !< The zt offset of the body reference point(s) from (0,0,0)  [1 to NBody; only used when PotMod=1; must be 0.0 if NBodyMod=2 ] [(m)]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: PtfmRefztRot      !< The rotation about zt of the body reference frame(s) from xt/yt [radians]
    REAL(ReKi)  :: WAMITULEN      !< WAMIT unit length scale [-]
    REAL(ReKi)  :: RhoXg      !< Density * Gravity -- from the Waves module. [-]
    INTEGER(IntKi)  :: NStepWave      !< Total number of frequency components = total number of time steps in the incident wave [-]
    INTEGER(IntKi)  :: NStepWave2      !< NStepWave / 2 [-]
    REAL(ReKi)  :: WaveDOmega      !< Frequency step for incident wave calculations [(rad/s)]
    REAL(ReKi)  :: WtrDens      !< Water density [(kg/m^3)]
    REAL(ReKi)  :: Gravity      !< Supplied by Driver:  Gravitational acceleration [(m/s^2)]
    REAL(ReKi)  :: WtrDpth      !< Water depth (positive-valued) [(m)]
    REAL(SiKi) , DIMENSION(:,:), POINTER  :: WaveElevC0 => NULL()      !< Discrete Fourier transform of the instantaneous elevation of incident waves at the platform reference point.  First column is real part, second column is imaginary part (points to SeaState module data) [(meters)]
    REAL(SiKi)  :: WaveDir      !< Mean incident wave propagation heading direction [(degrees)]
    LOGICAL  :: WaveMultiDir      !< Indicates the waves are multidirectional -- set by HydroDyn_Input [-]
    REAL(SiKi) , DIMENSION(:), POINTER  :: WaveDirArr => NULL()      !< Wave direction assigned to each frequency (points to SeaState module data) [(degrees)]
    REAL(SiKi)  :: WaveDirMin      !< Minimum wave direction from Waves module [-]
    REAL(SiKi)  :: WaveDirMax      !< Maximum wave direction from Waves module [-]
    INTEGER(IntKi)  :: WaveMod      !< The wave model to use.  This is for error checking -- ideally this would be done in the main calling routine, not here. [-]
    INTEGER(IntKi)  :: MnDrift      !< Calculate the mean drift force {0: no mean drift; [7,8,9,10,11, or 12]: WAMIT file to use} [-]
    INTEGER(IntKi)  :: NewmanApp      !< Slow drift forces computed with Newman approximation from WAMIT file:{0: No slow drift; [7,8,9,10,11, or 12]: WAMIT file to use} [-]
    INTEGER(IntKi)  :: DiffQTF      !< Full Difference-Frequency forces computed with full QTF's from WAMIT file: {0: No diff-QTF; [10,11, or 12]: WAMIT file to use} [-]
    INTEGER(IntKi)  :: SumQTF      !< Full Sum-Frequency forces computed with full QTF's from WAMIT file: {0: No sum-QTF; [10,11, or 12]: WAMIT file to use} [-]
    LOGICAL  :: MnDriftF      !< Flag indicating mean drift force should be calculated [-]
    LOGICAL  :: NewmanAppF      !< Flag indicating Newman approximation should be calculated [-]
    LOGICAL  :: DiffQTFF      !< Flag indicating the full difference QTF should be calculated [-]
    LOGICAL  :: SumQTFF      !< Flag indicating the full    sum     QTF should be calculated [-]
    REAL(ReKi)  :: WvLowCOff      !< Low cut-off frequency or lower frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(ReKi)  :: WvHiCOff      !< High cut-off frequency or upper frequency limit of the wave spectrum beyond which the wave spectrum is zeroed.  [used only when WaveMod=2,3,4] [(rad/s)]
    REAL(ReKi)  :: WvLowCOffD      !< Minimum frequency used in the difference methods [Ignored if all difference methods = 0] [(rad/s)]
    REAL(ReKi)  :: WvHiCOffD      !< Maximum frequency used in the difference methods [Ignored if all difference methods = 0] [(rad/s)]
    REAL(ReKi)  :: WvLowCOffS      !< Minimum frequency used in the sum-QTF method     [Ignored if SumQTF = 0] [(rad/s)]
    REAL(ReKi)  :: WvHiCOffS      !< Maximum frequency used in the sum-QTF method     [Ignored if SumQTF = 0] [(rad/s)]
  END TYPE WAMIT2_InitInputType
! =======================
! =========  WAMIT2_MiscVarType  =======
  TYPE, PUBLIC :: WAMIT2_MiscVarType
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: LastIndWave      !< Index for last interpolation step of 2nd order forces [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_Waves2      !< 2nd order force from this timestep [-]
  END TYPE WAMIT2_MiscVarType
! =======================
! =========  WAMIT2_ParameterType  =======
  TYPE, PUBLIC :: WAMIT2_ParameterType
    INTEGER(IntKi)  :: NStepWave      !< Number of wave time steps [-]
    INTEGER(IntKi)  :: NBody      !< [>=1; only used when PotMod=1. If NBodyMod=1, the WAMIT data contains a vector of size 6*NBody x 1 and matrices of size 6*NBody x 6*NBody; if NBodyMod>1, there are NBody sets of WAMIT data each with a vector of size 6 x 1 and matrices of size 6 x 6] [-]
    INTEGER(IntKi)  :: NBodyMod      !< Body coupling model {1: include coupling terms between each body and NBody in HydroDyn equals NBODY in WAMIT, 2: neglect coupling terms between each body and NBODY=1 with XBODY=0 in WAMIT, 3: Neglect coupling terms between each body and NBODY=1 with XBODY=/0 in WAMIT} (switch) [only used when PotMod=1] [-]
    REAL(SiKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveExctn2      !< Time series of the resulting 2nd order force (first index is timestep, second index is load component) [(N)]
    LOGICAL , DIMENSION(1:6)  :: MnDriftDims      !< Flags for which dimensions to calculate in MnDrift   calculations [-]
    LOGICAL , DIMENSION(1:6)  :: NewmanAppDims      !< Flags for which dimensions to calculate in NewmanApp calculations [-]
    LOGICAL , DIMENSION(1:6)  :: DiffQTFDims      !< Flags for which dimensions to calculate in DiffQTF   calculations [-]
    LOGICAL , DIMENSION(1:6)  :: SumQTFDims      !< Flags for which dimensions to calculate in SumQTF    calculations [-]
    LOGICAL  :: MnDriftF      !< Flag indicating mean drift force should be calculated [-]
    LOGICAL  :: NewmanAppF      !< Flag indicating Newman approximation should be calculated [-]
    LOGICAL  :: DiffQTFF      !< Flag indicating the full difference QTF should be calculated [-]
    LOGICAL  :: SumQTFF      !< Flag indicating the full    sum     QTF should be calculated [-]
  END TYPE WAMIT2_ParameterType
! =======================
! =========  WAMIT2_OutputType  =======
  TYPE, PUBLIC :: WAMIT2_OutputType
    TYPE(MeshType)  :: Mesh      !< Loads at the platform reference point in the inertial frame [-]
  END TYPE WAMIT2_OutputType
! =======================
CONTAINS
 SUBROUTINE WAMIT2_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT2_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(WAMIT2_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT2_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%HasWAMIT = SrcInitInputData%HasWAMIT
    DstInitInputData%WAMITFile = SrcInitInputData%WAMITFile
    DstInitInputData%NBody = SrcInitInputData%NBody
    DstInitInputData%NBodyMod = SrcInitInputData%NBodyMod
IF (ALLOCATED(SrcInitInputData%PtfmRefxt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefxt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefxt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefxt)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefxt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefxt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefxt = SrcInitInputData%PtfmRefxt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmRefyt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefyt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefyt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefyt)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefyt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefyt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefyt = SrcInitInputData%PtfmRefyt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmRefzt)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefzt,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefzt,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefzt)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefzt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefzt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefzt = SrcInitInputData%PtfmRefzt
ENDIF
IF (ALLOCATED(SrcInitInputData%PtfmRefztRot)) THEN
  i1_l = LBOUND(SrcInitInputData%PtfmRefztRot,1)
  i1_u = UBOUND(SrcInitInputData%PtfmRefztRot,1)
  IF (.NOT. ALLOCATED(DstInitInputData%PtfmRefztRot)) THEN 
    ALLOCATE(DstInitInputData%PtfmRefztRot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%PtfmRefztRot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%PtfmRefztRot = SrcInitInputData%PtfmRefztRot
ENDIF
    DstInitInputData%WAMITULEN = SrcInitInputData%WAMITULEN
    DstInitInputData%RhoXg = SrcInitInputData%RhoXg
    DstInitInputData%NStepWave = SrcInitInputData%NStepWave
    DstInitInputData%NStepWave2 = SrcInitInputData%NStepWave2
    DstInitInputData%WaveDOmega = SrcInitInputData%WaveDOmega
    DstInitInputData%WtrDens = SrcInitInputData%WtrDens
    DstInitInputData%Gravity = SrcInitInputData%Gravity
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%WaveElevC0 => SrcInitInputData%WaveElevC0
    DstInitInputData%WaveDir = SrcInitInputData%WaveDir
    DstInitInputData%WaveMultiDir = SrcInitInputData%WaveMultiDir
    DstInitInputData%WaveDirArr => SrcInitInputData%WaveDirArr
    DstInitInputData%WaveDirMin = SrcInitInputData%WaveDirMin
    DstInitInputData%WaveDirMax = SrcInitInputData%WaveDirMax
    DstInitInputData%WaveMod = SrcInitInputData%WaveMod
    DstInitInputData%MnDrift = SrcInitInputData%MnDrift
    DstInitInputData%NewmanApp = SrcInitInputData%NewmanApp
    DstInitInputData%DiffQTF = SrcInitInputData%DiffQTF
    DstInitInputData%SumQTF = SrcInitInputData%SumQTF
    DstInitInputData%MnDriftF = SrcInitInputData%MnDriftF
    DstInitInputData%NewmanAppF = SrcInitInputData%NewmanAppF
    DstInitInputData%DiffQTFF = SrcInitInputData%DiffQTFF
    DstInitInputData%SumQTFF = SrcInitInputData%SumQTFF
    DstInitInputData%WvLowCOff = SrcInitInputData%WvLowCOff
    DstInitInputData%WvHiCOff = SrcInitInputData%WvHiCOff
    DstInitInputData%WvLowCOffD = SrcInitInputData%WvLowCOffD
    DstInitInputData%WvHiCOffD = SrcInitInputData%WvHiCOffD
    DstInitInputData%WvLowCOffS = SrcInitInputData%WvLowCOffS
    DstInitInputData%WvHiCOffS = SrcInitInputData%WvHiCOffS
 END SUBROUTINE WAMIT2_CopyInitInput

 SUBROUTINE WAMIT2_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(WAMIT2_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT2_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%PtfmRefxt)) THEN
  DEALLOCATE(InitInputData%PtfmRefxt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefyt)) THEN
  DEALLOCATE(InitInputData%PtfmRefyt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefzt)) THEN
  DEALLOCATE(InitInputData%PtfmRefzt)
ENDIF
IF (ALLOCATED(InitInputData%PtfmRefztRot)) THEN
  DEALLOCATE(InitInputData%PtfmRefztRot)
ENDIF
NULLIFY(InitInputData%WaveElevC0)
NULLIFY(InitInputData%WaveDirArr)
 END SUBROUTINE WAMIT2_DestroyInitInput


subroutine WAMIT2_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT2_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT2_PackInitInput'
   logical         :: PtrInIndex
   if (Buf%ErrStat >= AbortErrLev) return
   ! HasWAMIT
   call RegPack(Buf, InData%HasWAMIT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITFile
   call RegPack(Buf, InData%WAMITFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegPack(Buf, InData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefxt
   call RegPack(Buf, allocated(InData%PtfmRefxt))
   if (allocated(InData%PtfmRefxt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefxt), ubound(InData%PtfmRefxt))
      call RegPack(Buf, InData%PtfmRefxt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefyt
   call RegPack(Buf, allocated(InData%PtfmRefyt))
   if (allocated(InData%PtfmRefyt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefyt), ubound(InData%PtfmRefyt))
      call RegPack(Buf, InData%PtfmRefyt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefzt
   call RegPack(Buf, allocated(InData%PtfmRefzt))
   if (allocated(InData%PtfmRefzt)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefzt), ubound(InData%PtfmRefzt))
      call RegPack(Buf, InData%PtfmRefzt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefztRot
   call RegPack(Buf, allocated(InData%PtfmRefztRot))
   if (allocated(InData%PtfmRefztRot)) then
      call RegPackBounds(Buf, 1, lbound(InData%PtfmRefztRot), ubound(InData%PtfmRefztRot))
      call RegPack(Buf, InData%PtfmRefztRot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITULEN
   call RegPack(Buf, InData%WAMITULEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegPack(Buf, InData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegPack(Buf, InData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegPack(Buf, InData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegPack(Buf, InData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegPack(Buf, InData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC0
   call RegPack(Buf, associated(InData%WaveElevC0))
   if (associated(InData%WaveElevC0)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveElevC0), ubound(InData%WaveElevC0))
      call RegPackPointer(Buf, c_loc(InData%WaveElevC0), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveElevC0)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDir
   call RegPack(Buf, InData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegPack(Buf, InData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   call RegPack(Buf, associated(InData%WaveDirArr))
   if (associated(InData%WaveDirArr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WaveDirArr), ubound(InData%WaveDirArr))
      call RegPackPointer(Buf, c_loc(InData%WaveDirArr), PtrInIndex)
      if (.not. PtrInIndex) then
         call RegPack(Buf, InData%WaveDirArr)
      end if
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMin
   call RegPack(Buf, InData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegPack(Buf, InData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegPack(Buf, InData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDrift
   call RegPack(Buf, InData%MnDrift)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanApp
   call RegPack(Buf, InData%NewmanApp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTF
   call RegPack(Buf, InData%DiffQTF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTF
   call RegPack(Buf, InData%SumQTF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDriftF
   call RegPack(Buf, InData%MnDriftF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanAppF
   call RegPack(Buf, InData%NewmanAppF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTFF
   call RegPack(Buf, InData%DiffQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTFF
   call RegPack(Buf, InData%SumQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegPack(Buf, InData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegPack(Buf, InData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffD
   call RegPack(Buf, InData%WvLowCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffD
   call RegPack(Buf, InData%WvHiCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffS
   call RegPack(Buf, InData%WvLowCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffS
   call RegPack(Buf, InData%WvHiCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT2_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT2_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT2_UnPackInitInput'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   integer(IntKi)  :: PtrIdx
   type(c_ptr)     :: Ptr
   if (Buf%ErrStat /= ErrID_None) return
   ! HasWAMIT
   call RegUnpack(Buf, OutData%HasWAMIT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WAMITFile
   call RegUnpack(Buf, OutData%WAMITFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegUnpack(Buf, OutData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! PtfmRefxt
   if (allocated(OutData%PtfmRefxt)) deallocate(OutData%PtfmRefxt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefxt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefxt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefxt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefyt
   if (allocated(OutData%PtfmRefyt)) deallocate(OutData%PtfmRefyt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefyt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefyt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefyt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefzt
   if (allocated(OutData%PtfmRefzt)) deallocate(OutData%PtfmRefzt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefzt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefzt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefzt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PtfmRefztRot
   if (allocated(OutData%PtfmRefztRot)) deallocate(OutData%PtfmRefztRot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PtfmRefztRot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PtfmRefztRot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PtfmRefztRot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WAMITULEN
   call RegUnpack(Buf, OutData%WAMITULEN)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RhoXg
   call RegUnpack(Buf, OutData%RhoXg)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NStepWave2
   call RegUnpack(Buf, OutData%NStepWave2)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDOmega
   call RegUnpack(Buf, OutData%WaveDOmega)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDens
   call RegUnpack(Buf, OutData%WtrDens)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Gravity
   call RegUnpack(Buf, OutData%Gravity)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveElevC0
   if (associated(OutData%WaveElevC0)) deallocate(OutData%WaveElevC0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveElevC0, UB(1:2)-LB(1:2))
         OutData%WaveElevC0(LB(1):,LB(2):) => OutData%WaveElevC0
      else
         allocate(OutData%WaveElevC0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElevC0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveElevC0)
         call RegUnpack(Buf, OutData%WaveElevC0)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveElevC0 => null()
   end if
   ! WaveDir
   call RegUnpack(Buf, OutData%WaveDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMultiDir
   call RegUnpack(Buf, OutData%WaveMultiDir)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirArr
   if (associated(OutData%WaveDirArr)) deallocate(OutData%WaveDirArr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      call RegUnpackPointer(Buf, Ptr, PtrIdx)
      if (RegCheckErr(Buf, RoutineName)) return
      if (c_associated(Ptr)) then
         call c_f_pointer(Ptr, OutData%WaveDirArr, UB(1:1)-LB(1:1))
         OutData%WaveDirArr(LB(1):) => OutData%WaveDirArr
      else
         allocate(OutData%WaveDirArr(LB(1):UB(1)),stat=stat)
         if (stat /= 0) then 
            call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveDirArr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
            return
         end if
         Buf%Pointers(PtrIdx) = c_loc(OutData%WaveDirArr)
         call RegUnpack(Buf, OutData%WaveDirArr)
         if (RegCheckErr(Buf, RoutineName)) return
      end if
   else
      OutData%WaveDirArr => null()
   end if
   ! WaveDirMin
   call RegUnpack(Buf, OutData%WaveDirMin)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveDirMax
   call RegUnpack(Buf, OutData%WaveDirMax)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveMod
   call RegUnpack(Buf, OutData%WaveMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDrift
   call RegUnpack(Buf, OutData%MnDrift)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanApp
   call RegUnpack(Buf, OutData%NewmanApp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTF
   call RegUnpack(Buf, OutData%DiffQTF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTF
   call RegUnpack(Buf, OutData%SumQTF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDriftF
   call RegUnpack(Buf, OutData%MnDriftF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanAppF
   call RegUnpack(Buf, OutData%NewmanAppF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTFF
   call RegUnpack(Buf, OutData%DiffQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTFF
   call RegUnpack(Buf, OutData%SumQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOff
   call RegUnpack(Buf, OutData%WvLowCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOff
   call RegUnpack(Buf, OutData%WvHiCOff)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffD
   call RegUnpack(Buf, OutData%WvLowCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffD
   call RegUnpack(Buf, OutData%WvHiCOffD)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvLowCOffS
   call RegUnpack(Buf, OutData%WvLowCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WvHiCOffS
   call RegUnpack(Buf, OutData%WvHiCOffS)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WAMIT2_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT2_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(WAMIT2_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT2_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%LastIndWave)) THEN
  i1_l = LBOUND(SrcMiscData%LastIndWave,1)
  i1_u = UBOUND(SrcMiscData%LastIndWave,1)
  IF (.NOT. ALLOCATED(DstMiscData%LastIndWave)) THEN 
    ALLOCATE(DstMiscData%LastIndWave(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LastIndWave.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LastIndWave = SrcMiscData%LastIndWave
ENDIF
IF (ALLOCATED(SrcMiscData%F_Waves2)) THEN
  i1_l = LBOUND(SrcMiscData%F_Waves2,1)
  i1_u = UBOUND(SrcMiscData%F_Waves2,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_Waves2)) THEN 
    ALLOCATE(DstMiscData%F_Waves2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_Waves2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_Waves2 = SrcMiscData%F_Waves2
ENDIF
 END SUBROUTINE WAMIT2_CopyMisc

 SUBROUTINE WAMIT2_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(WAMIT2_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT2_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%LastIndWave)) THEN
  DEALLOCATE(MiscData%LastIndWave)
ENDIF
IF (ALLOCATED(MiscData%F_Waves2)) THEN
  DEALLOCATE(MiscData%F_Waves2)
ENDIF
 END SUBROUTINE WAMIT2_DestroyMisc


subroutine WAMIT2_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT2_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT2_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! LastIndWave
   call RegPack(Buf, allocated(InData%LastIndWave))
   if (allocated(InData%LastIndWave)) then
      call RegPackBounds(Buf, 1, lbound(InData%LastIndWave), ubound(InData%LastIndWave))
      call RegPack(Buf, InData%LastIndWave)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_Waves2
   call RegPack(Buf, allocated(InData%F_Waves2))
   if (allocated(InData%F_Waves2)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_Waves2), ubound(InData%F_Waves2))
      call RegPack(Buf, InData%F_Waves2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT2_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT2_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT2_UnPackMisc'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! LastIndWave
   if (allocated(OutData%LastIndWave)) deallocate(OutData%LastIndWave)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LastIndWave(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LastIndWave.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LastIndWave)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_Waves2
   if (allocated(OutData%F_Waves2)) deallocate(OutData%F_Waves2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_Waves2(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_Waves2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_Waves2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE WAMIT2_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT2_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(WAMIT2_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT2_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%NStepWave = SrcParamData%NStepWave
    DstParamData%NBody = SrcParamData%NBody
    DstParamData%NBodyMod = SrcParamData%NBodyMod
IF (ALLOCATED(SrcParamData%WaveExctn2)) THEN
  i1_l = LBOUND(SrcParamData%WaveExctn2,1)
  i1_u = UBOUND(SrcParamData%WaveExctn2,1)
  i2_l = LBOUND(SrcParamData%WaveExctn2,2)
  i2_u = UBOUND(SrcParamData%WaveExctn2,2)
  IF (.NOT. ALLOCATED(DstParamData%WaveExctn2)) THEN 
    ALLOCATE(DstParamData%WaveExctn2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WaveExctn2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WaveExctn2 = SrcParamData%WaveExctn2
ENDIF
    DstParamData%MnDriftDims = SrcParamData%MnDriftDims
    DstParamData%NewmanAppDims = SrcParamData%NewmanAppDims
    DstParamData%DiffQTFDims = SrcParamData%DiffQTFDims
    DstParamData%SumQTFDims = SrcParamData%SumQTFDims
    DstParamData%MnDriftF = SrcParamData%MnDriftF
    DstParamData%NewmanAppF = SrcParamData%NewmanAppF
    DstParamData%DiffQTFF = SrcParamData%DiffQTFF
    DstParamData%SumQTFF = SrcParamData%SumQTFF
 END SUBROUTINE WAMIT2_CopyParam

 SUBROUTINE WAMIT2_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(WAMIT2_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT2_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%WaveExctn2)) THEN
  DEALLOCATE(ParamData%WaveExctn2)
ENDIF
 END SUBROUTINE WAMIT2_DestroyParam


subroutine WAMIT2_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT2_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT2_PackParam'
   if (Buf%ErrStat >= AbortErrLev) return
   ! NStepWave
   call RegPack(Buf, InData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegPack(Buf, InData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegPack(Buf, InData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveExctn2
   call RegPack(Buf, allocated(InData%WaveExctn2))
   if (allocated(InData%WaveExctn2)) then
      call RegPackBounds(Buf, 2, lbound(InData%WaveExctn2), ubound(InData%WaveExctn2))
      call RegPack(Buf, InData%WaveExctn2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDriftDims
   call RegPack(Buf, InData%MnDriftDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanAppDims
   call RegPack(Buf, InData%NewmanAppDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTFDims
   call RegPack(Buf, InData%DiffQTFDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTFDims
   call RegPack(Buf, InData%SumQTFDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDriftF
   call RegPack(Buf, InData%MnDriftF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanAppF
   call RegPack(Buf, InData%NewmanAppF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTFF
   call RegPack(Buf, InData%DiffQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTFF
   call RegPack(Buf, InData%SumQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT2_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT2_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT2_UnPackParam'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! NStepWave
   call RegUnpack(Buf, OutData%NStepWave)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBody
   call RegUnpack(Buf, OutData%NBody)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NBodyMod
   call RegUnpack(Buf, OutData%NBodyMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WaveExctn2
   if (allocated(OutData%WaveExctn2)) deallocate(OutData%WaveExctn2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WaveExctn2(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveExctn2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WaveExctn2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MnDriftDims
   call RegUnpack(Buf, OutData%MnDriftDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanAppDims
   call RegUnpack(Buf, OutData%NewmanAppDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTFDims
   call RegUnpack(Buf, OutData%DiffQTFDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTFDims
   call RegUnpack(Buf, OutData%SumQTFDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MnDriftF
   call RegUnpack(Buf, OutData%MnDriftF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NewmanAppF
   call RegUnpack(Buf, OutData%NewmanAppF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DiffQTFF
   call RegUnpack(Buf, OutData%DiffQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SumQTFF
   call RegUnpack(Buf, OutData%SumQTFF)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE WAMIT2_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(WAMIT2_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(WAMIT2_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'WAMIT2_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcOutputData%Mesh, DstOutputData%Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE WAMIT2_CopyOutput

 SUBROUTINE WAMIT2_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(WAMIT2_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'WAMIT2_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( OutputData%Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE WAMIT2_DestroyOutput


subroutine WAMIT2_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(WAMIT2_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'WAMIT2_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Mesh
   call MeshPack(Buf, InData%Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine WAMIT2_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(WAMIT2_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'WAMIT2_UnPackOutput'
   if (Buf%ErrStat /= ErrID_None) return
   ! Mesh
   call MeshUnpack(Buf, OutData%Mesh) ! Mesh 
end subroutine

 SUBROUTINE WAMIT2_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'WAMIT2_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL WAMIT2_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL WAMIT2_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL WAMIT2_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE WAMIT2_Output_ExtrapInterp


 SUBROUTINE WAMIT2_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'WAMIT2_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(y1%Mesh, y2%Mesh, tin, y_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE WAMIT2_Output_ExtrapInterp1


 SUBROUTINE WAMIT2_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(WAMIT2_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'WAMIT2_Output_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(y1%Mesh, y2%Mesh, y3%Mesh, tin, y_out%Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 END SUBROUTINE WAMIT2_Output_ExtrapInterp2

END MODULE WAMIT2_Types
!ENDOFREGISTRYGENERATEDFILE
