!STARTOFREGISTRYGENERATEDFILE 'SubDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! SubDyn_Types
!.................................................................................................................................
! This file is part of SubDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in SubDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE SubDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  IList  =======
  TYPE, PUBLIC :: IList
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: List      !< List of integers [-]
  END TYPE IList
! =======================
! =========  MeshAuxDataType  =======
  TYPE, PUBLIC :: MeshAuxDataType
    INTEGER(IntKi)  :: MemberID      !< Member ID for Output [-]
    INTEGER(IntKi)  :: NOutCnt      !< Number of Nodes for the output member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeCnt      !< Node ordinal numbers for the output member [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeIDs      !< Node IDs associated with ordinal numbers for the output member [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmIDs      !< Element IDs connected to each NodeIDs; max 10 elements [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElmNds      !< Flag to indicate 1st or 2nd node of element for each ElmIDs [-]
    REAL(R8Ki) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Me      !< Mass matrix connected to each joint element for outAll output [-]
    REAL(R8Ki) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Ke      !< Mass matrix connected to each joint element for outAll output [-]
    REAL(R8Ki) , DIMENSION(:,:,:), ALLOCATABLE  :: Fg      !< Gravity load vector connected to each joint element for requested member output [-]
  END TYPE MeshAuxDataType
! =======================
! =========  CB_MatArrays  =======
  TYPE, PUBLIC :: CB_MatArrays
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: MBB      !< FULL MBB ( no constraints applied) [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: MBM      !< FULL MBM ( no constraints applied) [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: KBB      !< FULL KBB ( no constraints applied) [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: PhiL      !< Retained CB modes, possibly allPhiL(nDOFL,nDOFL), or PhiL(nDOFL,nDOFM) [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: PhiR      !< FULL PhiR ( no constraints applied) [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: OmegaL      !< Eigenvalues of retained CB modes, possibly all (nDOFL or nDOFM) [-]
  END TYPE CB_MatArrays
! =======================
! =========  ElemPropType  =======
  TYPE, PUBLIC :: ElemPropType
    INTEGER(IntKi)  :: eType      !< Element Type [-]
    REAL(ReKi)  :: Length      !< Length of an element [-]
    REAL(ReKi)  :: Ixx      !< Moment of inertia of an element [-]
    REAL(ReKi)  :: Iyy      !< Moment of inertia of an element [-]
    REAL(ReKi)  :: Jzz      !< Moment of inertia of an element [-]
    LOGICAL  :: Shear      !< Use timoshenko (true) E-B (false) [-]
    REAL(ReKi)  :: Kappa_x      !< Shear coefficient [-]
    REAL(ReKi)  :: Kappa_y      !< Shear coefficient [-]
    REAL(ReKi)  :: YoungE      !< Young's modulus [-]
    REAL(ReKi)  :: ShearG      !< Shear modulus [N/m^2]
    REAL(ReKi) , DIMENSION(1:2)  :: D      !< Diameter at node 1 and 2, for visualization only [m]
    REAL(ReKi)  :: Area      !< Area of an element [m^2]
    REAL(ReKi)  :: Rho      !< Density [kg/m^3]
    REAL(ReKi)  :: T0      !< Pretension  [N]
    REAL(R8Ki) , DIMENSION(1:3,1:3)  :: DirCos      !< Element direction cosine matrix [-]
  END TYPE ElemPropType
! =======================
! =========  SD_InitInputType  =======
  TYPE, PUBLIC :: SD_InitInputType
    CHARACTER(1024)  :: SDInputFile      !< Name of the input file [-]
    CHARACTER(1024)  :: RootName      !< SubDyn rootname [-]
    REAL(ReKi)  :: g      !< Gravity acceleration [-]
    REAL(ReKi)  :: WtrDpth      !< Water Depth (positive valued) [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint      !< global position of transition piece reference point (could also be defined in SubDyn itself) [-]
    REAL(ReKi)  :: SubRotateZ      !< Rotation angle in degrees about global Z [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: SoilStiffness      !< Soil stiffness matrices from SoilDyn ['(N/m,]
    TYPE(MeshType)  :: SoilMesh      !< Mesh for soil stiffness locations [-]
    LOGICAL  :: Linearize = .FALSE.      !< Flag that tells this module if the glue code wants to linearize. [-]
  END TYPE SD_InitInputType
! =======================
! =========  SD_InitOutputType  =======
  TYPE, PUBLIC :: SD_InitOutputType
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputHdr      !< Names of the output-to-file channels [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: WriteOutputUnt      !< Units of the output-to-file channels [-]
    TYPE(ProgDesc)  :: Ver      !< This module's name, version, and date [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_y      !< Names of the outputs used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_x      !< Names of the continuous states used in linearization [-]
    CHARACTER(LinChanLen) , DIMENSION(:), ALLOCATABLE  :: LinNames_u      !< Names of the inputs used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_y      !< Flag that tells FAST/MBC3 if the outputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_x      !< Flag that tells FAST/MBC3 if the continuous states used in linearization are in the rotating frame (not used for glue) [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: RotFrame_u      !< Flag that tells FAST/MBC3 if the inputs used in linearization are in the rotating frame [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: IsLoad_u      !< Flag that tells FAST if the inputs used in linearization are loads (for preconditioning matrix) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: DerivOrder_x      !< Integer that tells FAST/MBC3 the maximum derivative order of continuous states used in linearization [-]
    LOGICAL , DIMENSION(:), ALLOCATABLE  :: CableCChanRqst      !< flag indicating control channel for active cable tensioning is requested [-]
  END TYPE SD_InitOutputType
! =======================
! =========  SD_InitType  =======
  TYPE, PUBLIC :: SD_InitType
    CHARACTER(1024)  :: RootName      !< SubDyn rootname [-]
    REAL(ReKi) , DIMENSION(1:3)  :: TP_RefPoint      !< global position of transition piece reference point (could also be defined in SubDyn itself) [-]
    REAL(ReKi)  :: SubRotateZ      !< Rotation angle in degrees about global Z [-]
    REAL(ReKi)  :: g      !< Gravity acceleration [-]
    REAL(DbKi)  :: DT      !< Time step from Glue Code [seconds]
    INTEGER(IntKi)  :: NJoints      !< Number of joints of the sub structure [-]
    INTEGER(IntKi)  :: NPropSetsX      !< Number of extended property sets [-]
    INTEGER(IntKi)  :: NPropSetsB      !< Number of property sets for beams [-]
    INTEGER(IntKi)  :: NPropSetsC      !< Number of property sets for cables [-]
    INTEGER(IntKi)  :: NPropSetsR      !< Number of property sets for rigid links [-]
    INTEGER(IntKi)  :: NCMass      !< Number of joints with concentrated mass [-]
    INTEGER(IntKi)  :: NCOSMs      !< Number of independent cosine matrices [-]
    INTEGER(IntKi)  :: FEMMod      !< FEM switch  element model in the FEM [-]
    INTEGER(IntKi)  :: NDiv      !< Number of divisions for each member [-]
    LOGICAL  :: CBMod      !< Perform C-B flag [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Joints      !< Joints number and coordinate values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSetsB      !< Property sets number and values [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSetsC      !< Property ID and values for cables [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSetsR      !< Property ID and values for rigid link [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropSetsX      !< Extended property sets [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: COSMs      !< Independent direction cosine matrices [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CMass      !< Concentrated mass information [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: JDampings      !< Damping coefficients for internal modes [-]
    INTEGER(IntKi)  :: GuyanDampMod      !< Guyan damping [0=none, 1=Rayleigh Damping, 2= user specified 6x6 matrix] [-]
    REAL(ReKi) , DIMENSION(1:2)  :: RayleighDamp      !< Mass and stiffness proportional damping coefficients (Rayleigh Damping) [only if GuyanDampMod=1] [-]
    REAL(ReKi) , DIMENSION(1:6,1:6)  :: GuyanDampMat      !< Guyan Damping Matrix, see also CBB [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Members      !< Member joints connection           [-]
    CHARACTER(ChanLen) , DIMENSION(:), ALLOCATABLE  :: SSOutList      !< List of Output Channels            [-]
    LOGICAL  :: OutCOSM      !< Output Cos-matrices Flag           [-]
    LOGICAL  :: TabDelim      !< Generate a tab-delimited output file in OutJckF-Flag                        [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: SSIK      !< SSI stiffness packed matrix elements (21 of them), for each reaction joint  [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: SSIM      !< SSI mass packed matrix elements (21 of them), for each reaction joint       [-]
    CHARACTER(1024) , DIMENSION(:), ALLOCATABLE  :: SSIfile      !< Soil Structure Interaction (SSI) files to associate with each reaction node [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Soil_K      !< Soil stiffness (at passed at Init, not in input file)  6x6xn                [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Soil_Points      !< Node positions where soil stiffness will be added                           [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: Soil_Nodes      !< Node indices where soil stiffness will be added                             [-]
    INTEGER(IntKi)  :: NElem      !< Total number of elements [-]
    INTEGER(IntKi)  :: NPropB      !< Total number of property sets for Beams [-]
    INTEGER(IntKi)  :: NPropC      !< Total number of property sets for Cable [-]
    INTEGER(IntKi)  :: NPropR      !< Total number of property sets for Rigid [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes      !< Nodes number and coordinates            [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropsB      !< Property sets and values for Beams      [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropsC      !< Property sets and values for Cable      [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PropsR      !< Property sets and values for Rigid link [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: K      !< System stiffness matrix                 [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: M      !< System mass matrix                      [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: ElemProps      !< Element properties(A, L, Ixx, Iyy, Jzz, Shear, Kappa, E, G, Rho, DirCos(1,1), DirCos(2, 1), ....., DirCos(3, 3) ) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: MemberNodes      !< Member number and list of nodes making up a member (>2 if subdivided) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnN      !< Nodes that connect to a common node    [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: NodesConnE      !< Elements that connect to a common node [-]
    LOGICAL  :: SSSum      !< SubDyn Summary File Flag               [-]
  END TYPE SD_InitType
! =======================
! =========  SD_ContinuousStateType  =======
  TYPE, PUBLIC :: SD_ContinuousStateType
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: qm      !< Virtual states, Nmod elements [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: qmdot      !< Derivative of states, Nmod elements [-]
  END TYPE SD_ContinuousStateType
! =======================
! =========  SD_DiscreteStateType  =======
  TYPE, PUBLIC :: SD_DiscreteStateType
    REAL(ReKi)  :: DummyDiscState      !< Remove this variable if you have discrete states [-]
  END TYPE SD_DiscreteStateType
! =======================
! =========  SD_ConstraintStateType  =======
  TYPE, PUBLIC :: SD_ConstraintStateType
    REAL(ReKi)  :: DummyConstrState      !< Remove this variable if you have constraint states [-]
  END TYPE SD_ConstraintStateType
! =======================
! =========  SD_OtherStateType  =======
  TYPE, PUBLIC :: SD_OtherStateType
    TYPE(SD_ContinuousStateType) , DIMENSION(:), ALLOCATABLE  :: xdot      !< previous state derivs for m-step time integrator [-]
    INTEGER(IntKi)  :: n      !< tracks time step for which OtherState was updated last [-]
  END TYPE SD_OtherStateType
! =======================
! =========  SD_MiscVarType  =======
  TYPE, PUBLIC :: SD_MiscVarType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: qmdotdot      !< 2nd Derivative of states, used only for output-file purposes [-]
    REAL(ReKi) , DIMENSION(1:6)  :: u_TP 
    REAL(ReKi) , DIMENSION(1:6)  :: udot_TP 
    REAL(ReKi) , DIMENSION(1:6)  :: udotdot_TP 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_L      !< Loads on internal DOF, size nL [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: F_L2      !< Loads on internal DOF, size nL, used for SIM and ADM4 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UR_bar_dotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL      !< Internal DOFs (L) displacements  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_NS      !< Internal DOFs (L) displacements, No SIM (NS) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_dotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: DU_full      !< Delta U used for extra moment, size nDOF [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_full      !< Displacement of all DOFs (full system) with SIM [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_full_NS      !< Displacement of all DOFs (full system), No SIM (NS) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_full_dot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_full_dotdot 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_full_elast      !< Elastic displacements for computation of K ue (without rigid body mode for floating), includes SIM [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: U_red 
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: FC_unit      !< Cable Force vector (for varying cable load, of unit cable load) [N]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: SDWrOutput      !< Data from previous step to be written to a SubDyn output file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AllOuts      !< Data for output file [-]
    REAL(DbKi)  :: LastOutTime      !< The time of the most recent stored output data [s]
    INTEGER(IntKi)  :: Decimat      !< Current output decimation counter [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fext      !< External loads on unconstrained DOFs [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Fext_red      !< External loads on constrained DOFs, Fext_red= T^t Fext [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_SIM      !< UL for SIM = PhiL qL0- PhiM qm0, size nL [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: UL_0m      !< Intermediate UL term for SIM = PhiM qm0, size nL [-]
  END TYPE SD_MiscVarType
! =======================
! =========  SD_ParameterType  =======
  TYPE, PUBLIC :: SD_ParameterType
    REAL(DbKi)  :: SDDeltaT      !< Time step (for integration of continuous states) [seconds]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1/2/3)Length of y2 array [-]
    INTEGER(IntKi)  :: nDOF      !< Total degree of freedom [-]
    INTEGER(IntKi)  :: nDOF_red      !< Total degree of freedom after constraint reduction [-]
    INTEGER(IntKi)  :: Nmembers      !< Number of members of the sub structure [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Elems      !< Element nodes connections [-]
    TYPE(ElemPropType) , DIMENSION(:), ALLOCATABLE  :: ElemProps      !< List of element properties [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: FG      !< Gravity force vector (with initial cable force T0), not reduced [N]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: DP0      !< Vector from TP to a Node at t=0, used for Floating Rigid Body motion [m]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: NodeID2JointID      !< Store Joint ID for each NodeID since SubDyn re-label nodes (and add more nodes) [-]
    LOGICAL  :: reduced      !< True if system has been reduced to account for constraints [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: T_red      !< Transformation matrix performing the constraint reduction x = T. xtilde [-]
    REAL(R8Ki) , DIMENSION(:,:), ALLOCATABLE  :: T_red_T      !< Transpose of T_red [-]
    TYPE(IList) , DIMENSION(:), ALLOCATABLE  :: NodesDOF      !< DOF indices of each nodes in unconstrained assembled system  [-]
    TYPE(IList) , DIMENSION(:), ALLOCATABLE  :: NodesDOFred      !< DOF indices of each nodes in constrained assembled system  [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: ElemsDOF      !< 12 DOF indices of node 1 and 2 of a given member in unconstrained assembled system  [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: DOFred2Nodes      !< nDOFRed x 3, for each constrained DOF, col1 node index, col2 number of DOF, col3 DOF starting from 1 [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: CtrlElem2Channel      !< nCtrlCable x 2, for each CtrlCable, Elem index, and Channel Index [-]
    INTEGER(IntKi)  :: nDOFM      !< retained degrees of freedom (modes) [-]
    INTEGER(IntKi)  :: SttcSolve      !< Solve dynamics about static equilibrium point (flag) [-]
    LOGICAL  :: GuyanLoadCorrection      !< Add Extra lever arm contribution to interface reaction outputs [-]
    LOGICAL  :: Floating      !< True if floating bottom (the 6 DOF are free at all reaction nodes) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: KMMDiag      !< Diagonal coefficients of Kmm (OmegaM squared) [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CMMDiag      !< Diagonal coefficients of Cmm (~2 Zeta OmegaM)) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MMB      !< Matrix after C-B reduction (transpose of MBM [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBmmB      !< MBm * MmB, used for Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_11      !< Coefficient of x in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C1_12      !< Coefficient of x in Y1 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_141      !< MBm PhiM^T [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D1_142      !< TI^T PhiR^T [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiM      !< Coefficient of x in Y2 [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_61      !< Coefficient of x in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: C2_62      !< Coefficient of x in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiRb_TI      !< Coefficient of u in Y2 (Phi_R bar * TI) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_63      !< Coefficient of u in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: D2_64      !< Coefficient of u in Y2 (URdotdot ULdotdot) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBB      !< Guyan Mass Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KBB      !< Guyan Stiffness Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CBB      !< Guyan Damping Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: CMM      !< CB damping matrix [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: MBM      !< Matrix after C-B reduction [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiL_T      !< Transpose of Matrix of C-B  modes [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: PhiLInvOmgL2      !< Matrix of C-B  modes times the inverse of OmegaL**2 (Phi_L*(Omg**2)^-1) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: KLLm1      !< KLL^{-1}, inverse of matrix KLL, for static solve only [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: AM2Jac      !< Jacobian (factored) for Adams-Boulton 2nd order Integration [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: AM2JacPiv      !< Pivot array for Jacobian factorization (for Adams-Boulton 2nd order Integration) [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TI      !< Matrix to calculate TP reference point reaction at top of structure [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: TIreact      !< Matrix to calculate single point reaction at base of structure [-]
    INTEGER(IntKi)  :: nNodes      !< Total number of nodes [-]
    INTEGER(IntKi)  :: nNodes_I      !< Number of Interface nodes [-]
    INTEGER(IntKi)  :: nNodes_L      !< Number of Internal nodes [-]
    INTEGER(IntKi)  :: nNodes_C      !< Number of joints with reactions [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes_I      !< Interface degree of freedoms [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes_L      !< Internal nodes (not interface nor reaction) [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Nodes_C      !< React degree of freedoms [-]
    INTEGER(IntKi)  :: nDOFI__      !< Size of IDI__ [-]
    INTEGER(IntKi)  :: nDOFI_Rb      !< Size of IDI_Rb [-]
    INTEGER(IntKi)  :: nDOFI_F      !< Size of IDI_F [-]
    INTEGER(IntKi)  :: nDOFL_L      !< Size of IDL_L [-]
    INTEGER(IntKi)  :: nDOFC__      !< Size of IDC__ [-]
    INTEGER(IntKi)  :: nDOFC_Rb      !< Size of IDC_Rb [-]
    INTEGER(IntKi)  :: nDOFC_L      !< Size of IDC_L [-]
    INTEGER(IntKi)  :: nDOFC_F      !< Size of IDC_F [-]
    INTEGER(IntKi)  :: nDOFR__      !< Size of IDR__ [-]
    INTEGER(IntKi)  :: nDOF__Rb      !< Size of ID__Rb [-]
    INTEGER(IntKi)  :: nDOF__L      !< Size of ID__L [-]
    INTEGER(IntKi)  :: nDOF__F      !< Size of ID__F [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI__      !< Index of all Interface DOFs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI_Rb      !< Index array of the interface (nodes connect to TP) dofs that are retained/master/follower DOFs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDI_F      !< Index array of the interface (nodes connect to TP) dofs that are fixed DOF [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDL_L      !< Index array of the internal dofs coming from internal nodes [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC__      !< Index of all bottom DOF [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC_Rb      !< Index array of the contraint dofs that are retained/master/follower DOF [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC_L      !< Index array of the contraint dofs that are follower/internal DOF [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDC_F      !< Index array of the contraint dofs that are fixd DOF [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: IDR__      !< Index array of the interface and restraint dofs [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ID__Rb      !< Index array of all the retained/leader/master dofs (from any nodes of the structure) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ID__L      !< Index array of all the follower/internal dofs (from any nodes of the structure) [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: ID__F      !< Index array of the DOF that are fixed (from any nodes of the structure) [-]
    INTEGER(IntKi)  :: NMOutputs      !< Number of members whose output is written [-]
    INTEGER(IntKi)  :: NumOuts      !< Number of output channels read from input file [-]
    INTEGER(IntKi)  :: OutSwtch      !< Output Requested Channels to local or global output file [1/2/3] [-]
    INTEGER(IntKi)  :: UnJckF      !< Unit of SD ouput file [-]
    CHARACTER(1)  :: Delim      !< Column delimiter for output text files [-]
    CHARACTER(20)  :: OutFmt      !< Format for Output [-]
    CHARACTER(20)  :: OutSFmt      !< Format for Output Headers [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst      !< List of user requested members and nodes [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst2      !< List of all member joint nodes and elements for output [-]
    TYPE(MeshAuxDataType) , DIMENSION(:), ALLOCATABLE  :: MoutLst3      !< List of all member joint nodes and elements for output [-]
    TYPE(OutParmType) , DIMENSION(:), ALLOCATABLE  :: OutParam      !< An array holding names, units, and indices of all of the selected output channels. # logical [-]
    LOGICAL  :: OutAll      !< Flag to output or not all joint forces [-]
    INTEGER(IntKi)  :: OutCBModes      !< Flag to output CB and Guyan modes to a given format [-]
    INTEGER(IntKi)  :: OutFEMModes      !< Flag to output FEM modes to a given format [-]
    LOGICAL  :: OutReact      !< Flag to check whether reactions are requested [-]
    INTEGER(IntKi)  :: OutAllInt      !< Integer version of OutAll [-]
    INTEGER(IntKi)  :: OutAllDims      !< Integer version of OutAll [-]
    INTEGER(IntKi)  :: OutDec      !< Output Decimation for Requested Channels [-]
    INTEGER(IntKi) , DIMENSION(:,:), ALLOCATABLE  :: Jac_u_indx      !< matrix to help fill/pack the u vector in computing the jacobian [-]
    REAL(R8Ki) , DIMENSION(:), ALLOCATABLE  :: du      !< vector that determines size of perturbation for u (inputs) [-]
    REAL(R8Ki) , DIMENSION(1:2)  :: dx      !< vector that determines size of perturbation for x (continuous states) [-]
    INTEGER(IntKi)  :: Jac_ny      !< number of outputs in jacobian matrix [-]
    INTEGER(IntKi)  :: Jac_nx      !< half the number of continuous states in jacobian matrix [-]
    LOGICAL  :: RotStates      !< Orient states in rotating frame during linearization? (flag) [-]
  END TYPE SD_ParameterType
! =======================
! =========  SD_InputType  =======
  TYPE, PUBLIC :: SD_InputType
    TYPE(MeshType)  :: TPMesh      !< Transition piece inputs on a point mesh [-]
    TYPE(MeshType)  :: LMesh      !< Point mesh for interior node inputs [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: CableDeltaL      !< Cable tension, control input [-]
  END TYPE SD_InputType
! =======================
! =========  SD_OutputType  =======
  TYPE, PUBLIC :: SD_OutputType
    TYPE(MeshType)  :: Y1Mesh      !< Transition piece outputs on a point mesh [-]
    TYPE(MeshType)  :: Y2Mesh      !< Interior+Interface nodes rigid body displacements + elastic velocities and accelerations on a point mesh [-]
    TYPE(MeshType)  :: Y3Mesh      !< Interior+Interface nodes full elastic displacements/velocities and accelerations on a point mesh [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WriteOutput      !< Data to be written to an output file [-]
  END TYPE SD_OutputType
! =======================
CONTAINS
 SUBROUTINE SD_CopyIList( SrcIListData, DstIListData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IList), INTENT(IN) :: SrcIListData
   TYPE(IList), INTENT(INOUT) :: DstIListData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyIList'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcIListData%List)) THEN
  i1_l = LBOUND(SrcIListData%List,1)
  i1_u = UBOUND(SrcIListData%List,1)
  IF (.NOT. ALLOCATED(DstIListData%List)) THEN 
    ALLOCATE(DstIListData%List(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstIListData%List.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstIListData%List = SrcIListData%List
ENDIF
 END SUBROUTINE SD_CopyIList

 SUBROUTINE SD_DestroyIList( IListData, ErrStat, ErrMsg )
  TYPE(IList), INTENT(INOUT) :: IListData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyIList'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(IListData%List)) THEN
  DEALLOCATE(IListData%List)
ENDIF
 END SUBROUTINE SD_DestroyIList


subroutine SD_PackIList(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(IList), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackIList'
   if (Buf%ErrStat >= AbortErrLev) return
   ! List
   call RegPack(Buf, allocated(InData%List))
   if (allocated(InData%List)) then
      call RegPackBounds(Buf, 1, lbound(InData%List), ubound(InData%List))
      call RegPack(Buf, InData%List)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackIList(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(IList), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackIList'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! List
   if (allocated(OutData%List)) deallocate(OutData%List)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%List(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%List.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%List)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyMeshAuxDataType( SrcMeshAuxDataTypeData, DstMeshAuxDataTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MeshAuxDataType), INTENT(IN) :: SrcMeshAuxDataTypeData
   TYPE(MeshAuxDataType), INTENT(INOUT) :: DstMeshAuxDataTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyMeshAuxDataType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMeshAuxDataTypeData%MemberID = SrcMeshAuxDataTypeData%MemberID
    DstMeshAuxDataTypeData%NOutCnt = SrcMeshAuxDataTypeData%NOutCnt
IF (ALLOCATED(SrcMeshAuxDataTypeData%NodeCnt)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%NodeCnt,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%NodeCnt,1)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%NodeCnt)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%NodeCnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%NodeCnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%NodeCnt = SrcMeshAuxDataTypeData%NodeCnt
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%NodeIDs)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%NodeIDs,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%NodeIDs,1)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%NodeIDs)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%NodeIDs(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%NodeIDs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%NodeIDs = SrcMeshAuxDataTypeData%NodeIDs
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%ElmIDs)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%ElmIDs,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%ElmIDs,1)
  i2_l = LBOUND(SrcMeshAuxDataTypeData%ElmIDs,2)
  i2_u = UBOUND(SrcMeshAuxDataTypeData%ElmIDs,2)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%ElmIDs)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%ElmIDs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%ElmIDs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%ElmIDs = SrcMeshAuxDataTypeData%ElmIDs
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%ElmNds)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%ElmNds,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%ElmNds,1)
  i2_l = LBOUND(SrcMeshAuxDataTypeData%ElmNds,2)
  i2_u = UBOUND(SrcMeshAuxDataTypeData%ElmNds,2)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%ElmNds)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%ElmNds(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%ElmNds.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%ElmNds = SrcMeshAuxDataTypeData%ElmNds
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%Me)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%Me,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%Me,1)
  i2_l = LBOUND(SrcMeshAuxDataTypeData%Me,2)
  i2_u = UBOUND(SrcMeshAuxDataTypeData%Me,2)
  i3_l = LBOUND(SrcMeshAuxDataTypeData%Me,3)
  i3_u = UBOUND(SrcMeshAuxDataTypeData%Me,3)
  i4_l = LBOUND(SrcMeshAuxDataTypeData%Me,4)
  i4_u = UBOUND(SrcMeshAuxDataTypeData%Me,4)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%Me)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%Me(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%Me.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%Me = SrcMeshAuxDataTypeData%Me
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%Ke)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%Ke,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%Ke,1)
  i2_l = LBOUND(SrcMeshAuxDataTypeData%Ke,2)
  i2_u = UBOUND(SrcMeshAuxDataTypeData%Ke,2)
  i3_l = LBOUND(SrcMeshAuxDataTypeData%Ke,3)
  i3_u = UBOUND(SrcMeshAuxDataTypeData%Ke,3)
  i4_l = LBOUND(SrcMeshAuxDataTypeData%Ke,4)
  i4_u = UBOUND(SrcMeshAuxDataTypeData%Ke,4)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%Ke)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%Ke(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%Ke.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%Ke = SrcMeshAuxDataTypeData%Ke
ENDIF
IF (ALLOCATED(SrcMeshAuxDataTypeData%Fg)) THEN
  i1_l = LBOUND(SrcMeshAuxDataTypeData%Fg,1)
  i1_u = UBOUND(SrcMeshAuxDataTypeData%Fg,1)
  i2_l = LBOUND(SrcMeshAuxDataTypeData%Fg,2)
  i2_u = UBOUND(SrcMeshAuxDataTypeData%Fg,2)
  i3_l = LBOUND(SrcMeshAuxDataTypeData%Fg,3)
  i3_u = UBOUND(SrcMeshAuxDataTypeData%Fg,3)
  IF (.NOT. ALLOCATED(DstMeshAuxDataTypeData%Fg)) THEN 
    ALLOCATE(DstMeshAuxDataTypeData%Fg(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMeshAuxDataTypeData%Fg.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMeshAuxDataTypeData%Fg = SrcMeshAuxDataTypeData%Fg
ENDIF
 END SUBROUTINE SD_CopyMeshAuxDataType

 SUBROUTINE SD_DestroyMeshAuxDataType( MeshAuxDataTypeData, ErrStat, ErrMsg )
  TYPE(MeshAuxDataType), INTENT(INOUT) :: MeshAuxDataTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyMeshAuxDataType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MeshAuxDataTypeData%NodeCnt)) THEN
  DEALLOCATE(MeshAuxDataTypeData%NodeCnt)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%NodeIDs)) THEN
  DEALLOCATE(MeshAuxDataTypeData%NodeIDs)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%ElmIDs)) THEN
  DEALLOCATE(MeshAuxDataTypeData%ElmIDs)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%ElmNds)) THEN
  DEALLOCATE(MeshAuxDataTypeData%ElmNds)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%Me)) THEN
  DEALLOCATE(MeshAuxDataTypeData%Me)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%Ke)) THEN
  DEALLOCATE(MeshAuxDataTypeData%Ke)
ENDIF
IF (ALLOCATED(MeshAuxDataTypeData%Fg)) THEN
  DEALLOCATE(MeshAuxDataTypeData%Fg)
ENDIF
 END SUBROUTINE SD_DestroyMeshAuxDataType


subroutine SD_PackMeshAuxDataType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(MeshAuxDataType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackMeshAuxDataType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! MemberID
   call RegPack(Buf, InData%MemberID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutCnt
   call RegPack(Buf, InData%NOutCnt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeCnt
   call RegPack(Buf, allocated(InData%NodeCnt))
   if (allocated(InData%NodeCnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%NodeCnt), ubound(InData%NodeCnt))
      call RegPack(Buf, InData%NodeCnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeIDs
   call RegPack(Buf, allocated(InData%NodeIDs))
   if (allocated(InData%NodeIDs)) then
      call RegPackBounds(Buf, 1, lbound(InData%NodeIDs), ubound(InData%NodeIDs))
      call RegPack(Buf, InData%NodeIDs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElmIDs
   call RegPack(Buf, allocated(InData%ElmIDs))
   if (allocated(InData%ElmIDs)) then
      call RegPackBounds(Buf, 2, lbound(InData%ElmIDs), ubound(InData%ElmIDs))
      call RegPack(Buf, InData%ElmIDs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElmNds
   call RegPack(Buf, allocated(InData%ElmNds))
   if (allocated(InData%ElmNds)) then
      call RegPackBounds(Buf, 2, lbound(InData%ElmNds), ubound(InData%ElmNds))
      call RegPack(Buf, InData%ElmNds)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Me
   call RegPack(Buf, allocated(InData%Me))
   if (allocated(InData%Me)) then
      call RegPackBounds(Buf, 4, lbound(InData%Me), ubound(InData%Me))
      call RegPack(Buf, InData%Me)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ke
   call RegPack(Buf, allocated(InData%Ke))
   if (allocated(InData%Ke)) then
      call RegPackBounds(Buf, 4, lbound(InData%Ke), ubound(InData%Ke))
      call RegPack(Buf, InData%Ke)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fg
   call RegPack(Buf, allocated(InData%Fg))
   if (allocated(InData%Fg)) then
      call RegPackBounds(Buf, 3, lbound(InData%Fg), ubound(InData%Fg))
      call RegPack(Buf, InData%Fg)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackMeshAuxDataType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(MeshAuxDataType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackMeshAuxDataType'
   integer(IntKi)  :: LB(4), UB(4)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! MemberID
   call RegUnpack(Buf, OutData%MemberID)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NOutCnt
   call RegUnpack(Buf, OutData%NOutCnt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeCnt
   if (allocated(OutData%NodeCnt)) deallocate(OutData%NodeCnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodeCnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodeCnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NodeCnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NodeIDs
   if (allocated(OutData%NodeIDs)) deallocate(OutData%NodeIDs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodeIDs(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodeIDs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NodeIDs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ElmIDs
   if (allocated(OutData%ElmIDs)) deallocate(OutData%ElmIDs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElmIDs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElmIDs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElmIDs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ElmNds
   if (allocated(OutData%ElmNds)) deallocate(OutData%ElmNds)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElmNds(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElmNds.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElmNds)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Me
   if (allocated(OutData%Me)) deallocate(OutData%Me)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Me(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Me.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Me)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ke
   if (allocated(OutData%Ke)) deallocate(OutData%Ke)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 4, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Ke(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3),LB(4):UB(4)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ke.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Ke)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Fg
   if (allocated(OutData%Fg)) deallocate(OutData%Fg)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Fg(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fg.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Fg)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyCB_MatArrays( SrcCB_MatArraysData, DstCB_MatArraysData, CtrlCode, ErrStat, ErrMsg )
   TYPE(CB_MatArrays), INTENT(IN) :: SrcCB_MatArraysData
   TYPE(CB_MatArrays), INTENT(INOUT) :: DstCB_MatArraysData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyCB_MatArrays'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcCB_MatArraysData%MBB)) THEN
  i1_l = LBOUND(SrcCB_MatArraysData%MBB,1)
  i1_u = UBOUND(SrcCB_MatArraysData%MBB,1)
  i2_l = LBOUND(SrcCB_MatArraysData%MBB,2)
  i2_u = UBOUND(SrcCB_MatArraysData%MBB,2)
  IF (.NOT. ALLOCATED(DstCB_MatArraysData%MBB)) THEN 
    ALLOCATE(DstCB_MatArraysData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%MBB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCB_MatArraysData%MBB = SrcCB_MatArraysData%MBB
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%MBM)) THEN
  i1_l = LBOUND(SrcCB_MatArraysData%MBM,1)
  i1_u = UBOUND(SrcCB_MatArraysData%MBM,1)
  i2_l = LBOUND(SrcCB_MatArraysData%MBM,2)
  i2_u = UBOUND(SrcCB_MatArraysData%MBM,2)
  IF (.NOT. ALLOCATED(DstCB_MatArraysData%MBM)) THEN 
    ALLOCATE(DstCB_MatArraysData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%MBM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCB_MatArraysData%MBM = SrcCB_MatArraysData%MBM
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%KBB)) THEN
  i1_l = LBOUND(SrcCB_MatArraysData%KBB,1)
  i1_u = UBOUND(SrcCB_MatArraysData%KBB,1)
  i2_l = LBOUND(SrcCB_MatArraysData%KBB,2)
  i2_u = UBOUND(SrcCB_MatArraysData%KBB,2)
  IF (.NOT. ALLOCATED(DstCB_MatArraysData%KBB)) THEN 
    ALLOCATE(DstCB_MatArraysData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%KBB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCB_MatArraysData%KBB = SrcCB_MatArraysData%KBB
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%PhiL)) THEN
  i1_l = LBOUND(SrcCB_MatArraysData%PhiL,1)
  i1_u = UBOUND(SrcCB_MatArraysData%PhiL,1)
  i2_l = LBOUND(SrcCB_MatArraysData%PhiL,2)
  i2_u = UBOUND(SrcCB_MatArraysData%PhiL,2)
  IF (.NOT. ALLOCATED(DstCB_MatArraysData%PhiL)) THEN 
    ALLOCATE(DstCB_MatArraysData%PhiL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%PhiL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCB_MatArraysData%PhiL = SrcCB_MatArraysData%PhiL
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%PhiR)) THEN
  i1_l = LBOUND(SrcCB_MatArraysData%PhiR,1)
  i1_u = UBOUND(SrcCB_MatArraysData%PhiR,1)
  i2_l = LBOUND(SrcCB_MatArraysData%PhiR,2)
  i2_u = UBOUND(SrcCB_MatArraysData%PhiR,2)
  IF (.NOT. ALLOCATED(DstCB_MatArraysData%PhiR)) THEN 
    ALLOCATE(DstCB_MatArraysData%PhiR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%PhiR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCB_MatArraysData%PhiR = SrcCB_MatArraysData%PhiR
ENDIF
IF (ALLOCATED(SrcCB_MatArraysData%OmegaL)) THEN
  i1_l = LBOUND(SrcCB_MatArraysData%OmegaL,1)
  i1_u = UBOUND(SrcCB_MatArraysData%OmegaL,1)
  IF (.NOT. ALLOCATED(DstCB_MatArraysData%OmegaL)) THEN 
    ALLOCATE(DstCB_MatArraysData%OmegaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstCB_MatArraysData%OmegaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstCB_MatArraysData%OmegaL = SrcCB_MatArraysData%OmegaL
ENDIF
 END SUBROUTINE SD_CopyCB_MatArrays

 SUBROUTINE SD_DestroyCB_MatArrays( CB_MatArraysData, ErrStat, ErrMsg )
  TYPE(CB_MatArrays), INTENT(INOUT) :: CB_MatArraysData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyCB_MatArrays'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(CB_MatArraysData%MBB)) THEN
  DEALLOCATE(CB_MatArraysData%MBB)
ENDIF
IF (ALLOCATED(CB_MatArraysData%MBM)) THEN
  DEALLOCATE(CB_MatArraysData%MBM)
ENDIF
IF (ALLOCATED(CB_MatArraysData%KBB)) THEN
  DEALLOCATE(CB_MatArraysData%KBB)
ENDIF
IF (ALLOCATED(CB_MatArraysData%PhiL)) THEN
  DEALLOCATE(CB_MatArraysData%PhiL)
ENDIF
IF (ALLOCATED(CB_MatArraysData%PhiR)) THEN
  DEALLOCATE(CB_MatArraysData%PhiR)
ENDIF
IF (ALLOCATED(CB_MatArraysData%OmegaL)) THEN
  DEALLOCATE(CB_MatArraysData%OmegaL)
ENDIF
 END SUBROUTINE SD_DestroyCB_MatArrays


subroutine SD_PackCB_MatArrays(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(CB_MatArrays), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackCB_MatArrays'
   if (Buf%ErrStat >= AbortErrLev) return
   ! MBB
   call RegPack(Buf, allocated(InData%MBB))
   if (allocated(InData%MBB)) then
      call RegPackBounds(Buf, 2, lbound(InData%MBB), ubound(InData%MBB))
      call RegPack(Buf, InData%MBB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MBM
   call RegPack(Buf, allocated(InData%MBM))
   if (allocated(InData%MBM)) then
      call RegPackBounds(Buf, 2, lbound(InData%MBM), ubound(InData%MBM))
      call RegPack(Buf, InData%MBM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! KBB
   call RegPack(Buf, allocated(InData%KBB))
   if (allocated(InData%KBB)) then
      call RegPackBounds(Buf, 2, lbound(InData%KBB), ubound(InData%KBB))
      call RegPack(Buf, InData%KBB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiL
   call RegPack(Buf, allocated(InData%PhiL))
   if (allocated(InData%PhiL)) then
      call RegPackBounds(Buf, 2, lbound(InData%PhiL), ubound(InData%PhiL))
      call RegPack(Buf, InData%PhiL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiR
   call RegPack(Buf, allocated(InData%PhiR))
   if (allocated(InData%PhiR)) then
      call RegPackBounds(Buf, 2, lbound(InData%PhiR), ubound(InData%PhiR))
      call RegPack(Buf, InData%PhiR)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OmegaL
   call RegPack(Buf, allocated(InData%OmegaL))
   if (allocated(InData%OmegaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%OmegaL), ubound(InData%OmegaL))
      call RegPack(Buf, InData%OmegaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackCB_MatArrays(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(CB_MatArrays), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackCB_MatArrays'
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! MBB
   if (allocated(OutData%MBB)) deallocate(OutData%MBB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MBB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MBB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MBB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MBM
   if (allocated(OutData%MBM)) deallocate(OutData%MBM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MBM(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MBM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MBM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! KBB
   if (allocated(OutData%KBB)) deallocate(OutData%KBB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%KBB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%KBB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%KBB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PhiL
   if (allocated(OutData%PhiL)) deallocate(OutData%PhiL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PhiL(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PhiL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PhiL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PhiR
   if (allocated(OutData%PhiR)) deallocate(OutData%PhiR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PhiR(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PhiR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PhiR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OmegaL
   if (allocated(OutData%OmegaL)) deallocate(OutData%OmegaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OmegaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OmegaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%OmegaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyElemPropType( SrcElemPropTypeData, DstElemPropTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(ElemPropType), INTENT(IN) :: SrcElemPropTypeData
   TYPE(ElemPropType), INTENT(INOUT) :: DstElemPropTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyElemPropType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstElemPropTypeData%eType = SrcElemPropTypeData%eType
    DstElemPropTypeData%Length = SrcElemPropTypeData%Length
    DstElemPropTypeData%Ixx = SrcElemPropTypeData%Ixx
    DstElemPropTypeData%Iyy = SrcElemPropTypeData%Iyy
    DstElemPropTypeData%Jzz = SrcElemPropTypeData%Jzz
    DstElemPropTypeData%Shear = SrcElemPropTypeData%Shear
    DstElemPropTypeData%Kappa_x = SrcElemPropTypeData%Kappa_x
    DstElemPropTypeData%Kappa_y = SrcElemPropTypeData%Kappa_y
    DstElemPropTypeData%YoungE = SrcElemPropTypeData%YoungE
    DstElemPropTypeData%ShearG = SrcElemPropTypeData%ShearG
    DstElemPropTypeData%D = SrcElemPropTypeData%D
    DstElemPropTypeData%Area = SrcElemPropTypeData%Area
    DstElemPropTypeData%Rho = SrcElemPropTypeData%Rho
    DstElemPropTypeData%T0 = SrcElemPropTypeData%T0
    DstElemPropTypeData%DirCos = SrcElemPropTypeData%DirCos
 END SUBROUTINE SD_CopyElemPropType

 SUBROUTINE SD_DestroyElemPropType( ElemPropTypeData, ErrStat, ErrMsg )
  TYPE(ElemPropType), INTENT(INOUT) :: ElemPropTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyElemPropType'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SD_DestroyElemPropType


subroutine SD_PackElemPropType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(ElemPropType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackElemPropType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! eType
   call RegPack(Buf, InData%eType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Length
   call RegPack(Buf, InData%Length)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ixx
   call RegPack(Buf, InData%Ixx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Iyy
   call RegPack(Buf, InData%Iyy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jzz
   call RegPack(Buf, InData%Jzz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Shear
   call RegPack(Buf, InData%Shear)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Kappa_x
   call RegPack(Buf, InData%Kappa_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Kappa_y
   call RegPack(Buf, InData%Kappa_y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YoungE
   call RegPack(Buf, InData%YoungE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShearG
   call RegPack(Buf, InData%ShearG)
   if (RegCheckErr(Buf, RoutineName)) return
   ! D
   call RegPack(Buf, InData%D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Area
   call RegPack(Buf, InData%Area)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rho
   call RegPack(Buf, InData%Rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! T0
   call RegPack(Buf, InData%T0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DirCos
   call RegPack(Buf, InData%DirCos)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackElemPropType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(ElemPropType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackElemPropType'
   if (Buf%ErrStat /= ErrID_None) return
   ! eType
   call RegUnpack(Buf, OutData%eType)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Length
   call RegUnpack(Buf, OutData%Length)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ixx
   call RegUnpack(Buf, OutData%Ixx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Iyy
   call RegUnpack(Buf, OutData%Iyy)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jzz
   call RegUnpack(Buf, OutData%Jzz)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Shear
   call RegUnpack(Buf, OutData%Shear)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Kappa_x
   call RegUnpack(Buf, OutData%Kappa_x)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Kappa_y
   call RegUnpack(Buf, OutData%Kappa_y)
   if (RegCheckErr(Buf, RoutineName)) return
   ! YoungE
   call RegUnpack(Buf, OutData%YoungE)
   if (RegCheckErr(Buf, RoutineName)) return
   ! ShearG
   call RegUnpack(Buf, OutData%ShearG)
   if (RegCheckErr(Buf, RoutineName)) return
   ! D
   call RegUnpack(Buf, OutData%D)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Area
   call RegUnpack(Buf, OutData%Area)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Rho
   call RegUnpack(Buf, OutData%Rho)
   if (RegCheckErr(Buf, RoutineName)) return
   ! T0
   call RegUnpack(Buf, OutData%T0)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DirCos
   call RegUnpack(Buf, OutData%DirCos)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InitInputType), INTENT(INOUT) :: SrcInitInputData
   TYPE(SD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%SDInputFile = SrcInitInputData%SDInputFile
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%g = SrcInitInputData%g
    DstInitInputData%WtrDpth = SrcInitInputData%WtrDpth
    DstInitInputData%TP_RefPoint = SrcInitInputData%TP_RefPoint
    DstInitInputData%SubRotateZ = SrcInitInputData%SubRotateZ
IF (ALLOCATED(SrcInitInputData%SoilStiffness)) THEN
  i1_l = LBOUND(SrcInitInputData%SoilStiffness,1)
  i1_u = UBOUND(SrcInitInputData%SoilStiffness,1)
  i2_l = LBOUND(SrcInitInputData%SoilStiffness,2)
  i2_u = UBOUND(SrcInitInputData%SoilStiffness,2)
  i3_l = LBOUND(SrcInitInputData%SoilStiffness,3)
  i3_u = UBOUND(SrcInitInputData%SoilStiffness,3)
  IF (.NOT. ALLOCATED(DstInitInputData%SoilStiffness)) THEN 
    ALLOCATE(DstInitInputData%SoilStiffness(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%SoilStiffness.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%SoilStiffness = SrcInitInputData%SoilStiffness
ENDIF
      CALL MeshCopy( SrcInitInputData%SoilMesh, DstInitInputData%SoilMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    DstInitInputData%Linearize = SrcInitInputData%Linearize
 END SUBROUTINE SD_CopyInitInput

 SUBROUTINE SD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(SD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyInitInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitInputData%SoilStiffness)) THEN
  DEALLOCATE(InitInputData%SoilStiffness)
ENDIF
  CALL MeshDestroy( InitInputData%SoilMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
 END SUBROUTINE SD_DestroyInitInput


subroutine SD_PackInitInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_InitInputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackInitInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! SDInputFile
   call RegPack(Buf, InData%SDInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! g
   call RegPack(Buf, InData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegPack(Buf, InData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TP_RefPoint
   call RegPack(Buf, InData%TP_RefPoint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubRotateZ
   call RegPack(Buf, InData%SubRotateZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SoilStiffness
   call RegPack(Buf, allocated(InData%SoilStiffness))
   if (allocated(InData%SoilStiffness)) then
      call RegPackBounds(Buf, 3, lbound(InData%SoilStiffness), ubound(InData%SoilStiffness))
      call RegPack(Buf, InData%SoilStiffness)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SoilMesh
   call MeshPack(Buf, InData%SoilMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Linearize
   call RegPack(Buf, InData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackInitInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_InitInputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackInitInput'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! SDInputFile
   call RegUnpack(Buf, OutData%SDInputFile)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! g
   call RegUnpack(Buf, OutData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! WtrDpth
   call RegUnpack(Buf, OutData%WtrDpth)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TP_RefPoint
   call RegUnpack(Buf, OutData%TP_RefPoint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubRotateZ
   call RegUnpack(Buf, OutData%SubRotateZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SoilStiffness
   if (allocated(OutData%SoilStiffness)) deallocate(OutData%SoilStiffness)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SoilStiffness(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SoilStiffness.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SoilStiffness)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SoilMesh
   call MeshUnpack(Buf, OutData%SoilMesh) ! SoilMesh 
   ! Linearize
   call RegUnpack(Buf, OutData%Linearize)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(SD_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInitOutputData%WriteOutputHdr)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputHdr,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputHdr,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputHdr)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputHdr(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputHdr.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputHdr = SrcInitOutputData%WriteOutputHdr
ENDIF
IF (ALLOCATED(SrcInitOutputData%WriteOutputUnt)) THEN
  i1_l = LBOUND(SrcInitOutputData%WriteOutputUnt,1)
  i1_u = UBOUND(SrcInitOutputData%WriteOutputUnt,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%WriteOutputUnt)) THEN 
    ALLOCATE(DstInitOutputData%WriteOutputUnt(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%WriteOutputUnt.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%WriteOutputUnt = SrcInitOutputData%WriteOutputUnt
ENDIF
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInitOutputData%LinNames_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_y,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_y)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_y = SrcInitOutputData%LinNames_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_x,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_x)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_x = SrcInitOutputData%LinNames_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%LinNames_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%LinNames_u,1)
  i1_u = UBOUND(SrcInitOutputData%LinNames_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%LinNames_u)) THEN 
    ALLOCATE(DstInitOutputData%LinNames_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%LinNames_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%LinNames_u = SrcInitOutputData%LinNames_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_y)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_y,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_y,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_y)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_y(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_y.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_y = SrcInitOutputData%RotFrame_y
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_x,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_x)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_x = SrcInitOutputData%RotFrame_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%RotFrame_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%RotFrame_u,1)
  i1_u = UBOUND(SrcInitOutputData%RotFrame_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%RotFrame_u)) THEN 
    ALLOCATE(DstInitOutputData%RotFrame_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%RotFrame_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%RotFrame_u = SrcInitOutputData%RotFrame_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%IsLoad_u)) THEN
  i1_l = LBOUND(SrcInitOutputData%IsLoad_u,1)
  i1_u = UBOUND(SrcInitOutputData%IsLoad_u,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%IsLoad_u)) THEN 
    ALLOCATE(DstInitOutputData%IsLoad_u(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%IsLoad_u.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%IsLoad_u = SrcInitOutputData%IsLoad_u
ENDIF
IF (ALLOCATED(SrcInitOutputData%DerivOrder_x)) THEN
  i1_l = LBOUND(SrcInitOutputData%DerivOrder_x,1)
  i1_u = UBOUND(SrcInitOutputData%DerivOrder_x,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%DerivOrder_x)) THEN 
    ALLOCATE(DstInitOutputData%DerivOrder_x(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%DerivOrder_x.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%DerivOrder_x = SrcInitOutputData%DerivOrder_x
ENDIF
IF (ALLOCATED(SrcInitOutputData%CableCChanRqst)) THEN
  i1_l = LBOUND(SrcInitOutputData%CableCChanRqst,1)
  i1_u = UBOUND(SrcInitOutputData%CableCChanRqst,1)
  IF (.NOT. ALLOCATED(DstInitOutputData%CableCChanRqst)) THEN 
    ALLOCATE(DstInitOutputData%CableCChanRqst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitOutputData%CableCChanRqst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitOutputData%CableCChanRqst = SrcInitOutputData%CableCChanRqst
ENDIF
 END SUBROUTINE SD_CopyInitOutput

 SUBROUTINE SD_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(SD_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyInitOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitOutputData%WriteOutputHdr)) THEN
  DEALLOCATE(InitOutputData%WriteOutputHdr)
ENDIF
IF (ALLOCATED(InitOutputData%WriteOutputUnt)) THEN
  DEALLOCATE(InitOutputData%WriteOutputUnt)
ENDIF
  CALL NWTC_Library_DestroyProgDesc( InitOutputData%Ver, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InitOutputData%LinNames_y)) THEN
  DEALLOCATE(InitOutputData%LinNames_y)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_x)) THEN
  DEALLOCATE(InitOutputData%LinNames_x)
ENDIF
IF (ALLOCATED(InitOutputData%LinNames_u)) THEN
  DEALLOCATE(InitOutputData%LinNames_u)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_y)) THEN
  DEALLOCATE(InitOutputData%RotFrame_y)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_x)) THEN
  DEALLOCATE(InitOutputData%RotFrame_x)
ENDIF
IF (ALLOCATED(InitOutputData%RotFrame_u)) THEN
  DEALLOCATE(InitOutputData%RotFrame_u)
ENDIF
IF (ALLOCATED(InitOutputData%IsLoad_u)) THEN
  DEALLOCATE(InitOutputData%IsLoad_u)
ENDIF
IF (ALLOCATED(InitOutputData%DerivOrder_x)) THEN
  DEALLOCATE(InitOutputData%DerivOrder_x)
ENDIF
IF (ALLOCATED(InitOutputData%CableCChanRqst)) THEN
  DEALLOCATE(InitOutputData%CableCChanRqst)
ENDIF
 END SUBROUTINE SD_DestroyInitOutput


subroutine SD_PackInitOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_InitOutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackInitOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! WriteOutputHdr
   call RegPack(Buf, allocated(InData%WriteOutputHdr))
   if (allocated(InData%WriteOutputHdr)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputHdr), ubound(InData%WriteOutputHdr))
      call RegPack(Buf, InData%WriteOutputHdr)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutputUnt
   call RegPack(Buf, allocated(InData%WriteOutputUnt))
   if (allocated(InData%WriteOutputUnt)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutputUnt), ubound(InData%WriteOutputUnt))
      call RegPack(Buf, InData%WriteOutputUnt)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Ver
   call NWTC_Library_PackProgDesc(Buf, InData%Ver) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_y
   call RegPack(Buf, allocated(InData%LinNames_y))
   if (allocated(InData%LinNames_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_y), ubound(InData%LinNames_y))
      call RegPack(Buf, InData%LinNames_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_x
   call RegPack(Buf, allocated(InData%LinNames_x))
   if (allocated(InData%LinNames_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_x), ubound(InData%LinNames_x))
      call RegPack(Buf, InData%LinNames_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LinNames_u
   call RegPack(Buf, allocated(InData%LinNames_u))
   if (allocated(InData%LinNames_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%LinNames_u), ubound(InData%LinNames_u))
      call RegPack(Buf, InData%LinNames_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_y
   call RegPack(Buf, allocated(InData%RotFrame_y))
   if (allocated(InData%RotFrame_y)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_y), ubound(InData%RotFrame_y))
      call RegPack(Buf, InData%RotFrame_y)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_x
   call RegPack(Buf, allocated(InData%RotFrame_x))
   if (allocated(InData%RotFrame_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_x), ubound(InData%RotFrame_x))
      call RegPack(Buf, InData%RotFrame_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotFrame_u
   call RegPack(Buf, allocated(InData%RotFrame_u))
   if (allocated(InData%RotFrame_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%RotFrame_u), ubound(InData%RotFrame_u))
      call RegPack(Buf, InData%RotFrame_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IsLoad_u
   call RegPack(Buf, allocated(InData%IsLoad_u))
   if (allocated(InData%IsLoad_u)) then
      call RegPackBounds(Buf, 1, lbound(InData%IsLoad_u), ubound(InData%IsLoad_u))
      call RegPack(Buf, InData%IsLoad_u)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DerivOrder_x
   call RegPack(Buf, allocated(InData%DerivOrder_x))
   if (allocated(InData%DerivOrder_x)) then
      call RegPackBounds(Buf, 1, lbound(InData%DerivOrder_x), ubound(InData%DerivOrder_x))
      call RegPack(Buf, InData%DerivOrder_x)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableCChanRqst
   call RegPack(Buf, allocated(InData%CableCChanRqst))
   if (allocated(InData%CableCChanRqst)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableCChanRqst), ubound(InData%CableCChanRqst))
      call RegPack(Buf, InData%CableCChanRqst)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackInitOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_InitOutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackInitOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! WriteOutputHdr
   if (allocated(OutData%WriteOutputHdr)) deallocate(OutData%WriteOutputHdr)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputHdr(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputHdr.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputHdr)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! WriteOutputUnt
   if (allocated(OutData%WriteOutputUnt)) deallocate(OutData%WriteOutputUnt)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutputUnt(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutputUnt.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutputUnt)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Ver
   call NWTC_Library_UnpackProgDesc(Buf, OutData%Ver) ! Ver 
   ! LinNames_y
   if (allocated(OutData%LinNames_y)) deallocate(OutData%LinNames_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_x
   if (allocated(OutData%LinNames_x)) deallocate(OutData%LinNames_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LinNames_u
   if (allocated(OutData%LinNames_u)) deallocate(OutData%LinNames_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%LinNames_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%LinNames_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%LinNames_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_y
   if (allocated(OutData%RotFrame_y)) deallocate(OutData%RotFrame_y)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_y(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_y.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_y)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_x
   if (allocated(OutData%RotFrame_x)) deallocate(OutData%RotFrame_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! RotFrame_u
   if (allocated(OutData%RotFrame_u)) deallocate(OutData%RotFrame_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%RotFrame_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotFrame_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%RotFrame_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IsLoad_u
   if (allocated(OutData%IsLoad_u)) deallocate(OutData%IsLoad_u)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IsLoad_u(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IsLoad_u.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IsLoad_u)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DerivOrder_x
   if (allocated(OutData%DerivOrder_x)) deallocate(OutData%DerivOrder_x)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DerivOrder_x(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DerivOrder_x.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DerivOrder_x)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CableCChanRqst
   if (allocated(OutData%CableCChanRqst)) deallocate(OutData%CableCChanRqst)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableCChanRqst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableCChanRqst.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableCChanRqst)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyInitType( SrcInitTypeData, DstInitTypeData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InitType), INTENT(IN) :: SrcInitTypeData
   TYPE(SD_InitType), INTENT(INOUT) :: DstInitTypeData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyInitType'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitTypeData%RootName = SrcInitTypeData%RootName
    DstInitTypeData%TP_RefPoint = SrcInitTypeData%TP_RefPoint
    DstInitTypeData%SubRotateZ = SrcInitTypeData%SubRotateZ
    DstInitTypeData%g = SrcInitTypeData%g
    DstInitTypeData%DT = SrcInitTypeData%DT
    DstInitTypeData%NJoints = SrcInitTypeData%NJoints
    DstInitTypeData%NPropSetsX = SrcInitTypeData%NPropSetsX
    DstInitTypeData%NPropSetsB = SrcInitTypeData%NPropSetsB
    DstInitTypeData%NPropSetsC = SrcInitTypeData%NPropSetsC
    DstInitTypeData%NPropSetsR = SrcInitTypeData%NPropSetsR
    DstInitTypeData%NCMass = SrcInitTypeData%NCMass
    DstInitTypeData%NCOSMs = SrcInitTypeData%NCOSMs
    DstInitTypeData%FEMMod = SrcInitTypeData%FEMMod
    DstInitTypeData%NDiv = SrcInitTypeData%NDiv
    DstInitTypeData%CBMod = SrcInitTypeData%CBMod
IF (ALLOCATED(SrcInitTypeData%Joints)) THEN
  i1_l = LBOUND(SrcInitTypeData%Joints,1)
  i1_u = UBOUND(SrcInitTypeData%Joints,1)
  i2_l = LBOUND(SrcInitTypeData%Joints,2)
  i2_u = UBOUND(SrcInitTypeData%Joints,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%Joints)) THEN 
    ALLOCATE(DstInitTypeData%Joints(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Joints.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%Joints = SrcInitTypeData%Joints
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropSetsB)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropSetsB,1)
  i1_u = UBOUND(SrcInitTypeData%PropSetsB,1)
  i2_l = LBOUND(SrcInitTypeData%PropSetsB,2)
  i2_u = UBOUND(SrcInitTypeData%PropSetsB,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropSetsB)) THEN 
    ALLOCATE(DstInitTypeData%PropSetsB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropSetsB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropSetsB = SrcInitTypeData%PropSetsB
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropSetsC)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropSetsC,1)
  i1_u = UBOUND(SrcInitTypeData%PropSetsC,1)
  i2_l = LBOUND(SrcInitTypeData%PropSetsC,2)
  i2_u = UBOUND(SrcInitTypeData%PropSetsC,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropSetsC)) THEN 
    ALLOCATE(DstInitTypeData%PropSetsC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropSetsC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropSetsC = SrcInitTypeData%PropSetsC
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropSetsR)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropSetsR,1)
  i1_u = UBOUND(SrcInitTypeData%PropSetsR,1)
  i2_l = LBOUND(SrcInitTypeData%PropSetsR,2)
  i2_u = UBOUND(SrcInitTypeData%PropSetsR,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropSetsR)) THEN 
    ALLOCATE(DstInitTypeData%PropSetsR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropSetsR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropSetsR = SrcInitTypeData%PropSetsR
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropSetsX)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropSetsX,1)
  i1_u = UBOUND(SrcInitTypeData%PropSetsX,1)
  i2_l = LBOUND(SrcInitTypeData%PropSetsX,2)
  i2_u = UBOUND(SrcInitTypeData%PropSetsX,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropSetsX)) THEN 
    ALLOCATE(DstInitTypeData%PropSetsX(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropSetsX.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropSetsX = SrcInitTypeData%PropSetsX
ENDIF
IF (ALLOCATED(SrcInitTypeData%COSMs)) THEN
  i1_l = LBOUND(SrcInitTypeData%COSMs,1)
  i1_u = UBOUND(SrcInitTypeData%COSMs,1)
  i2_l = LBOUND(SrcInitTypeData%COSMs,2)
  i2_u = UBOUND(SrcInitTypeData%COSMs,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%COSMs)) THEN 
    ALLOCATE(DstInitTypeData%COSMs(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%COSMs.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%COSMs = SrcInitTypeData%COSMs
ENDIF
IF (ALLOCATED(SrcInitTypeData%CMass)) THEN
  i1_l = LBOUND(SrcInitTypeData%CMass,1)
  i1_u = UBOUND(SrcInitTypeData%CMass,1)
  i2_l = LBOUND(SrcInitTypeData%CMass,2)
  i2_u = UBOUND(SrcInitTypeData%CMass,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%CMass)) THEN 
    ALLOCATE(DstInitTypeData%CMass(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%CMass.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%CMass = SrcInitTypeData%CMass
ENDIF
IF (ALLOCATED(SrcInitTypeData%JDampings)) THEN
  i1_l = LBOUND(SrcInitTypeData%JDampings,1)
  i1_u = UBOUND(SrcInitTypeData%JDampings,1)
  IF (.NOT. ALLOCATED(DstInitTypeData%JDampings)) THEN 
    ALLOCATE(DstInitTypeData%JDampings(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%JDampings.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%JDampings = SrcInitTypeData%JDampings
ENDIF
    DstInitTypeData%GuyanDampMod = SrcInitTypeData%GuyanDampMod
    DstInitTypeData%RayleighDamp = SrcInitTypeData%RayleighDamp
    DstInitTypeData%GuyanDampMat = SrcInitTypeData%GuyanDampMat
IF (ALLOCATED(SrcInitTypeData%Members)) THEN
  i1_l = LBOUND(SrcInitTypeData%Members,1)
  i1_u = UBOUND(SrcInitTypeData%Members,1)
  i2_l = LBOUND(SrcInitTypeData%Members,2)
  i2_u = UBOUND(SrcInitTypeData%Members,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%Members)) THEN 
    ALLOCATE(DstInitTypeData%Members(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Members.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%Members = SrcInitTypeData%Members
ENDIF
IF (ALLOCATED(SrcInitTypeData%SSOutList)) THEN
  i1_l = LBOUND(SrcInitTypeData%SSOutList,1)
  i1_u = UBOUND(SrcInitTypeData%SSOutList,1)
  IF (.NOT. ALLOCATED(DstInitTypeData%SSOutList)) THEN 
    ALLOCATE(DstInitTypeData%SSOutList(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%SSOutList.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%SSOutList = SrcInitTypeData%SSOutList
ENDIF
    DstInitTypeData%OutCOSM = SrcInitTypeData%OutCOSM
    DstInitTypeData%TabDelim = SrcInitTypeData%TabDelim
IF (ALLOCATED(SrcInitTypeData%SSIK)) THEN
  i1_l = LBOUND(SrcInitTypeData%SSIK,1)
  i1_u = UBOUND(SrcInitTypeData%SSIK,1)
  i2_l = LBOUND(SrcInitTypeData%SSIK,2)
  i2_u = UBOUND(SrcInitTypeData%SSIK,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%SSIK)) THEN 
    ALLOCATE(DstInitTypeData%SSIK(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%SSIK.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%SSIK = SrcInitTypeData%SSIK
ENDIF
IF (ALLOCATED(SrcInitTypeData%SSIM)) THEN
  i1_l = LBOUND(SrcInitTypeData%SSIM,1)
  i1_u = UBOUND(SrcInitTypeData%SSIM,1)
  i2_l = LBOUND(SrcInitTypeData%SSIM,2)
  i2_u = UBOUND(SrcInitTypeData%SSIM,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%SSIM)) THEN 
    ALLOCATE(DstInitTypeData%SSIM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%SSIM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%SSIM = SrcInitTypeData%SSIM
ENDIF
IF (ALLOCATED(SrcInitTypeData%SSIfile)) THEN
  i1_l = LBOUND(SrcInitTypeData%SSIfile,1)
  i1_u = UBOUND(SrcInitTypeData%SSIfile,1)
  IF (.NOT. ALLOCATED(DstInitTypeData%SSIfile)) THEN 
    ALLOCATE(DstInitTypeData%SSIfile(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%SSIfile.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%SSIfile = SrcInitTypeData%SSIfile
ENDIF
IF (ALLOCATED(SrcInitTypeData%Soil_K)) THEN
  i1_l = LBOUND(SrcInitTypeData%Soil_K,1)
  i1_u = UBOUND(SrcInitTypeData%Soil_K,1)
  i2_l = LBOUND(SrcInitTypeData%Soil_K,2)
  i2_u = UBOUND(SrcInitTypeData%Soil_K,2)
  i3_l = LBOUND(SrcInitTypeData%Soil_K,3)
  i3_u = UBOUND(SrcInitTypeData%Soil_K,3)
  IF (.NOT. ALLOCATED(DstInitTypeData%Soil_K)) THEN 
    ALLOCATE(DstInitTypeData%Soil_K(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Soil_K.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%Soil_K = SrcInitTypeData%Soil_K
ENDIF
IF (ALLOCATED(SrcInitTypeData%Soil_Points)) THEN
  i1_l = LBOUND(SrcInitTypeData%Soil_Points,1)
  i1_u = UBOUND(SrcInitTypeData%Soil_Points,1)
  i2_l = LBOUND(SrcInitTypeData%Soil_Points,2)
  i2_u = UBOUND(SrcInitTypeData%Soil_Points,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%Soil_Points)) THEN 
    ALLOCATE(DstInitTypeData%Soil_Points(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Soil_Points.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%Soil_Points = SrcInitTypeData%Soil_Points
ENDIF
IF (ALLOCATED(SrcInitTypeData%Soil_Nodes)) THEN
  i1_l = LBOUND(SrcInitTypeData%Soil_Nodes,1)
  i1_u = UBOUND(SrcInitTypeData%Soil_Nodes,1)
  IF (.NOT. ALLOCATED(DstInitTypeData%Soil_Nodes)) THEN 
    ALLOCATE(DstInitTypeData%Soil_Nodes(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Soil_Nodes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%Soil_Nodes = SrcInitTypeData%Soil_Nodes
ENDIF
    DstInitTypeData%NElem = SrcInitTypeData%NElem
    DstInitTypeData%NPropB = SrcInitTypeData%NPropB
    DstInitTypeData%NPropC = SrcInitTypeData%NPropC
    DstInitTypeData%NPropR = SrcInitTypeData%NPropR
IF (ALLOCATED(SrcInitTypeData%Nodes)) THEN
  i1_l = LBOUND(SrcInitTypeData%Nodes,1)
  i1_u = UBOUND(SrcInitTypeData%Nodes,1)
  i2_l = LBOUND(SrcInitTypeData%Nodes,2)
  i2_u = UBOUND(SrcInitTypeData%Nodes,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%Nodes)) THEN 
    ALLOCATE(DstInitTypeData%Nodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%Nodes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%Nodes = SrcInitTypeData%Nodes
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropsB)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropsB,1)
  i1_u = UBOUND(SrcInitTypeData%PropsB,1)
  i2_l = LBOUND(SrcInitTypeData%PropsB,2)
  i2_u = UBOUND(SrcInitTypeData%PropsB,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropsB)) THEN 
    ALLOCATE(DstInitTypeData%PropsB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropsB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropsB = SrcInitTypeData%PropsB
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropsC)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropsC,1)
  i1_u = UBOUND(SrcInitTypeData%PropsC,1)
  i2_l = LBOUND(SrcInitTypeData%PropsC,2)
  i2_u = UBOUND(SrcInitTypeData%PropsC,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropsC)) THEN 
    ALLOCATE(DstInitTypeData%PropsC(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropsC.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropsC = SrcInitTypeData%PropsC
ENDIF
IF (ALLOCATED(SrcInitTypeData%PropsR)) THEN
  i1_l = LBOUND(SrcInitTypeData%PropsR,1)
  i1_u = UBOUND(SrcInitTypeData%PropsR,1)
  i2_l = LBOUND(SrcInitTypeData%PropsR,2)
  i2_u = UBOUND(SrcInitTypeData%PropsR,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%PropsR)) THEN 
    ALLOCATE(DstInitTypeData%PropsR(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%PropsR.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%PropsR = SrcInitTypeData%PropsR
ENDIF
IF (ALLOCATED(SrcInitTypeData%K)) THEN
  i1_l = LBOUND(SrcInitTypeData%K,1)
  i1_u = UBOUND(SrcInitTypeData%K,1)
  i2_l = LBOUND(SrcInitTypeData%K,2)
  i2_u = UBOUND(SrcInitTypeData%K,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%K)) THEN 
    ALLOCATE(DstInitTypeData%K(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%K.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%K = SrcInitTypeData%K
ENDIF
IF (ALLOCATED(SrcInitTypeData%M)) THEN
  i1_l = LBOUND(SrcInitTypeData%M,1)
  i1_u = UBOUND(SrcInitTypeData%M,1)
  i2_l = LBOUND(SrcInitTypeData%M,2)
  i2_u = UBOUND(SrcInitTypeData%M,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%M)) THEN 
    ALLOCATE(DstInitTypeData%M(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%M = SrcInitTypeData%M
ENDIF
IF (ALLOCATED(SrcInitTypeData%ElemProps)) THEN
  i1_l = LBOUND(SrcInitTypeData%ElemProps,1)
  i1_u = UBOUND(SrcInitTypeData%ElemProps,1)
  i2_l = LBOUND(SrcInitTypeData%ElemProps,2)
  i2_u = UBOUND(SrcInitTypeData%ElemProps,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%ElemProps)) THEN 
    ALLOCATE(DstInitTypeData%ElemProps(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%ElemProps.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%ElemProps = SrcInitTypeData%ElemProps
ENDIF
IF (ALLOCATED(SrcInitTypeData%MemberNodes)) THEN
  i1_l = LBOUND(SrcInitTypeData%MemberNodes,1)
  i1_u = UBOUND(SrcInitTypeData%MemberNodes,1)
  i2_l = LBOUND(SrcInitTypeData%MemberNodes,2)
  i2_u = UBOUND(SrcInitTypeData%MemberNodes,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%MemberNodes)) THEN 
    ALLOCATE(DstInitTypeData%MemberNodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%MemberNodes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%MemberNodes = SrcInitTypeData%MemberNodes
ENDIF
IF (ALLOCATED(SrcInitTypeData%NodesConnN)) THEN
  i1_l = LBOUND(SrcInitTypeData%NodesConnN,1)
  i1_u = UBOUND(SrcInitTypeData%NodesConnN,1)
  i2_l = LBOUND(SrcInitTypeData%NodesConnN,2)
  i2_u = UBOUND(SrcInitTypeData%NodesConnN,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%NodesConnN)) THEN 
    ALLOCATE(DstInitTypeData%NodesConnN(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%NodesConnN.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%NodesConnN = SrcInitTypeData%NodesConnN
ENDIF
IF (ALLOCATED(SrcInitTypeData%NodesConnE)) THEN
  i1_l = LBOUND(SrcInitTypeData%NodesConnE,1)
  i1_u = UBOUND(SrcInitTypeData%NodesConnE,1)
  i2_l = LBOUND(SrcInitTypeData%NodesConnE,2)
  i2_u = UBOUND(SrcInitTypeData%NodesConnE,2)
  IF (.NOT. ALLOCATED(DstInitTypeData%NodesConnE)) THEN 
    ALLOCATE(DstInitTypeData%NodesConnE(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitTypeData%NodesConnE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitTypeData%NodesConnE = SrcInitTypeData%NodesConnE
ENDIF
    DstInitTypeData%SSSum = SrcInitTypeData%SSSum
 END SUBROUTINE SD_CopyInitType

 SUBROUTINE SD_DestroyInitType( InitTypeData, ErrStat, ErrMsg )
  TYPE(SD_InitType), INTENT(INOUT) :: InitTypeData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyInitType'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(InitTypeData%Joints)) THEN
  DEALLOCATE(InitTypeData%Joints)
ENDIF
IF (ALLOCATED(InitTypeData%PropSetsB)) THEN
  DEALLOCATE(InitTypeData%PropSetsB)
ENDIF
IF (ALLOCATED(InitTypeData%PropSetsC)) THEN
  DEALLOCATE(InitTypeData%PropSetsC)
ENDIF
IF (ALLOCATED(InitTypeData%PropSetsR)) THEN
  DEALLOCATE(InitTypeData%PropSetsR)
ENDIF
IF (ALLOCATED(InitTypeData%PropSetsX)) THEN
  DEALLOCATE(InitTypeData%PropSetsX)
ENDIF
IF (ALLOCATED(InitTypeData%COSMs)) THEN
  DEALLOCATE(InitTypeData%COSMs)
ENDIF
IF (ALLOCATED(InitTypeData%CMass)) THEN
  DEALLOCATE(InitTypeData%CMass)
ENDIF
IF (ALLOCATED(InitTypeData%JDampings)) THEN
  DEALLOCATE(InitTypeData%JDampings)
ENDIF
IF (ALLOCATED(InitTypeData%Members)) THEN
  DEALLOCATE(InitTypeData%Members)
ENDIF
IF (ALLOCATED(InitTypeData%SSOutList)) THEN
  DEALLOCATE(InitTypeData%SSOutList)
ENDIF
IF (ALLOCATED(InitTypeData%SSIK)) THEN
  DEALLOCATE(InitTypeData%SSIK)
ENDIF
IF (ALLOCATED(InitTypeData%SSIM)) THEN
  DEALLOCATE(InitTypeData%SSIM)
ENDIF
IF (ALLOCATED(InitTypeData%SSIfile)) THEN
  DEALLOCATE(InitTypeData%SSIfile)
ENDIF
IF (ALLOCATED(InitTypeData%Soil_K)) THEN
  DEALLOCATE(InitTypeData%Soil_K)
ENDIF
IF (ALLOCATED(InitTypeData%Soil_Points)) THEN
  DEALLOCATE(InitTypeData%Soil_Points)
ENDIF
IF (ALLOCATED(InitTypeData%Soil_Nodes)) THEN
  DEALLOCATE(InitTypeData%Soil_Nodes)
ENDIF
IF (ALLOCATED(InitTypeData%Nodes)) THEN
  DEALLOCATE(InitTypeData%Nodes)
ENDIF
IF (ALLOCATED(InitTypeData%PropsB)) THEN
  DEALLOCATE(InitTypeData%PropsB)
ENDIF
IF (ALLOCATED(InitTypeData%PropsC)) THEN
  DEALLOCATE(InitTypeData%PropsC)
ENDIF
IF (ALLOCATED(InitTypeData%PropsR)) THEN
  DEALLOCATE(InitTypeData%PropsR)
ENDIF
IF (ALLOCATED(InitTypeData%K)) THEN
  DEALLOCATE(InitTypeData%K)
ENDIF
IF (ALLOCATED(InitTypeData%M)) THEN
  DEALLOCATE(InitTypeData%M)
ENDIF
IF (ALLOCATED(InitTypeData%ElemProps)) THEN
  DEALLOCATE(InitTypeData%ElemProps)
ENDIF
IF (ALLOCATED(InitTypeData%MemberNodes)) THEN
  DEALLOCATE(InitTypeData%MemberNodes)
ENDIF
IF (ALLOCATED(InitTypeData%NodesConnN)) THEN
  DEALLOCATE(InitTypeData%NodesConnN)
ENDIF
IF (ALLOCATED(InitTypeData%NodesConnE)) THEN
  DEALLOCATE(InitTypeData%NodesConnE)
ENDIF
 END SUBROUTINE SD_DestroyInitType


subroutine SD_PackInitType(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_InitType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackInitType'
   if (Buf%ErrStat >= AbortErrLev) return
   ! RootName
   call RegPack(Buf, InData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TP_RefPoint
   call RegPack(Buf, InData%TP_RefPoint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubRotateZ
   call RegPack(Buf, InData%SubRotateZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! g
   call RegPack(Buf, InData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegPack(Buf, InData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NJoints
   call RegPack(Buf, InData%NJoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsX
   call RegPack(Buf, InData%NPropSetsX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsB
   call RegPack(Buf, InData%NPropSetsB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsC
   call RegPack(Buf, InData%NPropSetsC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsR
   call RegPack(Buf, InData%NPropSetsR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NCMass
   call RegPack(Buf, InData%NCMass)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NCOSMs
   call RegPack(Buf, InData%NCOSMs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FEMMod
   call RegPack(Buf, InData%FEMMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NDiv
   call RegPack(Buf, InData%NDiv)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CBMod
   call RegPack(Buf, InData%CBMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Joints
   call RegPack(Buf, allocated(InData%Joints))
   if (allocated(InData%Joints)) then
      call RegPackBounds(Buf, 2, lbound(InData%Joints), ubound(InData%Joints))
      call RegPack(Buf, InData%Joints)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropSetsB
   call RegPack(Buf, allocated(InData%PropSetsB))
   if (allocated(InData%PropSetsB)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropSetsB), ubound(InData%PropSetsB))
      call RegPack(Buf, InData%PropSetsB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropSetsC
   call RegPack(Buf, allocated(InData%PropSetsC))
   if (allocated(InData%PropSetsC)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropSetsC), ubound(InData%PropSetsC))
      call RegPack(Buf, InData%PropSetsC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropSetsR
   call RegPack(Buf, allocated(InData%PropSetsR))
   if (allocated(InData%PropSetsR)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropSetsR), ubound(InData%PropSetsR))
      call RegPack(Buf, InData%PropSetsR)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropSetsX
   call RegPack(Buf, allocated(InData%PropSetsX))
   if (allocated(InData%PropSetsX)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropSetsX), ubound(InData%PropSetsX))
      call RegPack(Buf, InData%PropSetsX)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! COSMs
   call RegPack(Buf, allocated(InData%COSMs))
   if (allocated(InData%COSMs)) then
      call RegPackBounds(Buf, 2, lbound(InData%COSMs), ubound(InData%COSMs))
      call RegPack(Buf, InData%COSMs)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMass
   call RegPack(Buf, allocated(InData%CMass))
   if (allocated(InData%CMass)) then
      call RegPackBounds(Buf, 2, lbound(InData%CMass), ubound(InData%CMass))
      call RegPack(Buf, InData%CMass)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! JDampings
   call RegPack(Buf, allocated(InData%JDampings))
   if (allocated(InData%JDampings)) then
      call RegPackBounds(Buf, 1, lbound(InData%JDampings), ubound(InData%JDampings))
      call RegPack(Buf, InData%JDampings)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! GuyanDampMod
   call RegPack(Buf, InData%GuyanDampMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RayleighDamp
   call RegPack(Buf, InData%RayleighDamp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GuyanDampMat
   call RegPack(Buf, InData%GuyanDampMat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Members
   call RegPack(Buf, allocated(InData%Members))
   if (allocated(InData%Members)) then
      call RegPackBounds(Buf, 2, lbound(InData%Members), ubound(InData%Members))
      call RegPack(Buf, InData%Members)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SSOutList
   call RegPack(Buf, allocated(InData%SSOutList))
   if (allocated(InData%SSOutList)) then
      call RegPackBounds(Buf, 1, lbound(InData%SSOutList), ubound(InData%SSOutList))
      call RegPack(Buf, InData%SSOutList)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutCOSM
   call RegPack(Buf, InData%OutCOSM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TabDelim
   call RegPack(Buf, InData%TabDelim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SSIK
   call RegPack(Buf, allocated(InData%SSIK))
   if (allocated(InData%SSIK)) then
      call RegPackBounds(Buf, 2, lbound(InData%SSIK), ubound(InData%SSIK))
      call RegPack(Buf, InData%SSIK)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SSIM
   call RegPack(Buf, allocated(InData%SSIM))
   if (allocated(InData%SSIM)) then
      call RegPackBounds(Buf, 2, lbound(InData%SSIM), ubound(InData%SSIM))
      call RegPack(Buf, InData%SSIM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SSIfile
   call RegPack(Buf, allocated(InData%SSIfile))
   if (allocated(InData%SSIfile)) then
      call RegPackBounds(Buf, 1, lbound(InData%SSIfile), ubound(InData%SSIfile))
      call RegPack(Buf, InData%SSIfile)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Soil_K
   call RegPack(Buf, allocated(InData%Soil_K))
   if (allocated(InData%Soil_K)) then
      call RegPackBounds(Buf, 3, lbound(InData%Soil_K), ubound(InData%Soil_K))
      call RegPack(Buf, InData%Soil_K)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Soil_Points
   call RegPack(Buf, allocated(InData%Soil_Points))
   if (allocated(InData%Soil_Points)) then
      call RegPackBounds(Buf, 2, lbound(InData%Soil_Points), ubound(InData%Soil_Points))
      call RegPack(Buf, InData%Soil_Points)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Soil_Nodes
   call RegPack(Buf, allocated(InData%Soil_Nodes))
   if (allocated(InData%Soil_Nodes)) then
      call RegPackBounds(Buf, 1, lbound(InData%Soil_Nodes), ubound(InData%Soil_Nodes))
      call RegPack(Buf, InData%Soil_Nodes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NElem
   call RegPack(Buf, InData%NElem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropB
   call RegPack(Buf, InData%NPropB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropC
   call RegPack(Buf, InData%NPropC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropR
   call RegPack(Buf, InData%NPropR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nodes
   call RegPack(Buf, allocated(InData%Nodes))
   if (allocated(InData%Nodes)) then
      call RegPackBounds(Buf, 2, lbound(InData%Nodes), ubound(InData%Nodes))
      call RegPack(Buf, InData%Nodes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsB
   call RegPack(Buf, allocated(InData%PropsB))
   if (allocated(InData%PropsB)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropsB), ubound(InData%PropsB))
      call RegPack(Buf, InData%PropsB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsC
   call RegPack(Buf, allocated(InData%PropsC))
   if (allocated(InData%PropsC)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropsC), ubound(InData%PropsC))
      call RegPack(Buf, InData%PropsC)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PropsR
   call RegPack(Buf, allocated(InData%PropsR))
   if (allocated(InData%PropsR)) then
      call RegPackBounds(Buf, 2, lbound(InData%PropsR), ubound(InData%PropsR))
      call RegPack(Buf, InData%PropsR)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! K
   call RegPack(Buf, allocated(InData%K))
   if (allocated(InData%K)) then
      call RegPackBounds(Buf, 2, lbound(InData%K), ubound(InData%K))
      call RegPack(Buf, InData%K)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! M
   call RegPack(Buf, allocated(InData%M))
   if (allocated(InData%M)) then
      call RegPackBounds(Buf, 2, lbound(InData%M), ubound(InData%M))
      call RegPack(Buf, InData%M)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElemProps
   call RegPack(Buf, allocated(InData%ElemProps))
   if (allocated(InData%ElemProps)) then
      call RegPackBounds(Buf, 2, lbound(InData%ElemProps), ubound(InData%ElemProps))
      call RegPack(Buf, InData%ElemProps)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MemberNodes
   call RegPack(Buf, allocated(InData%MemberNodes))
   if (allocated(InData%MemberNodes)) then
      call RegPackBounds(Buf, 2, lbound(InData%MemberNodes), ubound(InData%MemberNodes))
      call RegPack(Buf, InData%MemberNodes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodesConnN
   call RegPack(Buf, allocated(InData%NodesConnN))
   if (allocated(InData%NodesConnN)) then
      call RegPackBounds(Buf, 2, lbound(InData%NodesConnN), ubound(InData%NodesConnN))
      call RegPack(Buf, InData%NodesConnN)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodesConnE
   call RegPack(Buf, allocated(InData%NodesConnE))
   if (allocated(InData%NodesConnE)) then
      call RegPackBounds(Buf, 2, lbound(InData%NodesConnE), ubound(InData%NodesConnE))
      call RegPack(Buf, InData%NodesConnE)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SSSum
   call RegPack(Buf, InData%SSSum)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackInitType(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_InitType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackInitType'
   integer(IntKi)  :: LB(3), UB(3)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! RootName
   call RegUnpack(Buf, OutData%RootName)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TP_RefPoint
   call RegUnpack(Buf, OutData%TP_RefPoint)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SubRotateZ
   call RegUnpack(Buf, OutData%SubRotateZ)
   if (RegCheckErr(Buf, RoutineName)) return
   ! g
   call RegUnpack(Buf, OutData%g)
   if (RegCheckErr(Buf, RoutineName)) return
   ! DT
   call RegUnpack(Buf, OutData%DT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NJoints
   call RegUnpack(Buf, OutData%NJoints)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsX
   call RegUnpack(Buf, OutData%NPropSetsX)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsB
   call RegUnpack(Buf, OutData%NPropSetsB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsC
   call RegUnpack(Buf, OutData%NPropSetsC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropSetsR
   call RegUnpack(Buf, OutData%NPropSetsR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NCMass
   call RegUnpack(Buf, OutData%NCMass)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NCOSMs
   call RegUnpack(Buf, OutData%NCOSMs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! FEMMod
   call RegUnpack(Buf, OutData%FEMMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NDiv
   call RegUnpack(Buf, OutData%NDiv)
   if (RegCheckErr(Buf, RoutineName)) return
   ! CBMod
   call RegUnpack(Buf, OutData%CBMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Joints
   if (allocated(OutData%Joints)) deallocate(OutData%Joints)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Joints(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Joints.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Joints)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropSetsB
   if (allocated(OutData%PropSetsB)) deallocate(OutData%PropSetsB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropSetsB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropSetsB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropSetsB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropSetsC
   if (allocated(OutData%PropSetsC)) deallocate(OutData%PropSetsC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropSetsC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropSetsC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropSetsC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropSetsR
   if (allocated(OutData%PropSetsR)) deallocate(OutData%PropSetsR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropSetsR(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropSetsR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropSetsR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropSetsX
   if (allocated(OutData%PropSetsX)) deallocate(OutData%PropSetsX)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropSetsX(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropSetsX.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropSetsX)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! COSMs
   if (allocated(OutData%COSMs)) deallocate(OutData%COSMs)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%COSMs(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%COSMs.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%COSMs)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CMass
   if (allocated(OutData%CMass)) deallocate(OutData%CMass)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CMass(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CMass.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CMass)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! JDampings
   if (allocated(OutData%JDampings)) deallocate(OutData%JDampings)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%JDampings(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%JDampings.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%JDampings)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! GuyanDampMod
   call RegUnpack(Buf, OutData%GuyanDampMod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RayleighDamp
   call RegUnpack(Buf, OutData%RayleighDamp)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GuyanDampMat
   call RegUnpack(Buf, OutData%GuyanDampMat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Members
   if (allocated(OutData%Members)) deallocate(OutData%Members)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Members(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Members.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Members)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SSOutList
   if (allocated(OutData%SSOutList)) deallocate(OutData%SSOutList)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SSOutList(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SSOutList.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SSOutList)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! OutCOSM
   call RegUnpack(Buf, OutData%OutCOSM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! TabDelim
   call RegUnpack(Buf, OutData%TabDelim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SSIK
   if (allocated(OutData%SSIK)) deallocate(OutData%SSIK)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SSIK(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SSIK.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SSIK)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SSIM
   if (allocated(OutData%SSIM)) deallocate(OutData%SSIM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SSIM(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SSIM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SSIM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SSIfile
   if (allocated(OutData%SSIfile)) deallocate(OutData%SSIfile)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SSIfile(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SSIfile.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SSIfile)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Soil_K
   if (allocated(OutData%Soil_K)) deallocate(OutData%Soil_K)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 3, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Soil_K(LB(1):UB(1),LB(2):UB(2),LB(3):UB(3)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Soil_K.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Soil_K)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Soil_Points
   if (allocated(OutData%Soil_Points)) deallocate(OutData%Soil_Points)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Soil_Points(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Soil_Points.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Soil_Points)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Soil_Nodes
   if (allocated(OutData%Soil_Nodes)) deallocate(OutData%Soil_Nodes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Soil_Nodes(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Soil_Nodes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Soil_Nodes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NElem
   call RegUnpack(Buf, OutData%NElem)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropB
   call RegUnpack(Buf, OutData%NPropB)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropC
   call RegUnpack(Buf, OutData%NPropC)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NPropR
   call RegUnpack(Buf, OutData%NPropR)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nodes
   if (allocated(OutData%Nodes)) deallocate(OutData%Nodes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Nodes(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Nodes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropsB
   if (allocated(OutData%PropsB)) deallocate(OutData%PropsB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropsB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropsB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropsB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropsC
   if (allocated(OutData%PropsC)) deallocate(OutData%PropsC)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropsC(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropsC.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropsC)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PropsR
   if (allocated(OutData%PropsR)) deallocate(OutData%PropsR)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PropsR(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PropsR.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PropsR)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! K
   if (allocated(OutData%K)) deallocate(OutData%K)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%K(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%K.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%K)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! M
   if (allocated(OutData%M)) deallocate(OutData%M)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%M(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%M)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ElemProps
   if (allocated(OutData%ElemProps)) deallocate(OutData%ElemProps)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElemProps(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElemProps.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElemProps)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MemberNodes
   if (allocated(OutData%MemberNodes)) deallocate(OutData%MemberNodes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MemberNodes(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MemberNodes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MemberNodes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NodesConnN
   if (allocated(OutData%NodesConnN)) deallocate(OutData%NodesConnN)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodesConnN(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodesConnN.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NodesConnN)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NodesConnE
   if (allocated(OutData%NodesConnE)) deallocate(OutData%NodesConnE)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodesConnE(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodesConnE.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NodesConnE)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SSSum
   call RegUnpack(Buf, OutData%SSSum)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(SD_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%qm)) THEN
  i1_l = LBOUND(SrcContStateData%qm,1)
  i1_u = UBOUND(SrcContStateData%qm,1)
  IF (.NOT. ALLOCATED(DstContStateData%qm)) THEN 
    ALLOCATE(DstContStateData%qm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%qm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%qm = SrcContStateData%qm
ENDIF
IF (ALLOCATED(SrcContStateData%qmdot)) THEN
  i1_l = LBOUND(SrcContStateData%qmdot,1)
  i1_u = UBOUND(SrcContStateData%qmdot,1)
  IF (.NOT. ALLOCATED(DstContStateData%qmdot)) THEN 
    ALLOCATE(DstContStateData%qmdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%qmdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%qmdot = SrcContStateData%qmdot
ENDIF
 END SUBROUTINE SD_CopyContState

 SUBROUTINE SD_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(SD_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyContState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ContStateData%qm)) THEN
  DEALLOCATE(ContStateData%qm)
ENDIF
IF (ALLOCATED(ContStateData%qmdot)) THEN
  DEALLOCATE(ContStateData%qmdot)
ENDIF
 END SUBROUTINE SD_DestroyContState


subroutine SD_PackContState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_ContinuousStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackContState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! qm
   call RegPack(Buf, allocated(InData%qm))
   if (allocated(InData%qm)) then
      call RegPackBounds(Buf, 1, lbound(InData%qm), ubound(InData%qm))
      call RegPack(Buf, InData%qm)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! qmdot
   call RegPack(Buf, allocated(InData%qmdot))
   if (allocated(InData%qmdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%qmdot), ubound(InData%qmdot))
      call RegPack(Buf, InData%qmdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackContState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_ContinuousStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackContState'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! qm
   if (allocated(OutData%qm)) deallocate(OutData%qm)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%qm(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%qm.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%qm)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! qmdot
   if (allocated(OutData%qmdot)) deallocate(OutData%qmdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%qmdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%qmdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%qmdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(SD_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%DummyDiscState = SrcDiscStateData%DummyDiscState
 END SUBROUTINE SD_CopyDiscState

 SUBROUTINE SD_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(SD_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyDiscState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SD_DestroyDiscState


subroutine SD_PackDiscState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_DiscreteStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackDiscState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyDiscState
   call RegPack(Buf, InData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackDiscState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_DiscreteStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackDiscState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyDiscState
   call RegUnpack(Buf, OutData%DummyDiscState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(SD_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%DummyConstrState = SrcConstrStateData%DummyConstrState
 END SUBROUTINE SD_CopyConstrState

 SUBROUTINE SD_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(SD_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyConstrState'

  ErrStat = ErrID_None
  ErrMsg  = ""

 END SUBROUTINE SD_DestroyConstrState


subroutine SD_PackConstrState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_ConstraintStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackConstrState'
   if (Buf%ErrStat >= AbortErrLev) return
   ! DummyConstrState
   call RegPack(Buf, InData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackConstrState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_ConstraintStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackConstrState'
   if (Buf%ErrStat /= ErrID_None) return
   ! DummyConstrState
   call RegUnpack(Buf, OutData%DummyConstrState)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(SD_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOtherStateData%xdot)) THEN
  i1_l = LBOUND(SrcOtherStateData%xdot,1)
  i1_u = UBOUND(SrcOtherStateData%xdot,1)
  IF (.NOT. ALLOCATED(DstOtherStateData%xdot)) THEN 
    ALLOCATE(DstOtherStateData%xdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOtherStateData%xdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcOtherStateData%xdot,1), UBOUND(SrcOtherStateData%xdot,1)
      CALL SD_CopyContState( SrcOtherStateData%xdot(i1), DstOtherStateData%xdot(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstOtherStateData%n = SrcOtherStateData%n
 END SUBROUTINE SD_CopyOtherState

 SUBROUTINE SD_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(SD_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyOtherState'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(OtherStateData%xdot)) THEN
DO i1 = LBOUND(OtherStateData%xdot,1), UBOUND(OtherStateData%xdot,1)
  CALL SD_DestroyContState( OtherStateData%xdot(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(OtherStateData%xdot)
ENDIF
 END SUBROUTINE SD_DestroyOtherState


subroutine SD_PackOtherState(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_OtherStateType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   if (Buf%ErrStat >= AbortErrLev) return
   ! xdot
   call RegPack(Buf, allocated(InData%xdot))
   if (allocated(InData%xdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%xdot), ubound(InData%xdot))
      LB(1:1) = lbound(InData%xdot)
      UB(1:1) = ubound(InData%xdot)
      do i1 = LB(1), UB(1)
         call SD_PackContState(Buf, InData%xdot(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! n
   call RegPack(Buf, InData%n)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackOtherState(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_OtherStateType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackOtherState'
   integer(IntKi)  :: i1
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! xdot
   if (allocated(OutData%xdot)) deallocate(OutData%xdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%xdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%xdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackContState(Buf, OutData%xdot(i1)) ! xdot 
      end do
   end if
   ! n
   call RegUnpack(Buf, OutData%n)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(SD_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%qmdotdot)) THEN
  i1_l = LBOUND(SrcMiscData%qmdotdot,1)
  i1_u = UBOUND(SrcMiscData%qmdotdot,1)
  IF (.NOT. ALLOCATED(DstMiscData%qmdotdot)) THEN 
    ALLOCATE(DstMiscData%qmdotdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%qmdotdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%qmdotdot = SrcMiscData%qmdotdot
ENDIF
    DstMiscData%u_TP = SrcMiscData%u_TP
    DstMiscData%udot_TP = SrcMiscData%udot_TP
    DstMiscData%udotdot_TP = SrcMiscData%udotdot_TP
IF (ALLOCATED(SrcMiscData%F_L)) THEN
  i1_l = LBOUND(SrcMiscData%F_L,1)
  i1_u = UBOUND(SrcMiscData%F_L,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_L)) THEN 
    ALLOCATE(DstMiscData%F_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_L = SrcMiscData%F_L
ENDIF
IF (ALLOCATED(SrcMiscData%F_L2)) THEN
  i1_l = LBOUND(SrcMiscData%F_L2,1)
  i1_u = UBOUND(SrcMiscData%F_L2,1)
  IF (.NOT. ALLOCATED(DstMiscData%F_L2)) THEN 
    ALLOCATE(DstMiscData%F_L2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%F_L2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%F_L2 = SrcMiscData%F_L2
ENDIF
IF (ALLOCATED(SrcMiscData%UR_bar)) THEN
  i1_l = LBOUND(SrcMiscData%UR_bar,1)
  i1_u = UBOUND(SrcMiscData%UR_bar,1)
  IF (.NOT. ALLOCATED(DstMiscData%UR_bar)) THEN 
    ALLOCATE(DstMiscData%UR_bar(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UR_bar.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UR_bar = SrcMiscData%UR_bar
ENDIF
IF (ALLOCATED(SrcMiscData%UR_bar_dot)) THEN
  i1_l = LBOUND(SrcMiscData%UR_bar_dot,1)
  i1_u = UBOUND(SrcMiscData%UR_bar_dot,1)
  IF (.NOT. ALLOCATED(DstMiscData%UR_bar_dot)) THEN 
    ALLOCATE(DstMiscData%UR_bar_dot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UR_bar_dot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UR_bar_dot = SrcMiscData%UR_bar_dot
ENDIF
IF (ALLOCATED(SrcMiscData%UR_bar_dotdot)) THEN
  i1_l = LBOUND(SrcMiscData%UR_bar_dotdot,1)
  i1_u = UBOUND(SrcMiscData%UR_bar_dotdot,1)
  IF (.NOT. ALLOCATED(DstMiscData%UR_bar_dotdot)) THEN 
    ALLOCATE(DstMiscData%UR_bar_dotdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UR_bar_dotdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UR_bar_dotdot = SrcMiscData%UR_bar_dotdot
ENDIF
IF (ALLOCATED(SrcMiscData%UL)) THEN
  i1_l = LBOUND(SrcMiscData%UL,1)
  i1_u = UBOUND(SrcMiscData%UL,1)
  IF (.NOT. ALLOCATED(DstMiscData%UL)) THEN 
    ALLOCATE(DstMiscData%UL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UL = SrcMiscData%UL
ENDIF
IF (ALLOCATED(SrcMiscData%UL_NS)) THEN
  i1_l = LBOUND(SrcMiscData%UL_NS,1)
  i1_u = UBOUND(SrcMiscData%UL_NS,1)
  IF (.NOT. ALLOCATED(DstMiscData%UL_NS)) THEN 
    ALLOCATE(DstMiscData%UL_NS(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UL_NS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UL_NS = SrcMiscData%UL_NS
ENDIF
IF (ALLOCATED(SrcMiscData%UL_dot)) THEN
  i1_l = LBOUND(SrcMiscData%UL_dot,1)
  i1_u = UBOUND(SrcMiscData%UL_dot,1)
  IF (.NOT. ALLOCATED(DstMiscData%UL_dot)) THEN 
    ALLOCATE(DstMiscData%UL_dot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UL_dot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UL_dot = SrcMiscData%UL_dot
ENDIF
IF (ALLOCATED(SrcMiscData%UL_dotdot)) THEN
  i1_l = LBOUND(SrcMiscData%UL_dotdot,1)
  i1_u = UBOUND(SrcMiscData%UL_dotdot,1)
  IF (.NOT. ALLOCATED(DstMiscData%UL_dotdot)) THEN 
    ALLOCATE(DstMiscData%UL_dotdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UL_dotdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UL_dotdot = SrcMiscData%UL_dotdot
ENDIF
IF (ALLOCATED(SrcMiscData%DU_full)) THEN
  i1_l = LBOUND(SrcMiscData%DU_full,1)
  i1_u = UBOUND(SrcMiscData%DU_full,1)
  IF (.NOT. ALLOCATED(DstMiscData%DU_full)) THEN 
    ALLOCATE(DstMiscData%DU_full(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%DU_full.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%DU_full = SrcMiscData%DU_full
ENDIF
IF (ALLOCATED(SrcMiscData%U_full)) THEN
  i1_l = LBOUND(SrcMiscData%U_full,1)
  i1_u = UBOUND(SrcMiscData%U_full,1)
  IF (.NOT. ALLOCATED(DstMiscData%U_full)) THEN 
    ALLOCATE(DstMiscData%U_full(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%U_full.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%U_full = SrcMiscData%U_full
ENDIF
IF (ALLOCATED(SrcMiscData%U_full_NS)) THEN
  i1_l = LBOUND(SrcMiscData%U_full_NS,1)
  i1_u = UBOUND(SrcMiscData%U_full_NS,1)
  IF (.NOT. ALLOCATED(DstMiscData%U_full_NS)) THEN 
    ALLOCATE(DstMiscData%U_full_NS(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%U_full_NS.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%U_full_NS = SrcMiscData%U_full_NS
ENDIF
IF (ALLOCATED(SrcMiscData%U_full_dot)) THEN
  i1_l = LBOUND(SrcMiscData%U_full_dot,1)
  i1_u = UBOUND(SrcMiscData%U_full_dot,1)
  IF (.NOT. ALLOCATED(DstMiscData%U_full_dot)) THEN 
    ALLOCATE(DstMiscData%U_full_dot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%U_full_dot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%U_full_dot = SrcMiscData%U_full_dot
ENDIF
IF (ALLOCATED(SrcMiscData%U_full_dotdot)) THEN
  i1_l = LBOUND(SrcMiscData%U_full_dotdot,1)
  i1_u = UBOUND(SrcMiscData%U_full_dotdot,1)
  IF (.NOT. ALLOCATED(DstMiscData%U_full_dotdot)) THEN 
    ALLOCATE(DstMiscData%U_full_dotdot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%U_full_dotdot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%U_full_dotdot = SrcMiscData%U_full_dotdot
ENDIF
IF (ALLOCATED(SrcMiscData%U_full_elast)) THEN
  i1_l = LBOUND(SrcMiscData%U_full_elast,1)
  i1_u = UBOUND(SrcMiscData%U_full_elast,1)
  IF (.NOT. ALLOCATED(DstMiscData%U_full_elast)) THEN 
    ALLOCATE(DstMiscData%U_full_elast(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%U_full_elast.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%U_full_elast = SrcMiscData%U_full_elast
ENDIF
IF (ALLOCATED(SrcMiscData%U_red)) THEN
  i1_l = LBOUND(SrcMiscData%U_red,1)
  i1_u = UBOUND(SrcMiscData%U_red,1)
  IF (.NOT. ALLOCATED(DstMiscData%U_red)) THEN 
    ALLOCATE(DstMiscData%U_red(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%U_red.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%U_red = SrcMiscData%U_red
ENDIF
IF (ALLOCATED(SrcMiscData%FC_unit)) THEN
  i1_l = LBOUND(SrcMiscData%FC_unit,1)
  i1_u = UBOUND(SrcMiscData%FC_unit,1)
  IF (.NOT. ALLOCATED(DstMiscData%FC_unit)) THEN 
    ALLOCATE(DstMiscData%FC_unit(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%FC_unit.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%FC_unit = SrcMiscData%FC_unit
ENDIF
IF (ALLOCATED(SrcMiscData%SDWrOutput)) THEN
  i1_l = LBOUND(SrcMiscData%SDWrOutput,1)
  i1_u = UBOUND(SrcMiscData%SDWrOutput,1)
  IF (.NOT. ALLOCATED(DstMiscData%SDWrOutput)) THEN 
    ALLOCATE(DstMiscData%SDWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%SDWrOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%SDWrOutput = SrcMiscData%SDWrOutput
ENDIF
IF (ALLOCATED(SrcMiscData%AllOuts)) THEN
  i1_l = LBOUND(SrcMiscData%AllOuts,1)
  i1_u = UBOUND(SrcMiscData%AllOuts,1)
  IF (.NOT. ALLOCATED(DstMiscData%AllOuts)) THEN 
    ALLOCATE(DstMiscData%AllOuts(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%AllOuts.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%AllOuts = SrcMiscData%AllOuts
ENDIF
    DstMiscData%LastOutTime = SrcMiscData%LastOutTime
    DstMiscData%Decimat = SrcMiscData%Decimat
IF (ALLOCATED(SrcMiscData%Fext)) THEN
  i1_l = LBOUND(SrcMiscData%Fext,1)
  i1_u = UBOUND(SrcMiscData%Fext,1)
  IF (.NOT. ALLOCATED(DstMiscData%Fext)) THEN 
    ALLOCATE(DstMiscData%Fext(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Fext.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Fext = SrcMiscData%Fext
ENDIF
IF (ALLOCATED(SrcMiscData%Fext_red)) THEN
  i1_l = LBOUND(SrcMiscData%Fext_red,1)
  i1_u = UBOUND(SrcMiscData%Fext_red,1)
  IF (.NOT. ALLOCATED(DstMiscData%Fext_red)) THEN 
    ALLOCATE(DstMiscData%Fext_red(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Fext_red.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Fext_red = SrcMiscData%Fext_red
ENDIF
IF (ALLOCATED(SrcMiscData%UL_SIM)) THEN
  i1_l = LBOUND(SrcMiscData%UL_SIM,1)
  i1_u = UBOUND(SrcMiscData%UL_SIM,1)
  IF (.NOT. ALLOCATED(DstMiscData%UL_SIM)) THEN 
    ALLOCATE(DstMiscData%UL_SIM(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UL_SIM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UL_SIM = SrcMiscData%UL_SIM
ENDIF
IF (ALLOCATED(SrcMiscData%UL_0m)) THEN
  i1_l = LBOUND(SrcMiscData%UL_0m,1)
  i1_u = UBOUND(SrcMiscData%UL_0m,1)
  IF (.NOT. ALLOCATED(DstMiscData%UL_0m)) THEN 
    ALLOCATE(DstMiscData%UL_0m(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%UL_0m.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%UL_0m = SrcMiscData%UL_0m
ENDIF
 END SUBROUTINE SD_CopyMisc

 SUBROUTINE SD_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(SD_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyMisc'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(MiscData%qmdotdot)) THEN
  DEALLOCATE(MiscData%qmdotdot)
ENDIF
IF (ALLOCATED(MiscData%F_L)) THEN
  DEALLOCATE(MiscData%F_L)
ENDIF
IF (ALLOCATED(MiscData%F_L2)) THEN
  DEALLOCATE(MiscData%F_L2)
ENDIF
IF (ALLOCATED(MiscData%UR_bar)) THEN
  DEALLOCATE(MiscData%UR_bar)
ENDIF
IF (ALLOCATED(MiscData%UR_bar_dot)) THEN
  DEALLOCATE(MiscData%UR_bar_dot)
ENDIF
IF (ALLOCATED(MiscData%UR_bar_dotdot)) THEN
  DEALLOCATE(MiscData%UR_bar_dotdot)
ENDIF
IF (ALLOCATED(MiscData%UL)) THEN
  DEALLOCATE(MiscData%UL)
ENDIF
IF (ALLOCATED(MiscData%UL_NS)) THEN
  DEALLOCATE(MiscData%UL_NS)
ENDIF
IF (ALLOCATED(MiscData%UL_dot)) THEN
  DEALLOCATE(MiscData%UL_dot)
ENDIF
IF (ALLOCATED(MiscData%UL_dotdot)) THEN
  DEALLOCATE(MiscData%UL_dotdot)
ENDIF
IF (ALLOCATED(MiscData%DU_full)) THEN
  DEALLOCATE(MiscData%DU_full)
ENDIF
IF (ALLOCATED(MiscData%U_full)) THEN
  DEALLOCATE(MiscData%U_full)
ENDIF
IF (ALLOCATED(MiscData%U_full_NS)) THEN
  DEALLOCATE(MiscData%U_full_NS)
ENDIF
IF (ALLOCATED(MiscData%U_full_dot)) THEN
  DEALLOCATE(MiscData%U_full_dot)
ENDIF
IF (ALLOCATED(MiscData%U_full_dotdot)) THEN
  DEALLOCATE(MiscData%U_full_dotdot)
ENDIF
IF (ALLOCATED(MiscData%U_full_elast)) THEN
  DEALLOCATE(MiscData%U_full_elast)
ENDIF
IF (ALLOCATED(MiscData%U_red)) THEN
  DEALLOCATE(MiscData%U_red)
ENDIF
IF (ALLOCATED(MiscData%FC_unit)) THEN
  DEALLOCATE(MiscData%FC_unit)
ENDIF
IF (ALLOCATED(MiscData%SDWrOutput)) THEN
  DEALLOCATE(MiscData%SDWrOutput)
ENDIF
IF (ALLOCATED(MiscData%AllOuts)) THEN
  DEALLOCATE(MiscData%AllOuts)
ENDIF
IF (ALLOCATED(MiscData%Fext)) THEN
  DEALLOCATE(MiscData%Fext)
ENDIF
IF (ALLOCATED(MiscData%Fext_red)) THEN
  DEALLOCATE(MiscData%Fext_red)
ENDIF
IF (ALLOCATED(MiscData%UL_SIM)) THEN
  DEALLOCATE(MiscData%UL_SIM)
ENDIF
IF (ALLOCATED(MiscData%UL_0m)) THEN
  DEALLOCATE(MiscData%UL_0m)
ENDIF
 END SUBROUTINE SD_DestroyMisc


subroutine SD_PackMisc(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_MiscVarType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackMisc'
   if (Buf%ErrStat >= AbortErrLev) return
   ! qmdotdot
   call RegPack(Buf, allocated(InData%qmdotdot))
   if (allocated(InData%qmdotdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%qmdotdot), ubound(InData%qmdotdot))
      call RegPack(Buf, InData%qmdotdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! u_TP
   call RegPack(Buf, InData%u_TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! udot_TP
   call RegPack(Buf, InData%udot_TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! udotdot_TP
   call RegPack(Buf, InData%udotdot_TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_L
   call RegPack(Buf, allocated(InData%F_L))
   if (allocated(InData%F_L)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_L), ubound(InData%F_L))
      call RegPack(Buf, InData%F_L)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_L2
   call RegPack(Buf, allocated(InData%F_L2))
   if (allocated(InData%F_L2)) then
      call RegPackBounds(Buf, 1, lbound(InData%F_L2), ubound(InData%F_L2))
      call RegPack(Buf, InData%F_L2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UR_bar
   call RegPack(Buf, allocated(InData%UR_bar))
   if (allocated(InData%UR_bar)) then
      call RegPackBounds(Buf, 1, lbound(InData%UR_bar), ubound(InData%UR_bar))
      call RegPack(Buf, InData%UR_bar)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UR_bar_dot
   call RegPack(Buf, allocated(InData%UR_bar_dot))
   if (allocated(InData%UR_bar_dot)) then
      call RegPackBounds(Buf, 1, lbound(InData%UR_bar_dot), ubound(InData%UR_bar_dot))
      call RegPack(Buf, InData%UR_bar_dot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UR_bar_dotdot
   call RegPack(Buf, allocated(InData%UR_bar_dotdot))
   if (allocated(InData%UR_bar_dotdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%UR_bar_dotdot), ubound(InData%UR_bar_dotdot))
      call RegPack(Buf, InData%UR_bar_dotdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UL
   call RegPack(Buf, allocated(InData%UL))
   if (allocated(InData%UL)) then
      call RegPackBounds(Buf, 1, lbound(InData%UL), ubound(InData%UL))
      call RegPack(Buf, InData%UL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UL_NS
   call RegPack(Buf, allocated(InData%UL_NS))
   if (allocated(InData%UL_NS)) then
      call RegPackBounds(Buf, 1, lbound(InData%UL_NS), ubound(InData%UL_NS))
      call RegPack(Buf, InData%UL_NS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UL_dot
   call RegPack(Buf, allocated(InData%UL_dot))
   if (allocated(InData%UL_dot)) then
      call RegPackBounds(Buf, 1, lbound(InData%UL_dot), ubound(InData%UL_dot))
      call RegPack(Buf, InData%UL_dot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UL_dotdot
   call RegPack(Buf, allocated(InData%UL_dotdot))
   if (allocated(InData%UL_dotdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%UL_dotdot), ubound(InData%UL_dotdot))
      call RegPack(Buf, InData%UL_dotdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DU_full
   call RegPack(Buf, allocated(InData%DU_full))
   if (allocated(InData%DU_full)) then
      call RegPackBounds(Buf, 1, lbound(InData%DU_full), ubound(InData%DU_full))
      call RegPack(Buf, InData%DU_full)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U_full
   call RegPack(Buf, allocated(InData%U_full))
   if (allocated(InData%U_full)) then
      call RegPackBounds(Buf, 1, lbound(InData%U_full), ubound(InData%U_full))
      call RegPack(Buf, InData%U_full)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U_full_NS
   call RegPack(Buf, allocated(InData%U_full_NS))
   if (allocated(InData%U_full_NS)) then
      call RegPackBounds(Buf, 1, lbound(InData%U_full_NS), ubound(InData%U_full_NS))
      call RegPack(Buf, InData%U_full_NS)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U_full_dot
   call RegPack(Buf, allocated(InData%U_full_dot))
   if (allocated(InData%U_full_dot)) then
      call RegPackBounds(Buf, 1, lbound(InData%U_full_dot), ubound(InData%U_full_dot))
      call RegPack(Buf, InData%U_full_dot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U_full_dotdot
   call RegPack(Buf, allocated(InData%U_full_dotdot))
   if (allocated(InData%U_full_dotdot)) then
      call RegPackBounds(Buf, 1, lbound(InData%U_full_dotdot), ubound(InData%U_full_dotdot))
      call RegPack(Buf, InData%U_full_dotdot)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U_full_elast
   call RegPack(Buf, allocated(InData%U_full_elast))
   if (allocated(InData%U_full_elast)) then
      call RegPackBounds(Buf, 1, lbound(InData%U_full_elast), ubound(InData%U_full_elast))
      call RegPack(Buf, InData%U_full_elast)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! U_red
   call RegPack(Buf, allocated(InData%U_red))
   if (allocated(InData%U_red)) then
      call RegPackBounds(Buf, 1, lbound(InData%U_red), ubound(InData%U_red))
      call RegPack(Buf, InData%U_red)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FC_unit
   call RegPack(Buf, allocated(InData%FC_unit))
   if (allocated(InData%FC_unit)) then
      call RegPackBounds(Buf, 1, lbound(InData%FC_unit), ubound(InData%FC_unit))
      call RegPack(Buf, InData%FC_unit)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! SDWrOutput
   call RegPack(Buf, allocated(InData%SDWrOutput))
   if (allocated(InData%SDWrOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%SDWrOutput), ubound(InData%SDWrOutput))
      call RegPack(Buf, InData%SDWrOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AllOuts
   call RegPack(Buf, allocated(InData%AllOuts))
   if (allocated(InData%AllOuts)) then
      call RegPackBounds(Buf, 1, lbound(InData%AllOuts), ubound(InData%AllOuts))
      call RegPack(Buf, InData%AllOuts)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! LastOutTime
   call RegPack(Buf, InData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Decimat
   call RegPack(Buf, InData%Decimat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fext
   call RegPack(Buf, allocated(InData%Fext))
   if (allocated(InData%Fext)) then
      call RegPackBounds(Buf, 1, lbound(InData%Fext), ubound(InData%Fext))
      call RegPack(Buf, InData%Fext)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fext_red
   call RegPack(Buf, allocated(InData%Fext_red))
   if (allocated(InData%Fext_red)) then
      call RegPackBounds(Buf, 1, lbound(InData%Fext_red), ubound(InData%Fext_red))
      call RegPack(Buf, InData%Fext_red)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UL_SIM
   call RegPack(Buf, allocated(InData%UL_SIM))
   if (allocated(InData%UL_SIM)) then
      call RegPackBounds(Buf, 1, lbound(InData%UL_SIM), ubound(InData%UL_SIM))
      call RegPack(Buf, InData%UL_SIM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! UL_0m
   call RegPack(Buf, allocated(InData%UL_0m))
   if (allocated(InData%UL_0m)) then
      call RegPackBounds(Buf, 1, lbound(InData%UL_0m), ubound(InData%UL_0m))
      call RegPack(Buf, InData%UL_0m)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackMisc(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_MiscVarType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackMisc'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! qmdotdot
   if (allocated(OutData%qmdotdot)) deallocate(OutData%qmdotdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%qmdotdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%qmdotdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%qmdotdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! u_TP
   call RegUnpack(Buf, OutData%u_TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! udot_TP
   call RegUnpack(Buf, OutData%udot_TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! udotdot_TP
   call RegUnpack(Buf, OutData%udotdot_TP)
   if (RegCheckErr(Buf, RoutineName)) return
   ! F_L
   if (allocated(OutData%F_L)) deallocate(OutData%F_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_L)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! F_L2
   if (allocated(OutData%F_L2)) deallocate(OutData%F_L2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%F_L2(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%F_L2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%F_L2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UR_bar
   if (allocated(OutData%UR_bar)) deallocate(OutData%UR_bar)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UR_bar(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UR_bar.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UR_bar)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UR_bar_dot
   if (allocated(OutData%UR_bar_dot)) deallocate(OutData%UR_bar_dot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UR_bar_dot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UR_bar_dot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UR_bar_dot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UR_bar_dotdot
   if (allocated(OutData%UR_bar_dotdot)) deallocate(OutData%UR_bar_dotdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UR_bar_dotdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UR_bar_dotdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UR_bar_dotdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UL
   if (allocated(OutData%UL)) deallocate(OutData%UL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UL_NS
   if (allocated(OutData%UL_NS)) deallocate(OutData%UL_NS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UL_NS(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UL_NS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UL_NS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UL_dot
   if (allocated(OutData%UL_dot)) deallocate(OutData%UL_dot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UL_dot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UL_dot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UL_dot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UL_dotdot
   if (allocated(OutData%UL_dotdot)) deallocate(OutData%UL_dotdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UL_dotdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UL_dotdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UL_dotdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DU_full
   if (allocated(OutData%DU_full)) deallocate(OutData%DU_full)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DU_full(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DU_full.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DU_full)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U_full
   if (allocated(OutData%U_full)) deallocate(OutData%U_full)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U_full(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U_full.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U_full)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U_full_NS
   if (allocated(OutData%U_full_NS)) deallocate(OutData%U_full_NS)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U_full_NS(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U_full_NS.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U_full_NS)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U_full_dot
   if (allocated(OutData%U_full_dot)) deallocate(OutData%U_full_dot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U_full_dot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U_full_dot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U_full_dot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U_full_dotdot
   if (allocated(OutData%U_full_dotdot)) deallocate(OutData%U_full_dotdot)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U_full_dotdot(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U_full_dotdot.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U_full_dotdot)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U_full_elast
   if (allocated(OutData%U_full_elast)) deallocate(OutData%U_full_elast)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U_full_elast(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U_full_elast.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U_full_elast)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! U_red
   if (allocated(OutData%U_red)) deallocate(OutData%U_red)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%U_red(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%U_red.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%U_red)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! FC_unit
   if (allocated(OutData%FC_unit)) deallocate(OutData%FC_unit)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FC_unit(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FC_unit.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FC_unit)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! SDWrOutput
   if (allocated(OutData%SDWrOutput)) deallocate(OutData%SDWrOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%SDWrOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%SDWrOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%SDWrOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AllOuts
   if (allocated(OutData%AllOuts)) deallocate(OutData%AllOuts)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AllOuts(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllOuts.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AllOuts)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! LastOutTime
   call RegUnpack(Buf, OutData%LastOutTime)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Decimat
   call RegUnpack(Buf, OutData%Decimat)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Fext
   if (allocated(OutData%Fext)) deallocate(OutData%Fext)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Fext(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fext.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Fext)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Fext_red
   if (allocated(OutData%Fext_red)) deallocate(OutData%Fext_red)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Fext_red(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fext_red.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Fext_red)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UL_SIM
   if (allocated(OutData%UL_SIM)) deallocate(OutData%UL_SIM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UL_SIM(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UL_SIM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UL_SIM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! UL_0m
   if (allocated(OutData%UL_0m)) deallocate(OutData%UL_0m)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%UL_0m(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%UL_0m.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%UL_0m)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(SD_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%SDDeltaT = SrcParamData%SDDeltaT
    DstParamData%IntMethod = SrcParamData%IntMethod
    DstParamData%nDOF = SrcParamData%nDOF
    DstParamData%nDOF_red = SrcParamData%nDOF_red
    DstParamData%Nmembers = SrcParamData%Nmembers
IF (ALLOCATED(SrcParamData%Elems)) THEN
  i1_l = LBOUND(SrcParamData%Elems,1)
  i1_u = UBOUND(SrcParamData%Elems,1)
  i2_l = LBOUND(SrcParamData%Elems,2)
  i2_u = UBOUND(SrcParamData%Elems,2)
  IF (.NOT. ALLOCATED(DstParamData%Elems)) THEN 
    ALLOCATE(DstParamData%Elems(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Elems.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Elems = SrcParamData%Elems
ENDIF
IF (ALLOCATED(SrcParamData%ElemProps)) THEN
  i1_l = LBOUND(SrcParamData%ElemProps,1)
  i1_u = UBOUND(SrcParamData%ElemProps,1)
  IF (.NOT. ALLOCATED(DstParamData%ElemProps)) THEN 
    ALLOCATE(DstParamData%ElemProps(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ElemProps.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%ElemProps,1), UBOUND(SrcParamData%ElemProps,1)
      CALL SD_Copyelemproptype( SrcParamData%ElemProps(i1), DstParamData%ElemProps(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%FG)) THEN
  i1_l = LBOUND(SrcParamData%FG,1)
  i1_u = UBOUND(SrcParamData%FG,1)
  IF (.NOT. ALLOCATED(DstParamData%FG)) THEN 
    ALLOCATE(DstParamData%FG(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%FG.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%FG = SrcParamData%FG
ENDIF
IF (ALLOCATED(SrcParamData%DP0)) THEN
  i1_l = LBOUND(SrcParamData%DP0,1)
  i1_u = UBOUND(SrcParamData%DP0,1)
  i2_l = LBOUND(SrcParamData%DP0,2)
  i2_u = UBOUND(SrcParamData%DP0,2)
  IF (.NOT. ALLOCATED(DstParamData%DP0)) THEN 
    ALLOCATE(DstParamData%DP0(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%DP0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%DP0 = SrcParamData%DP0
ENDIF
IF (ALLOCATED(SrcParamData%NodeID2JointID)) THEN
  i1_l = LBOUND(SrcParamData%NodeID2JointID,1)
  i1_u = UBOUND(SrcParamData%NodeID2JointID,1)
  IF (.NOT. ALLOCATED(DstParamData%NodeID2JointID)) THEN 
    ALLOCATE(DstParamData%NodeID2JointID(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NodeID2JointID.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%NodeID2JointID = SrcParamData%NodeID2JointID
ENDIF
    DstParamData%reduced = SrcParamData%reduced
IF (ALLOCATED(SrcParamData%T_red)) THEN
  i1_l = LBOUND(SrcParamData%T_red,1)
  i1_u = UBOUND(SrcParamData%T_red,1)
  i2_l = LBOUND(SrcParamData%T_red,2)
  i2_u = UBOUND(SrcParamData%T_red,2)
  IF (.NOT. ALLOCATED(DstParamData%T_red)) THEN 
    ALLOCATE(DstParamData%T_red(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%T_red.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%T_red = SrcParamData%T_red
ENDIF
IF (ALLOCATED(SrcParamData%T_red_T)) THEN
  i1_l = LBOUND(SrcParamData%T_red_T,1)
  i1_u = UBOUND(SrcParamData%T_red_T,1)
  i2_l = LBOUND(SrcParamData%T_red_T,2)
  i2_u = UBOUND(SrcParamData%T_red_T,2)
  IF (.NOT. ALLOCATED(DstParamData%T_red_T)) THEN 
    ALLOCATE(DstParamData%T_red_T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%T_red_T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%T_red_T = SrcParamData%T_red_T
ENDIF
IF (ALLOCATED(SrcParamData%NodesDOF)) THEN
  i1_l = LBOUND(SrcParamData%NodesDOF,1)
  i1_u = UBOUND(SrcParamData%NodesDOF,1)
  IF (.NOT. ALLOCATED(DstParamData%NodesDOF)) THEN 
    ALLOCATE(DstParamData%NodesDOF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NodesDOF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%NodesDOF,1), UBOUND(SrcParamData%NodesDOF,1)
      CALL SD_Copyilist( SrcParamData%NodesDOF(i1), DstParamData%NodesDOF(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%NodesDOFred)) THEN
  i1_l = LBOUND(SrcParamData%NodesDOFred,1)
  i1_u = UBOUND(SrcParamData%NodesDOFred,1)
  IF (.NOT. ALLOCATED(DstParamData%NodesDOFred)) THEN 
    ALLOCATE(DstParamData%NodesDOFred(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%NodesDOFred.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%NodesDOFred,1), UBOUND(SrcParamData%NodesDOFred,1)
      CALL SD_Copyilist( SrcParamData%NodesDOFred(i1), DstParamData%NodesDOFred(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%ElemsDOF)) THEN
  i1_l = LBOUND(SrcParamData%ElemsDOF,1)
  i1_u = UBOUND(SrcParamData%ElemsDOF,1)
  i2_l = LBOUND(SrcParamData%ElemsDOF,2)
  i2_u = UBOUND(SrcParamData%ElemsDOF,2)
  IF (.NOT. ALLOCATED(DstParamData%ElemsDOF)) THEN 
    ALLOCATE(DstParamData%ElemsDOF(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ElemsDOF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ElemsDOF = SrcParamData%ElemsDOF
ENDIF
IF (ALLOCATED(SrcParamData%DOFred2Nodes)) THEN
  i1_l = LBOUND(SrcParamData%DOFred2Nodes,1)
  i1_u = UBOUND(SrcParamData%DOFred2Nodes,1)
  i2_l = LBOUND(SrcParamData%DOFred2Nodes,2)
  i2_u = UBOUND(SrcParamData%DOFred2Nodes,2)
  IF (.NOT. ALLOCATED(DstParamData%DOFred2Nodes)) THEN 
    ALLOCATE(DstParamData%DOFred2Nodes(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%DOFred2Nodes.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%DOFred2Nodes = SrcParamData%DOFred2Nodes
ENDIF
IF (ALLOCATED(SrcParamData%CtrlElem2Channel)) THEN
  i1_l = LBOUND(SrcParamData%CtrlElem2Channel,1)
  i1_u = UBOUND(SrcParamData%CtrlElem2Channel,1)
  i2_l = LBOUND(SrcParamData%CtrlElem2Channel,2)
  i2_u = UBOUND(SrcParamData%CtrlElem2Channel,2)
  IF (.NOT. ALLOCATED(DstParamData%CtrlElem2Channel)) THEN 
    ALLOCATE(DstParamData%CtrlElem2Channel(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%CtrlElem2Channel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%CtrlElem2Channel = SrcParamData%CtrlElem2Channel
ENDIF
    DstParamData%nDOFM = SrcParamData%nDOFM
    DstParamData%SttcSolve = SrcParamData%SttcSolve
    DstParamData%GuyanLoadCorrection = SrcParamData%GuyanLoadCorrection
    DstParamData%Floating = SrcParamData%Floating
IF (ALLOCATED(SrcParamData%KMMDiag)) THEN
  i1_l = LBOUND(SrcParamData%KMMDiag,1)
  i1_u = UBOUND(SrcParamData%KMMDiag,1)
  IF (.NOT. ALLOCATED(DstParamData%KMMDiag)) THEN 
    ALLOCATE(DstParamData%KMMDiag(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%KMMDiag.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%KMMDiag = SrcParamData%KMMDiag
ENDIF
IF (ALLOCATED(SrcParamData%CMMDiag)) THEN
  i1_l = LBOUND(SrcParamData%CMMDiag,1)
  i1_u = UBOUND(SrcParamData%CMMDiag,1)
  IF (.NOT. ALLOCATED(DstParamData%CMMDiag)) THEN 
    ALLOCATE(DstParamData%CMMDiag(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%CMMDiag.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%CMMDiag = SrcParamData%CMMDiag
ENDIF
IF (ALLOCATED(SrcParamData%MMB)) THEN
  i1_l = LBOUND(SrcParamData%MMB,1)
  i1_u = UBOUND(SrcParamData%MMB,1)
  i2_l = LBOUND(SrcParamData%MMB,2)
  i2_u = UBOUND(SrcParamData%MMB,2)
  IF (.NOT. ALLOCATED(DstParamData%MMB)) THEN 
    ALLOCATE(DstParamData%MMB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MMB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MMB = SrcParamData%MMB
ENDIF
IF (ALLOCATED(SrcParamData%MBmmB)) THEN
  i1_l = LBOUND(SrcParamData%MBmmB,1)
  i1_u = UBOUND(SrcParamData%MBmmB,1)
  i2_l = LBOUND(SrcParamData%MBmmB,2)
  i2_u = UBOUND(SrcParamData%MBmmB,2)
  IF (.NOT. ALLOCATED(DstParamData%MBmmB)) THEN 
    ALLOCATE(DstParamData%MBmmB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBmmB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MBmmB = SrcParamData%MBmmB
ENDIF
IF (ALLOCATED(SrcParamData%C1_11)) THEN
  i1_l = LBOUND(SrcParamData%C1_11,1)
  i1_u = UBOUND(SrcParamData%C1_11,1)
  i2_l = LBOUND(SrcParamData%C1_11,2)
  i2_u = UBOUND(SrcParamData%C1_11,2)
  IF (.NOT. ALLOCATED(DstParamData%C1_11)) THEN 
    ALLOCATE(DstParamData%C1_11(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C1_11.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%C1_11 = SrcParamData%C1_11
ENDIF
IF (ALLOCATED(SrcParamData%C1_12)) THEN
  i1_l = LBOUND(SrcParamData%C1_12,1)
  i1_u = UBOUND(SrcParamData%C1_12,1)
  i2_l = LBOUND(SrcParamData%C1_12,2)
  i2_u = UBOUND(SrcParamData%C1_12,2)
  IF (.NOT. ALLOCATED(DstParamData%C1_12)) THEN 
    ALLOCATE(DstParamData%C1_12(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C1_12.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%C1_12 = SrcParamData%C1_12
ENDIF
IF (ALLOCATED(SrcParamData%D1_141)) THEN
  i1_l = LBOUND(SrcParamData%D1_141,1)
  i1_u = UBOUND(SrcParamData%D1_141,1)
  i2_l = LBOUND(SrcParamData%D1_141,2)
  i2_u = UBOUND(SrcParamData%D1_141,2)
  IF (.NOT. ALLOCATED(DstParamData%D1_141)) THEN 
    ALLOCATE(DstParamData%D1_141(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_141.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D1_141 = SrcParamData%D1_141
ENDIF
IF (ALLOCATED(SrcParamData%D1_142)) THEN
  i1_l = LBOUND(SrcParamData%D1_142,1)
  i1_u = UBOUND(SrcParamData%D1_142,1)
  i2_l = LBOUND(SrcParamData%D1_142,2)
  i2_u = UBOUND(SrcParamData%D1_142,2)
  IF (.NOT. ALLOCATED(DstParamData%D1_142)) THEN 
    ALLOCATE(DstParamData%D1_142(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D1_142.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D1_142 = SrcParamData%D1_142
ENDIF
IF (ALLOCATED(SrcParamData%PhiM)) THEN
  i1_l = LBOUND(SrcParamData%PhiM,1)
  i1_u = UBOUND(SrcParamData%PhiM,1)
  i2_l = LBOUND(SrcParamData%PhiM,2)
  i2_u = UBOUND(SrcParamData%PhiM,2)
  IF (.NOT. ALLOCATED(DstParamData%PhiM)) THEN 
    ALLOCATE(DstParamData%PhiM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PhiM = SrcParamData%PhiM
ENDIF
IF (ALLOCATED(SrcParamData%C2_61)) THEN
  i1_l = LBOUND(SrcParamData%C2_61,1)
  i1_u = UBOUND(SrcParamData%C2_61,1)
  i2_l = LBOUND(SrcParamData%C2_61,2)
  i2_u = UBOUND(SrcParamData%C2_61,2)
  IF (.NOT. ALLOCATED(DstParamData%C2_61)) THEN 
    ALLOCATE(DstParamData%C2_61(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C2_61.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%C2_61 = SrcParamData%C2_61
ENDIF
IF (ALLOCATED(SrcParamData%C2_62)) THEN
  i1_l = LBOUND(SrcParamData%C2_62,1)
  i1_u = UBOUND(SrcParamData%C2_62,1)
  i2_l = LBOUND(SrcParamData%C2_62,2)
  i2_u = UBOUND(SrcParamData%C2_62,2)
  IF (.NOT. ALLOCATED(DstParamData%C2_62)) THEN 
    ALLOCATE(DstParamData%C2_62(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%C2_62.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%C2_62 = SrcParamData%C2_62
ENDIF
IF (ALLOCATED(SrcParamData%PhiRb_TI)) THEN
  i1_l = LBOUND(SrcParamData%PhiRb_TI,1)
  i1_u = UBOUND(SrcParamData%PhiRb_TI,1)
  i2_l = LBOUND(SrcParamData%PhiRb_TI,2)
  i2_u = UBOUND(SrcParamData%PhiRb_TI,2)
  IF (.NOT. ALLOCATED(DstParamData%PhiRb_TI)) THEN 
    ALLOCATE(DstParamData%PhiRb_TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiRb_TI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PhiRb_TI = SrcParamData%PhiRb_TI
ENDIF
IF (ALLOCATED(SrcParamData%D2_63)) THEN
  i1_l = LBOUND(SrcParamData%D2_63,1)
  i1_u = UBOUND(SrcParamData%D2_63,1)
  i2_l = LBOUND(SrcParamData%D2_63,2)
  i2_u = UBOUND(SrcParamData%D2_63,2)
  IF (.NOT. ALLOCATED(DstParamData%D2_63)) THEN 
    ALLOCATE(DstParamData%D2_63(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D2_63.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D2_63 = SrcParamData%D2_63
ENDIF
IF (ALLOCATED(SrcParamData%D2_64)) THEN
  i1_l = LBOUND(SrcParamData%D2_64,1)
  i1_u = UBOUND(SrcParamData%D2_64,1)
  i2_l = LBOUND(SrcParamData%D2_64,2)
  i2_u = UBOUND(SrcParamData%D2_64,2)
  IF (.NOT. ALLOCATED(DstParamData%D2_64)) THEN 
    ALLOCATE(DstParamData%D2_64(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%D2_64.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%D2_64 = SrcParamData%D2_64
ENDIF
IF (ALLOCATED(SrcParamData%MBB)) THEN
  i1_l = LBOUND(SrcParamData%MBB,1)
  i1_u = UBOUND(SrcParamData%MBB,1)
  i2_l = LBOUND(SrcParamData%MBB,2)
  i2_u = UBOUND(SrcParamData%MBB,2)
  IF (.NOT. ALLOCATED(DstParamData%MBB)) THEN 
    ALLOCATE(DstParamData%MBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MBB = SrcParamData%MBB
ENDIF
IF (ALLOCATED(SrcParamData%KBB)) THEN
  i1_l = LBOUND(SrcParamData%KBB,1)
  i1_u = UBOUND(SrcParamData%KBB,1)
  i2_l = LBOUND(SrcParamData%KBB,2)
  i2_u = UBOUND(SrcParamData%KBB,2)
  IF (.NOT. ALLOCATED(DstParamData%KBB)) THEN 
    ALLOCATE(DstParamData%KBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%KBB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%KBB = SrcParamData%KBB
ENDIF
IF (ALLOCATED(SrcParamData%CBB)) THEN
  i1_l = LBOUND(SrcParamData%CBB,1)
  i1_u = UBOUND(SrcParamData%CBB,1)
  i2_l = LBOUND(SrcParamData%CBB,2)
  i2_u = UBOUND(SrcParamData%CBB,2)
  IF (.NOT. ALLOCATED(DstParamData%CBB)) THEN 
    ALLOCATE(DstParamData%CBB(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%CBB.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%CBB = SrcParamData%CBB
ENDIF
IF (ALLOCATED(SrcParamData%CMM)) THEN
  i1_l = LBOUND(SrcParamData%CMM,1)
  i1_u = UBOUND(SrcParamData%CMM,1)
  i2_l = LBOUND(SrcParamData%CMM,2)
  i2_u = UBOUND(SrcParamData%CMM,2)
  IF (.NOT. ALLOCATED(DstParamData%CMM)) THEN 
    ALLOCATE(DstParamData%CMM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%CMM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%CMM = SrcParamData%CMM
ENDIF
IF (ALLOCATED(SrcParamData%MBM)) THEN
  i1_l = LBOUND(SrcParamData%MBM,1)
  i1_u = UBOUND(SrcParamData%MBM,1)
  i2_l = LBOUND(SrcParamData%MBM,2)
  i2_u = UBOUND(SrcParamData%MBM,2)
  IF (.NOT. ALLOCATED(DstParamData%MBM)) THEN 
    ALLOCATE(DstParamData%MBM(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MBM.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%MBM = SrcParamData%MBM
ENDIF
IF (ALLOCATED(SrcParamData%PhiL_T)) THEN
  i1_l = LBOUND(SrcParamData%PhiL_T,1)
  i1_u = UBOUND(SrcParamData%PhiL_T,1)
  i2_l = LBOUND(SrcParamData%PhiL_T,2)
  i2_u = UBOUND(SrcParamData%PhiL_T,2)
  IF (.NOT. ALLOCATED(DstParamData%PhiL_T)) THEN 
    ALLOCATE(DstParamData%PhiL_T(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiL_T.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PhiL_T = SrcParamData%PhiL_T
ENDIF
IF (ALLOCATED(SrcParamData%PhiLInvOmgL2)) THEN
  i1_l = LBOUND(SrcParamData%PhiLInvOmgL2,1)
  i1_u = UBOUND(SrcParamData%PhiLInvOmgL2,1)
  i2_l = LBOUND(SrcParamData%PhiLInvOmgL2,2)
  i2_u = UBOUND(SrcParamData%PhiLInvOmgL2,2)
  IF (.NOT. ALLOCATED(DstParamData%PhiLInvOmgL2)) THEN 
    ALLOCATE(DstParamData%PhiLInvOmgL2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PhiLInvOmgL2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PhiLInvOmgL2 = SrcParamData%PhiLInvOmgL2
ENDIF
IF (ALLOCATED(SrcParamData%KLLm1)) THEN
  i1_l = LBOUND(SrcParamData%KLLm1,1)
  i1_u = UBOUND(SrcParamData%KLLm1,1)
  i2_l = LBOUND(SrcParamData%KLLm1,2)
  i2_u = UBOUND(SrcParamData%KLLm1,2)
  IF (.NOT. ALLOCATED(DstParamData%KLLm1)) THEN 
    ALLOCATE(DstParamData%KLLm1(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%KLLm1.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%KLLm1 = SrcParamData%KLLm1
ENDIF
IF (ALLOCATED(SrcParamData%AM2Jac)) THEN
  i1_l = LBOUND(SrcParamData%AM2Jac,1)
  i1_u = UBOUND(SrcParamData%AM2Jac,1)
  i2_l = LBOUND(SrcParamData%AM2Jac,2)
  i2_u = UBOUND(SrcParamData%AM2Jac,2)
  IF (.NOT. ALLOCATED(DstParamData%AM2Jac)) THEN 
    ALLOCATE(DstParamData%AM2Jac(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM2Jac.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AM2Jac = SrcParamData%AM2Jac
ENDIF
IF (ALLOCATED(SrcParamData%AM2JacPiv)) THEN
  i1_l = LBOUND(SrcParamData%AM2JacPiv,1)
  i1_u = UBOUND(SrcParamData%AM2JacPiv,1)
  IF (.NOT. ALLOCATED(DstParamData%AM2JacPiv)) THEN 
    ALLOCATE(DstParamData%AM2JacPiv(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%AM2JacPiv.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%AM2JacPiv = SrcParamData%AM2JacPiv
ENDIF
IF (ALLOCATED(SrcParamData%TI)) THEN
  i1_l = LBOUND(SrcParamData%TI,1)
  i1_u = UBOUND(SrcParamData%TI,1)
  i2_l = LBOUND(SrcParamData%TI,2)
  i2_u = UBOUND(SrcParamData%TI,2)
  IF (.NOT. ALLOCATED(DstParamData%TI)) THEN 
    ALLOCATE(DstParamData%TI(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TI.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%TI = SrcParamData%TI
ENDIF
IF (ALLOCATED(SrcParamData%TIreact)) THEN
  i1_l = LBOUND(SrcParamData%TIreact,1)
  i1_u = UBOUND(SrcParamData%TIreact,1)
  i2_l = LBOUND(SrcParamData%TIreact,2)
  i2_u = UBOUND(SrcParamData%TIreact,2)
  IF (.NOT. ALLOCATED(DstParamData%TIreact)) THEN 
    ALLOCATE(DstParamData%TIreact(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%TIreact.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%TIreact = SrcParamData%TIreact
ENDIF
    DstParamData%nNodes = SrcParamData%nNodes
    DstParamData%nNodes_I = SrcParamData%nNodes_I
    DstParamData%nNodes_L = SrcParamData%nNodes_L
    DstParamData%nNodes_C = SrcParamData%nNodes_C
IF (ALLOCATED(SrcParamData%Nodes_I)) THEN
  i1_l = LBOUND(SrcParamData%Nodes_I,1)
  i1_u = UBOUND(SrcParamData%Nodes_I,1)
  i2_l = LBOUND(SrcParamData%Nodes_I,2)
  i2_u = UBOUND(SrcParamData%Nodes_I,2)
  IF (.NOT. ALLOCATED(DstParamData%Nodes_I)) THEN 
    ALLOCATE(DstParamData%Nodes_I(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Nodes_I.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Nodes_I = SrcParamData%Nodes_I
ENDIF
IF (ALLOCATED(SrcParamData%Nodes_L)) THEN
  i1_l = LBOUND(SrcParamData%Nodes_L,1)
  i1_u = UBOUND(SrcParamData%Nodes_L,1)
  i2_l = LBOUND(SrcParamData%Nodes_L,2)
  i2_u = UBOUND(SrcParamData%Nodes_L,2)
  IF (.NOT. ALLOCATED(DstParamData%Nodes_L)) THEN 
    ALLOCATE(DstParamData%Nodes_L(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Nodes_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Nodes_L = SrcParamData%Nodes_L
ENDIF
IF (ALLOCATED(SrcParamData%Nodes_C)) THEN
  i1_l = LBOUND(SrcParamData%Nodes_C,1)
  i1_u = UBOUND(SrcParamData%Nodes_C,1)
  i2_l = LBOUND(SrcParamData%Nodes_C,2)
  i2_u = UBOUND(SrcParamData%Nodes_C,2)
  IF (.NOT. ALLOCATED(DstParamData%Nodes_C)) THEN 
    ALLOCATE(DstParamData%Nodes_C(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Nodes_C.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Nodes_C = SrcParamData%Nodes_C
ENDIF
    DstParamData%nDOFI__ = SrcParamData%nDOFI__
    DstParamData%nDOFI_Rb = SrcParamData%nDOFI_Rb
    DstParamData%nDOFI_F = SrcParamData%nDOFI_F
    DstParamData%nDOFL_L = SrcParamData%nDOFL_L
    DstParamData%nDOFC__ = SrcParamData%nDOFC__
    DstParamData%nDOFC_Rb = SrcParamData%nDOFC_Rb
    DstParamData%nDOFC_L = SrcParamData%nDOFC_L
    DstParamData%nDOFC_F = SrcParamData%nDOFC_F
    DstParamData%nDOFR__ = SrcParamData%nDOFR__
    DstParamData%nDOF__Rb = SrcParamData%nDOF__Rb
    DstParamData%nDOF__L = SrcParamData%nDOF__L
    DstParamData%nDOF__F = SrcParamData%nDOF__F
IF (ALLOCATED(SrcParamData%IDI__)) THEN
  i1_l = LBOUND(SrcParamData%IDI__,1)
  i1_u = UBOUND(SrcParamData%IDI__,1)
  IF (.NOT. ALLOCATED(DstParamData%IDI__)) THEN 
    ALLOCATE(DstParamData%IDI__(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDI__.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDI__ = SrcParamData%IDI__
ENDIF
IF (ALLOCATED(SrcParamData%IDI_Rb)) THEN
  i1_l = LBOUND(SrcParamData%IDI_Rb,1)
  i1_u = UBOUND(SrcParamData%IDI_Rb,1)
  IF (.NOT. ALLOCATED(DstParamData%IDI_Rb)) THEN 
    ALLOCATE(DstParamData%IDI_Rb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDI_Rb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDI_Rb = SrcParamData%IDI_Rb
ENDIF
IF (ALLOCATED(SrcParamData%IDI_F)) THEN
  i1_l = LBOUND(SrcParamData%IDI_F,1)
  i1_u = UBOUND(SrcParamData%IDI_F,1)
  IF (.NOT. ALLOCATED(DstParamData%IDI_F)) THEN 
    ALLOCATE(DstParamData%IDI_F(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDI_F.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDI_F = SrcParamData%IDI_F
ENDIF
IF (ALLOCATED(SrcParamData%IDL_L)) THEN
  i1_l = LBOUND(SrcParamData%IDL_L,1)
  i1_u = UBOUND(SrcParamData%IDL_L,1)
  IF (.NOT. ALLOCATED(DstParamData%IDL_L)) THEN 
    ALLOCATE(DstParamData%IDL_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDL_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDL_L = SrcParamData%IDL_L
ENDIF
IF (ALLOCATED(SrcParamData%IDC__)) THEN
  i1_l = LBOUND(SrcParamData%IDC__,1)
  i1_u = UBOUND(SrcParamData%IDC__,1)
  IF (.NOT. ALLOCATED(DstParamData%IDC__)) THEN 
    ALLOCATE(DstParamData%IDC__(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDC__.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDC__ = SrcParamData%IDC__
ENDIF
IF (ALLOCATED(SrcParamData%IDC_Rb)) THEN
  i1_l = LBOUND(SrcParamData%IDC_Rb,1)
  i1_u = UBOUND(SrcParamData%IDC_Rb,1)
  IF (.NOT. ALLOCATED(DstParamData%IDC_Rb)) THEN 
    ALLOCATE(DstParamData%IDC_Rb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDC_Rb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDC_Rb = SrcParamData%IDC_Rb
ENDIF
IF (ALLOCATED(SrcParamData%IDC_L)) THEN
  i1_l = LBOUND(SrcParamData%IDC_L,1)
  i1_u = UBOUND(SrcParamData%IDC_L,1)
  IF (.NOT. ALLOCATED(DstParamData%IDC_L)) THEN 
    ALLOCATE(DstParamData%IDC_L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDC_L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDC_L = SrcParamData%IDC_L
ENDIF
IF (ALLOCATED(SrcParamData%IDC_F)) THEN
  i1_l = LBOUND(SrcParamData%IDC_F,1)
  i1_u = UBOUND(SrcParamData%IDC_F,1)
  IF (.NOT. ALLOCATED(DstParamData%IDC_F)) THEN 
    ALLOCATE(DstParamData%IDC_F(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDC_F.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDC_F = SrcParamData%IDC_F
ENDIF
IF (ALLOCATED(SrcParamData%IDR__)) THEN
  i1_l = LBOUND(SrcParamData%IDR__,1)
  i1_u = UBOUND(SrcParamData%IDR__,1)
  IF (.NOT. ALLOCATED(DstParamData%IDR__)) THEN 
    ALLOCATE(DstParamData%IDR__(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%IDR__.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%IDR__ = SrcParamData%IDR__
ENDIF
IF (ALLOCATED(SrcParamData%ID__Rb)) THEN
  i1_l = LBOUND(SrcParamData%ID__Rb,1)
  i1_u = UBOUND(SrcParamData%ID__Rb,1)
  IF (.NOT. ALLOCATED(DstParamData%ID__Rb)) THEN 
    ALLOCATE(DstParamData%ID__Rb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ID__Rb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ID__Rb = SrcParamData%ID__Rb
ENDIF
IF (ALLOCATED(SrcParamData%ID__L)) THEN
  i1_l = LBOUND(SrcParamData%ID__L,1)
  i1_u = UBOUND(SrcParamData%ID__L,1)
  IF (.NOT. ALLOCATED(DstParamData%ID__L)) THEN 
    ALLOCATE(DstParamData%ID__L(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ID__L.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ID__L = SrcParamData%ID__L
ENDIF
IF (ALLOCATED(SrcParamData%ID__F)) THEN
  i1_l = LBOUND(SrcParamData%ID__F,1)
  i1_u = UBOUND(SrcParamData%ID__F,1)
  IF (.NOT. ALLOCATED(DstParamData%ID__F)) THEN 
    ALLOCATE(DstParamData%ID__F(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ID__F.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ID__F = SrcParamData%ID__F
ENDIF
    DstParamData%NMOutputs = SrcParamData%NMOutputs
    DstParamData%NumOuts = SrcParamData%NumOuts
    DstParamData%OutSwtch = SrcParamData%OutSwtch
    DstParamData%UnJckF = SrcParamData%UnJckF
    DstParamData%Delim = SrcParamData%Delim
    DstParamData%OutFmt = SrcParamData%OutFmt
    DstParamData%OutSFmt = SrcParamData%OutSFmt
IF (ALLOCATED(SrcParamData%MoutLst)) THEN
  i1_l = LBOUND(SrcParamData%MoutLst,1)
  i1_u = UBOUND(SrcParamData%MoutLst,1)
  IF (.NOT. ALLOCATED(DstParamData%MoutLst)) THEN 
    ALLOCATE(DstParamData%MoutLst(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%MoutLst,1), UBOUND(SrcParamData%MoutLst,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst(i1), DstParamData%MoutLst(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst2)) THEN
  i1_l = LBOUND(SrcParamData%MoutLst2,1)
  i1_u = UBOUND(SrcParamData%MoutLst2,1)
  IF (.NOT. ALLOCATED(DstParamData%MoutLst2)) THEN 
    ALLOCATE(DstParamData%MoutLst2(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst2.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%MoutLst2,1), UBOUND(SrcParamData%MoutLst2,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst2(i1), DstParamData%MoutLst2(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%MoutLst3)) THEN
  i1_l = LBOUND(SrcParamData%MoutLst3,1)
  i1_u = UBOUND(SrcParamData%MoutLst3,1)
  IF (.NOT. ALLOCATED(DstParamData%MoutLst3)) THEN 
    ALLOCATE(DstParamData%MoutLst3(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%MoutLst3.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%MoutLst3,1), UBOUND(SrcParamData%MoutLst3,1)
      CALL SD_Copymeshauxdatatype( SrcParamData%MoutLst3(i1), DstParamData%MoutLst3(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcParamData%OutParam)) THEN
  i1_l = LBOUND(SrcParamData%OutParam,1)
  i1_u = UBOUND(SrcParamData%OutParam,1)
  IF (.NOT. ALLOCATED(DstParamData%OutParam)) THEN 
    ALLOCATE(DstParamData%OutParam(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%OutParam.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcParamData%OutParam,1), UBOUND(SrcParamData%OutParam,1)
      CALL NWTC_Library_Copyoutparmtype( SrcParamData%OutParam(i1), DstParamData%OutParam(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
    DstParamData%OutAll = SrcParamData%OutAll
    DstParamData%OutCBModes = SrcParamData%OutCBModes
    DstParamData%OutFEMModes = SrcParamData%OutFEMModes
    DstParamData%OutReact = SrcParamData%OutReact
    DstParamData%OutAllInt = SrcParamData%OutAllInt
    DstParamData%OutAllDims = SrcParamData%OutAllDims
    DstParamData%OutDec = SrcParamData%OutDec
IF (ALLOCATED(SrcParamData%Jac_u_indx)) THEN
  i1_l = LBOUND(SrcParamData%Jac_u_indx,1)
  i1_u = UBOUND(SrcParamData%Jac_u_indx,1)
  i2_l = LBOUND(SrcParamData%Jac_u_indx,2)
  i2_u = UBOUND(SrcParamData%Jac_u_indx,2)
  IF (.NOT. ALLOCATED(DstParamData%Jac_u_indx)) THEN 
    ALLOCATE(DstParamData%Jac_u_indx(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Jac_u_indx.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Jac_u_indx = SrcParamData%Jac_u_indx
ENDIF
IF (ALLOCATED(SrcParamData%du)) THEN
  i1_l = LBOUND(SrcParamData%du,1)
  i1_u = UBOUND(SrcParamData%du,1)
  IF (.NOT. ALLOCATED(DstParamData%du)) THEN 
    ALLOCATE(DstParamData%du(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%du.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%du = SrcParamData%du
ENDIF
    DstParamData%dx = SrcParamData%dx
    DstParamData%Jac_ny = SrcParamData%Jac_ny
    DstParamData%Jac_nx = SrcParamData%Jac_nx
    DstParamData%RotStates = SrcParamData%RotStates
 END SUBROUTINE SD_CopyParam

 SUBROUTINE SD_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(SD_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyParam'

  ErrStat = ErrID_None
  ErrMsg  = ""

IF (ALLOCATED(ParamData%Elems)) THEN
  DEALLOCATE(ParamData%Elems)
ENDIF
IF (ALLOCATED(ParamData%ElemProps)) THEN
DO i1 = LBOUND(ParamData%ElemProps,1), UBOUND(ParamData%ElemProps,1)
  CALL SD_DestroyElemPropType( ParamData%ElemProps(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%ElemProps)
ENDIF
IF (ALLOCATED(ParamData%FG)) THEN
  DEALLOCATE(ParamData%FG)
ENDIF
IF (ALLOCATED(ParamData%DP0)) THEN
  DEALLOCATE(ParamData%DP0)
ENDIF
IF (ALLOCATED(ParamData%NodeID2JointID)) THEN
  DEALLOCATE(ParamData%NodeID2JointID)
ENDIF
IF (ALLOCATED(ParamData%T_red)) THEN
  DEALLOCATE(ParamData%T_red)
ENDIF
IF (ALLOCATED(ParamData%T_red_T)) THEN
  DEALLOCATE(ParamData%T_red_T)
ENDIF
IF (ALLOCATED(ParamData%NodesDOF)) THEN
DO i1 = LBOUND(ParamData%NodesDOF,1), UBOUND(ParamData%NodesDOF,1)
  CALL SD_DestroyIList( ParamData%NodesDOF(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%NodesDOF)
ENDIF
IF (ALLOCATED(ParamData%NodesDOFred)) THEN
DO i1 = LBOUND(ParamData%NodesDOFred,1), UBOUND(ParamData%NodesDOFred,1)
  CALL SD_DestroyIList( ParamData%NodesDOFred(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%NodesDOFred)
ENDIF
IF (ALLOCATED(ParamData%ElemsDOF)) THEN
  DEALLOCATE(ParamData%ElemsDOF)
ENDIF
IF (ALLOCATED(ParamData%DOFred2Nodes)) THEN
  DEALLOCATE(ParamData%DOFred2Nodes)
ENDIF
IF (ALLOCATED(ParamData%CtrlElem2Channel)) THEN
  DEALLOCATE(ParamData%CtrlElem2Channel)
ENDIF
IF (ALLOCATED(ParamData%KMMDiag)) THEN
  DEALLOCATE(ParamData%KMMDiag)
ENDIF
IF (ALLOCATED(ParamData%CMMDiag)) THEN
  DEALLOCATE(ParamData%CMMDiag)
ENDIF
IF (ALLOCATED(ParamData%MMB)) THEN
  DEALLOCATE(ParamData%MMB)
ENDIF
IF (ALLOCATED(ParamData%MBmmB)) THEN
  DEALLOCATE(ParamData%MBmmB)
ENDIF
IF (ALLOCATED(ParamData%C1_11)) THEN
  DEALLOCATE(ParamData%C1_11)
ENDIF
IF (ALLOCATED(ParamData%C1_12)) THEN
  DEALLOCATE(ParamData%C1_12)
ENDIF
IF (ALLOCATED(ParamData%D1_141)) THEN
  DEALLOCATE(ParamData%D1_141)
ENDIF
IF (ALLOCATED(ParamData%D1_142)) THEN
  DEALLOCATE(ParamData%D1_142)
ENDIF
IF (ALLOCATED(ParamData%PhiM)) THEN
  DEALLOCATE(ParamData%PhiM)
ENDIF
IF (ALLOCATED(ParamData%C2_61)) THEN
  DEALLOCATE(ParamData%C2_61)
ENDIF
IF (ALLOCATED(ParamData%C2_62)) THEN
  DEALLOCATE(ParamData%C2_62)
ENDIF
IF (ALLOCATED(ParamData%PhiRb_TI)) THEN
  DEALLOCATE(ParamData%PhiRb_TI)
ENDIF
IF (ALLOCATED(ParamData%D2_63)) THEN
  DEALLOCATE(ParamData%D2_63)
ENDIF
IF (ALLOCATED(ParamData%D2_64)) THEN
  DEALLOCATE(ParamData%D2_64)
ENDIF
IF (ALLOCATED(ParamData%MBB)) THEN
  DEALLOCATE(ParamData%MBB)
ENDIF
IF (ALLOCATED(ParamData%KBB)) THEN
  DEALLOCATE(ParamData%KBB)
ENDIF
IF (ALLOCATED(ParamData%CBB)) THEN
  DEALLOCATE(ParamData%CBB)
ENDIF
IF (ALLOCATED(ParamData%CMM)) THEN
  DEALLOCATE(ParamData%CMM)
ENDIF
IF (ALLOCATED(ParamData%MBM)) THEN
  DEALLOCATE(ParamData%MBM)
ENDIF
IF (ALLOCATED(ParamData%PhiL_T)) THEN
  DEALLOCATE(ParamData%PhiL_T)
ENDIF
IF (ALLOCATED(ParamData%PhiLInvOmgL2)) THEN
  DEALLOCATE(ParamData%PhiLInvOmgL2)
ENDIF
IF (ALLOCATED(ParamData%KLLm1)) THEN
  DEALLOCATE(ParamData%KLLm1)
ENDIF
IF (ALLOCATED(ParamData%AM2Jac)) THEN
  DEALLOCATE(ParamData%AM2Jac)
ENDIF
IF (ALLOCATED(ParamData%AM2JacPiv)) THEN
  DEALLOCATE(ParamData%AM2JacPiv)
ENDIF
IF (ALLOCATED(ParamData%TI)) THEN
  DEALLOCATE(ParamData%TI)
ENDIF
IF (ALLOCATED(ParamData%TIreact)) THEN
  DEALLOCATE(ParamData%TIreact)
ENDIF
IF (ALLOCATED(ParamData%Nodes_I)) THEN
  DEALLOCATE(ParamData%Nodes_I)
ENDIF
IF (ALLOCATED(ParamData%Nodes_L)) THEN
  DEALLOCATE(ParamData%Nodes_L)
ENDIF
IF (ALLOCATED(ParamData%Nodes_C)) THEN
  DEALLOCATE(ParamData%Nodes_C)
ENDIF
IF (ALLOCATED(ParamData%IDI__)) THEN
  DEALLOCATE(ParamData%IDI__)
ENDIF
IF (ALLOCATED(ParamData%IDI_Rb)) THEN
  DEALLOCATE(ParamData%IDI_Rb)
ENDIF
IF (ALLOCATED(ParamData%IDI_F)) THEN
  DEALLOCATE(ParamData%IDI_F)
ENDIF
IF (ALLOCATED(ParamData%IDL_L)) THEN
  DEALLOCATE(ParamData%IDL_L)
ENDIF
IF (ALLOCATED(ParamData%IDC__)) THEN
  DEALLOCATE(ParamData%IDC__)
ENDIF
IF (ALLOCATED(ParamData%IDC_Rb)) THEN
  DEALLOCATE(ParamData%IDC_Rb)
ENDIF
IF (ALLOCATED(ParamData%IDC_L)) THEN
  DEALLOCATE(ParamData%IDC_L)
ENDIF
IF (ALLOCATED(ParamData%IDC_F)) THEN
  DEALLOCATE(ParamData%IDC_F)
ENDIF
IF (ALLOCATED(ParamData%IDR__)) THEN
  DEALLOCATE(ParamData%IDR__)
ENDIF
IF (ALLOCATED(ParamData%ID__Rb)) THEN
  DEALLOCATE(ParamData%ID__Rb)
ENDIF
IF (ALLOCATED(ParamData%ID__L)) THEN
  DEALLOCATE(ParamData%ID__L)
ENDIF
IF (ALLOCATED(ParamData%ID__F)) THEN
  DEALLOCATE(ParamData%ID__F)
ENDIF
IF (ALLOCATED(ParamData%MoutLst)) THEN
DO i1 = LBOUND(ParamData%MoutLst,1), UBOUND(ParamData%MoutLst,1)
  CALL SD_DestroyMeshAuxDataType( ParamData%MoutLst(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%MoutLst)
ENDIF
IF (ALLOCATED(ParamData%MoutLst2)) THEN
DO i1 = LBOUND(ParamData%MoutLst2,1), UBOUND(ParamData%MoutLst2,1)
  CALL SD_DestroyMeshAuxDataType( ParamData%MoutLst2(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%MoutLst2)
ENDIF
IF (ALLOCATED(ParamData%MoutLst3)) THEN
DO i1 = LBOUND(ParamData%MoutLst3,1), UBOUND(ParamData%MoutLst3,1)
  CALL SD_DestroyMeshAuxDataType( ParamData%MoutLst3(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%MoutLst3)
ENDIF
IF (ALLOCATED(ParamData%OutParam)) THEN
DO i1 = LBOUND(ParamData%OutParam,1), UBOUND(ParamData%OutParam,1)
  CALL NWTC_Library_DestroyOutParmType( ParamData%OutParam(i1), ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
ENDDO
  DEALLOCATE(ParamData%OutParam)
ENDIF
IF (ALLOCATED(ParamData%Jac_u_indx)) THEN
  DEALLOCATE(ParamData%Jac_u_indx)
ENDIF
IF (ALLOCATED(ParamData%du)) THEN
  DEALLOCATE(ParamData%du)
ENDIF
 END SUBROUTINE SD_DestroyParam


subroutine SD_PackParam(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_ParameterType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackParam'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   if (Buf%ErrStat >= AbortErrLev) return
   ! SDDeltaT
   call RegPack(Buf, InData%SDDeltaT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IntMethod
   call RegPack(Buf, InData%IntMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF
   call RegPack(Buf, InData%nDOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF_red
   call RegPack(Buf, InData%nDOF_red)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nmembers
   call RegPack(Buf, InData%Nmembers)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Elems
   call RegPack(Buf, allocated(InData%Elems))
   if (allocated(InData%Elems)) then
      call RegPackBounds(Buf, 2, lbound(InData%Elems), ubound(InData%Elems))
      call RegPack(Buf, InData%Elems)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElemProps
   call RegPack(Buf, allocated(InData%ElemProps))
   if (allocated(InData%ElemProps)) then
      call RegPackBounds(Buf, 1, lbound(InData%ElemProps), ubound(InData%ElemProps))
      LB(1:1) = lbound(InData%ElemProps)
      UB(1:1) = ubound(InData%ElemProps)
      do i1 = LB(1), UB(1)
         call SD_PackElemPropType(Buf, InData%ElemProps(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! FG
   call RegPack(Buf, allocated(InData%FG))
   if (allocated(InData%FG)) then
      call RegPackBounds(Buf, 1, lbound(InData%FG), ubound(InData%FG))
      call RegPack(Buf, InData%FG)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DP0
   call RegPack(Buf, allocated(InData%DP0))
   if (allocated(InData%DP0)) then
      call RegPackBounds(Buf, 2, lbound(InData%DP0), ubound(InData%DP0))
      call RegPack(Buf, InData%DP0)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodeID2JointID
   call RegPack(Buf, allocated(InData%NodeID2JointID))
   if (allocated(InData%NodeID2JointID)) then
      call RegPackBounds(Buf, 1, lbound(InData%NodeID2JointID), ubound(InData%NodeID2JointID))
      call RegPack(Buf, InData%NodeID2JointID)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! reduced
   call RegPack(Buf, InData%reduced)
   if (RegCheckErr(Buf, RoutineName)) return
   ! T_red
   call RegPack(Buf, allocated(InData%T_red))
   if (allocated(InData%T_red)) then
      call RegPackBounds(Buf, 2, lbound(InData%T_red), ubound(InData%T_red))
      call RegPack(Buf, InData%T_red)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! T_red_T
   call RegPack(Buf, allocated(InData%T_red_T))
   if (allocated(InData%T_red_T)) then
      call RegPackBounds(Buf, 2, lbound(InData%T_red_T), ubound(InData%T_red_T))
      call RegPack(Buf, InData%T_red_T)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodesDOF
   call RegPack(Buf, allocated(InData%NodesDOF))
   if (allocated(InData%NodesDOF)) then
      call RegPackBounds(Buf, 1, lbound(InData%NodesDOF), ubound(InData%NodesDOF))
      LB(1:1) = lbound(InData%NodesDOF)
      UB(1:1) = ubound(InData%NodesDOF)
      do i1 = LB(1), UB(1)
         call SD_PackIList(Buf, InData%NodesDOF(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NodesDOFred
   call RegPack(Buf, allocated(InData%NodesDOFred))
   if (allocated(InData%NodesDOFred)) then
      call RegPackBounds(Buf, 1, lbound(InData%NodesDOFred), ubound(InData%NodesDOFred))
      LB(1:1) = lbound(InData%NodesDOFred)
      UB(1:1) = ubound(InData%NodesDOFred)
      do i1 = LB(1), UB(1)
         call SD_PackIList(Buf, InData%NodesDOFred(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ElemsDOF
   call RegPack(Buf, allocated(InData%ElemsDOF))
   if (allocated(InData%ElemsDOF)) then
      call RegPackBounds(Buf, 2, lbound(InData%ElemsDOF), ubound(InData%ElemsDOF))
      call RegPack(Buf, InData%ElemsDOF)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! DOFred2Nodes
   call RegPack(Buf, allocated(InData%DOFred2Nodes))
   if (allocated(InData%DOFred2Nodes)) then
      call RegPackBounds(Buf, 2, lbound(InData%DOFred2Nodes), ubound(InData%DOFred2Nodes))
      call RegPack(Buf, InData%DOFred2Nodes)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CtrlElem2Channel
   call RegPack(Buf, allocated(InData%CtrlElem2Channel))
   if (allocated(InData%CtrlElem2Channel)) then
      call RegPackBounds(Buf, 2, lbound(InData%CtrlElem2Channel), ubound(InData%CtrlElem2Channel))
      call RegPack(Buf, InData%CtrlElem2Channel)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFM
   call RegPack(Buf, InData%nDOFM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SttcSolve
   call RegPack(Buf, InData%SttcSolve)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GuyanLoadCorrection
   call RegPack(Buf, InData%GuyanLoadCorrection)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Floating
   call RegPack(Buf, InData%Floating)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KMMDiag
   call RegPack(Buf, allocated(InData%KMMDiag))
   if (allocated(InData%KMMDiag)) then
      call RegPackBounds(Buf, 1, lbound(InData%KMMDiag), ubound(InData%KMMDiag))
      call RegPack(Buf, InData%KMMDiag)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMMDiag
   call RegPack(Buf, allocated(InData%CMMDiag))
   if (allocated(InData%CMMDiag)) then
      call RegPackBounds(Buf, 1, lbound(InData%CMMDiag), ubound(InData%CMMDiag))
      call RegPack(Buf, InData%CMMDiag)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MMB
   call RegPack(Buf, allocated(InData%MMB))
   if (allocated(InData%MMB)) then
      call RegPackBounds(Buf, 2, lbound(InData%MMB), ubound(InData%MMB))
      call RegPack(Buf, InData%MMB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MBmmB
   call RegPack(Buf, allocated(InData%MBmmB))
   if (allocated(InData%MBmmB)) then
      call RegPackBounds(Buf, 2, lbound(InData%MBmmB), ubound(InData%MBmmB))
      call RegPack(Buf, InData%MBmmB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C1_11
   call RegPack(Buf, allocated(InData%C1_11))
   if (allocated(InData%C1_11)) then
      call RegPackBounds(Buf, 2, lbound(InData%C1_11), ubound(InData%C1_11))
      call RegPack(Buf, InData%C1_11)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C1_12
   call RegPack(Buf, allocated(InData%C1_12))
   if (allocated(InData%C1_12)) then
      call RegPackBounds(Buf, 2, lbound(InData%C1_12), ubound(InData%C1_12))
      call RegPack(Buf, InData%C1_12)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D1_141
   call RegPack(Buf, allocated(InData%D1_141))
   if (allocated(InData%D1_141)) then
      call RegPackBounds(Buf, 2, lbound(InData%D1_141), ubound(InData%D1_141))
      call RegPack(Buf, InData%D1_141)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D1_142
   call RegPack(Buf, allocated(InData%D1_142))
   if (allocated(InData%D1_142)) then
      call RegPackBounds(Buf, 2, lbound(InData%D1_142), ubound(InData%D1_142))
      call RegPack(Buf, InData%D1_142)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiM
   call RegPack(Buf, allocated(InData%PhiM))
   if (allocated(InData%PhiM)) then
      call RegPackBounds(Buf, 2, lbound(InData%PhiM), ubound(InData%PhiM))
      call RegPack(Buf, InData%PhiM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C2_61
   call RegPack(Buf, allocated(InData%C2_61))
   if (allocated(InData%C2_61)) then
      call RegPackBounds(Buf, 2, lbound(InData%C2_61), ubound(InData%C2_61))
      call RegPack(Buf, InData%C2_61)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! C2_62
   call RegPack(Buf, allocated(InData%C2_62))
   if (allocated(InData%C2_62)) then
      call RegPackBounds(Buf, 2, lbound(InData%C2_62), ubound(InData%C2_62))
      call RegPack(Buf, InData%C2_62)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiRb_TI
   call RegPack(Buf, allocated(InData%PhiRb_TI))
   if (allocated(InData%PhiRb_TI)) then
      call RegPackBounds(Buf, 2, lbound(InData%PhiRb_TI), ubound(InData%PhiRb_TI))
      call RegPack(Buf, InData%PhiRb_TI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D2_63
   call RegPack(Buf, allocated(InData%D2_63))
   if (allocated(InData%D2_63)) then
      call RegPackBounds(Buf, 2, lbound(InData%D2_63), ubound(InData%D2_63))
      call RegPack(Buf, InData%D2_63)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! D2_64
   call RegPack(Buf, allocated(InData%D2_64))
   if (allocated(InData%D2_64)) then
      call RegPackBounds(Buf, 2, lbound(InData%D2_64), ubound(InData%D2_64))
      call RegPack(Buf, InData%D2_64)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MBB
   call RegPack(Buf, allocated(InData%MBB))
   if (allocated(InData%MBB)) then
      call RegPackBounds(Buf, 2, lbound(InData%MBB), ubound(InData%MBB))
      call RegPack(Buf, InData%MBB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! KBB
   call RegPack(Buf, allocated(InData%KBB))
   if (allocated(InData%KBB)) then
      call RegPackBounds(Buf, 2, lbound(InData%KBB), ubound(InData%KBB))
      call RegPack(Buf, InData%KBB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CBB
   call RegPack(Buf, allocated(InData%CBB))
   if (allocated(InData%CBB)) then
      call RegPackBounds(Buf, 2, lbound(InData%CBB), ubound(InData%CBB))
      call RegPack(Buf, InData%CBB)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! CMM
   call RegPack(Buf, allocated(InData%CMM))
   if (allocated(InData%CMM)) then
      call RegPackBounds(Buf, 2, lbound(InData%CMM), ubound(InData%CMM))
      call RegPack(Buf, InData%CMM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MBM
   call RegPack(Buf, allocated(InData%MBM))
   if (allocated(InData%MBM)) then
      call RegPackBounds(Buf, 2, lbound(InData%MBM), ubound(InData%MBM))
      call RegPack(Buf, InData%MBM)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiL_T
   call RegPack(Buf, allocated(InData%PhiL_T))
   if (allocated(InData%PhiL_T)) then
      call RegPackBounds(Buf, 2, lbound(InData%PhiL_T), ubound(InData%PhiL_T))
      call RegPack(Buf, InData%PhiL_T)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! PhiLInvOmgL2
   call RegPack(Buf, allocated(InData%PhiLInvOmgL2))
   if (allocated(InData%PhiLInvOmgL2)) then
      call RegPackBounds(Buf, 2, lbound(InData%PhiLInvOmgL2), ubound(InData%PhiLInvOmgL2))
      call RegPack(Buf, InData%PhiLInvOmgL2)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! KLLm1
   call RegPack(Buf, allocated(InData%KLLm1))
   if (allocated(InData%KLLm1)) then
      call RegPackBounds(Buf, 2, lbound(InData%KLLm1), ubound(InData%KLLm1))
      call RegPack(Buf, InData%KLLm1)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AM2Jac
   call RegPack(Buf, allocated(InData%AM2Jac))
   if (allocated(InData%AM2Jac)) then
      call RegPackBounds(Buf, 2, lbound(InData%AM2Jac), ubound(InData%AM2Jac))
      call RegPack(Buf, InData%AM2Jac)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! AM2JacPiv
   call RegPack(Buf, allocated(InData%AM2JacPiv))
   if (allocated(InData%AM2JacPiv)) then
      call RegPackBounds(Buf, 1, lbound(InData%AM2JacPiv), ubound(InData%AM2JacPiv))
      call RegPack(Buf, InData%AM2JacPiv)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TI
   call RegPack(Buf, allocated(InData%TI))
   if (allocated(InData%TI)) then
      call RegPackBounds(Buf, 2, lbound(InData%TI), ubound(InData%TI))
      call RegPack(Buf, InData%TI)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! TIreact
   call RegPack(Buf, allocated(InData%TIreact))
   if (allocated(InData%TIreact)) then
      call RegPackBounds(Buf, 2, lbound(InData%TIreact), ubound(InData%TIreact))
      call RegPack(Buf, InData%TIreact)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes
   call RegPack(Buf, InData%nNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes_I
   call RegPack(Buf, InData%nNodes_I)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes_L
   call RegPack(Buf, InData%nNodes_L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes_C
   call RegPack(Buf, InData%nNodes_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nodes_I
   call RegPack(Buf, allocated(InData%Nodes_I))
   if (allocated(InData%Nodes_I)) then
      call RegPackBounds(Buf, 2, lbound(InData%Nodes_I), ubound(InData%Nodes_I))
      call RegPack(Buf, InData%Nodes_I)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nodes_L
   call RegPack(Buf, allocated(InData%Nodes_L))
   if (allocated(InData%Nodes_L)) then
      call RegPackBounds(Buf, 2, lbound(InData%Nodes_L), ubound(InData%Nodes_L))
      call RegPack(Buf, InData%Nodes_L)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nodes_C
   call RegPack(Buf, allocated(InData%Nodes_C))
   if (allocated(InData%Nodes_C)) then
      call RegPackBounds(Buf, 2, lbound(InData%Nodes_C), ubound(InData%Nodes_C))
      call RegPack(Buf, InData%Nodes_C)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFI__
   call RegPack(Buf, InData%nDOFI__)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFI_Rb
   call RegPack(Buf, InData%nDOFI_Rb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFI_F
   call RegPack(Buf, InData%nDOFI_F)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFL_L
   call RegPack(Buf, InData%nDOFL_L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC__
   call RegPack(Buf, InData%nDOFC__)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC_Rb
   call RegPack(Buf, InData%nDOFC_Rb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC_L
   call RegPack(Buf, InData%nDOFC_L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC_F
   call RegPack(Buf, InData%nDOFC_F)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFR__
   call RegPack(Buf, InData%nDOFR__)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF__Rb
   call RegPack(Buf, InData%nDOF__Rb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF__L
   call RegPack(Buf, InData%nDOF__L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF__F
   call RegPack(Buf, InData%nDOF__F)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDI__
   call RegPack(Buf, allocated(InData%IDI__))
   if (allocated(InData%IDI__)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDI__), ubound(InData%IDI__))
      call RegPack(Buf, InData%IDI__)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDI_Rb
   call RegPack(Buf, allocated(InData%IDI_Rb))
   if (allocated(InData%IDI_Rb)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDI_Rb), ubound(InData%IDI_Rb))
      call RegPack(Buf, InData%IDI_Rb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDI_F
   call RegPack(Buf, allocated(InData%IDI_F))
   if (allocated(InData%IDI_F)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDI_F), ubound(InData%IDI_F))
      call RegPack(Buf, InData%IDI_F)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDL_L
   call RegPack(Buf, allocated(InData%IDL_L))
   if (allocated(InData%IDL_L)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDL_L), ubound(InData%IDL_L))
      call RegPack(Buf, InData%IDL_L)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDC__
   call RegPack(Buf, allocated(InData%IDC__))
   if (allocated(InData%IDC__)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDC__), ubound(InData%IDC__))
      call RegPack(Buf, InData%IDC__)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDC_Rb
   call RegPack(Buf, allocated(InData%IDC_Rb))
   if (allocated(InData%IDC_Rb)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDC_Rb), ubound(InData%IDC_Rb))
      call RegPack(Buf, InData%IDC_Rb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDC_L
   call RegPack(Buf, allocated(InData%IDC_L))
   if (allocated(InData%IDC_L)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDC_L), ubound(InData%IDC_L))
      call RegPack(Buf, InData%IDC_L)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDC_F
   call RegPack(Buf, allocated(InData%IDC_F))
   if (allocated(InData%IDC_F)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDC_F), ubound(InData%IDC_F))
      call RegPack(Buf, InData%IDC_F)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDR__
   call RegPack(Buf, allocated(InData%IDR__))
   if (allocated(InData%IDR__)) then
      call RegPackBounds(Buf, 1, lbound(InData%IDR__), ubound(InData%IDR__))
      call RegPack(Buf, InData%IDR__)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ID__Rb
   call RegPack(Buf, allocated(InData%ID__Rb))
   if (allocated(InData%ID__Rb)) then
      call RegPackBounds(Buf, 1, lbound(InData%ID__Rb), ubound(InData%ID__Rb))
      call RegPack(Buf, InData%ID__Rb)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ID__L
   call RegPack(Buf, allocated(InData%ID__L))
   if (allocated(InData%ID__L)) then
      call RegPackBounds(Buf, 1, lbound(InData%ID__L), ubound(InData%ID__L))
      call RegPack(Buf, InData%ID__L)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! ID__F
   call RegPack(Buf, allocated(InData%ID__F))
   if (allocated(InData%ID__F)) then
      call RegPackBounds(Buf, 1, lbound(InData%ID__F), ubound(InData%ID__F))
      call RegPack(Buf, InData%ID__F)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! NMOutputs
   call RegPack(Buf, InData%NMOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegPack(Buf, InData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegPack(Buf, InData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnJckF
   call RegPack(Buf, InData%UnJckF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegPack(Buf, InData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegPack(Buf, InData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegPack(Buf, InData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MoutLst
   call RegPack(Buf, allocated(InData%MoutLst))
   if (allocated(InData%MoutLst)) then
      call RegPackBounds(Buf, 1, lbound(InData%MoutLst), ubound(InData%MoutLst))
      LB(1:1) = lbound(InData%MoutLst)
      UB(1:1) = ubound(InData%MoutLst)
      do i1 = LB(1), UB(1)
         call SD_PackMeshAuxDataType(Buf, InData%MoutLst(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MoutLst2
   call RegPack(Buf, allocated(InData%MoutLst2))
   if (allocated(InData%MoutLst2)) then
      call RegPackBounds(Buf, 1, lbound(InData%MoutLst2), ubound(InData%MoutLst2))
      LB(1:1) = lbound(InData%MoutLst2)
      UB(1:1) = ubound(InData%MoutLst2)
      do i1 = LB(1), UB(1)
         call SD_PackMeshAuxDataType(Buf, InData%MoutLst2(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! MoutLst3
   call RegPack(Buf, allocated(InData%MoutLst3))
   if (allocated(InData%MoutLst3)) then
      call RegPackBounds(Buf, 1, lbound(InData%MoutLst3), ubound(InData%MoutLst3))
      LB(1:1) = lbound(InData%MoutLst3)
      UB(1:1) = ubound(InData%MoutLst3)
      do i1 = LB(1), UB(1)
         call SD_PackMeshAuxDataType(Buf, InData%MoutLst3(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutParam
   call RegPack(Buf, allocated(InData%OutParam))
   if (allocated(InData%OutParam)) then
      call RegPackBounds(Buf, 1, lbound(InData%OutParam), ubound(InData%OutParam))
      LB(1:1) = lbound(InData%OutParam)
      UB(1:1) = ubound(InData%OutParam)
      do i1 = LB(1), UB(1)
         call NWTC_Library_PackOutParmType(Buf, InData%OutParam(i1)) 
      end do
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAll
   call RegPack(Buf, InData%OutAll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutCBModes
   call RegPack(Buf, InData%OutCBModes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFEMModes
   call RegPack(Buf, InData%OutFEMModes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutReact
   call RegPack(Buf, InData%OutReact)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllInt
   call RegPack(Buf, InData%OutAllInt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllDims
   call RegPack(Buf, InData%OutAllDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDec
   call RegPack(Buf, InData%OutDec)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   call RegPack(Buf, allocated(InData%Jac_u_indx))
   if (allocated(InData%Jac_u_indx)) then
      call RegPackBounds(Buf, 2, lbound(InData%Jac_u_indx), ubound(InData%Jac_u_indx))
      call RegPack(Buf, InData%Jac_u_indx)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! du
   call RegPack(Buf, allocated(InData%du))
   if (allocated(InData%du)) then
      call RegPackBounds(Buf, 1, lbound(InData%du), ubound(InData%du))
      call RegPack(Buf, InData%du)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
   ! dx
   call RegPack(Buf, InData%dx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegPack(Buf, InData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nx
   call RegPack(Buf, InData%Jac_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotStates
   call RegPack(Buf, InData%RotStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackParam(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_ParameterType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackParam'
   integer(IntKi)  :: i1, i2
   integer(IntKi)  :: LB(2), UB(2)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! SDDeltaT
   call RegUnpack(Buf, OutData%SDDeltaT)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IntMethod
   call RegUnpack(Buf, OutData%IntMethod)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF
   call RegUnpack(Buf, OutData%nDOF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF_red
   call RegUnpack(Buf, OutData%nDOF_red)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nmembers
   call RegUnpack(Buf, OutData%Nmembers)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Elems
   if (allocated(OutData%Elems)) deallocate(OutData%Elems)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Elems(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Elems.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Elems)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ElemProps
   if (allocated(OutData%ElemProps)) deallocate(OutData%ElemProps)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElemProps(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElemProps.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackElemPropType(Buf, OutData%ElemProps(i1)) ! ElemProps 
      end do
   end if
   ! FG
   if (allocated(OutData%FG)) deallocate(OutData%FG)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%FG(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%FG.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%FG)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DP0
   if (allocated(OutData%DP0)) deallocate(OutData%DP0)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DP0(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DP0.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DP0)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NodeID2JointID
   if (allocated(OutData%NodeID2JointID)) deallocate(OutData%NodeID2JointID)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodeID2JointID(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodeID2JointID.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%NodeID2JointID)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! reduced
   call RegUnpack(Buf, OutData%reduced)
   if (RegCheckErr(Buf, RoutineName)) return
   ! T_red
   if (allocated(OutData%T_red)) deallocate(OutData%T_red)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%T_red(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%T_red.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%T_red)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! T_red_T
   if (allocated(OutData%T_red_T)) deallocate(OutData%T_red_T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%T_red_T(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%T_red_T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%T_red_T)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NodesDOF
   if (allocated(OutData%NodesDOF)) deallocate(OutData%NodesDOF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodesDOF(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodesDOF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackIList(Buf, OutData%NodesDOF(i1)) ! NodesDOF 
      end do
   end if
   ! NodesDOFred
   if (allocated(OutData%NodesDOFred)) deallocate(OutData%NodesDOFred)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%NodesDOFred(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%NodesDOFred.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackIList(Buf, OutData%NodesDOFred(i1)) ! NodesDOFred 
      end do
   end if
   ! ElemsDOF
   if (allocated(OutData%ElemsDOF)) deallocate(OutData%ElemsDOF)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ElemsDOF(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ElemsDOF.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ElemsDOF)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! DOFred2Nodes
   if (allocated(OutData%DOFred2Nodes)) deallocate(OutData%DOFred2Nodes)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%DOFred2Nodes(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%DOFred2Nodes.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%DOFred2Nodes)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CtrlElem2Channel
   if (allocated(OutData%CtrlElem2Channel)) deallocate(OutData%CtrlElem2Channel)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CtrlElem2Channel(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CtrlElem2Channel.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CtrlElem2Channel)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nDOFM
   call RegUnpack(Buf, OutData%nDOFM)
   if (RegCheckErr(Buf, RoutineName)) return
   ! SttcSolve
   call RegUnpack(Buf, OutData%SttcSolve)
   if (RegCheckErr(Buf, RoutineName)) return
   ! GuyanLoadCorrection
   call RegUnpack(Buf, OutData%GuyanLoadCorrection)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Floating
   call RegUnpack(Buf, OutData%Floating)
   if (RegCheckErr(Buf, RoutineName)) return
   ! KMMDiag
   if (allocated(OutData%KMMDiag)) deallocate(OutData%KMMDiag)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%KMMDiag(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%KMMDiag.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%KMMDiag)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CMMDiag
   if (allocated(OutData%CMMDiag)) deallocate(OutData%CMMDiag)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CMMDiag(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CMMDiag.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CMMDiag)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MMB
   if (allocated(OutData%MMB)) deallocate(OutData%MMB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MMB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MMB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MMB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MBmmB
   if (allocated(OutData%MBmmB)) deallocate(OutData%MBmmB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MBmmB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MBmmB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MBmmB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C1_11
   if (allocated(OutData%C1_11)) deallocate(OutData%C1_11)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C1_11(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C1_11.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C1_11)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C1_12
   if (allocated(OutData%C1_12)) deallocate(OutData%C1_12)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C1_12(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C1_12.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C1_12)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D1_141
   if (allocated(OutData%D1_141)) deallocate(OutData%D1_141)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D1_141(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D1_141.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D1_141)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D1_142
   if (allocated(OutData%D1_142)) deallocate(OutData%D1_142)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D1_142(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D1_142.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D1_142)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PhiM
   if (allocated(OutData%PhiM)) deallocate(OutData%PhiM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PhiM(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PhiM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PhiM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C2_61
   if (allocated(OutData%C2_61)) deallocate(OutData%C2_61)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C2_61(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C2_61.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C2_61)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! C2_62
   if (allocated(OutData%C2_62)) deallocate(OutData%C2_62)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%C2_62(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%C2_62.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%C2_62)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PhiRb_TI
   if (allocated(OutData%PhiRb_TI)) deallocate(OutData%PhiRb_TI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PhiRb_TI(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PhiRb_TI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PhiRb_TI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D2_63
   if (allocated(OutData%D2_63)) deallocate(OutData%D2_63)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D2_63(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D2_63.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D2_63)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! D2_64
   if (allocated(OutData%D2_64)) deallocate(OutData%D2_64)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%D2_64(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%D2_64.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%D2_64)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MBB
   if (allocated(OutData%MBB)) deallocate(OutData%MBB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MBB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MBB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MBB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! KBB
   if (allocated(OutData%KBB)) deallocate(OutData%KBB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%KBB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%KBB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%KBB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CBB
   if (allocated(OutData%CBB)) deallocate(OutData%CBB)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CBB(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CBB.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CBB)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! CMM
   if (allocated(OutData%CMM)) deallocate(OutData%CMM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CMM(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CMM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CMM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! MBM
   if (allocated(OutData%MBM)) deallocate(OutData%MBM)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MBM(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MBM.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%MBM)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PhiL_T
   if (allocated(OutData%PhiL_T)) deallocate(OutData%PhiL_T)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PhiL_T(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PhiL_T.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PhiL_T)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! PhiLInvOmgL2
   if (allocated(OutData%PhiLInvOmgL2)) deallocate(OutData%PhiLInvOmgL2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%PhiLInvOmgL2(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%PhiLInvOmgL2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%PhiLInvOmgL2)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! KLLm1
   if (allocated(OutData%KLLm1)) deallocate(OutData%KLLm1)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%KLLm1(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%KLLm1.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%KLLm1)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AM2Jac
   if (allocated(OutData%AM2Jac)) deallocate(OutData%AM2Jac)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AM2Jac(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AM2Jac.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AM2Jac)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! AM2JacPiv
   if (allocated(OutData%AM2JacPiv)) deallocate(OutData%AM2JacPiv)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%AM2JacPiv(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%AM2JacPiv.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%AM2JacPiv)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TI
   if (allocated(OutData%TI)) deallocate(OutData%TI)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TI(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TI.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TI)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! TIreact
   if (allocated(OutData%TIreact)) deallocate(OutData%TIreact)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%TIreact(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%TIreact.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%TIreact)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nNodes
   call RegUnpack(Buf, OutData%nNodes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes_I
   call RegUnpack(Buf, OutData%nNodes_I)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes_L
   call RegUnpack(Buf, OutData%nNodes_L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nNodes_C
   call RegUnpack(Buf, OutData%nNodes_C)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Nodes_I
   if (allocated(OutData%Nodes_I)) deallocate(OutData%Nodes_I)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Nodes_I(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes_I.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Nodes_I)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Nodes_L
   if (allocated(OutData%Nodes_L)) deallocate(OutData%Nodes_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Nodes_L(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Nodes_L)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! Nodes_C
   if (allocated(OutData%Nodes_C)) deallocate(OutData%Nodes_C)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Nodes_C(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Nodes_C.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Nodes_C)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! nDOFI__
   call RegUnpack(Buf, OutData%nDOFI__)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFI_Rb
   call RegUnpack(Buf, OutData%nDOFI_Rb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFI_F
   call RegUnpack(Buf, OutData%nDOFI_F)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFL_L
   call RegUnpack(Buf, OutData%nDOFL_L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC__
   call RegUnpack(Buf, OutData%nDOFC__)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC_Rb
   call RegUnpack(Buf, OutData%nDOFC_Rb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC_L
   call RegUnpack(Buf, OutData%nDOFC_L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFC_F
   call RegUnpack(Buf, OutData%nDOFC_F)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOFR__
   call RegUnpack(Buf, OutData%nDOFR__)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF__Rb
   call RegUnpack(Buf, OutData%nDOF__Rb)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF__L
   call RegUnpack(Buf, OutData%nDOF__L)
   if (RegCheckErr(Buf, RoutineName)) return
   ! nDOF__F
   call RegUnpack(Buf, OutData%nDOF__F)
   if (RegCheckErr(Buf, RoutineName)) return
   ! IDI__
   if (allocated(OutData%IDI__)) deallocate(OutData%IDI__)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDI__(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDI__.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDI__)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDI_Rb
   if (allocated(OutData%IDI_Rb)) deallocate(OutData%IDI_Rb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDI_Rb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDI_Rb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDI_Rb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDI_F
   if (allocated(OutData%IDI_F)) deallocate(OutData%IDI_F)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDI_F(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDI_F.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDI_F)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDL_L
   if (allocated(OutData%IDL_L)) deallocate(OutData%IDL_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDL_L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDL_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDL_L)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDC__
   if (allocated(OutData%IDC__)) deallocate(OutData%IDC__)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDC__(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDC__.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDC__)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDC_Rb
   if (allocated(OutData%IDC_Rb)) deallocate(OutData%IDC_Rb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDC_Rb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDC_Rb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDC_Rb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDC_L
   if (allocated(OutData%IDC_L)) deallocate(OutData%IDC_L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDC_L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDC_L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDC_L)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDC_F
   if (allocated(OutData%IDC_F)) deallocate(OutData%IDC_F)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDC_F(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDC_F.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDC_F)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! IDR__
   if (allocated(OutData%IDR__)) deallocate(OutData%IDR__)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%IDR__(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%IDR__.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%IDR__)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ID__Rb
   if (allocated(OutData%ID__Rb)) deallocate(OutData%ID__Rb)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ID__Rb(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ID__Rb.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ID__Rb)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ID__L
   if (allocated(OutData%ID__L)) deallocate(OutData%ID__L)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ID__L(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ID__L.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ID__L)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! ID__F
   if (allocated(OutData%ID__F)) deallocate(OutData%ID__F)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%ID__F(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%ID__F.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%ID__F)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! NMOutputs
   call RegUnpack(Buf, OutData%NMOutputs)
   if (RegCheckErr(Buf, RoutineName)) return
   ! NumOuts
   call RegUnpack(Buf, OutData%NumOuts)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSwtch
   call RegUnpack(Buf, OutData%OutSwtch)
   if (RegCheckErr(Buf, RoutineName)) return
   ! UnJckF
   call RegUnpack(Buf, OutData%UnJckF)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Delim
   call RegUnpack(Buf, OutData%Delim)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFmt
   call RegUnpack(Buf, OutData%OutFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutSFmt
   call RegUnpack(Buf, OutData%OutSFmt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! MoutLst
   if (allocated(OutData%MoutLst)) deallocate(OutData%MoutLst)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MoutLst(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MoutLst.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackMeshAuxDataType(Buf, OutData%MoutLst(i1)) ! MoutLst 
      end do
   end if
   ! MoutLst2
   if (allocated(OutData%MoutLst2)) deallocate(OutData%MoutLst2)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MoutLst2(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MoutLst2.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackMeshAuxDataType(Buf, OutData%MoutLst2(i1)) ! MoutLst2 
      end do
   end if
   ! MoutLst3
   if (allocated(OutData%MoutLst3)) deallocate(OutData%MoutLst3)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%MoutLst3(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%MoutLst3.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call SD_UnpackMeshAuxDataType(Buf, OutData%MoutLst3(i1)) ! MoutLst3 
      end do
   end if
   ! OutParam
   if (allocated(OutData%OutParam)) deallocate(OutData%OutParam)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%OutParam(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%OutParam.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      do i1 = LB(1), UB(1)
         call NWTC_Library_UnpackOutParmType(Buf, OutData%OutParam(i1)) ! OutParam 
      end do
   end if
   ! OutAll
   call RegUnpack(Buf, OutData%OutAll)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutCBModes
   call RegUnpack(Buf, OutData%OutCBModes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutFEMModes
   call RegUnpack(Buf, OutData%OutFEMModes)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutReact
   call RegUnpack(Buf, OutData%OutReact)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllInt
   call RegUnpack(Buf, OutData%OutAllInt)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutAllDims
   call RegUnpack(Buf, OutData%OutAllDims)
   if (RegCheckErr(Buf, RoutineName)) return
   ! OutDec
   call RegUnpack(Buf, OutData%OutDec)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_u_indx
   if (allocated(OutData%Jac_u_indx)) deallocate(OutData%Jac_u_indx)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 2, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%Jac_u_indx(LB(1):UB(1),LB(2):UB(2)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%Jac_u_indx.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%Jac_u_indx)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! du
   if (allocated(OutData%du)) deallocate(OutData%du)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%du(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%du.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%du)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
   ! dx
   call RegUnpack(Buf, OutData%dx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_ny
   call RegUnpack(Buf, OutData%Jac_ny)
   if (RegCheckErr(Buf, RoutineName)) return
   ! Jac_nx
   call RegUnpack(Buf, OutData%Jac_nx)
   if (RegCheckErr(Buf, RoutineName)) return
   ! RotStates
   call RegUnpack(Buf, OutData%RotStates)
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine
 SUBROUTINE SD_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(SD_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcInputData%TPMesh, DstInputData%TPMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcInputData%LMesh, DstInputData%LMesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcInputData%CableDeltaL)) THEN
  i1_l = LBOUND(SrcInputData%CableDeltaL,1)
  i1_u = UBOUND(SrcInputData%CableDeltaL,1)
  IF (.NOT. ALLOCATED(DstInputData%CableDeltaL)) THEN 
    ALLOCATE(DstInputData%CableDeltaL(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%CableDeltaL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%CableDeltaL = SrcInputData%CableDeltaL
ENDIF
 END SUBROUTINE SD_CopyInput

 SUBROUTINE SD_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(SD_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyInput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( InputData%TPMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( InputData%LMesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(InputData%CableDeltaL)) THEN
  DEALLOCATE(InputData%CableDeltaL)
ENDIF
 END SUBROUTINE SD_DestroyInput


subroutine SD_PackInput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_InputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackInput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! TPMesh
   call MeshPack(Buf, InData%TPMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! LMesh
   call MeshPack(Buf, InData%LMesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! CableDeltaL
   call RegPack(Buf, allocated(InData%CableDeltaL))
   if (allocated(InData%CableDeltaL)) then
      call RegPackBounds(Buf, 1, lbound(InData%CableDeltaL), ubound(InData%CableDeltaL))
      call RegPack(Buf, InData%CableDeltaL)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackInput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_InputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackInput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! TPMesh
   call MeshUnpack(Buf, OutData%TPMesh) ! TPMesh 
   ! LMesh
   call MeshUnpack(Buf, OutData%LMesh) ! LMesh 
   ! CableDeltaL
   if (allocated(OutData%CableDeltaL)) deallocate(OutData%CableDeltaL)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%CableDeltaL(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%CableDeltaL.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%CableDeltaL)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine
 SUBROUTINE SD_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(SD_OutputType), INTENT(INOUT) :: SrcOutputData
   TYPE(SD_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'SD_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL MeshCopy( SrcOutputData%Y1Mesh, DstOutputData%Y1Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcOutputData%Y2Mesh, DstOutputData%Y2Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
      CALL MeshCopy( SrcOutputData%Y3Mesh, DstOutputData%Y3Mesh, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
IF (ALLOCATED(SrcOutputData%WriteOutput)) THEN
  i1_l = LBOUND(SrcOutputData%WriteOutput,1)
  i1_u = UBOUND(SrcOutputData%WriteOutput,1)
  IF (.NOT. ALLOCATED(DstOutputData%WriteOutput)) THEN 
    ALLOCATE(DstOutputData%WriteOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%WriteOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%WriteOutput = SrcOutputData%WriteOutput
ENDIF
 END SUBROUTINE SD_CopyOutput

 SUBROUTINE SD_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(SD_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*),    PARAMETER :: RoutineName = 'SD_DestroyOutput'

  ErrStat = ErrID_None
  ErrMsg  = ""

  CALL MeshDestroy( OutputData%Y1Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( OutputData%Y2Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
  CALL MeshDestroy( OutputData%Y3Mesh, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
IF (ALLOCATED(OutputData%WriteOutput)) THEN
  DEALLOCATE(OutputData%WriteOutput)
ENDIF
 END SUBROUTINE SD_DestroyOutput


subroutine SD_PackOutput(Buf, Indata)
   type(PackBuffer), intent(inout) :: Buf
   type(SD_OutputType), intent(in) :: InData
   character(*), parameter         :: RoutineName = 'SD_PackOutput'
   if (Buf%ErrStat >= AbortErrLev) return
   ! Y1Mesh
   call MeshPack(Buf, InData%Y1Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y2Mesh
   call MeshPack(Buf, InData%Y2Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! Y3Mesh
   call MeshPack(Buf, InData%Y3Mesh) 
   if (RegCheckErr(Buf, RoutineName)) return
   ! WriteOutput
   call RegPack(Buf, allocated(InData%WriteOutput))
   if (allocated(InData%WriteOutput)) then
      call RegPackBounds(Buf, 1, lbound(InData%WriteOutput), ubound(InData%WriteOutput))
      call RegPack(Buf, InData%WriteOutput)
   end if
   if (RegCheckErr(Buf, RoutineName)) return
end subroutine

subroutine SD_UnPackOutput(Buf, OutData)
   type(PackBuffer), intent(inout)    :: Buf
   type(SD_OutputType), intent(inout) :: OutData
   character(*), parameter            :: RoutineName = 'SD_UnPackOutput'
   integer(IntKi)  :: LB(1), UB(1)
   integer(IntKi)  :: stat
   logical         :: IsAllocAssoc
   if (Buf%ErrStat /= ErrID_None) return
   ! Y1Mesh
   call MeshUnpack(Buf, OutData%Y1Mesh) ! Y1Mesh 
   ! Y2Mesh
   call MeshUnpack(Buf, OutData%Y2Mesh) ! Y2Mesh 
   ! Y3Mesh
   call MeshUnpack(Buf, OutData%Y3Mesh) ! Y3Mesh 
   ! WriteOutput
   if (allocated(OutData%WriteOutput)) deallocate(OutData%WriteOutput)
   call RegUnpack(Buf, IsAllocAssoc)
   if (RegCheckErr(Buf, RoutineName)) return
   if (IsAllocAssoc) then
      call RegUnpackBounds(Buf, 1, LB, UB)
      if (RegCheckErr(Buf, RoutineName)) return
      allocate(OutData%WriteOutput(LB(1):UB(1)),stat=stat)
      if (stat /= 0) then 
         call SetErrStat(ErrID_Fatal, 'Error allocating OutData%WriteOutput.', Buf%ErrStat, Buf%ErrMsg, RoutineName)
         return
      end if
      call RegUnpack(Buf, OutData%WriteOutput)
      if (RegCheckErr(Buf, RoutineName)) return
   end if
end subroutine

 SUBROUTINE SD_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(SD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'SD_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL SD_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL SD_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL SD_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE SD_Input_ExtrapInterp


 SUBROUTINE SD_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(SD_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(SD_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(SD_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'SD_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(u1%TPMesh, u2%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(u1%LMesh, u2%LMesh, tin, u_out%LMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%CableDeltaL) .AND. ALLOCATED(u1%CableDeltaL)) THEN
  DO i1 = LBOUND(u_out%CableDeltaL,1),UBOUND(u_out%CableDeltaL,1)
    b = -(u1%CableDeltaL(i1) - u2%CableDeltaL(i1))
    u_out%CableDeltaL(i1) = u1%CableDeltaL(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE SD_Input_ExtrapInterp1


 SUBROUTINE SD_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(SD_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(SD_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(SD_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(SD_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'SD_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(u1%TPMesh, u2%TPMesh, u3%TPMesh, tin, u_out%TPMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(u1%LMesh, u2%LMesh, u3%LMesh, tin, u_out%LMesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(u_out%CableDeltaL) .AND. ALLOCATED(u1%CableDeltaL)) THEN
  DO i1 = LBOUND(u_out%CableDeltaL,1),UBOUND(u_out%CableDeltaL,1)
    b = (t(3)**2*(u1%CableDeltaL(i1) - u2%CableDeltaL(i1)) + t(2)**2*(-u1%CableDeltaL(i1) + u3%CableDeltaL(i1)))* scaleFactor
    c = ( (t(2)-t(3))*u1%CableDeltaL(i1) + t(3)*u2%CableDeltaL(i1) - t(2)*u3%CableDeltaL(i1) ) * scaleFactor
    u_out%CableDeltaL(i1) = u1%CableDeltaL(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE SD_Input_ExtrapInterp2


 SUBROUTINE SD_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(SD_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(SD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'SD_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL SD_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL SD_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL SD_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE SD_Output_ExtrapInterp


 SUBROUTINE SD_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(SD_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(SD_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(SD_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'SD_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / t(2)
      CALL MeshExtrapInterp1(y1%Y1Mesh, y2%Y1Mesh, tin, y_out%Y1Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(y1%Y2Mesh, y2%Y2Mesh, tin, y_out%Y2Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp1(y1%Y3Mesh, y2%Y3Mesh, tin, y_out%Y3Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = -(y1%WriteOutput(i1) - y2%WriteOutput(i1))
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b * ScaleFactor
  END DO
END IF ! check if allocated
 END SUBROUTINE SD_Output_ExtrapInterp1


 SUBROUTINE SD_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(SD_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(SD_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(SD_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(SD_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c        ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: ScaleFactor ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'SD_Output_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
 INTEGER                                    :: i1    ! dim1 counter variable for arrays
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF

   ScaleFactor = t_out / (t(2) * t(3) * (t(2) - t(3)))
      CALL MeshExtrapInterp2(y1%Y1Mesh, y2%Y1Mesh, y3%Y1Mesh, tin, y_out%Y1Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(y1%Y2Mesh, y2%Y2Mesh, y3%Y2Mesh, tin, y_out%Y2Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
      CALL MeshExtrapInterp2(y1%Y3Mesh, y2%Y3Mesh, y3%Y3Mesh, tin, y_out%Y3Mesh, tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
IF (ALLOCATED(y_out%WriteOutput) .AND. ALLOCATED(y1%WriteOutput)) THEN
  DO i1 = LBOUND(y_out%WriteOutput,1),UBOUND(y_out%WriteOutput,1)
    b = (t(3)**2*(y1%WriteOutput(i1) - y2%WriteOutput(i1)) + t(2)**2*(-y1%WriteOutput(i1) + y3%WriteOutput(i1)))* scaleFactor
    c = ( (t(2)-t(3))*y1%WriteOutput(i1) + t(3)*y2%WriteOutput(i1) - t(2)*y3%WriteOutput(i1) ) * scaleFactor
    y_out%WriteOutput(i1) = y1%WriteOutput(i1) + b  + c * t_out
  END DO
END IF ! check if allocated
 END SUBROUTINE SD_Output_ExtrapInterp2

END MODULE SubDyn_Types
!ENDOFREGISTRYGENERATEDFILE
